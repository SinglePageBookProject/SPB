<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Single Page Book Demo page <!-- ignore --></title>
<head>
<script src="../map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="../map_v1.css" />
</head>

<body>

<pre zoom>
<span xsmall>2 process_vm_readv</span>
PROCESS_VM_READV(2)                              Linux Programmer's Manual                             PROCESS_VM_READV(2)

NAME
       process_vm_readv, process_vm_writev - transfer data between process address spaces

SYNOPSIS
       #include <sys/uio.h>

       ssize_t process_vm_readv(pid_t pid,
                                const struct iovec *local_iov,
                                unsigned long liovcnt,
                                const struct iovec *remote_iov,
                                unsigned long riovcnt,
                                unsigned long flags);

       ssize_t process_vm_writev(pid_t pid,
                                 const struct iovec *local_iov,
                                 unsigned long liovcnt,
                                 const struct iovec *remote_iov,
                                 unsigned long riovcnt,
                                 unsigned long flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       process_vm_readv(), process_vm_writev():
           _GNU_SOURCE

DESCRIPTION
       These  system  calls  transfer  data between the address space of the calling process ("the local process") and the
       process identified by pid ("the remote process").  The data moves directly between the address spaces  of  the  two
       processes, without passing through kernel space.

       The  process_vm_readv()  system  call  transfers data from the remote process to the local process.  The data to be
       transferred is identified by remote_iov and riovcnt: remote_iov is a pointer to an array describing address  ranges
       in  the  process  pid,  and riovcnt specifies the number of elements in remote_iov.  The data is transferred to the
       locations specified by local_iov and liovcnt: local_iov is a pointer to an array describing address ranges  in  the
       calling process, and liovcnt specifies the number of elements in local_iov.

       The  process_vm_writev() system call is the converse of process_vm_readv()—it transfers data from the local process
       to the remote process.  Other than the direction of the transfer, the arguments liovcnt,  local_iov,  riovcnt,  and
       remote_iov have the same meaning as for process_vm_readv().

       The local_iov and remote_iov arguments point to an array of iovec structures, defined in <sys/uio.h> as:

           struct iovec {
               void  *iov_base;    /* Starting address */
               size_t iov_len;     /* Number of bytes to transfer */
           };

       Buffers are processed in array order.  This means that process_vm_readv() completely fills local_iov[0] before pro‐
       ceeding to local_iov[1], and so on.  Likewise, remote_iov[0] is completely read before proceeding to remote_iov[1],
       and so on.

       Similarly,  process_vm_writev()  writes  out the entire contents of local_iov[0] before proceeding to local_iov[1],
       and it completely fills remote_iov[0] before proceeding to remote_iov[1].

       The lengths of remote_iov[i].iov_len and local_iov[i].iov_len do not have to be the same.  Thus, it is possible  to
       split a single local buffer into multiple remote buffers, or vice versa.

       The flags argument is currently unused and must be set to 0.

       The  values  specified in the liovcnt and riovcnt arguments must be less than or equal to IOV_MAX (defined in <lim‐
       its.h> or accessible via the call sysconf(_SC_IOV_MAX)).

       The count arguments and local_iov are checked before doing any transfers.  If the counts are too big, or  local_iov
       is  invalid, or the addresses refer to regions that are inaccessible to the local process, none of the vectors will
       be processed and an error will be returned immediately.

       Note, however, that these system calls do not check the memory regions in the  remote  process  until  just  before
       doing  the  read/write.   Consequently, a partial read/write (see RETURN VALUE) may result if one of the remote_iov
       elements points to an invalid memory region in the remote process.   No  further  reads/writes  will  be  attempted
       beyond  that  point.   Keep this in mind when attempting to read data of unknown length (such as C strings that are
       null-terminated) from a remote process, by avoiding spanning memory pages (typically  4 KiB)  in  a  single  remote
       iovec element.  (Instead, split the remote read into two remote_iov elements and have them merge back into a single
       write local_iov entry.  The first read entry goes up to the page boundary, while the second starts on the next page
       boundary.)

       Permission  to  read  from or write to another process is governed by a ptrace access mode PTRACE_MODE_ATTACH_REAL‐
       CREDS check; see ptrace(2).

RETURN VALUE
       On success, process_vm_readv() returns the number of bytes read and process_vm_writev() returns the number of bytes
       written.  This return value may be less than the total number of requested bytes, if a partial read/write occurred.
       (Partial transfers apply at the granularity of iovec elements.  These system calls won't perform a partial transfer
       that  splits  a  single  iovec  element.)   The caller should check the return value to determine whether a partial
       read/write occurred.

       On error, -1 is returned and errno is set appropriately.

ERRORS
       EFAULT The memory described by local_iov is outside the caller's accessible address space.

       EFAULT The memory described by remote_iov is outside the accessible address space of the process pid.

       EINVAL The sum of the iov_len values of either local_iov or remote_iov overflows a ssize_t value.

       EINVAL flags is not 0.

       EINVAL liovcnt or riovcnt is too large.

       ENOMEM Could not allocate memory for internal copies of the iovec structures.

       EPERM  The caller does not have permission to access the address space of the process pid.

       ESRCH  No process with ID pid exists.

VERSIONS
       These system calls were added in Linux 3.2.  Support is provided in glibc since version 2.15.

CONFORMING TO
       These system calls are nonstandard Linux extensions.

NOTES
       The data transfers performed by process_vm_readv() and process_vm_writev() are not guaranteed to be atomic  in  any
       way.

       These  system calls were designed to permit fast message passing by allowing messages to be exchanged with a single
       copy operation (rather than the double copy that would be required  when  using,  for  example,  shared  memory  or
       pipes).

EXAMPLE
       The  following  code  sample  demonstrates the use of process_vm_readv().  It reads 20 bytes at the address 0x10000
       from the process with PID 10 and writes the first 10 bytes into buf1 and the second 10 bytes into buf2.

       #include <sys/uio.h>

       int
       main(void)
       {
           struct iovec local[2];
           struct iovec remote[1];
           char buf1[10];
           char buf2[10];
           ssize_t nread;
           pid_t pid = 10;             /* PID of remote process */

           local[0].iov_base = buf1;
           local[0].iov_len = 10;
           local[1].iov_base = buf2;
           local[1].iov_len = 10;
           remote[0].iov_base = (void *) 0x10000;
           remote[0].iov_len = 20;

           nread = process_vm_readv(pid, local, 2, remote, 1, 0);
           if (nread != 20)
               return 1;
           else
               return 0;
       }

SEE ALSO
       readv(2), writev(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                     PROCESS_VM_READV(2)
</pre>
<pre zoom>
<span xsmall>2 process_vm_readv</span>
PROCESS_VM_READV(2)                              Linux Programmer's Manual                             PROCESS_VM_READV(2)

NAME
       process_vm_readv, process_vm_writev - transfer data between process address spaces

SYNOPSIS
       #include <sys/uio.h>

       ssize_t process_vm_readv(pid_t pid,
                                const struct iovec *local_iov,
                                unsigned long liovcnt,
                                const struct iovec *remote_iov,
                                unsigned long riovcnt,
                                unsigned long flags);

       ssize_t process_vm_writev(pid_t pid,
                                 const struct iovec *local_iov,
                                 unsigned long liovcnt,
                                 const struct iovec *remote_iov,
                                 unsigned long riovcnt,
                                 unsigned long flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       process_vm_readv(), process_vm_writev():
           _GNU_SOURCE

DESCRIPTION
       These  system  calls  transfer  data between the address space of the calling process ("the local process") and the
       process identified by pid ("the remote process").  The data moves directly between the address spaces  of  the  two
       processes, without passing through kernel space.

       The  process_vm_readv()  system  call  transfers data from the remote process to the local process.  The data to be
       transferred is identified by remote_iov and riovcnt: remote_iov is a pointer to an array describing address  ranges
       in  the  process  pid,  and riovcnt specifies the number of elements in remote_iov.  The data is transferred to the
       locations specified by local_iov and liovcnt: local_iov is a pointer to an array describing address ranges  in  the
       calling process, and liovcnt specifies the number of elements in local_iov.

       The  process_vm_writev() system call is the converse of process_vm_readv()—it transfers data from the local process
       to the remote process.  Other than the direction of the transfer, the arguments liovcnt,  local_iov,  riovcnt,  and
       remote_iov have the same meaning as for process_vm_readv().

       The local_iov and remote_iov arguments point to an array of iovec structures, defined in <sys/uio.h> as:

           struct iovec {
               void  *iov_base;    /* Starting address */
               size_t iov_len;     /* Number of bytes to transfer */
           };

       Buffers are processed in array order.  This means that process_vm_readv() completely fills local_iov[0] before pro‐
       ceeding to local_iov[1], and so on.  Likewise, remote_iov[0] is completely read before proceeding to remote_iov[1],
       and so on.

       Similarly,  process_vm_writev()  writes  out the entire contents of local_iov[0] before proceeding to local_iov[1],
       and it completely fills remote_iov[0] before proceeding to remote_iov[1].

       The lengths of remote_iov[i].iov_len and local_iov[i].iov_len do not have to be the same.  Thus, it is possible  to
       split a single local buffer into multiple remote buffers, or vice versa.

       The flags argument is currently unused and must be set to 0.

       The  values  specified in the liovcnt and riovcnt arguments must be less than or equal to IOV_MAX (defined in <lim‐
       its.h> or accessible via the call sysconf(_SC_IOV_MAX)).

       The count arguments and local_iov are checked before doing any transfers.  If the counts are too big, or  local_iov
       is  invalid, or the addresses refer to regions that are inaccessible to the local process, none of the vectors will
       be processed and an error will be returned immediately.

       Note, however, that these system calls do not check the memory regions in the  remote  process  until  just  before
       doing  the  read/write.   Consequently, a partial read/write (see RETURN VALUE) may result if one of the remote_iov
       elements points to an invalid memory region in the remote process.   No  further  reads/writes  will  be  attempted
       beyond  that  point.   Keep this in mind when attempting to read data of unknown length (such as C strings that are
       null-terminated) from a remote process, by avoiding spanning memory pages (typically  4 KiB)  in  a  single  remote
       iovec element.  (Instead, split the remote read into two remote_iov elements and have them merge back into a single
       write local_iov entry.  The first read entry goes up to the page boundary, while the second starts on the next page
       boundary.)

       Permission  to  read  from or write to another process is governed by a ptrace access mode PTRACE_MODE_ATTACH_REAL‐
       CREDS check; see ptrace(2).

RETURN VALUE
       On success, process_vm_readv() returns the number of bytes read and process_vm_writev() returns the number of bytes
       written.  This return value may be less than the total number of requested bytes, if a partial read/write occurred.
       (Partial transfers apply at the granularity of iovec elements.  These system calls won't perform a partial transfer
       that  splits  a  single  iovec  element.)   The caller should check the return value to determine whether a partial
       read/write occurred.

       On error, -1 is returned and errno is set appropriately.

ERRORS
       EFAULT The memory described by local_iov is outside the caller's accessible address space.

       EFAULT The memory described by remote_iov is outside the accessible address space of the process pid.

       EINVAL The sum of the iov_len values of either local_iov or remote_iov overflows a ssize_t value.

       EINVAL flags is not 0.

       EINVAL liovcnt or riovcnt is too large.

       ENOMEM Could not allocate memory for internal copies of the iovec structures.

       EPERM  The caller does not have permission to access the address space of the process pid.

       ESRCH  No process with ID pid exists.

VERSIONS
       These system calls were added in Linux 3.2.  Support is provided in glibc since version 2.15.

CONFORMING TO
       These system calls are nonstandard Linux extensions.

NOTES
       The data transfers performed by process_vm_readv() and process_vm_writev() are not guaranteed to be atomic  in  any
       way.

       These  system calls were designed to permit fast message passing by allowing messages to be exchanged with a single
       copy operation (rather than the double copy that would be required  when  using,  for  example,  shared  memory  or
       pipes).

EXAMPLE
       The  following  code  sample  demonstrates the use of process_vm_readv().  It reads 20 bytes at the address 0x10000
       from the process with PID 10 and writes the first 10 bytes into buf1 and the second 10 bytes into buf2.

       #include <sys/uio.h>

       int
       main(void)
       {
           struct iovec local[2];
           struct iovec remote[1];
           char buf1[10];
           char buf2[10];
           ssize_t nread;
           pid_t pid = 10;             /* PID of remote process */

           local[0].iov_base = buf1;
           local[0].iov_len = 10;
           local[1].iov_base = buf2;
           local[1].iov_len = 10;
           remote[0].iov_base = (void *) 0x10000;
           remote[0].iov_len = 20;

           nread = process_vm_readv(pid, local, 2, remote, 1, 0);
           if (nread != 20)
               return 1;
           else
               return 0;
       }

SEE ALSO
       readv(2), writev(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                     PROCESS_VM_READV(2)
</pre>
<pre zoom>
<span xsmall>2 dup3</span>
DUP(2)                                           Linux Programmer's Manual                                          DUP(2)

NAME
       dup, dup2, dup3 - duplicate a file descriptor

SYNOPSIS
       #include <unistd.h>

       int dup(int oldfd);
       int dup2(int oldfd, int newfd);

       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <fcntl.h>              /* Obtain O_* constant definitions */
       #include <unistd.h>

       int dup3(int oldfd, int newfd, int flags);

DESCRIPTION
       The dup() system call creates a copy of the file descriptor oldfd, using the lowest-numbered unused file descriptor
       for the new descriptor.

       After a successful return, the old and new file descriptors may be used interchangeably.  They refer  to  the  same
       open file description (see open(2)) and thus share file offset and file status flags; for example, if the file off‐
       set is modified by using lseek(2) on one of the file descriptors, the offset is also changed for the other.

       The two file descriptors do not share file descriptor flags  (the  close-on-exec  flag).   The  close-on-exec  flag
       (FD_CLOEXEC; see fcntl(2)) for the duplicate descriptor is off.

   dup2()
       The  dup2()  system  call  performs  the  same  task as dup(), but instead of using the lowest-numbered unused file
       descriptor, it uses the file descriptor number specified in newfd.  If the file  descriptor  newfd  was  previously
       open, it is silently closed before being reused.

       The  steps  of  closing and reusing the file descriptor newfd are performed atomically.  This is important, because
       trying to implement equivalent functionality using close(2) and dup() would be subject to race conditions,  whereby
       newfd  might be reused between the two steps.  Such reuse could happen because the main program is interrupted by a
       signal handler that allocates a file descriptor, or because a parallel thread allocates a file descriptor.

       Note the following points:

       *  If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.

       *  If oldfd is a valid file descriptor, and newfd has the same value  as  oldfd,  then  dup2()  does  nothing,  and
          returns newfd.

   dup3()
       dup3() is the same as dup2(), except that:

       *  The  caller  can  force  the close-on-exec flag to be set for the new file descriptor by specifying O_CLOEXEC in
          flags.  See the description of the same flag in open(2) for reasons why this may be useful.

       *  If oldfd equals newfd, then dup3() fails with the error EINVAL.

RETURN VALUE
       On success, these system calls return the new file descriptor.  On error, -1 is returned, and errno is  set  appro‐
       priately.

ERRORS
       EBADF  oldfd isn't an open file descriptor.

       EBADF  newfd  is  out  of  the  allowed  range  for  file descriptors (see the discussion of RLIMIT_NOFILE in getr‐
              limit(2)).

       EBUSY  (Linux only) This may be returned by dup2() or dup3() during a race condition with open(2) and dup().

       EINTR  The dup2() or dup3() call was interrupted by a signal; see signal(7).

       EINVAL (dup3()) flags contain an invalid value.

       EINVAL (dup3()) oldfd was equal to newfd.

       EMFILE The per-process limit on the number of open file  descriptors  has  been  reached  (see  the  discussion  of
              RLIMIT_NOFILE in getrlimit(2)).

VERSIONS
       dup3() was added to Linux in version 2.6.27; glibc support is available starting with version 2.9.

CONFORMING TO
       dup(), dup2(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

       dup3() is Linux-specific.

NOTES
       The  error  returned  by  dup2()  is different from that returned by fcntl(..., F_DUPFD, ...)  when newfd is out of
       range.  On some systems, dup2() also sometimes returns EINVAL like F_DUPFD.

       If newfd was open, any errors that would have been reported at close(2) time are lost.   If  this  is  of  concern,
       then—unless  the  program  is single-threaded and does not allocate file descriptors in signal handlers—the correct
       approach is not to close newfd before calling dup2(), because of the race condition described above.  Instead, code
       something like the following could be used:

           /* Obtain a duplicate of 'newfd' that can subsequently
              be used to check for close() errors; an EBADF error
              means that 'newfd' was not open. */

           tmpfd = dup(newfd);
           if (tmpfd == -1 && errno != EBADF) {
               /* Handle unexpected dup() error */
           }

           /* Atomically duplicate 'oldfd' on 'newfd' */

           if (dup2(oldfd, newfd) == -1) {
               /* Handle dup2() error */
           }

           /* Now check for close() errors on the file originally
              referred to by 'newfd' */

           if (tmpfd != -1) {
               if (close(tmpfd) == -1) {
                   /* Handle errors from close */
               }
           }

SEE ALSO
       close(2), fcntl(2), open(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                  DUP(2)
</pre>
<pre zoom>
<span xsmall>2 chown</span>
CHOWN(2)                                         Linux Programmer's Manual                                        CHOWN(2)

NAME
       chown, fchown, lchown, fchownat - change ownership of a file

SYNOPSIS
       #include <unistd.h>

       int chown(const char *pathname, uid_t owner, gid_t group);
       int fchown(int fd, uid_t owner, gid_t group);
       int lchown(const char *pathname, uid_t owner, gid_t group);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <unistd.h>

       int fchownat(int dirfd, const char *pathname,
                    uid_t owner, gid_t group, int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       fchown(), lchown():
           /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
               || _XOPEN_SOURCE >= 500
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE
       fchownat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  system  calls change the owner and group of a file.  The chown(), fchown(), and lchown() system calls differ
       only in how the file is specified:

       * chown() changes the ownership of the file specified by pathname, which is dereferenced if it is a symbolic link.

       * fchown() changes the ownership of the file referred to by the open file descriptor fd.

       * lchown() is like chown(), but does not dereference symbolic links.

       Only a privileged process (Linux: one with the CAP_CHOWN capability) may change the owner of a file.  The owner  of
       a file may change the group of the file to any group of which that owner is a member.  A privileged process (Linux:
       with CAP_CHOWN) may change the group arbitrarily.

       If the owner or group is specified as -1, then that ID is not changed.

       When the owner or group of an executable file is changed by an unprivileged user, the S_ISUID and S_ISGID mode bits
       are cleared.  POSIX does not specify whether this also should happen when root does the chown(); the Linux behavior
       depends on the kernel version, and since Linux 2.2.13, root is treated like other users.  In case of  a  non-group-
       executable  file  (i.e., one for which the S_IXGRP bit is not set) the S_ISGID bit indicates mandatory locking, and
       is not cleared by a chown().

       When the owner or group of an executable file is changed (by any user),  all  capability  sets  for  the  file  are
       cleared.

   fchownat()
       The fchownat() system call operates in exactly the same way as chown(), except for the differences described here.

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       chown() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like chown()).

       If pathname is absolute, then dirfd is ignored.

       The flags argument is a bit mask created by ORing together 0 or more of the following values;

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2)  O_PATH  flag).   In  this case, dirfd can refer to any type of file, not just a directory.  If
              dirfd is AT_FDCWD, the call operates on the current working directory.  This flag is Linux-specific;  define
              _GNU_SOURCE to obtain its definition.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a symbolic link, do not dereference it: instead operate on the link itself, like lchown().
              (By default, fchownat() dereferences symbolic links, like chown().)

       See openat(2) for an explanation of the need for fchownat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       Depending on the filesystem, errors other than those listed below can be returned.

       The more general errors for chown() are listed below.

       EACCES Search permission is denied on a component of the path prefix.  (See also path_resolution(7).)

       EFAULT pathname points outside your accessible address space.

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ENAMETOOLONG
              pathname is too long.

       ENOENT The file does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of the path prefix is not a directory.

       EPERM  The calling process did not have the required permissions (see above) to change owner and/or group.

       EPERM  The file is marked immutable or append-only.  (See ioctl_iflags(2).)

       EROFS  The named file resides on a read-only filesystem.

       The general errors for fchown() are listed below:

       EBADF  fd is not a valid open file descriptor.

       EIO    A low-level I/O error occurred while modifying the inode.

       ENOENT See above.

       EPERM  See above.

       EROFS  See above.

       The same errors that occur for chown() can also occur for fchownat().  The following additional  errors  can  occur
       for fchownat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fchownat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       chown(), fchown(), lchown(): 4.4BSD, SVr4, POSIX.1-2001, POSIX.1-2008.

       The 4.4BSD version can be used only by the superuser (that is, ordinary users cannot give away files).

       fchownat(): POSIX.1-2008.

NOTES
   Ownership of new files
       When  a  new  file  is created (by, for example, open(2) or mkdir(2)), its owner is made the same as the filesystem
       user ID of the creating process.  The group of the file depends on a  range  of  factors,  including  the  type  of
       filesystem,  the  options  used to mount the filesystem, and whether or not the set-group-ID mode bit is enabled on
       the parent directory.  If the filesystem supports the -o grpid (or, synonymously -o bsdgroups) and -o nogrpid  (or,
       synonymously -o sysvgroups) mount(8) options, then the rules are as follows:

       * If  the  filesystem is mounted with -o grpid, then the group of a new file is made the same as that of the parent
         directory.

       * If the filesystem is mounted with -o nogrpid and the set-group-ID bit is disabled on the parent  directory,  then
         the group of a new file is made the same as the process's filesystem GID.

       * If  the  filesystem  is mounted with -o nogrpid and the set-group-ID bit is enabled on the parent directory, then
         the group of a new file is made the same as that of the parent directory.

       As at Linux 4.12, the -o grpid and -o nogrpid mount options are supported by ext2, ext3, ext4, and  XFS.   Filesys‐
       tems that don't support these mount options follow the -o nogrpid rules.

   Glibc notes
       On  older  kernels where fchownat() is unavailable, the glibc wrapper function falls back to the use of chown() and
       lchown().  When pathname is a relative pathname, glibc  constructs  a  pathname  based  on  the  symbolic  link  in
       /proc/self/fd that corresponds to the dirfd argument.

   NFS
       The  chown()  semantics are deliberately violated on NFS filesystems which have UID mapping enabled.  Additionally,
       the semantics of all system calls which access the file contents are violated, because chown() may cause  immediate
       access  revocation on already open files.  Client side caching may lead to a delay between the time where ownership
       have been changed to allow access for a user and the time where the file can actually be accessed by  the  user  on
       other clients.

   Historical details
       The  original  Linux chown(), fchown(), and lchown() system calls supported only 16-bit user and group IDs.  Subse‐
       quently, Linux 2.4 added chown32(),  fchown32(),  and  lchown32(),  supporting  32-bit  IDs.   The  glibc  chown(),
       fchown(), and lchown() wrapper functions transparently deal with the variations across kernel versions.

       In  versions  of  Linux  prior  to 2.1.81 (and distinct from 2.1.46), chown() did not follow symbolic links.  Since
       Linux 2.1.81, chown() does follow symbolic links, and there is a new system call lchown() that does not follow sym‐
       bolic  links.   Since Linux 2.1.86, this new call (that has the same semantics as the old chown()) has got the same
       syscall number, and chown() got the newly introduced number.

EXAMPLE
       The following program changes the ownership of the file named in its second  command-line  argument  to  the  value
       specified  in its first command-line argument.  The new owner can be specified either as a numeric user ID, or as a
       username (which is converted to a user ID by using getpwnam(3) to perform a lookup in the system password file).

   Program source
       #include <pwd.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>

       int
       main(int argc, char *argv[])
       {
           uid_t uid;
           struct passwd *pwd;
           char *endptr;

           if (argc != 3 || argv[1][0] == '\0') {
               fprintf(stderr, "%s <owner> <file>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           uid = strtol(argv[1], &endptr, 10);  /* Allow a numeric string */

           if (*endptr != '\0') {         /* Was not pure numeric string */
               pwd = getpwnam(argv[1]);   /* Try getting UID for username */
               if (pwd == NULL) {
                   perror("getpwnam");
                   exit(EXIT_FAILURE);
               }

               uid = pwd->pw_uid;
           }

           if (chown(argv[2], uid, -1) == -1) {
               perror("chown");
               exit(EXIT_FAILURE);
           }

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       chgrp(1), chown(1), chmod(2), flock(2), path_resolution(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                CHOWN(2)
</pre>
<pre zoom>
<span xsmall>2 statvfs</span>
STATVFS(3)                                       Linux Programmer's Manual                                      STATVFS(3)

NAME
       statvfs, fstatvfs - get filesystem statistics

SYNOPSIS
       #include <sys/statvfs.h>

       int statvfs(const char *path, struct statvfs *buf);
       int fstatvfs(int fd, struct statvfs *buf);

DESCRIPTION
       The function statvfs() returns information about a mounted filesystem.  path is the pathname of any file within the
       mounted filesystem.  buf is a pointer to a statvfs structure defined approximately as follows:

           struct statvfs {
               unsigned long  f_bsize;    /* Filesystem block size */
               unsigned long  f_frsize;   /* Fragment size */
               fsblkcnt_t     f_blocks;   /* Size of fs in f_frsize units */
               fsblkcnt_t     f_bfree;    /* Number of free blocks */
               fsblkcnt_t     f_bavail;   /* Number of free blocks for
                                             unprivileged users */
               fsfilcnt_t     f_files;    /* Number of inodes */
               fsfilcnt_t     f_ffree;    /* Number of free inodes */
               fsfilcnt_t     f_favail;   /* Number of free inodes for
                                             unprivileged users */
               unsigned long  f_fsid;     /* Filesystem ID */
               unsigned long  f_flag;     /* Mount flags */
               unsigned long  f_namemax;  /* Maximum filename length */
           };

       Here the types fsblkcnt_t and fsfilcnt_t are defined in <sys/types.h>.  Both used to be unsigned long.

       The field f_flag is a bit mask indicating various options that were employed when  mounting  this  filesystem.   It
       contains zero or more of the following flags:

       ST_MANDLOCK
              Mandatory locking is permitted on the filesystem (see fcntl(2)).

       ST_NOATIME
              Do not update access times; see mount(2).

       ST_NODEV
              Disallow access to device special files on this filesystem.

       ST_NODIRATIME
              Do not update directory access times; see mount(2).

       ST_NOEXEC
              Execution of programs is disallowed on this filesystem.

       ST_NOSUID
              The set-user-ID and set-group-ID bits are ignored by exec(3) for executable files on this filesystem

       ST_RDONLY
              This filesystem is mounted read-only.

       ST_RELATIME
              Update atime relative to mtime/ctime; see mount(2).

       ST_SYNCHRONOUS
              Writes are synched to the filesystem immediately (see the description of O_SYNC in open(2)).

       It is unspecified whether all members of the returned struct have meaningful values on all filesystems.

       fstatvfs() returns the same information about an open file referenced by descriptor fd.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES (statvfs())  Search permission is denied for a component of the path prefix of path.  (See also path_resolu‐
              tion(7).)

       EBADF  (fstatvfs()) fd is not a valid open file descriptor.

       EFAULT Buf or path points to an invalid address.

       EINTR  This call was interrupted by a signal; see signal(7).

       EIO    An I/O error occurred while reading from the filesystem.

       ELOOP  (statvfs()) Too many symbolic links were encountered in translating path.

       ENAMETOOLONG
              (statvfs()) path is too long.

       ENOENT (statvfs()) The file referred to by path does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOSYS The filesystem does not support this call.

       ENOTDIR
              (statvfs()) A component of the path prefix of path is not a directory.

       EOVERFLOW
              Some values were too large to be represented in the returned struct.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌──────────────────────┬───────────────┬─────────┐
       │Interface             │ Attribute     │ Value   │
       ├──────────────────────┼───────────────┼─────────┤
       │statvfs(), fstatvfs() │ Thread safety │ MT-Safe │
       └──────────────────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

       Only the ST_NOSUID and ST_RDONLY flags of the f_flag field are specified in POSIX.1.  To obtain definitions of  the
       remaining flags, one must define _GNU_SOURCE.

NOTES
       The Linux kernel has system calls statfs(2) and fstatfs(2) to support this library call.

       In glibc versions before 2.13, statvfs() populated the bits of the f_flag field by scanning the mount options shown
       in /proc/mounts.  However, starting with Linux 2.6.36, the underlying statfs(2) system call provides the  necessary
       information  via  the f_flags field, and since glibc version 2.13, the statvfs() function will use information from
       that field rather than scanning /proc/mounts.

       The glibc implementations of

           pathconf(path, _PC_REC_XFER_ALIGN);
           pathconf(path, _PC_ALLOC_SIZE_MIN);
           pathconf(path, _PC_REC_MIN_XFER_SIZE);

       respectively use the f_frsize, f_frsize, and f_bsize fields returned by a call to statvfs() with the argument path.

SEE ALSO
       statfs(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              STATVFS(3)
</pre>
<pre zoom>
<span xsmall>2 sched_yield</span>
SCHED_YIELD(2)                                   Linux Programmer's Manual                                  SCHED_YIELD(2)

NAME
       sched_yield - yield the processor

SYNOPSIS
       #include <sched.h>

       int sched_yield(void);

DESCRIPTION
       sched_yield() causes the calling thread to relinquish the CPU.  The thread is moved to the end of the queue for its
       static priority and a new thread gets to run.

RETURN VALUE
       On success, sched_yield() returns 0.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       In the Linux implementation, sched_yield() always succeeds.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       If the calling thread is the only thread in the highest priority list at that time, it will continue to run after a
       call to sched_yield().

       POSIX systems on which sched_yield() is available define _POSIX_PRIORITY_SCHEDULING in <unistd.h>.

       Strategic  calls to sched_yield() can improve performance by giving other threads or processes a chance to run when
       (heavily) contended resources (e.g., mutexes) have been released by the caller.  Avoid calling sched_yield() unnec‐
       essarily  or  inappropriately (e.g., when resources needed by other schedulable threads are still held by the call‐
       er), since doing so will result in unnecessary context switches, which will degrade system performance.

       sched_yield() is intended for use with read-time scheduling  policies  (i.e.,  SCHED_FIFO  or  SCHED_RR).   Use  of
       sched_yield()  with  nondeterministic  scheduling policies such as SCHED_OTHER is unspecified and very likely means
       your application design is broken.

SEE ALSO
       sched(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                          SCHED_YIELD(2)
</pre>
<pre zoom>
<span xsmall>2 brk</span>
BRK(2)                                           Linux Programmer's Manual                                          BRK(2)

NAME
       brk, sbrk - change data segment size

SYNOPSIS
       #include <unistd.h>

       int brk(void *addr);

       void *sbrk(intptr_t increment);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       brk(), sbrk():
           Since glibc 2.19:
               _DEFAULT_SOURCE ||
                   (_XOPEN_SOURCE >= 500) &&
                   ! (_POSIX_C_SOURCE >= 200112L)
           From glibc 2.12 to 2.19:
               _BSD_SOURCE || _SVID_SOURCE ||
                   (_XOPEN_SOURCE >= 500) &&
                   ! (_POSIX_C_SOURCE >= 200112L)
           Before glibc 2.12:
               _BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE >= 500

DESCRIPTION
       brk()  and  sbrk()  change  the  location of the program break, which defines the end of the process's data segment
       (i.e., the program break is the first location after the end of the uninitialized data  segment).   Increasing  the
       program break has the effect of allocating memory to the process; decreasing the break deallocates memory.

       brk()  sets  the  end of the data segment to the value specified by addr, when that value is reasonable, the system
       has enough memory, and the process does not exceed its maximum data size (see setrlimit(2)).

       sbrk() increments the program's data space by increment bytes.  Calling sbrk() with an increment of 0 can  be  used
       to find the current location of the program break.

RETURN VALUE
       On success, brk() returns zero.  On error, -1 is returned, and errno is set to ENOMEM.

       On  success,  sbrk() returns the previous program break.  (If the break was increased, then this value is a pointer
       to the start of the newly allocated memory).  On error, (void *) -1 is returned, and errno is set to ENOMEM.

CONFORMING TO
       4.3BSD; SUSv1, marked LEGACY in SUSv2, removed in POSIX.1-2001.

NOTES
       Avoid using brk() and sbrk(): the malloc(3) memory allocation package is the portable and comfortable way of  allo‐
       cating memory.

       Various systems use various types for the argument of sbrk().  Common are int, ssize_t, ptrdiff_t, intptr_t.

   C library/kernel differences
       The  return  value  described  above for brk() is the behavior provided by the glibc wrapper function for the Linux
       brk() system call.  (On most other implementations, the return value from brk() is the same; this return value  was
       also  specified  in  SUSv2.)   However,  the actual Linux system call returns the new program break on success.  On
       failure, the system call returns the current break.  The glibc  wrapper  function  does  some  work  (i.e.,  checks
       whether the new break is less than addr) to provide the 0 and -1 return values described above.

       On Linux, sbrk() is implemented as a library function that uses the brk() system call, and does some internal book‐
       keeping so that it can return the old break value.

SEE ALSO
       execve(2), getrlimit(2), end(3), malloc(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2016-03-15                                                  BRK(2)
</pre>
<pre zoom>
<span xsmall>2 ioctl_iflags</span>
IOCTL_IFLAGS(2)                                  Linux Programmer's Manual                                 IOCTL_IFLAGS(2)

NAME
       ioctl_iflags - ioctl() operations for inode flags

DESCRIPTION
       Various  Linux  filesystems  support  the  notion  of inode flags—attributes that modify the semantics of files and
       directories.  These flags can be retrieved and modified using two ioctl(2) operations:

           int attr;
           fd = open("pathname", ...);

           ioctl(fd, FS_IOC_GETFLAGS, &attr);  /* Place current flags
                                                  in 'attr' */
           attr |= FS_NOATIME_FL;              /* Tweak returned bit mask */
           ioctl(fd, FS_IOC_SETFLAGS, &attr);  /* Update flags for inode
                                                  referred to by 'fd' */

       The lsattr(1) and chattr(1) shell commands provide interfaces to these two operations, allowing a user to view  and
       modify the inode flags associated with a file.

       The following flags are supported (shown along with the corresponding letter used to indicate the flag by lsattr(1)
       and chattr(1)):

       FS_APPEND_FL 'a'
              The file can be opened only with the O_APPEND flag.  (This restriction applies even to the superuser.)  Only
              a privileged process (CAP_LINUX_IMMUTABLE) can set or clear this attribute.

       FS_COMPR_FL 'c'
              Store  the  file  in  a  compressed  format  on  disk.  This flag is not supported by most of the mainstream
              filesystem implementations; one exception is btrfs(5).

       FS_DIRSYNC_FL 'D' (since Linux 2.6.0)
              Write directory changes synchronously to disk.  This flag provides  semantics  equivalent  to  the  mount(2)
              MS_DIRSYNC option, but on a per-directory basis.  This flag can be applied only to directories.

       FS_IMMUTABLE_FL 'i'
              The  file  is immutable: no changes are permitted to the file contents or metadata (permissions, timestamps,
              ownership, link count and so on).  (This restriction applies even to  the  superuser.)   Only  a  privileged
              process (CAP_LINUX_IMMUTABLE) can set or clear this attribute.

       FS_JOURNAL_DATA_FL 'j'
              Enable  journaling  of  file data on ext3(5) and ext4(5) filesystems.  On a filesystem that is journaling in
              ordered or writeback mode, a privileged (CAP_SYS_RESOURCE) process can set this flag to enable journaling of
              data updates on a per-file basis.

       FS_NOATIME_FL 'A'
              Don't update the file last access time when the file is accessed.  This can provide I/O performance benefits
              for applications that do not care about the accuracy of this timestamp.  This  flag  provides  functionality
              similar to the mount(2) MS_NOATIME flag, but on a per-file basis.

       FS_NOCOW_FL 'C' (since Linux 2.6.39)
              The  file  will  not  be subject to copy-on-write updates.  This flag has an effect only on filesystems that
              support copy-on-write semantics, such as Btrfs.  See chattr(1) and btrfs(5).

       FS_NODUMP_FL 'd'
              Don't include this file in backups made using dump(8).

       FS_NOTAIL_FL 't'
              This flag is supported only on Reiserfs.  It disables the Reiserfs tail-packing feature, which tries to pack
              small files (and the final fragment of larger files) into the same disk block as the file metadata.

       FS_PROJINHERIT_FL 'P' (since Linux 4.5)
              Inherit  the quota project ID.  Files and subdirectories will inherit the project ID of the directory.  This
              flag can be applied only to directories.

       FS_SECRM_FL 's'
              Mark the file for secure deletion.  This feature is not implemented by any filesystem,  since  the  task  of
              securely erasing a file from a recording medium is surprisingly difficult.

       FS_SYNC_FL 'S'
              Make  file  updates  synchronous.   For files, this makes all writes synchronous (as though all opens of the
              file were with the O_SYNC flag).  For directories, this has the same effect as the FS_DIRSYNC_FL flag.

       FS_TOPDIR_FL 'T'
              Mark a directory for special treatment  under  the  Orlov  block-allocation  strategy.   See  chattr(1)  for
              details.  This flag can be applied only to directories and has an effect only for ext2, ext3, and ext4.

       FS_UNRM_FL 'u'
              Allow  the  file to be undeleted if it is deleted.  This feature is not implemented by any filesystem, since
              it is possible to implement file-recovery mechanisms outside the kernel.

       In most cases, when any of the above flags is set on a directory, the flag is inherited by files and subdirectories
       created inside that directory.  Exceptions include FS_TOPDIR_FL, which is not inheritable, and FS_DIRSYNC_FL, which
       is inherited only by subdirectories.

CONFORMING TO
       Inode flags are a nonstandard Linux extension.

NOTES
       In order to change the inode flags of a file using the FS_IOC_SETFLAGS operation, the  effective  user  ID  of  the
       caller must match the owner of the file, or the caller must have the CAP_FOWNER capability.

SEE ALSO
       chattr(1), lsattr(1), mount(2), btrfs(5), ext4(5), xfs(5), xattr(7), mount(8)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                         IOCTL_IFLAGS(2)
</pre>
<pre zoom>
<span xsmall>2 chmod</span>
CHMOD(2)                                         Linux Programmer's Manual                                        CHMOD(2)

NAME
       chmod, fchmod, fchmodat - change permissions of a file

SYNOPSIS
       #include <sys/stat.h>

       int chmod(const char *pathname, mode_t mode);
       int fchmod(int fd, mode_t mode);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       fchmod():
           Since glibc 2.24:
               _POSIX_C_SOURCE >= 199309L
           Glibc 2.19 to 2.23
               _POSIX_C_SOURCE
           Glibc 2.16 to 2.19:
               _BSD_SOURCE || _POSIX_C_SOURCE
           Glibc 2.12 to 2.16:
               _BSD_SOURCE || _XOPEN_SOURCE >= 500 ||
                   _POSIX_C_SOURCE >= 200809L
           Glibc 2.11 and earlier:
               _BSD_SOURCE || _XOPEN_SOURCE >= 500

       fchmodat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       The  chmod()  and  fchmod()  system calls change a files mode bits.  (The file mode consists of the file permission
       bits plus the set-user-ID, set-group-ID, and sticky bits.)  These system calls differ only in how the file is spec‐
       ified:

       * chmod()  changes  the mode of the file specified whose pathname is given in pathname, which is dereferenced if it
         is a symbolic link.

       * fchmod() changes the mode of the file referred to by the open file descriptor fd.

       The new file mode is specified in mode, which is a bit mask created by ORing together zero or more of  the  follow‐
       ing:

       S_ISUID  (04000)  set-user-ID (set process effective user ID on execve(2))

       S_ISGID  (02000)  set-group-ID  (set  process  effective  group ID on execve(2); mandatory locking, as described in
                         fcntl(2); take a new file's group from parent directory, as described in chown(2) and mkdir(2))

       S_ISVTX  (01000)  sticky bit (restricted deletion flag, as described in unlink(2))

       S_IRUSR  (00400)  read by owner

       S_IWUSR  (00200)  write by owner

       S_IXUSR  (00100)  execute/search by owner ("search" applies for directories, and  means  that  entries  within  the
                         directory can be accessed)

       S_IRGRP  (00040)  read by group

       S_IWGRP  (00020)  write by group

       S_IXGRP  (00010)  execute/search by group

       S_IROTH  (00004)  read by others

       S_IWOTH  (00002)  write by others

       S_IXOTH  (00001)  execute/search by others

       The  effective  UID  of  the  calling  process  must match the owner of the file, or the process must be privileged
       (Linux: it must have the CAP_FOWNER capability).

       If the calling process is not privileged (Linux: does not have the CAP_FSETID capability), and  the  group  of  the
       file  does  not  match the effective group ID of the process or one of its supplementary group IDs, the S_ISGID bit
       will be turned off, but this will not cause an error to be returned.

       As a security measure, depending on the filesystem, the set-user-ID and set-group-ID execution bits may  be  turned
       off  if a file is written.  (On Linux, this occurs if the writing process does not have the CAP_FSETID capability.)
       On some filesystems, only the superuser can set the sticky bit, which may have a special meaning.  For  the  sticky
       bit, and for set-user-ID and set-group-ID bits on directories, see inode(7).

       On  NFS  filesystems, restricting the permissions will immediately influence already open files, because the access
       control is done on the server, but open files are maintained by  the  client.   Widening  the  permissions  may  be
       delayed for other clients if attribute caching is enabled on them.

   fchmodat()
       The fchmodat() system call operates in exactly the same way as chmod(), except for the differences described here.

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       chmod() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like chmod()).

       If pathname is absolute, then dirfd is ignored.

       flags can either be 0, or include the following flag:

       AT_SYMLINK_NOFOLLOW
              If pathname is a symbolic link, do not dereference it: instead operate on the link itself.  This flag is not
              currently implemented.

       See openat(2) for an explanation of the need for fchmodat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       Depending on the filesystem, errors other than those listed below can be returned.

       The more general errors for chmod() are listed below:

       EACCES Search permission is denied on a component of the path prefix.  (See also path_resolution(7).)

       EFAULT pathname points outside your accessible address space.

       EIO    An I/O error occurred.

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ENAMETOOLONG
              pathname is too long.

       ENOENT The file does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of the path prefix is not a directory.

       EPERM  The  effective  UID  does not match the owner of the file, and the process is not privileged (Linux: it does
              not have the CAP_FOWNER capability).

       EPERM  The file is marked immutable or append-only.  (See ioctl_iflags(2).)

       EROFS  The named file resides on a read-only filesystem.

       The general errors for fchmod() are listed below:

       EBADF  The file descriptor fd is not valid.

       EIO    See above.

       EPERM  See above.

       EROFS  See above.

       The same errors that occur for chmod() can also occur for fchmodat().  The following additional  errors  can  occur
       for fchmodat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

       ENOTSUP
              flags specified AT_SYMLINK_NOFOLLOW, which is not supported.

VERSIONS
       fchmodat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       chmod(), fchmod(): 4.4BSD, SVr4, POSIX.1-2001i, POSIX.1-2008.

       fchmodat(): POSIX.1-2008.

NOTES
   C library/kernel differences
       The  GNU  C  library  fchmodat()  wrapper function implements the POSIX-specified interface described in this page.
       This interface differs from the underlying Linux system call, which does not have a flags argument.

   Glibc notes
       On older kernels where fchmodat() is unavailable, the glibc wrapper function falls back  to  the  use  of  chmod().
       When  pathname is a relative pathname, glibc constructs a pathname based on the symbolic link in /proc/self/fd that
       corresponds to the dirfd argument.

SEE ALSO
       chmod(1), chown(2), execve(2), open(2), stat(2), inode(7), path_resolution(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                CHMOD(2)
</pre>
<pre zoom>
<span xsmall>2 getresgid32</span>
GETRESUID(2)                                     Linux Programmer's Manual                                    GETRESUID(2)

NAME
       getresuid, getresgid - get real, effective and saved user/group IDs

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <unistd.h>

       int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
       int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);

DESCRIPTION
       getresuid() returns the real UID, the effective UID, and the saved set-user-ID of the calling process, in the argu‐
       ments ruid, euid, and suid, respectively.  getresgid() performs the analogous task for the process's group IDs.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT One of the arguments specified an address outside the calling program's address space.

VERSIONS
       These system calls appeared on Linux starting with kernel 2.1.44.

       The prototypes are given by glibc since version 2.3.2, provided _GNU_SOURCE is defined.

CONFORMING TO
       These calls are nonstandard; they also appear on HP-UX and some of the BSDs.

NOTES
       The original Linux getresuid() and getresgid() system calls supported only  16-bit  user  and  group  IDs.   Subse‐
       quently, Linux 2.4 added getresuid32() and getresgid32(), supporting 32-bit IDs.  The glibc getresuid() and getres‐
       gid() wrapper functions transparently deal with the variations across kernel versions.

SEE ALSO
       getuid(2), setresuid(2), setreuid(2), setuid(2), credentials(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            GETRESUID(2)
</pre>
<pre zoom>
<span xsmall>2 readlink</span>
READLINK(2)                                      Linux Programmer's Manual                                     READLINK(2)

NAME
       readlink, readlinkat - read value of a symbolic link

SYNOPSIS
       #include <unistd.h>

       ssize_t readlink(const char *pathname, char *buf, size_t bufsiz);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <unistd.h>

       ssize_t readlinkat(int dirfd, const char *pathname,
                          char *buf, size_t bufsiz);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       readlink():
           _XOPEN_SOURCE >= 500 || _POSIX_C_SOURCE >= 200112L
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

       readlinkat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       readlink()  places the contents of the symbolic link pathname in the buffer buf, which has size bufsiz.  readlink()
       does not append a null byte to buf.  It will (silently) truncate the contents (to a length of  bufsiz  characters),
       in case the buffer is too small to hold all of the contents.

   readlinkat()
       The  readlinkat()  system call operates in exactly the same way as readlink(), except for the differences described
       here.

       If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by  the
       file  descriptor dirfd (rather than relative to the current working directory of the calling process, as is done by
       readlink() for a relative pathname).

       If pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the  cur‐
       rent working directory of the calling process (like readlink()).

       If pathname is absolute, then dirfd is ignored.

       Since  Linux 2.6.39, pathname can be an empty string, in which case the call operates on the symbolic link referred
       to by dirfd (which should have been obtained using open(2) with the O_PATH and O_NOFOLLOW flags).

       See openat(2) for an explanation of the need for readlinkat().

RETURN VALUE
       On success, these calls return the number of bytes placed in buf.  (If the returned value equals bufsiz, then trun‐
       cation may have occurred.)  On error, -1 is returned and errno is set to indicate the error.

ERRORS
       EACCES Search permission is denied for a component of the path prefix.  (See also path_resolution(7).)

       EFAULT buf extends outside the process's allocated address space.

       EINVAL bufsiz is not positive.

       EINVAL The named file (i.e., the final filename component of pathname) is not a symbolic link.

       EIO    An I/O error occurred while reading from the filesystem.

       ELOOP  Too many symbolic links were encountered in translating the pathname.

       ENAMETOOLONG
              A pathname, or a component of a pathname, was too long.

       ENOENT The named file does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of the path prefix is not a directory.

       The following additional errors can occur for readlinkat():

       EBADF  dirfd is not a valid file descriptor.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       readlinkat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       readlink(): 4.4BSD (readlink() first appeared in 4.2BSD), POSIX.1-2001, POSIX.1-2008.

       readlinkat(): POSIX.1-2008.

NOTES
       In  versions  of glibc up to and including glibc 2.4, the return type of readlink() was declared as int.  Nowadays,
       the return type is declared as ssize_t, as (newly) required in POSIX.1-2001.

       Using a statically sized buffer might not provide enough room for the symbolic link contents.   The  required  size
       for  the  buffer  can be obtained from the stat.st_size value returned by a call to lstat(2) on the link.  However,
       the number of bytes written by readlink() and readlinkat() should be checked to make sure that the size of the sym‐
       bolic  link  did not increase between the calls.  Dynamically allocating the buffer for readlink() and readlinkat()
       also addresses a common portability problem when using PATH_MAX for the buffer size, as this constant is not  guar‐
       anteed to be defined per POSIX if the system does not have such limit.

   Glibc notes
       On older kernels where readlinkat() is unavailable, the glibc wrapper function falls back to the use of readlink().
       When pathname is a relative pathname, glibc constructs a pathname based on the symbolic link in /proc/self/fd  that
       corresponds to the dirfd argument.

EXAMPLE
       The  following  program  allocates  the  buffer  needed  by readlink() dynamically from the information provided by
       lstat(2), falling back to a buffer of size PATH_MAX in cases where lstat(2) reports a size of zero.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <limits.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;
           char *buf;
           ssize_t nbytes, bufsiz;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           /* Add one to the link size, so that we can determine whether
              the buffer returned by readlink() was truncated. */

           bufsiz = sb.st_size + 1;

           /* Some magic symlinks under (for example) /proc and /sys
              report 'st_size' as zero. In that case, take PATH_MAX as
              a "good enough" estimate. */

           if (sb.st_size == 0)
               bufsiz = PATH_MAX;

           buf = malloc(bufsiz);
           if (buf == NULL) {
               perror("malloc");
               exit(EXIT_FAILURE);
           }

           nbytes = readlink(argv[1], buf, bufsiz);
           if (nbytes == -1) {
               perror("readlink");
               exit(EXIT_FAILURE);
           }

           printf("'%s' points to '%.*s'\n", argv[1], (int) nbytes, buf);

           /* If the return value was equal to the buffer size, then the
              the link target was larger than expected (perhaps because the
              target was changed between the call to lstat() and the call to
              readlink()). Warn the user that the returned target may have
              been truncated. */

           if (nbytes == bufsiz)
               printf("(Returned buffer may have been truncated)\n");

           free(buf);
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       readlink(1), lstat(2), stat(2), symlink(2), realpath(3), path_resolution(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             READLINK(2)
</pre>
<pre zoom>
<span xsmall>2 select</span>
SELECT(2)                                        Linux Programmer's Manual                                       SELECT(2)

NAME
       select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O multiplexing

SYNOPSIS
       /* According to POSIX.1-2001, POSIX.1-2008 */
       #include <sys/select.h>

       /* According to earlier standards */
       #include <sys/time.h>
       #include <sys/types.h>
       #include <unistd.h>

       int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);

       void FD_CLR(int fd, fd_set *set);
       int  FD_ISSET(int fd, fd_set *set);
       void FD_SET(int fd, fd_set *set);
       void FD_ZERO(fd_set *set);

       #include <sys/select.h>

       int pselect(int nfds, fd_set *readfds, fd_set *writefds,
                   fd_set *exceptfds, const struct timespec *timeout,
                   const sigset_t *sigmask);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pselect(): _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       select()  and pselect() allow a program to monitor multiple file descriptors, waiting until one or more of the file
       descriptors become "ready" for some class of I/O operation (e.g., input possible).  A file descriptor is considered
       ready if it is possible to perform a corresponding I/O operation (e.g., read(2) without blocking, or a sufficiently
       small write(2)).

       select() can monitor only file descriptors numbers that are less than FD_SETSIZE; poll(2) does not have this  limi‐
       tation.  See BUGS.

       The operation of select() and pselect() is identical, other than these three differences:

       (i)    select()  uses  a  timeout  that is a struct timeval (with seconds and microseconds), while pselect() uses a
              struct timespec (with seconds and nanoseconds).

       (ii)   select() may update the timeout argument to indicate how much time was left.  pselect() does not change this
              argument.

       (iii)  select() has no sigmask argument, and behaves as pselect() called with NULL sigmask.

       Three  independent sets of file descriptors are watched.  The file descriptors listed in readfds will be watched to
       see if characters become available for reading (more precisely, to see if a read will not block; in  particular,  a
       file descriptor is also ready on end-of-file).  The file descriptors in writefds will be watched to see if space is
       available for write (though a large write may still block).  The file descriptors in exceptfds will be watched  for
       exceptional conditions.  (For examples of some exceptional conditions, see the discussion of POLLPRI in poll(2).)

       On  exit, each of the file descriptor sets is modified in place to indicate which file descriptors actually changed
       status.  (Thus, if using select() within a loop, the sets must be reinitialized before each call.)

       Each of the three file descriptor sets may be specified as NULL if no file descriptors are to be  watched  for  the
       corresponding class of events.

       Four  macros  are provided to manipulate the sets.  FD_ZERO() clears a set.  FD_SET() and FD_CLR() respectively add
       and remove a given file descriptor from a set.  FD_ISSET() tests to see if a file descriptor is part  of  the  set;
       this is useful after select() returns.

       nfds  should  be  set to the highest-numbered file descriptor in any of the three sets, plus 1.  The indicated file
       descriptors in each set are checked, up to this limit (but see BUGS).

       The timeout argument specifies the interval that select() should block waiting for  a  file  descriptor  to  become
       ready.  The call will block until either:

       *  a file descriptor becomes ready;

       *  the call is interrupted by a signal handler; or

       *  the timeout expires.

       Note  that  the  timeout  interval will be rounded up to the system clock granularity, and kernel scheduling delays
       mean that the blocking interval may overrun by a small amount.  If both fields of the timeval structure  are  zero,
       then  select()  returns  immediately.  (This is useful for polling.)  If timeout is NULL (no timeout), select() can
       block indefinitely.

       sigmask is a pointer to a signal mask (see sigprocmask(2)); if it is not NULL, then pselect()  first  replaces  the
       current signal mask by the one pointed to by sigmask, then does the "select" function, and then restores the origi‐
       nal signal mask.

       Other than the difference in the precision of the timeout argument, the following pselect() call:

           ready = pselect(nfds, &readfds, &writefds, &exceptfds,
                           timeout, &sigmask);

       is equivalent to atomically executing the following calls:

           sigset_t origmask;

           pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);
           ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);
           pthread_sigmask(SIG_SETMASK, &origmask, NULL);

       The reason that pselect() is needed is that if one wants to wait for either a signal or for a  file  descriptor  to
       become  ready, then an atomic test is needed to prevent race conditions.  (Suppose the signal handler sets a global
       flag and returns.  Then a test of this global flag followed by a call of select() could hang  indefinitely  if  the
       signal arrived just after the test but just before the call.  By contrast, pselect() allows one to first block sig‐
       nals, handle the signals that have come in, then call pselect() with the desired sigmask, avoiding the race.)

   The timeout
       The time structures involved are defined in <sys/time.h> and look like

           struct timeval {
               long    tv_sec;         /* seconds */
               long    tv_usec;        /* microseconds */
           };

       and

           struct timespec {
               long    tv_sec;         /* seconds */
               long    tv_nsec;        /* nanoseconds */
           };

       (However, see below on the POSIX.1 versions.)

       Some code calls select() with all three sets empty, nfds zero, and a non-NULL timeout as a fairly portable  way  to
       sleep with subsecond precision.

       On  Linux,  select() modifies timeout to reflect the amount of time not slept; most other implementations do not do
       this.  (POSIX.1 permits either behavior.)  This causes problems both when Linux code which reads timeout is  ported
       to other operating systems, and when code is ported to Linux that reuses a struct timeval for multiple select()s in
       a loop without reinitializing it.  Consider timeout to be undefined after select() returns.

RETURN VALUE
       On success, select() and pselect() return the number of file descriptors contained in the three returned descriptor
       sets  (that  is,  the  total  number of bits that are set in readfds, writefds, exceptfds) which may be zero if the
       timeout expires before anything interesting happens.  On error, -1 is returned, and errno is set  to  indicate  the
       error; the file descriptor sets are unmodified, and timeout becomes undefined.

ERRORS
       EBADF  An  invalid  file  descriptor  was  given  in  one of the sets.  (Perhaps a file descriptor that was already
              closed, or one on which an error has occurred.)  However, see BUGS.

       EINTR  A signal was caught; see signal(7).

       EINVAL nfds is negative or exceeds the RLIMIT_NOFILE resource limit (see getrlimit(2)).

       EINVAL The value contained within timeout is invalid.

       ENOMEM Unable to allocate memory for internal tables.

VERSIONS
       pselect() was added to Linux in kernel 2.6.16.  Prior to this, pselect() was emulated in glibc (but see BUGS).

CONFORMING TO
       select() conforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD (select() first appeared in 4.2BSD).  Generally  porta‐
       ble to/from non-BSD systems supporting clones of the BSD socket layer (including System V variants).  However, note
       that the System V variant typically sets the timeout variable before exit, but the BSD variant does not.

       pselect() is defined in POSIX.1g, and in POSIX.1-2001 and POSIX.1-2008.

NOTES
       An fd_set is a fixed size buffer.  Executing FD_CLR() or FD_SET() with a value of fd that is negative or  is  equal
       to  or  larger  than  FD_SETSIZE will result in undefined behavior.  Moreover, POSIX requires fd to be a valid file
       descriptor.

       On some other UNIX systems, select() can fail with the error EAGAIN if the system fails to allocate kernel-internal
       resources, rather than ENOMEM as Linux does.  POSIX specifies this error for poll(2), but not for select().  Porta‐
       ble programs may wish to check for EAGAIN and loop, just as with EINTR.

       On systems that lack pselect(), reliable (and more portable) signal trapping can be achieved  using  the  self-pipe
       trick.  In this technique, a signal handler writes a byte to a pipe whose other end is monitored by select() in the
       main program.  (To avoid possibly blocking when writing to a pipe that may be full or reading from a pipe that  may
       be empty, nonblocking I/O is used when reading from and writing to the pipe.)

       Concerning  the  types involved, the classical situation is that the two fields of a timeval structure are typed as
       long (as shown above), and the structure is defined in <sys/time.h>.  The POSIX.1 situation is

           struct timeval {
               time_t         tv_sec;     /* seconds */
               suseconds_t    tv_usec;    /* microseconds */
           };

       where the structure is defined in <sys/select.h>  and  the  data  types  time_t  and  suseconds_t  are  defined  in
       <sys/types.h>.

       Concerning prototypes, the classical situation is that one should include <time.h> for select().  The POSIX.1 situ‐
       ation is that one should include <sys/select.h> for select() and pselect().

       Under glibc 2.0, <sys/select.h> gives the wrong prototype for pselect().  Under glibc 2.1 to 2.2.1, it  gives  pse‐
       lect() when _GNU_SOURCE is defined.  Since glibc 2.2.2, the requirements are as shown in the SYNOPSIS.

   Correspondence between select() and poll() notifications
       Within  the  Linux kernel source, we find the following definitions which show the correspondence between the read‐
       able, writable, and exceptional condition notifications of select() and the event notifications provided by poll(2)
       (and epoll(7)):

           #define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP |
                               POLLERR)
                              /* Ready for reading */
           #define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)
                              /* Ready for writing */
           #define POLLEX_SET (POLLPRI)
                              /* Exceptional condition */

   Multithreaded applications
       If  a  file descriptor being monitored by select() is closed in another thread, the result is unspecified.  On some
       UNIX systems, select() unblocks and returns, with an indication that the file descriptor is ready (a subsequent I/O
       operation  will  likely  fail  with an error, unless another the file descriptor reopened between the time select()
       returned and the I/O operations was performed).  On Linux (and some other systems), closing the file descriptor  in
       another thread has no effect on select().  In summary, any application that relies on a particular behavior in this
       scenario must be considered buggy.

   C library/kernel differences
       The Linux kernel allows file descriptor sets of arbitrary size, determining the length of the sets  to  be  checked
       from the value of nfds.  However, in the glibc implementation, the fd_set type is fixed in size.  See also BUGS.

       The  pselect() interface described in this page is implemented by glibc.  The underlying Linux system call is named
       pselect6().  This system call has somewhat different behavior from the glibc wrapper function.

       The Linux pselect6() system call modifies its timeout argument.  However, the glibc  wrapper  function  hides  this
       behavior  by  using  a  local variable for the timeout argument that is passed to the system call.  Thus, the glibc
       pselect() function does not modify its timeout argument; this is the behavior required by POSIX.1-2001.

       The final argument of the pselect6() system call is not a sigset_t * pointer, but is instead  a  structure  of  the
       form:

           struct {
               const kernel_sigset_t *ss;   /* Pointer to signal set */
               size_t ss_len;               /* Size (in bytes) of object
                                               pointed to by 'ss' */
           };

       This  allows  the  system call to obtain both a pointer to the signal set and its size, while allowing for the fact
       that most architectures support a maximum of 6 arguments to a system call.  See sigprocmask(2) for a discussion  of
       the difference between the kernel and libc notion of the signal set.

BUGS
       POSIX  allows  an  implementation to define an upper limit, advertised via the constant FD_SETSIZE, on the range of
       file descriptors that can be specified in a file descriptor set.  The Linux kernel imposes no fixed limit, but  the
       glibc implementation makes fd_set a fixed-size type, with FD_SETSIZE defined as 1024, and the FD_*() macros operat‐
       ing according to that limit.  To monitor file descriptors greater than 1023, use poll(2) instead.

       According to POSIX, select() should check all specified file descriptors in the three file descriptor sets,  up  to
       the  limit  nfds-1.   However, the current implementation ignores any file descriptor in these sets that is greater
       than the maximum file descriptor number that the process currently has open.  According to  POSIX,  any  such  file
       descriptor that is specified in one of the sets should result in the error EBADF.

       Glibc 2.0 provided a version of pselect() that did not take a sigmask argument.

       Starting  with  version 2.1, glibc provided an emulation of pselect() that was implemented using sigprocmask(2) and
       select().  This implementation remained vulnerable to the very race condition that pselect() was designed  to  pre‐
       vent.  Modern versions of glibc use the (race-free) pselect() system call on kernels where it is provided.

       Under  Linux,  select() may report a socket file descriptor as "ready for reading", while nevertheless a subsequent
       read blocks.  This could for example happen when data has arrived but upon examination has wrong  checksum  and  is
       discarded.   There  may be other circumstances in which a file descriptor is spuriously reported as ready.  Thus it
       may be safer to use O_NONBLOCK on sockets that should not block.

       On Linux, select() also modifies timeout if the call is interrupted by a signal  handler  (i.e.,  the  EINTR  error
       return).   This  is not permitted by POSIX.1.  The Linux pselect() system call has the same behavior, but the glibc
       wrapper hides this behavior by internally copying the timeout to a local variable and passing that variable to  the
       system call.

EXAMPLE
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/time.h>
       #include <sys/types.h>
       #include <unistd.h>

       int
       main(void)
       {
           fd_set rfds;
           struct timeval tv;
           int retval;

           /* Watch stdin (fd 0) to see when it has input. */

           FD_ZERO(&rfds);
           FD_SET(0, &rfds);

           /* Wait up to five seconds. */

           tv.tv_sec = 5;
           tv.tv_usec = 0;

           retval = select(1, &rfds, NULL, NULL, &tv);
           /* Don't rely on the value of tv now! */

           if (retval == -1)
               perror("select()");
           else if (retval)
               printf("Data is available now.\n");
               /* FD_ISSET(0, &rfds) will be true. */
           else
               printf("No data within five seconds.\n");

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       accept(2),  connect(2), poll(2), read(2), recv(2), restart_syscall(2), send(2), sigprocmask(2), write(2), epoll(7),
       time(7)

       For a tutorial with discussion and examples, see select_tut(2).

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SELECT(2)
</pre>
<pre zoom>
<span xsmall>2 get_kernel_syms</span>
GET_KERNEL_SYMS(2)                               Linux Programmer's Manual                              GET_KERNEL_SYMS(2)

NAME
       get_kernel_syms - retrieve exported kernel and module symbols

SYNOPSIS
       #include <linux/module.h>

       int get_kernel_syms(struct kernel_sym *table);

       Note: No declaration of this system call is provided in glibc headers; see NOTES.

DESCRIPTION
       Note: This system call is present only in kernels before Linux 2.6.

       If  table  is  NULL, get_kernel_syms() returns the number of symbols available for query.  Otherwise, it fills in a
       table of structures:

           struct kernel_sym {
               unsigned long value;
               char          name[60];
           };

       The symbols are interspersed with magic symbols of the form #module-name with the kernel having an empty name.  The
       value associated with a symbol of this form is the address at which the module is loaded.

       The  symbols exported from each module follow their magic module tag and the modules are returned in the reverse of
       the order in which they were loaded.

RETURN VALUE
       On success, returns the number of symbols copied to table.  On error, -1 is returned and  errno  is  set  appropri‐
       ately.

ERRORS
       There is only one possible error return:

       ENOSYS get_kernel_syms() is not supported in this version of the kernel.

VERSIONS
       This system call is present on Linux only up until kernel 2.4; it was removed in Linux 2.6.

CONFORMING TO
       get_kernel_syms() is Linux-specific.

NOTES
       This  obsolete  system call is not supported by glibc.  No declaration is provided in glibc headers, but, through a
       quirk of history, glibc versions before 2.23 did export an ABI for this system call.  Therefore, in order to employ
       this system call, it was sufficient to manually declare the interface in your code; alternatively, you could invoke
       the system call using syscall(2).

BUGS
       There is no way to indicate the size of the buffer allocated for table.  If symbols have been added to  the  kernel
       since the program queried for the symbol table size, memory will be corrupted.

       The length of exported symbol names is limited to 59 characters.

       Because  of these limitations, this system call is deprecated in favor of query_module(2) (which is itself nowadays
       deprecated in favor of other interfaces described on its manual page).

SEE ALSO
       create_module(2), delete_module(2), init_module(2), query_module(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                      GET_KERNEL_SYMS(2)
</pre>
<pre zoom>
<span xsmall>2 adjtimex</span>
ADJTIMEX(2)                                      Linux Programmer's Manual                                     ADJTIMEX(2)

NAME
       adjtimex, ntp_adjtime - tune kernel clock

SYNOPSIS
       #include <sys/timex.h>

       int adjtimex(struct timex *buf);

       int ntp_adjtime(struct timex *buf);

DESCRIPTION
       Linux uses David L. Mills' clock adjustment algorithm (see RFC 5905).  The system call adjtimex() reads and option‐
       ally sets adjustment parameters for this algorithm.  It takes a pointer to a timex structure, updates kernel param‐
       eters  from  (selected)  field values, and returns the same structure updated with the current kernel values.  This
       structure is declared as follows:

           struct timex {
               int  modes;      /* Mode selector */
               long offset;     /* Time offset; nanoseconds, if STA_NANO
                                   status flag is set, otherwise
                                   microseconds */
               long freq;       /* Frequency offset; see NOTES for units */
               long maxerror;   /* Maximum error (microseconds) */
               long esterror;   /* Estimated error (microseconds) */
               int  status;     /* Clock command/status */
               long constant;   /* PLL (phase-locked loop) time constant */
               long precision;  /* Clock precision
                                   (microseconds, read-only) */
               long tolerance;  /* Clock frequency tolerance (read-only);
                                   see NOTES for units */
               struct timeval time;
                                /* Current time (read-only, except for
                                   ADJ_SETOFFSET); upon return, time.tv_usec
                                   contains nanoseconds, if STA_NANO status
                                   flag is set, otherwise microseconds */
               long tick;       /* Microseconds between clock ticks */
               long ppsfreq;    /* PPS (pulse per second) frequency
                                   (read-only); see NOTES for units */
               long jitter;     /* PPS jitter (read-only); nanoseconds, if
                                   STA_NANO status flag is set, otherwise
                                   microseconds */
               int  shift;      /* PPS interval duration
                                   (seconds, read-only) */
               long stabil;     /* PPS stability (read-only);
                                   see NOTES for units */
               long jitcnt;     /* PPS count of jitter limit exceeded
                                   events (read-only) */
               long calcnt;     /* PPS count of calibration intervals
                                   (read-only) */
               long errcnt;     /* PPS count of calibration errors
                                   (read-only) */
               long stbcnt;     /* PPS count of stability limit exceeded
                                   events (read-only) */
               int tai;         /* TAI offset, as set by previous ADJ_TAI
                                   operation (seconds, read-only,
                                   since Linux 2.6.26) */
               /* Further padding bytes to allow for future expansion */
           };

       The modes field determines which parameters, if any, to set.  (As described later in this page, the constants  used
       for  ntp_adjtime()  are equivalent but differently named.)  It is a bit mask containing a bitwise-or combination of
       zero or more of the following bits:

       ADJ_OFFSET
              Set time offset from buf.offset.  Since Linux 2.6.26, the supplied value is clamped  to  the  range  (-0.5s,
              +0.5s).  In older kernels, an EINVAL error occurs if the supplied value is out of range.

       ADJ_FREQUENCY
              Set  frequency  offset  from  buf.freq.   Since  Linux  2.6.26,  the  supplied value is clamped to the range
              (-32768000, +32768000).  In older kernels, an EINVAL error occurs if the supplied value is out of range.

       ADJ_MAXERROR
              Set maximum time error from buf.maxerror.

       ADJ_ESTERROR
              Set estimated time error from buf.esterror.

       ADJ_STATUS
              Set clock status bits from buf.status.  A description of these bits is provided below.

       ADJ_TIMECONST
              Set PLL time constant from buf.constant.  If the STA_NANO status flag (see below) is clear, the kernel  adds
              4 to this value.

       ADJ_SETOFFSET (since Linux 2.6.39)
              Add buf.time to the current time.  If buf.status includes the ADJ_NANO flag, then buf.time.tv_usec is inter‐
              preted as a nanosecond value; otherwise it is interpreted as microseconds.

       ADJ_MICRO (since Linux 2.6.26)
              Select microsecond resolution.

       ADJ_NANO (since Linux 2.6.26)
              Select nanosecond resolution.  Only one of ADJ_MICRO and ADJ_NANO should be specified.

       ADJ_TAI (since Linux 2.6.26)
              Set TAI (Atomic International Time) offset from buf.constant.

              ADJ_TAI should not be used in conjunction with  ADJ_TIMECONST,  since  the  latter  mode  also  employs  the
              buf.constant field.

              For   a   complete   explanation   of   TAI   and   the   difference   between   TAI   and   UTC,  see  BIPM
              ⟨http://www.bipm.org/en/bipm/tai/tai.html⟩

       ADJ_TICK
              Set tick value from buf.tick.

       Alternatively, modes can be specified as either of the following (multibit mask) values, in which case  other  bits
       should not be specified in modes:

       ADJ_OFFSET_SINGLESHOT
              Old-fashioned  adjtime():  (gradually)  adjust  time  by  value  specified in buf.offset, which specifies an
              adjustment in microseconds.

       ADJ_OFFSET_SS_READ (functional since Linux 2.6.28)
              Return (in buf.offset) the remaining amount of time to be adjusted after  an  earlier  ADJ_OFFSET_SINGLESHOT
              operation.  This feature was added in Linux 2.6.24, but did not work correctly until Linux 2.6.28.

       Ordinary  users  are restricted to a value of either 0 or ADJ_OFFSET_SS_READ for modes.  Only the superuser may set
       any parameters.

       The buf.status field is a bit mask that is used to set and/or retrieve status bits associated with the  NTP  imple‐
       mentation.  Some bits in the mask are both readable and settable, while others are read-only.

       STA_PLL (read-write)
              Enable phase-locked loop (PLL) updates via ADJ_OFFSET.

       STA_PPSFREQ (read-write)
              Enable PPS (pulse-per-second) frequency discipline.

       STA_PPSTIME (read-write)
              Enable PPS time discipline.

       STA_FLL (read-write)
              Select frequency-locked loop (FLL) mode.

       STA_INS (read-write)
              Insert  a leap second after the last second of the UTC day, thus extending the last minute of the day by one
              second.  Leap-second insertion will occur each day, so long as this flag remains set.

       STA_DEL (read-write)
              Delete a leap second at the last second of the UTC day.  Leap second deletion will occur each day,  so  long
              as this flag remains set.

       STA_UNSYNC (read-write)
              Clock unsynchronized.

       STA_FREQHOLD (read-write)
              Hold  frequency.   Normally  adjustments  made  via ADJ_OFFSET result in dampened frequency adjustments also
              being made.  So a single call corrects the current offset, but as offsets in the  same  direction  are  made
              repeatedly, the small frequency adjustments will accumulate to fix the long-term skew.

              This flag prevents the small frequency adjustment from being made when correcting for an ADJ_OFFSET value.

       STA_PPSSIGNAL (read-only)
              A valid PPS (pulse-per-second) signal is present.

       STA_PPSJITTER (read-only)
              PPS signal jitter exceeded.

       STA_PPSWANDER (read-only)
              PPS signal wander exceeded.

       STA_PPSERROR (read-only)
              PPS signal calibration error.

       STA_CLOCKERR (read-only)
              Clock hardware fault.

       STA_NANO (read-only; since Linux 2.6.26)
              Resolution (0 = microsecond, 1 = nanoseconds).  Set via ADJ_NANO, cleared via ADJ_MICRO.

       STA_MODE (since Linux 2.6.26)
              Mode (0 = Phase Locked Loop, 1 = Frequency Locked Loop).

       STA_CLK (read-only; since Linux 2.6.26)
              Clock source (0 = A, 1 = B); currently unused.

       Attempts to set read-only status bits are silently ignored.

   ntp_adjtime ()
       The ntp_adjtime() library function (described in the NTP "Kernel Application Program API", KAPI) is a more portable
       interface for performing the same task as adjtimex().  Other than the following points, it  is  identical  to  adj‐
       time():

       *  The  constants  used  in  modes  are  prefixed with "MOD_" rather than "ADJ_", and have the same suffixes (thus,
          MOD_OFFSET, MOD_FREQUENCY, and so on), other than the exceptions noted in the following points.

       *  MOD_CLKA is the synonym for ADJ_OFFSET_SINGLESHOT.

       *  MOD_CLKB is the synonym for ADJ_TICK.

       *  The is no synonym for ADJ_OFFSET_SS_READ, which is not described in the KAPI.

RETURN VALUE
       On success, adjtimex() and ntp_adjtime() return the clock state; that is, one of the following values:

       TIME_OK     Clock synchronized, no leap second adjustment pending.

       TIME_INS    Indicates that a leap second will be added at the end of the UTC day.

       TIME_DEL    Indicates that a leap second will be deleted at the end of the UTC day.

       TIME_OOP    Insertion of a leap second is in progress.

       TIME_WAIT   A leap-second insertion or deletion has been completed.  This value will be  returned  until  the  next
                   ADJ_STATUS operation clears the STA_INS and STA_DEL flags.

       TIME_ERROR  The system clock is not synchronized to a reliable server.  This value is returned when any of the fol‐
                   lowing holds true:

                   *  Either STA_UNSYNC or STA_CLOCKERR is set.

                   *  STA_PPSSIGNAL is clear and either STA_PPSFREQ or STA_PPSTIME is set.

                   *  STA_PPSTIME and STA_PPSJITTER are both set.

                   *  STA_PPSFREQ is set and either STA_PPSWANDER or STA_PPSJITTER is set.

                   The symbolic name TIME_BAD is a synonym for TIME_ERROR, provided for backward compatibility.

       Note that starting with Linux 3.4, the call operates asynchronously and the return value usually will not reflect a
       state change caused by the call itself.

       On failure, these calls return -1 and set errno.

ERRORS
       EFAULT buf does not point to writable memory.

       EINVAL (kernels before Linux 2.6.26)
              An attempt was made to set buf.freq to a value outside the range (-33554432, +33554432).

       EINVAL (kernels before Linux 2.6.26)
              An  attempt was made to set buf.offset to a value outside the permitted range.  In kernels before Linux 2.0,
              the permitted range was (-131072, +131072).  From Linux 2.0  onwards,  the  permitted  range  was  (-512000,
              +512000).

       EINVAL An attempt was made to set buf.status to a value other than those listed above.

       EINVAL An  attempt  was  made to set buf.tick to a value outside the range 900000/HZ to 1100000/HZ, where HZ is the
              system timer interrupt frequency.

       EPERM  buf.modes is neither 0 nor ADJ_OFFSET_SS_READ, and the caller does not  have  sufficient  privilege.   Under
              Linux, the CAP_SYS_TIME capability is required.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌──────────────┬───────────────┬─────────┐
       │Interface     │ Attribute     │ Value   │
       ├──────────────┼───────────────┼─────────┤
       │ntp_adjtime() │ Thread safety │ MT-Safe │
       └──────────────┴───────────────┴─────────┘
CONFORMING TO
       Neither of these interfaces is described in POSIX.1

       adjtimex() is Linux-specific and should not be used in programs intended to be portable.

       The preferred API for the NTP daemon is ntp_adjtime().

NOTES
       In  struct  timex, freq, ppsfreq, and stabil are ppm (parts per million) with a 16-bit fractional part, which means
       that a value of 1 in one of those fields actually means 2^-16 ppm, and 2^16=65536 is 1 ppm.  This is the  case  for
       both input values (in the case of freq) and output values.

       The  leap-second  processing  triggered by STA_INS and STA_DEL is done by the kernel in timer context Thus, it will
       take one tick into the second for the leap second to be inserted or deleted.

SEE ALSO
       settimeofday(2), adjtime(3), ntp_gettime(3), capabilities(7), time(7), adjtimex(8), hwclock(8)

       NTP "Kernel Application Program Interface" ⟨http://www.slac.stanford.edu/comp/unix/package/rtems/src/ssrlApps/
       ntpNanoclock/api.htm⟩

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2016-10-08                                             ADJTIMEX(2)
</pre>
<pre zoom>
<span xsmall>2 statfs64</span>
STATFS(2)                                        Linux Programmer's Manual                                       STATFS(2)

NAME
       statfs, fstatfs - get filesystem statistics

SYNOPSIS
       #include <sys/vfs.h>    /* or <sys/statfs.h> */

       int statfs(const char *path, struct statfs *buf);
       int fstatfs(int fd, struct statfs *buf);

DESCRIPTION
       The  statfs()  system call returns information about a mounted filesystem.  path is the pathname of any file within
       the mounted filesystem.  buf is a pointer to a statfs structure defined approximately as follows:

           struct statfs {
               __fsword_t f_type;    /* Type of filesystem (see below) */
               __fsword_t f_bsize;   /* Optimal transfer block size */
               fsblkcnt_t f_blocks;  /* Total data blocks in filesystem */
               fsblkcnt_t f_bfree;   /* Free blocks in filesystem */
               fsblkcnt_t f_bavail;  /* Free blocks available to
                                        unprivileged user */
               fsfilcnt_t f_files;   /* Total file nodes in filesystem */
               fsfilcnt_t f_ffree;   /* Free file nodes in filesystem */
               fsid_t     f_fsid;    /* Filesystem ID */
               __fsword_t f_namelen; /* Maximum length of filenames */
               __fsword_t f_frsize;  /* Fragment size (since Linux 2.6) */
               __fsword_t f_flags;   /* Mount flags of filesystem
                                        (since Linux 2.6.36) */
               __fsword_t f_spare[xxx];
                               /* Padding bytes reserved for future use */
           };

       The following filesystem types may appear in f_type:

           ADFS_SUPER_MAGIC      0xadf5
           AFFS_SUPER_MAGIC      0xadff
           AFS_SUPER_MAGIC       0x5346414f
           ANON_INODE_FS_MAGIC   0x09041934 /* Anonymous inode FS (for
                                               pseudofiles that have no name;
                                               e.g., epoll, signalfd, bpf) */
           AUTOFS_SUPER_MAGIC    0x0187
           BDEVFS_MAGIC          0x62646576
           BEFS_SUPER_MAGIC      0x42465331
           BFS_MAGIC             0x1badface
           BINFMTFS_MAGIC        0x42494e4d
           BPF_FS_MAGIC          0xcafe4a11
           BTRFS_SUPER_MAGIC     0x9123683e
           BTRFS_TEST_MAGIC      0x73727279
           CGROUP_SUPER_MAGIC    0x27e0eb   /* Cgroup pseudo FS */
           CGROUP2_SUPER_MAGIC   0x63677270 /* Cgroup v2 pseudo FS */
           CIFS_MAGIC_NUMBER     0xff534d42
           CODA_SUPER_MAGIC      0x73757245
           COH_SUPER_MAGIC       0x012ff7b7
           CRAMFS_MAGIC          0x28cd3d45
           DEBUGFS_MAGIC         0x64626720
           DEVFS_SUPER_MAGIC     0x1373     /* Linux 2.6.17 and earlier */
           DEVPTS_SUPER_MAGIC    0x1cd1
           ECRYPTFS_SUPER_MAGIC  0xf15f
           EFIVARFS_MAGIC        0xde5e81e4
           EFS_SUPER_MAGIC       0x00414a53
           EXT_SUPER_MAGIC       0x137d     /* Linux 2.0 and earlier */
           EXT2_OLD_SUPER_MAGIC  0xef51
           EXT2_SUPER_MAGIC      0xef53
           EXT3_SUPER_MAGIC      0xef53
           EXT4_SUPER_MAGIC      0xef53
           F2FS_SUPER_MAGIC      0xf2f52010
           FUSE_SUPER_MAGIC      0x65735546
           FUTEXFS_SUPER_MAGIC   0xbad1dea  /* Unused */
           HFS_SUPER_MAGIC       0x4244
           HOSTFS_SUPER_MAGIC    0x00c0ffee
           HPFS_SUPER_MAGIC      0xf995e849
           HUGETLBFS_MAGIC       0x958458f6
           ISOFS_SUPER_MAGIC     0x9660
           JFFS2_SUPER_MAGIC     0x72b6
           JFS_SUPER_MAGIC       0x3153464a
           MINIX_SUPER_MAGIC     0x137f     /* original minix FS */
           MINIX_SUPER_MAGIC2    0x138f     /* 30 char minix FS */
           MINIX2_SUPER_MAGIC    0x2468     /* minix V2 FS */
           MINIX2_SUPER_MAGIC2   0x2478     /* minix V2 FS, 30 char names */
           MINIX3_SUPER_MAGIC    0x4d5a     /* minix V3 FS, 60 char names */
           MQUEUE_MAGIC          0x19800202 /* POSIX message queue FS */
           MSDOS_SUPER_MAGIC     0x4d44
           MTD_INODE_FS_MAGIC    0x11307854
           NCP_SUPER_MAGIC       0x564c
           NFS_SUPER_MAGIC       0x6969
           NILFS_SUPER_MAGIC     0x3434
           NSFS_MAGIC            0x6e736673
           NTFS_SB_MAGIC         0x5346544e
           OCFS2_SUPER_MAGIC     0x7461636f
           OPENPROM_SUPER_MAGIC  0x9fa1
           OVERLAYFS_SUPER_MAGIC 0x794c7630
           PIPEFS_MAGIC          0x50495045
           PROC_SUPER_MAGIC      0x9fa0     /* /proc FS */
           PSTOREFS_MAGIC        0x6165676c
           QNX4_SUPER_MAGIC      0x002f
           QNX6_SUPER_MAGIC      0x68191122
           RAMFS_MAGIC           0x858458f6
           REISERFS_SUPER_MAGIC  0x52654973
           ROMFS_MAGIC           0x7275
           SECURITYFS_MAGIC      0x73636673
           SELINUX_MAGIC         0xf97cff8c
           SMACK_MAGIC           0x43415d53
           SMB_SUPER_MAGIC       0x517b
           SOCKFS_MAGIC          0x534f434b
           SQUASHFS_MAGIC        0x73717368
           SYSFS_MAGIC           0x62656572
           SYSV2_SUPER_MAGIC     0x012ff7b6
           SYSV4_SUPER_MAGIC     0x012ff7b5
           TMPFS_MAGIC           0x01021994
           TRACEFS_MAGIC         0x74726163
           UDF_SUPER_MAGIC       0x15013346
           UFS_MAGIC             0x00011954
           USBDEVICE_SUPER_MAGIC 0x9fa2
           V9FS_MAGIC            0x01021997
           VXFS_SUPER_MAGIC      0xa501fcf5
           XENFS_SUPER_MAGIC     0xabba1974
           XENIX_SUPER_MAGIC     0x012ff7b4
           XFS_SUPER_MAGIC       0x58465342
           _XIAFS_SUPER_MAGIC    0x012fd16d /* Linux 2.0 and earlier */

       Most of these MAGIC constants are defined in /usr/include/linux/magic.h, and some are hardcoded in kernel sources.

       The f_flags field is a bit mask indicating mount options for the filesystem.  It contains zero or more of the  fol‐
       lowing bits:

       ST_MANDLOCK
              Mandatory locking is permitted on the filesystem (see fcntl(2)).

       ST_NOATIME
              Do not update access times; see mount(2).

       ST_NODEV
              Disallow access to device special files on this filesystem.

       ST_NODIRATIME
              Do not update directory access times; see mount(2).

       ST_NOEXEC
              Execution of programs is disallowed on this filesystem.

       ST_NOSUID
              The set-user-ID and set-group-ID bits are ignored by exec(3) for executable files on this filesystem

       ST_RDONLY
              This filesystem is mounted read-only.

       ST_RELATIME
              Update atime relative to mtime/ctime; see mount(2).

       ST_SYNCHRONOUS
              Writes are synched to the filesystem immediately (see the description of O_SYNC in open(2)).

       Nobody knows what f_fsid is supposed to contain (but see below).

       Fields that are undefined for a particular filesystem are set to 0.

       fstatfs() returns the same information about an open file referenced by descriptor fd.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES (statfs())  Search  permission is denied for a component of the path prefix of path.  (See also path_resolu‐
              tion(7).)

       EBADF  (fstatfs()) fd is not a valid open file descriptor.

       EFAULT buf or path points to an invalid address.

       EINTR  The call was interrupted by a signal; see signal(7).

       EIO    An I/O error occurred while reading from the filesystem.

       ELOOP  (statfs()) Too many symbolic links were encountered in translating path.

       ENAMETOOLONG
              (statfs()) path is too long.

       ENOENT (statfs()) The file referred to by path does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOSYS The filesystem does not support this call.

       ENOTDIR
              (statfs()) A component of the path prefix of path is not a directory.

       EOVERFLOW
              Some values were too large to be represented in the returned struct.

CONFORMING TO
       Linux-specific.  The Linux statfs() was inspired by the 4.4BSD one (but they do not use the same structure).

NOTES
       The __fsword_t type used for various fields in the statfs structure  definition  is  a  glibc  internal  type,  not
       intended  for  public use.  This leaves the programmer in a bit of a conundrum when trying to copy or compare these
       fields to local variables in a program.  Using unsigned int for such variables suffices on most systems.

       The original Linux statfs() and fstatfs() system calls were not designed with extremely large file sizes  in  mind.
       Subsequently,  Linux  2.6  added new statfs64() and fstatfs64() system calls that employ a new structure, statfs64.
       The new structure contains the same fields as the original statfs structure, but the sizes of  various  fields  are
       increased,  to accommodate large file sizes.  The glibc statfs() and fstatfs() wrapper functions transparently deal
       with the kernel differences.

       Some systems have only <sys/vfs.h>, other systems also have <sys/statfs.h>, where the former includes  the  latter.
       So it seems including the former is the best choice.

       LSB has deprecated the library calls statfs() and fstatfs() and tells us to use statvfs(2) and fstatvfs(2) instead.

   The f_fsid field
       Solaris,  Irix  and  POSIX have a system call statvfs(2) that returns a struct statvfs (defined in <sys/statvfs.h>)
       containing an unsigned long f_fsid.  Linux, SunOS, HP-UX, 4.4BSD have a system call statfs() that returns a  struct
       statfs (defined in <sys/vfs.h>) containing a fsid_t f_fsid, where fsid_t is defined as struct { int val[2]; }.  The
       same holds for FreeBSD, except that it uses the include file <sys/mount.h>.

       The general idea is that f_fsid contains some random stuff such that the pair (f_fsid,ino)  uniquely  determines  a
       file.   Some  operating  systems  use  (a  variation  on) the device number, or the device number combined with the
       filesystem type.  Several operating systems restrict giving out the f_fsid field to the superuser only (and zero it
       for unprivileged users), because this field is used in the filehandle of the filesystem when NFS-exported, and giv‐
       ing it out is a security concern.

       Under some operating systems, the fsid can be used as the second argument to the sysfs(2) system call.

BUGS
       From Linux 2.6.38 up to and including Linux 3.1, fstatfs() failed with the error ENOSYS for file  descriptors  cre‐
       ated by pipe(2).

SEE ALSO
       stat(2), statvfs(3), path_resolution(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               STATFS(2)
</pre>
<pre zoom>
<span xsmall>2 sigpending</span>
SIGPENDING(2)                                    Linux Programmer's Manual                                   SIGPENDING(2)

NAME
       sigpending, rt_sigpending - examine pending signals

SYNOPSIS
       #include <signal.h>

       int sigpending(sigset_t *set);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       sigpending(): _POSIX_C_SOURCE

DESCRIPTION
       sigpending()  returns  the  set  of  signals that are pending for delivery to the calling thread (i.e., the signals
       which have been raised while blocked).  The mask of pending signals is returned in set.

RETURN VALUE
       sigpending() returns 0 on success and -1 on error.  In the event of an error, errno is set to indicate the cause.

ERRORS
       EFAULT set points to memory which is not a valid part of the process address space.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       See sigsetops(3) for details on manipulating signal sets.

       If a signal is both blocked and has a disposition of "ignored", it is not added to the mask of pending signals when
       generated.

       The  set of signals that is pending for a thread is the union of the set of signals that is pending for that thread
       and the set of signals that is pending for the process as a whole; see signal(7).

       A child created via fork(2) initially has an empty pending signal set; the pending signal set is  preserved  across
       an execve(2).

   C library/kernel differences
       The  original  Linux  system call was named sigpending().  However, with the addition of real-time signals in Linux
       2.2, the fixed-size, 32-bit sigset_t argument supported by that system call was no longer fit for purpose.   Conse‐
       quently,  a  new system call, rt_sigpending(), was added to support an enlarged sigset_t type.  The new system call
       takes a second argument, size_t sigsetsize, which specifies the size in bytes of the signal set in set.  The  glibc
       sigpending()  wrapper  function  hides these details from us, transparently calling rt_sigpending() when the kernel
       provides it.

BUGS
       In versions of glibc up to and including 2.2.1, there is a bug in the wrapper function for sigpending() which means
       that information about pending real-time signals is not correctly returned.

SEE ALSO
       kill(2), sigaction(2), signal(2), sigprocmask(2), sigsuspend(2), sigsetops(3), signal(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           SIGPENDING(2)
</pre>
<pre zoom>
<span xsmall>2 getgid</span>
GETGID(2)                                        Linux Programmer's Manual                                       GETGID(2)

NAME
       getgid, getegid - get group identity

SYNOPSIS
       #include <unistd.h>
       #include <sys/types.h>

       gid_t getgid(void);
       gid_t getegid(void);

DESCRIPTION
       getgid() returns the real group ID of the calling process.

       getegid() returns the effective group ID of the calling process.

ERRORS
       These functions are always successful.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD.

NOTES
       The  original  Linux  getgid() and getegid() system calls supported only 16-bit group IDs.  Subsequently, Linux 2.4
       added getgid32() and getegid32(), supporting 32-bit IDs.  The glibc getgid() and getegid() wrapper functions trans‐
       parently deal with the variations across kernel versions.

SEE ALSO
       getresgid(2), setgid(2), setregid(2), credentials(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               GETGID(2)
</pre>
<pre zoom>
<span xsmall>2 ppoll</span>
POLL(2)                                          Linux Programmer's Manual                                         POLL(2)

NAME
       poll, ppoll - wait for some event on a file descriptor

SYNOPSIS
       #include <poll.h>

       int poll(struct pollfd *fds, nfds_t nfds, int timeout);

       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <signal.h>
       #include <poll.h>

       int ppoll(struct pollfd *fds, nfds_t nfds,
               const struct timespec *tmo_p, const sigset_t *sigmask);

DESCRIPTION
       poll()  performs a similar task to select(2): it waits for one of a set of file descriptors to become ready to per‐
       form I/O.

       The set of file descriptors to be monitored is specified in the fds argument, which is an array  of  structures  of
       the following form:

           struct pollfd {
               int   fd;         /* file descriptor */
               short events;     /* requested events */
               short revents;    /* returned events */
           };

       The caller should specify the number of items in the fds array in nfds.

       The field fd contains a file descriptor for an open file.  If this field is negative, then the corresponding events
       field is ignored and the revents field returns zero.  (This provides an easy way of ignoring a file descriptor  for
       a  single poll() call: simply negate the fd field.  Note, however, that this technique can't be used to ignore file
       descriptor 0.)

       The field events is an input parameter, a bit mask specifying the events the application is interested in  for  the
       file  descriptor  fd.   This  field may be specified as zero, in which case the only events that can be returned in
       revents are POLLHUP, POLLERR, and POLLNVAL (see below).

       The field revents is an output parameter, filled by the kernel with the events that actually  occurred.   The  bits
       returned  in  revents can include any of those specified in events, or one of the values POLLERR, POLLHUP, or POLL‐
       NVAL.  (These three bits are meaningless in the events field, and will be set in the  revents  field  whenever  the
       corresponding condition is true.)

       If  none  of  the  events requested (and no error) has occurred for any of the file descriptors, then poll() blocks
       until one of the events occurs.

       The timeout argument specifies the number of milliseconds that poll() should block waiting for a file descriptor to
       become ready.  The call will block until either:

       *  a file descriptor becomes ready;

       *  the call is interrupted by a signal handler; or

       *  the timeout expires.

       Note  that  the  timeout  interval will be rounded up to the system clock granularity, and kernel scheduling delays
       mean that the blocking interval may overrun by a small amount.  Specifying a negative value  in  timeout  means  an
       infinite  timeout.   Specifying  a timeout of zero causes poll() to return immediately, even if no file descriptors
       are ready.

       The bits that may be set/returned in events and revents are defined in <poll.h>:

       POLLIN There is data to read.

       POLLPRI
              There is some exceptional condition on the file descriptor.  Possibilities include:

              *  There is out-of-band data on a TCP socket (see tcp(7)).

              *  A pseudoterminal master in packet mode has seen a state change on the slave (see ioctl_tty(2)).

              *  A cgroup.events file has been modified (see cgroups(7)).

       POLLOUT
              Writing is now possible, though a write larger that the available space in a socket or pipe will still block
              (unless O_NONBLOCK is set).

       POLLRDHUP (since Linux 2.6.17)
              Stream socket peer closed connection, or shut down writing half of connection.  The _GNU_SOURCE feature test
              macro must be defined (before including any header files) in order to obtain this definition.

       POLLERR
              Error condition (only returned in revents; ignored in events).  This bit is also set for a  file  descriptor
              referring to the write end of a pipe when the read end has been closed.

       POLLHUP
              Hang up (only returned in revents; ignored in events).  Note that when reading from a channel such as a pipe
              or a stream socket, this event merely indicates that the peer closed its end  of  the  channel.   Subsequent
              reads  from  the channel will return 0 (end of file) only after all outstanding data in the channel has been
              consumed.

       POLLNVAL
              Invalid request: fd not open (only returned in revents; ignored in events).

       When compiling with _XOPEN_SOURCE defined, one also has the following, which convey no further  information  beyond
       the bits listed above:

       POLLRDNORM
              Equivalent to POLLIN.

       POLLRDBAND
              Priority band data can be read (generally unused on Linux).

       POLLWRNORM
              Equivalent to POLLOUT.

       POLLWRBAND
              Priority data may be written.

       Linux also knows about, but does not use POLLMSG.

   ppoll()
       The relationship between poll() and ppoll() is analogous to the relationship between select(2) and pselect(2): like
       pselect(2), ppoll() allows an application to safely wait until either a file descriptor becomes ready  or  until  a
       signal is caught.

       Other than the difference in the precision of the timeout argument, the following ppoll() call:

           ready = ppoll(&fds, nfds, tmo_p, &sigmask);

       is equivalent to atomically executing the following calls:

           sigset_t origmask;
           int timeout;

           timeout = (tmo_p == NULL) ? -1 :
                     (tmo_p->tv_sec * 1000 + tmo_p->tv_nsec / 1000000);
           pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);
           ready = poll(&fds, nfds, timeout);
           pthread_sigmask(SIG_SETMASK, &origmask, NULL);

       See the description of pselect(2) for an explanation of why ppoll() is necessary.

       If  the sigmask argument is specified as NULL, then no signal mask manipulation is performed (and thus ppoll() dif‐
       fers from poll() only in the precision of the timeout argument).

       The tmo_p argument specifies an upper limit on the amount of time that ppoll() will  block.   This  argument  is  a
       pointer to a structure of the following form:

           struct timespec {
               long    tv_sec;         /* seconds */
               long    tv_nsec;        /* nanoseconds */
           };

       If tmo_p is specified as NULL, then ppoll() can block indefinitely.

RETURN VALUE
       On  success,  a positive number is returned; this is the number of structures which have nonzero revents fields (in
       other words, those descriptors with events or errors reported).  A value of 0 indicates that the call timed out and
       no file descriptors were ready.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT The array given as argument was not contained in the calling program's address space.

       EINTR  A signal occurred before any requested event; see signal(7).

       EINVAL The nfds value exceeds the RLIMIT_NOFILE value.

       ENOMEM There was no space to allocate file descriptor tables.

VERSIONS
       The poll() system call was introduced in Linux 2.1.23.  On older kernels that lack this system call, the glibc (and
       the old Linux libc) poll() wrapper function provides emulation using select(2).

       The ppoll() system call was added to Linux in kernel 2.6.16.  The ppoll() library call was added in glibc 2.4.

CONFORMING TO
       poll() conforms to POSIX.1-2001 and POSIX.1-2008.  ppoll() is Linux-specific.

NOTES
       On some other UNIX systems, poll() can fail with the error EAGAIN if the system fails to  allocate  kernel-internal
       resources, rather than ENOMEM as Linux does.  POSIX permits this behavior.  Portable programs may wish to check for
       EAGAIN and loop, just as with EINTR.

       Some implementations define the nonstandard constant INFTIM with the value -1 for use  as  a  timeout  for  poll().
       This constant is not provided in glibc.

       For a discussion of what may happen if a file descriptor being monitored by poll() is closed in another thread, see
       select(2).

   C library/kernel differences
       The Linux ppoll() system call modifies its tmo_p argument.  However, the glibc wrapper function hides this behavior
       by  using  a  local  variable  for the timeout argument that is passed to the system call.  Thus, the glibc ppoll()
       function does not modify its tmo_p argument.

       The raw ppoll() system call has a fifth argument, size_t sigsetsize, which specifies the size in bytes of the  sig‐
       mask  argument.   The glibc ppoll() wrapper function specifies this argument as a fixed value (equal to sizeof(ker‐
       nel_sigset_t)).  See sigprocmask(2) for a discussion on the differences between the kernel and the libc  notion  of
       the sigset.

BUGS
       See the discussion of spurious readiness notifications under the BUGS section of select(2).

SEE ALSO
       restart_syscall(2), select(2), select_tut(2), epoll(7), time(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 POLL(2)
</pre>
<pre zoom>
<span xsmall>2 _Exit</span>
_EXIT(2)                                         Linux Programmer's Manual                                        _EXIT(2)

NAME
       _exit, _Exit - terminate the calling process

SYNOPSIS
       #include <unistd.h>

       void _exit(int status);

       #include <stdlib.h>

       void _Exit(int status);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       _Exit():
           _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       The  function  _exit()  terminates  the  calling process "immediately".  Any open file descriptors belonging to the
       process are closed.  Any children of the process are inherited by init(1) (or by the nearest "subreaper" process as
       defined  through the use of the prctl(2) PR_SET_CHILD_SUBREAPER operation).  The process's parent is sent a SIGCHLD
       signal.

       The value status & 0377 is returned to the parent process as the process's exit status, and can be collected  using
       one of the wait(2) family of calls.

       The function _Exit() is equivalent to _exit().

RETURN VALUE
       These functions do not return.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  The function _Exit() was introduced by C99.

NOTES
       For a discussion on the effects of an exit, the transmission of exit status, zombie processes, signals sent, and so
       on, see exit(3).

       The function _exit() is like exit(3), but does not call any functions  registered  with  atexit(3)  or  on_exit(3).
       Open  stdio(3)  streams are not flushed.  On the other hand, _exit() does close open file descriptors, and this may
       cause an unknown delay, waiting for pending output to finish.  If the delay is undesired, it may be useful to  call
       functions  like  tcflush(3) before calling _exit().  Whether any pending I/O is canceled, and which pending I/O may
       be canceled upon _exit(), is implementation-dependent.

   C library/kernel differences
       In glibc up to version 2.3, the _exit() wrapper function invoked the kernel system call of the  same  name.   Since
       glibc 2.3, the wrapper function invokes exit_group(2), in order to terminate all of the threads in a process.

SEE ALSO
       execve(2),  exit_group(2),  fork(2),  kill(2),  wait(2),  wait4(2),  waitpid(2),  atexit(3),  exit(3),  on_exit(3),
       termios(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-05-03                                                _EXIT(2)
</pre>
<pre zoom>
<span xsmall>2 getpgrp</span>
SETPGID(2)                                       Linux Programmer's Manual                                      SETPGID(2)

NAME
       setpgid, getpgid, setpgrp, getpgrp - set/get process group

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int setpgid(pid_t pid, pid_t pgid);
       pid_t getpgid(pid_t pid);

       pid_t getpgrp(void);                 /* POSIX.1 version */
       pid_t getpgrp(pid_t pid);            /* BSD version */

       int setpgrp(void);                   /* System V version */
       int setpgrp(pid_t pid, pid_t pgid);  /* BSD version */

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       getpgid():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L

       setpgrp() (POSIX.1):
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.19: */ _DEFAULT_SOURCE
               || /* Glibc versions <= 2.19: */ _SVID_SOURCE

       setpgrp() (BSD), getpgrp() (BSD):
           [These are available only before glibc 2.19]
           _BSD_SOURCE &&
               ! (_POSIX_SOURCE || _POSIX_C_SOURCE || _XOPEN_SOURCE ||
                   _GNU_SOURCE || _SVID_SOURCE)

DESCRIPTION
       All of these interfaces are available on Linux, and are used for getting and setting the process group ID (PGID) of
       a process.  The preferred, POSIX.1-specified ways of doing this are:  getpgrp(void),  for  retrieving  the  calling
       process's PGID; and setpgid(), for setting a process's PGID.

       setpgid()  sets the PGID of the process specified by pid to pgid.  If pid is zero, then the process ID of the call‐
       ing process is used.  If pgid is zero, then the PGID of the process specified by  pid  is  made  the  same  as  its
       process  ID.   If  setpgid() is used to move a process from one process group to another (as is done by some shells
       when creating pipelines), both process groups must be part of the same session (see setsid(2) and  credentials(7)).
       In this case, the pgid specifies an existing process group to be joined and the session ID of that group must match
       the session ID of the joining process.

       The POSIX.1 version of getpgrp(), which takes no arguments, returns the PGID of the calling process.

       getpgid() returns the PGID of the process specified by pid.  If pid is zero, the process ID of the calling  process
       is used.  (Retrieving the PGID of a process other than the caller is rarely necessary, and the POSIX.1 getpgrp() is
       preferred for that task.)

       The System V-style setpgrp(), which takes no arguments, is equivalent to setpgid(0, 0).

       The BSD-specific setpgrp() call, which takes arguments pid and pgid, is a wrapper function that calls

           setpgid(pid, pgid)

       Since glibc 2.19, the BSD-specific setpgrp() function is no longer exposed by <unistd.h>; calls should be  replaced
       with the setpgid() call shown above.

       The BSD-specific getpgrp() call, which takes a single pid argument, is a wrapper function that calls

           getpgid(pid)

       Since  glibc 2.19, the BSD-specific getpgrp() function is no longer exposed by <unistd.h>; calls should be replaced
       with calls to the POSIX.1 getpgrp() which takes no arguments (if the intent is to obtain  the  caller's  PGID),  or
       with the getpgid() call shown above.

RETURN VALUE
       On success, setpgid() and setpgrp() return zero.  On error, -1 is returned, and errno is set appropriately.

       The POSIX.1 getpgrp() always returns the PGID of the caller.

       getpgid(),  and  the BSD-specific getpgrp() return a process group on success.  On error, -1 is returned, and errno
       is set appropriately.

ERRORS
       EACCES An attempt was made to change the process group ID of one of the children of the  calling  process  and  the
              child had already performed an execve(2) (setpgid(), setpgrp()).

       EINVAL pgid is less than 0 (setpgid(), setpgrp()).

       EPERM  An  attempt was made to move a process into a process group in a different session, or to change the process
              group ID of one of the children of the calling process and the child was  in  a  different  session,  or  to
              change the process group ID of a session leader (setpgid(), setpgrp()).

       ESRCH  For  getpgid():  pid  does  not  match any process.  For setpgid(): pid is not the calling process and not a
              child of the calling process.

CONFORMING TO
       setpgid() and the version of getpgrp() with no arguments conform to POSIX.1-2001.

       POSIX.1-2001 also specifies getpgid() and the version of setpgrp() that takes no  arguments.   (POSIX.1-2008  marks
       this setpgrp() specification as obsolete.)

       The  version  of  getpgrp()  with  one  argument  and the version of setpgrp() that takes two arguments derive from
       4.2BSD, and are not specified by POSIX.1.

NOTES
       A child created via fork(2) inherits its parent's process group ID.  The PGID is preserved across an execve(2).

       Each process group is a member of a session and each process is a member of the session of which its process  group
       is a member.  (See credentials(7).)

       A  session  can  have a controlling terminal.  At any time, one (and only one) of the process groups in the session
       can be the foreground process group for the terminal; the remaining process groups are in  the  background.   If  a
       signal  is  generated from the terminal (e.g., typing the interrupt key to generate SIGINT), that signal is sent to
       the foreground process group.  (See termios(3) for a description of the characters that  generate  signals.)   Only
       the foreground process group may read(2) from the terminal; if a background process group tries to read(2) from the
       terminal, then the group is sent a SIGTTIN signal, which suspends it.  The tcgetpgrp(3) and tcsetpgrp(3)  functions
       are used to get/set the foreground process group of the controlling terminal.

       The  setpgid() and getpgrp() calls are used by programs such as bash(1) to create process groups in order to imple‐
       ment shell job control.

       If the termination of a process causes a process group to become orphaned, and if any member of the newly  orphaned
       process  group  is  stopped,  then a SIGHUP signal followed by a SIGCONT signal will be sent to each process in the
       newly orphaned process group.  An orphaned process group is one in which the parent  of  every  member  of  process
       group  is either itself also a member of the process group or is a member of a process group in a different session
       (see also credentials(7)).

SEE ALSO
       getuid(2), setsid(2), tcgetpgrp(3), tcsetpgrp(3), termios(3), credentials(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              SETPGID(2)
</pre>
<pre zoom>
<span xsmall>2 stty</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 outb_p</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 sendto</span>
SEND(2)                                          Linux Programmer's Manual                                         SEND(2)

NAME
       send, sendto, sendmsg - send a message on a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       ssize_t send(int sockfd, const void *buf, size_t len, int flags);

       ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);

       ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);

DESCRIPTION
       The system calls send(), sendto(), and sendmsg() are used to transmit a message to another socket.

       The send() call may be used only when the socket is in a connected state (so that the intended recipient is known).
       The only difference between send() and write(2) is the presence of flags.  With a zero flags  argument,  send()  is
       equivalent to write(2).  Also, the following call

           send(sockfd, buf, len, flags);

       is equivalent to

           sendto(sockfd, buf, len, flags, NULL, 0);

       The argument sockfd is the file descriptor of the sending socket.

       If  sendto() is used on a connection-mode (SOCK_STREAM, SOCK_SEQPACKET) socket, the arguments dest_addr and addrlen
       are ignored (and the error EISCONN may be returned when they are not  NULL  and  0),  and  the  error  ENOTCONN  is
       returned  when  the  socket was not actually connected.  Otherwise, the address of the target is given by dest_addr
       with addrlen specifying its size.  For sendmsg(), the  address  of  the  target  is  given  by  msg.msg_name,  with
       msg.msg_namelen specifying its size.

       For  send() and sendto(), the message is found in buf and has length len.  For sendmsg(), the message is pointed to
       by the elements of the array msg.msg_iov.  The sendmsg() call also allows sending ancillary  data  (also  known  as
       control information).

       If  the message is too long to pass atomically through the underlying protocol, the error EMSGSIZE is returned, and
       the message is not transmitted.

       No indication of failure to deliver is implicit in a send().  Locally detected errors are  indicated  by  a  return
       value of -1.

       When  the  message  does  not fit into the send buffer of the socket, send() normally blocks, unless the socket has
       been placed in nonblocking I/O mode.  In nonblocking mode it would fail with the error  EAGAIN  or  EWOULDBLOCK  in
       this case.  The select(2) call may be used to determine when it is possible to send more data.

   The flags argument
       The flags argument is the bitwise OR of zero or more of the following flags.

       MSG_CONFIRM (since Linux 2.3.15)
              Tell  the link layer that forward progress happened: you got a successful reply from the other side.  If the
              link layer doesn't get this it will regularly reprobe the neighbor (e.g., via a unicast ARP).  Valid only on
              SOCK_DGRAM and SOCK_RAW sockets and currently implemented only for IPv4 and IPv6.  See arp(7) for details.

       MSG_DONTROUTE
              Don't use a gateway to send out the packet, send to hosts only on directly connected networks.  This is usu‐
              ally used only by diagnostic or routing programs.  This is defined only for protocol  families  that  route;
              packet sockets don't.

       MSG_DONTWAIT (since Linux 2.2)
              Enables  nonblocking  operation; if the operation would block, EAGAIN or EWOULDBLOCK is returned.  This pro‐
              vides similar behavior to setting the O_NONBLOCK flag (via the fcntl(2) F_SETFL operation), but  differs  in
              that  MSG_DONTWAIT  is  a per-call option, whereas O_NONBLOCK is a setting on the open file description (see
              open(2)), which will affect all threads in the calling process and as well as other processes that hold file
              descriptors referring to the same open file description.

       MSG_EOR (since Linux 2.2)
              Terminates a record (when this notion is supported, as for sockets of type SOCK_SEQPACKET).

       MSG_MORE (since Linux 2.4.4)
              The  caller  has  more  data  to  send.  This flag is used with TCP sockets to obtain the same effect as the
              TCP_CORK socket option (see tcp(7)), with the difference that this flag can be set on a per-call basis.

              Since Linux 2.6, this flag is also supported for UDP sockets, and informs the kernel to package all  of  the
              data  sent  in calls with this flag set into a single datagram which is transmitted only when a call is per‐
              formed that does not specify this flag.  (See also the UDP_CORK socket option described in udp(7).)

       MSG_NOSIGNAL (since Linux 2.2)
              Don't generate a SIGPIPE signal if the peer on a stream-oriented socket  has  closed  the  connection.   The
              EPIPE error is still returned.  This provides similar behavior to using sigaction(2) to ignore SIGPIPE, but,
              whereas MSG_NOSIGNAL is a per-call feature, ignoring SIGPIPE sets  a  process  attribute  that  affects  all
              threads in the process.

       MSG_OOB
              Sends  out-of-band data on sockets that support this notion (e.g., of type SOCK_STREAM); the underlying pro‐
              tocol must also support out-of-band data.

   sendmsg()
       The definition of the msghdr structure employed by sendmsg() is as follows:

           struct msghdr {
               void         *msg_name;       /* optional address */
               socklen_t     msg_namelen;    /* size of address */
               struct iovec *msg_iov;        /* scatter/gather array */
               size_t        msg_iovlen;     /* # elements in msg_iov */
               void         *msg_control;    /* ancillary data, see below */
               size_t        msg_controllen; /* ancillary data buffer len */
               int           msg_flags;      /* flags (unused) */
           };

       The msg_name field is used on an unconnected socket to specify the target address for a datagram.  It points  to  a
       buffer  containing  the  address;  the msg_namelen field should be set to the size of the address.  For a connected
       socket, these fields should be specified as NULL and 0, respectively.

       The msg_iov and msg_iovlen fields specify scatter-gather locations, as for writev(2).

       You may send control information using the msg_control and msg_controllen  members.   The  maximum  control  buffer
       length the kernel can process is limited per socket by the value in /proc/sys/net/core/optmem_max; see socket(7).

       The msg_flags field is ignored.

RETURN VALUE
       On success, these calls return the number of bytes sent.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       These are some standard errors generated by the socket layer.  Additional errors may be generated and returned from
       the underlying protocol modules; see their respective manual pages.

       EACCES (For UNIX domain sockets, which are identified by pathname) Write permission is denied  on  the  destination
              socket  file,  or search permission is denied for one of the directories the path prefix.  (See path_resolu‐
              tion(7).)

              (For UDP sockets) An attempt was made to send to a network/broadcast address as  though  it  was  a  unicast
              address.

       EAGAIN or EWOULDBLOCK
              The  socket is marked nonblocking and the requested operation would block.  POSIX.1-2001 allows either error
              to be returned for this case, and does not require these constants to have the same  value,  so  a  portable
              application should check for both possibilities.

       EAGAIN (Internet  domain  datagram  sockets)  The  socket referred to by sockfd had not previously been bound to an
              address and, upon attempting to bind it to an ephemeral port, it was determined that all port numbers in the
              ephemeral  port range are currently in use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range in
              ip(7).

       EALREADY
              Another Fast Open is in progress.

       EBADF  sockfd is not a valid open file descriptor.

       ECONNRESET
              Connection reset by peer.

       EDESTADDRREQ
              The socket is not connection-mode, and no peer address is set.

       EFAULT An invalid user space address was specified for an argument.

       EINTR  A signal occurred before any data was transmitted; see signal(7).

       EINVAL Invalid argument passed.

       EISCONN
              The connection-mode socket was connected already but a recipient was specified.  (Now either this  error  is
              returned, or the recipient specification is ignored.)

       EMSGSIZE
              The  socket  type requires that message be sent atomically, and the size of the message to be sent made this
              impossible.

       ENOBUFS
              The output queue for a network interface was full.  This generally indicates that the interface has  stopped
              sending,  but  may be caused by transient congestion.  (Normally, this does not occur in Linux.  Packets are
              just silently dropped when a device queue overflows.)

       ENOMEM No memory available.

       ENOTCONN
              The socket is not connected, and no target has been given.

       ENOTSOCK
              The file descriptor sockfd does not refer to a socket.

       EOPNOTSUPP
              Some bit in the flags argument is inappropriate for the socket type.

       EPIPE  The local end has been shut down on a connection oriented socket.  In  this  case,  the  process  will  also
              receive a SIGPIPE unless MSG_NOSIGNAL is set.

CONFORMING TO
       4.4BSD, SVr4, POSIX.1-2001.  These interfaces first appeared in 4.2BSD.

       POSIX.1-2001 describes only the MSG_OOB and MSG_EOR flags.  POSIX.1-2008 adds a specification of MSG_NOSIGNAL.  The
       MSG_CONFIRM flag is a Linux extension.

NOTES
       According to POSIX.1-2001, the msg_controllen field of the msghdr structure should be typed as socklen_t, but glibc
       currently types it as size_t.

       See  sendmmsg(2) for information about a Linux-specific system call that can be used to transmit multiple datagrams
       in a single call.

BUGS
       Linux may return EPIPE instead of ENOTCONN.

EXAMPLE
       An example of the use of sendto() is shown in getaddrinfo(3).

SEE ALSO
       fcntl(2), getsockopt(2), recv(2), select(2), sendfile(2), sendmmsg(2), shutdown(2), socket(2),  write(2),  cmsg(3),
       ip(7), ipv6(7), socket(7), tcp(7), udp(7), unix(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 SEND(2)
</pre>
<pre zoom>
<span xsmall>2 open</span>
OPEN(2)                                          Linux Programmer's Manual                                         OPEN(2)

NAME
       open, openat, creat - open and possibly create a file

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>

       int open(const char *pathname, int flags);
       int open(const char *pathname, int flags, mode_t mode);

       int creat(const char *pathname, mode_t mode);

       int openat(int dirfd, const char *pathname, int flags);
       int openat(int dirfd, const char *pathname, int flags, mode_t mode);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       openat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       The  open() system call opens the file specified by pathname.  If the specified file does not exist, it may option‐
       ally (if O_CREAT is specified in flags) be created by open().

       The return value of open() is a file descriptor, a small, nonnegative integer that is  used  in  subsequent  system
       calls  (read(2),  write(2), lseek(2), fcntl(2), etc.) to refer to the open file.  The file descriptor returned by a
       successful call will be the lowest-numbered file descriptor not currently open for the process.

       By default, the new file descriptor is set to remain open across an execve(2) (i.e., the FD_CLOEXEC file descriptor
       flag  described in fcntl(2) is initially disabled); the O_CLOEXEC flag, described below, can be used to change this
       default.  The file offset is set to the beginning of the file (see lseek(2)).

       A call to open() creates a new open file description, an entry in the system-wide table of open  files.   The  open
       file  description  records the file offset and the file status flags (see below).  A file descriptor is a reference
       to an open file description; this reference is unaffected if pathname is subsequently removed or modified to  refer
       to a different file.  For further details on open file descriptions, see NOTES.

       The  argument  flags  must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR.  These request
       opening the file read-only, write-only, or read/write, respectively.

       In addition, zero or more file creation flags and file status flags can be bitwise-or'd in flags.   The  file  cre‐
       ation  flags  are  O_CLOEXEC, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_TMPFILE, and O_TRUNC.  The file
       status flags are all of the remaining flags listed below.  The distinction between these two  groups  of  flags  is
       that  the file creation flags affect the semantics of the open operation itself, while the file status flags affect
       the semantics of subsequent I/O operations.  The file status flags can be retrieved and (in some  cases)  modified;
       see fcntl(2) for details.

       The full list of file creation flags and file status flags is as follows:

       O_APPEND
              The  file  is  opened in append mode.  Before each write(2), the file offset is positioned at the end of the
              file, as if with lseek(2).  The modification of the file offset and the write operation are performed  as  a
              single atomic step.

              O_APPEND  may  lead to corrupted files on NFS filesystems if more than one process appends data to a file at
              once.  This is because NFS does not support appending to a file, so the client kernel has  to  simulate  it,
              which can't be done without a race condition.

       O_ASYNC
              Enable  signal-driven  I/O:  generate a signal (SIGIO by default, but this can be changed via fcntl(2)) when
              input or output becomes possible on this file descriptor.  This feature is  available  only  for  terminals,
              pseudoterminals,  sockets,  and  (since  Linux 2.6) pipes and FIFOs.  See fcntl(2) for further details.  See
              also BUGS, below.

       O_CLOEXEC (since Linux 2.6.23)
              Enable the close-on-exec flag for the new file descriptor.  Specifying this flag permits a program to  avoid
              additional fcntl(2) F_SETFD operations to set the FD_CLOEXEC flag.

              Note  that  the  use  of  this  flag  is  essential in some multithreaded programs, because using a separate
              fcntl(2) F_SETFD operation to set the FD_CLOEXEC flag does not suffice to avoid race  conditions  where  one
              thread opens a file descriptor and attempts to set its close-on-exec flag using fcntl(2) at the same time as
              another thread does a fork(2) plus execve(2).  Depending on the order of execution, the race may lead to the
              file descriptor returned by open() being unintentionally leaked to the program executed by the child process
              created by fork(2).  (This kind of race is in principle possible for any system call  that  creates  a  file
              descriptor  whose  close-on-exec flag should be set, and various other Linux system calls provide an equiva‐
              lent of the O_CLOEXEC flag to deal with this problem.)

       O_CREAT
              If pathname does not exist, create it as a regular file.

              The owner (user ID) of the new file is set to the effective user ID of the process.

              The group ownership (group ID) of the new file is set either to the effective group ID of the process  (Sys‐
              tem V semantics) or to the group ID of the parent directory (BSD semantics).  On Linux, the behavior depends
              on whether the set-group-ID mode bit is set on the parent directory: if that bit is set, then BSD  semantics
              apply;  otherwise,  System  V  semantics apply.  For some filesystems, the behavior also depends on the bsd‐
              groups and sysvgroups mount options described in mount(8)).

              The mode argument specifies the file mode bits be applied when a new file is created.  This argument must be
              supplied  when  O_CREAT  or  O_TMPFILE is specified in flags; if neither O_CREAT nor O_TMPFILE is specified,
              then mode is ignored.  The effective mode is modified by the process's  umask  in  the  usual  way:  in  the
              absence of a default ACL, the mode of the created file is (mode & ~umask).  Note that this mode applies only
              to future accesses of the newly created file; the open() call that creates a read-only file may well  return
              a read/write file descriptor.

              The following symbolic constants are provided for mode:

              S_IRWXU  00700 user (file owner) has read, write, and execute permission

              S_IRUSR  00400 user has read permission

              S_IWUSR  00200 user has write permission

              S_IXUSR  00100 user has execute permission

              S_IRWXG  00070 group has read, write, and execute permission

              S_IRGRP  00040 group has read permission

              S_IWGRP  00020 group has write permission

              S_IXGRP  00010 group has execute permission

              S_IRWXO  00007 others have read, write, and execute permission

              S_IROTH  00004 others have read permission

              S_IWOTH  00002 others have write permission

              S_IXOTH  00001 others have execute permission

              According to POSIX, the effect when other bits are set in mode is unspecified.  On Linux, the following bits
              are also honored in mode:

              S_ISUID  0004000 set-user-ID bit

              S_ISGID  0002000 set-group-ID bit (see inode(7)).

              S_ISVTX  0001000 sticky bit (see inode(7)).

       O_DIRECT (since Linux 2.4.10)
              Try to minimize cache effects of the I/O to and from this file.  In general this will  degrade  performance,
              but  it  is  useful in special situations, such as when applications do their own caching.  File I/O is done
              directly to/from user-space buffers.  The O_DIRECT flag on its own makes an effort  to  transfer  data  syn‐
              chronously,  but does not give the guarantees of the O_SYNC flag that data and necessary metadata are trans‐
              ferred.  To guarantee synchronous I/O, O_SYNC must be used in addition to O_DIRECT.   See  NOTES  below  for
              further discussion.

              A semantically similar (but deprecated) interface for block devices is described in raw(8).

       O_DIRECTORY
              If  pathname  is not a directory, cause the open to fail.  This flag was added in kernel version 2.1.126, to
              avoid denial-of-service problems if opendir(3) is called on a FIFO or tape device.

       O_DSYNC
              Write operations on the file will complete according to the requirements of synchronized I/O data  integrity
              completion.

              By  the time write(2) (and similar) return, the output data has been transferred to the underlying hardware,
              along with any file metadata that would be required to retrieve that data (i.e., as though each write(2) was
              followed by a call to fdatasync(2)).  See NOTES below.

       O_EXCL Ensure  that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname
              already exists, then open() fails with the error EEXIST.

              When these two flags are specified, symbolic links are not followed: if pathname is a  symbolic  link,  then
              open() fails regardless of where the symbolic link points.

              In  general,  the behavior of O_EXCL is undefined if it is used without O_CREAT.  There is one exception: on
              Linux 2.6 and later, O_EXCL can be used without O_CREAT if pathname refers to a block device.  If the  block
              device is in use by the system (e.g., mounted), open() fails with the error EBUSY.

              On  NFS,  O_EXCL  is  supported  only when using NFSv3 or later on kernel 2.6 or later.  In NFS environments
              where O_EXCL support is not provided, programs that rely on it for performing locking tasks will  contain  a
              race  condition.   Portable  programs that want to perform atomic file locking using a lockfile, and need to
              avoid reliance on NFS support for O_EXCL, can create a unique file on the same filesystem (e.g., incorporat‐
              ing  hostname  and  PID), and use link(2) to make a link to the lockfile.  If link(2) returns 0, the lock is
              successful.  Otherwise, use stat(2) on the unique file to check if its link count has  increased  to  2,  in
              which case the lock is also successful.

       O_LARGEFILE
              (LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be
              opened.  The _LARGEFILE64_SOURCE macro must be defined (before including  any  header  files)  in  order  to
              obtain  this definition.  Setting the _FILE_OFFSET_BITS feature test macro to 64 (rather than using O_LARGE‐
              FILE) is the preferred method of accessing large files on 32-bit systems (see feature_test_macros(7)).

       O_NOATIME (since Linux 2.6.8)
              Do not update the file last access time (st_atime in the inode) when the file is read(2).

              This flag can be employed only if one of the following conditions is true:

              *  The effective UID of the process matches the owner UID of the file.

              *  The calling process has the CAP_FOWNER capability in its user namespace and the owner UID of the file has
                 a mapping in the namespace.

              This  flag  is  intended  for use by indexing or backup programs, where its use can significantly reduce the
              amount of disk activity.  This flag may not be effective on all filesystems.  One example is NFS, where  the
              server maintains the access time.

       O_NOCTTY
              If  pathname  refers  to  a terminal device—see tty(4)—it will not become the process's controlling terminal
              even if the process does not have one.

       O_NOFOLLOW
              If pathname is a symbolic link, then the open fails, with the error ELOOP.  Symbolic links in earlier compo‐
              nents  of  the  pathname  will still be followed.  (Note that the ELOOP error that can occur in this case is
              indistinguishable from the case where an open fails because there are too many symbolic  links  found  while
              resolving components in the prefix part of the pathname.)

              This  flag  is  a  FreeBSD extension, which was added to Linux in version 2.1.126, and has subsequently been
              standardized in POSIX.1-2008.

              See also O_PATH below.

       O_NONBLOCK or O_NDELAY
              When possible, the file is opened in nonblocking mode.  Neither the open() nor any subsequent operations  on
              the file descriptor which is returned will cause the calling process to wait.

              Note  that  this  flag  has  no  effect  for  regular  files and block devices; that is, I/O operations will
              (briefly) block when device activity is required, regardless of whether O_NONBLOCK is set.  Since O_NONBLOCK
              semantics might eventually be implemented, applications should not depend upon blocking behavior when speci‐
              fying this flag for regular files and block devices.

              For the handling of FIFOs (named pipes), see also fifo(7).  For a discussion of the effect of O_NONBLOCK  in
              conjunction with mandatory file locks and with file leases, see fcntl(2).

       O_PATH (since Linux 2.6.39)
              Obtain  a  file  descriptor that can be used for two purposes: to indicate a location in the filesystem tree
              and to perform operations that act purely at the file descriptor level.  The file itself is not opened,  and
              other  file operations (e.g., read(2), write(2), fchmod(2), fchown(2), fgetxattr(2), ioctl(2), mmap(2)) fail
              with the error EBADF.

              The following operations can be performed on the resulting file descriptor:

              *  close(2).

              *  fchdir(2), if the file descriptor refers to a directory (since Linux 3.5).

              *  fstat(2) (since Linux 3.6).

              *  fstatfs(2) (since Linux 3.12).

              *  Duplicating the file descriptor (dup(2), fcntl(2) F_DUPFD, etc.).

              *  Getting and setting file descriptor flags (fcntl(2) F_GETFD and F_SETFD).

              *  Retrieving open file status flags using the fcntl(2) F_GETFL operation: the returned flags  will  include
                 the bit O_PATH.

              *  Passing  the  file descriptor as the dirfd argument of openat() and the other "*at()" system calls.  This
                 includes linkat(2) with AT_EMPTY_PATH (or via procfs using AT_SYMLINK_FOLLOW) even if the file is  not  a
                 directory.

              *  Passing the file descriptor to another process via a UNIX domain socket (see SCM_RIGHTS in unix(7)).

              When O_PATH is specified in flags, flag bits other than O_CLOEXEC, O_DIRECTORY, and O_NOFOLLOW are ignored.

              Opening  a  file  or  directory  with the O_PATH flag requires no permissions on the object itself (but does
              require execute permission on the directories in the path prefix).  Depending on the subsequent operation, a
              check  for  suitable  file  permissions may be performed (e.g., fchdir(2) requires execute permission on the
              directory referred to by its file descriptor argument).  By contrast, obtaining a reference to a  filesystem
              object  by  opening  it  with the O_RDONLY flag requires that the caller have read permission on the object,
              even when the subsequent operation (e.g., fchdir(2), fstat(2)) does  not  require  read  permission  on  the
              object.

              If  pathname  is  a  symbolic  link  and the O_NOFOLLOW flag is also specified, then the call returns a file
              descriptor referring to the symbolic link.  This file descriptor can be used as the dirfd argument in  calls
              to fchownat(2), fstatat(2), linkat(2), and readlinkat(2) with an empty pathname to have the calls operate on
              the symbolic link.

              If pathname refers to an automount point that has not yet been triggered, so no other filesystem is  mounted
              on  it,  then  the  call returns a file descriptor referring to the automount directory without triggering a
              mount.  fstatfs(2) can then be used to determine if it is, in fact, an untriggered automount point  (.f_type
              == AUTOFS_SUPER_MAGIC).

              One  use  of  O_PATH for regular files is to provide the equivalent of POSIX.1's O_EXEC functionality.  This
              permits us to open a file for which we have execute permission but not read  permission,  and  then  execute
              that file, with steps something like the following:

                  char buf[PATH_MAX];
                  fd = open("some_prog", O_PATH);
                  snprintf(buf, PATH_MAX, "/proc/self/fd/%d", fd);
                  execl(buf, "some_prog", (char *) NULL);

              An O_PATH file descriptor can also be passed as the argument of fexecve(3).

       O_SYNC Write  operations on the file will complete according to the requirements of synchronized I/O file integrity
              completion (by contrast with the synchronized I/O data integrity completion provided by O_DSYNC.)

              By the time write(2) (or similar) returns, the output data and associated file  metadata  have  been  trans‐
              ferred  to  the underlying hardware (i.e., as though each write(2) was followed by a call to fsync(2)).  See
              NOTES below.

       O_TMPFILE (since Linux 3.11)
              Create an unnamed temporary regular file.  The pathname argument specifies a  directory;  an  unnamed  inode
              will  be  created  in that directory's filesystem.  Anything written to the resulting file will be lost when
              the last file descriptor is closed, unless the file is given a name.

              O_TMPFILE must be specified with one of O_RDWR or O_WRONLY and, optionally, O_EXCL.  If O_EXCL is not speci‐
              fied,  then linkat(2) can be used to link the temporary file into the filesystem, making it permanent, using
              code like the following:

                  char path[PATH_MAX];
                  fd = open("/path/to/dir", O_TMPFILE | O_RDWR,
                                          S_IRUSR | S_IWUSR);

                  /* File I/O on 'fd'... */

                  snprintf(path, PATH_MAX,  "/proc/self/fd/%d", fd);
                  linkat(AT_FDCWD, path, AT_FDCWD, "/path/for/file",
                                          AT_SYMLINK_FOLLOW);

              In this case, the open() mode argument determines the file permission mode, as with O_CREAT.

              Specifying O_EXCL in conjunction with O_TMPFILE prevents  a  temporary  file  from  being  linked  into  the
              filesystem in the above manner.  (Note that the meaning of O_EXCL in this case is different from the meaning
              of O_EXCL otherwise.)

              There are two main use cases for O_TMPFILE:

              *  Improved tmpfile(3) functionality: race-free creation of  temporary  files  that  (1)  are  automatically
                 deleted  when  closed; (2) can never be reached via any pathname; (3) are not subject to symlink attacks;
                 and (4) do not require the caller to devise unique names.

              *  Creating a file that is initially invisible, which is then populated  with  data  and  adjusted  to  have
                 appropriate  filesystem  attributes  (fchown(2),  fchmod(2), fsetxattr(2), etc.)  before being atomically
                 linked into the filesystem in a fully formed state (using linkat(2) as described above).

              O_TMPFILE requires support by the underlying filesystem; only a subset of  Linux  filesystems  provide  that
              support.  In the initial implementation, support was provided in the ext2, ext3, ext4, UDF, Minix, and shmem
              filesystems.  Support for other filesystems has subsequently been added as follows: XFS (Linux 3.15);  Btrfs
              (Linux 3.16); F2FS (Linux 3.16); and ubifs (Linux 4.9)

       O_TRUNC
              If  the  file  already  exists  and is a regular file and the access mode allows writing (i.e., is O_RDWR or
              O_WRONLY) it will be truncated to length 0.  If the file is a FIFO or terminal device file, the O_TRUNC flag
              is ignored.  Otherwise, the effect of O_TRUNC is unspecified.

   creat()
       A call to creat() is equivalent to calling open() with flags equal to O_CREAT|O_WRONLY|O_TRUNC.

   openat()
       The openat() system call operates in exactly the same way as open(), except for the differences described here.

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       open() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like open()).

       If pathname is absolute, then dirfd is ignored.

RETURN VALUE
       open(), openat(), and creat() return the new file descriptor, or -1 if an error occurred (in which case,  errno  is
       set appropriately).

ERRORS
       open(), openat(), and creat() can fail with the following errors:

       EACCES The  requested  access to the file is not allowed, or search permission is denied for one of the directories
              in the path prefix of pathname, or the file did not exist yet and write access to the  parent  directory  is
              not allowed.  (See also path_resolution(7).)

       EDQUOT Where  O_CREAT  is  specified, the file does not exist, and the user's quota of disk blocks or inodes on the
              filesystem has been exhausted.

       EEXIST pathname already exists and O_CREAT and O_EXCL were used.

       EFAULT pathname points outside your accessible address space.

       EFBIG  See EOVERFLOW.

       EINTR  While blocked waiting to complete an open of a slow device (e.g., a FIFO; see fifo(7)), the call was  inter‐
              rupted by a signal handler; see signal(7).

       EINVAL The filesystem does not support the O_DIRECT flag.  See NOTES for more information.

       EINVAL Invalid value in flags.

       EINVAL O_TMPFILE was specified in flags, but neither O_WRONLY nor O_RDWR was specified.

       EINVAL O_CREAT  was  specified  in flags and the final component ("basename") of the new file's pathname is invalid
              (e.g., it contains characters not permitted by the underlying filesystem).

       EISDIR pathname refers to a directory and the access requested involved writing (that is,  O_WRONLY  or  O_RDWR  is
              set).

       EISDIR pathname  refers  to an existing directory, O_TMPFILE and one of O_WRONLY or O_RDWR were specified in flags,
              but this kernel version does not provide the O_TMPFILE functionality.

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ELOOP  pathname was a symbolic link, and flags specified O_NOFOLLOW but not O_PATH.

       EMFILE The per-process limit on the number of open file descriptors  has  been  reached  (see  the  description  of
              RLIMIT_NOFILE in getrlimit(2)).

       ENAMETOOLONG
              pathname was too long.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENODEV pathname  refers  to a device special file and no corresponding device exists.  (This is a Linux kernel bug;
              in this situation ENXIO must be returned.)

       ENOENT O_CREAT is not set and the named file does not exist.  Or, a directory component in pathname does not  exist
              or is a dangling symbolic link.

       ENOENT pathname refers to a nonexistent directory, O_TMPFILE and one of O_WRONLY or O_RDWR were specified in flags,
              but this kernel version does not provide the O_TMPFILE functionality.

       ENOMEM The named file is a FIFO, but memory for the FIFO buffer can't be allocated because the per-user hard  limit
              on memory allocation for pipes has been reached and the caller is not privileged; see pipe(7).

       ENOMEM Insufficient kernel memory was available.

       ENOSPC pathname was to be created but the device containing pathname has no room for the new file.

       ENOTDIR
              A  component  used as a directory in pathname is not, in fact, a directory, or O_DIRECTORY was specified and
              pathname was not a directory.

       ENXIO  O_NONBLOCK | O_WRONLY is set, the named file is a FIFO, and no process has the FIFO open for reading.

       ENXIO  The file is a device special file and no corresponding device exists.

       EOPNOTSUPP
              The filesystem containing pathname does not support O_TMPFILE.

       EOVERFLOW
              pathname refers to a regular file that is too large to be opened.  The usual scenario here is that an appli‐
              cation  compiled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 tried to open a file whose size exceeds
              (1<<31)-1 bytes; see also O_LARGEFILE above.  This is the error specified  by  POSIX.1;  in  kernels  before
              2.6.24, Linux gave the error EFBIG for this case.

       EPERM  The  O_NOATIME  flag  was  specified, but the effective user ID of the caller did not match the owner of the
              file and the caller was not privileged.

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       EROFS  pathname refers to a file on a read-only filesystem and write access was requested.

       ETXTBSY
              pathname refers to an executable image which is currently being executed and write access was requested.

       ETXTBSY
              pathname refers to a file that is currently in use as a swap file, and the O_TRUNC flag was specified.

       ETXTBSY
              pathname refers to a file that is currently being read by the kernel (e.g. for module/firmware loading), and
              write access was requested.

       EWOULDBLOCK
              The O_NONBLOCK flag was specified, and an incompatible lease was held on the file (see fcntl(2)).

       The following additional errors can occur for openat():

       EBADF  dirfd is not a valid file descriptor.

       ENOTDIR
              pathname is a relative pathname and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       openat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       open(), creat() SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       openat(): POSIX.1-2008.

       The  O_DIRECT,  O_NOATIME,  O_PATH,  and O_TMPFILE flags are Linux-specific.  One must define _GNU_SOURCE to obtain
       their definitions.

       The O_CLOEXEC, O_DIRECTORY, and  O_NOFOLLOW  flags  are  not  specified  in  POSIX.1-2001,  but  are  specified  in
       POSIX.1-2008.   Since  glibc 2.12, one can obtain their definitions by defining either _POSIX_C_SOURCE with a value
       greater than or equal to 200809L or _XOPEN_SOURCE with a value greater than or equal to 700.   In  glibc  2.11  and
       earlier, one obtains the definitions by defining _GNU_SOURCE.

       As  noted  in  feature_test_macros(7),  feature test macros such as _POSIX_C_SOURCE, _XOPEN_SOURCE, and _GNU_SOURCE
       must be defined before including any header files.

NOTES
       Under Linux, the O_NONBLOCK flag indicates that one wants to open but does not necessarily have  the  intention  to
       read or write.  This is typically used to open devices in order to get a file descriptor for use with ioctl(2).

       The  (undefined)  effect  of O_RDONLY | O_TRUNC varies among implementations.  On many systems the file is actually
       truncated.

       Note that open() can open device special files, but creat() cannot create them; use mknod(2) instead.

       If the file is newly created, its st_atime, st_ctime, st_mtime fields (respectively, time of last access,  time  of
       last  status  change,  and  time  of  last  modification;  see stat(2)) are set to the current time, and so are the
       st_ctime and st_mtime fields of the parent directory.  Otherwise, if the file is modified because  of  the  O_TRUNC
       flag, its st_ctime and st_mtime fields are set to the current time.

       The  files  in  the  /proc/[pid]/fd  directory show the open file descriptors of the process with the PID pid.  The
       files in the /proc/[pid]/fdinfo directory show even more information about these files  descriptors.   See  proc(5)
       for further details of both of these directories.

   Open file descriptions
       The  term  open  file description is the one used by POSIX to refer to the entries in the system-wide table of open
       files.  In other contexts, this object is variously also called an "open file object", a "file  handle",  an  "open
       file table entry", or—in kernel-developer parlance—a struct file.

       When a file descriptor is duplicated (using dup(2) or similar), the duplicate refers to the same open file descrip‐
       tion as the original file descriptor, and the two file descriptors consequently share the file offset and file sta‐
       tus  flags.  Such sharing can also occur between processes: a child process created via fork(2) inherits duplicates
       of its parent's file descriptors, and those duplicates refer to the same open file descriptions.

       Each open() of a file creates a new open file description; thus, there may be multiple open file descriptions  cor‐
       responding to a file inode.

       On  Linux, one can use the kcmp(2) KCMP_FILE operation to test whether two file descriptors (in the same process or
       in two different processes) refer to the same open file description.

   Synchronized I/O
       The POSIX.1-2008 "synchronized I/O" option specifies different variants of  synchronized  I/O,  and  specifies  the
       open()  flags  O_SYNC,  O_DSYNC, and O_RSYNC for controlling the behavior.  Regardless of whether an implementation
       supports this option, it must at least support the use of O_SYNC for regular files.

       Linux implements O_SYNC and O_DSYNC, but not O_RSYNC.  (Somewhat incorrectly, glibc defines  O_RSYNC  to  have  the
       same value as O_SYNC.)

       O_SYNC  provides synchronized I/O file integrity completion, meaning write operations will flush data and all asso‐
       ciated metadata to the underlying hardware.  O_DSYNC provides synchronized I/O data integrity  completion,  meaning
       write operations will flush data to the underlying hardware, but will only flush metadata updates that are required
       to allow a subsequent read operation to complete successfully.  Data integrity completion can reduce the number  of
       disk operations that are required for applications that don't need the guarantees of file integrity completion.

       To  understand  the  difference between the two types of completion, consider two pieces of file metadata: the file
       last modification timestamp (st_mtime) and the file length.  All write operations will update the last file modifi‐
       cation timestamp, but only writes that add data to the end of the file will change the file length.  The last modi‐
       fication timestamp is not needed to ensure that a read completes successfully,  but  the  file  length  is.   Thus,
       O_DSYNC  would  only guarantee to flush updates to the file length metadata (whereas O_SYNC would also always flush
       the last modification timestamp metadata).

       Before Linux 2.6.33, Linux implemented only the O_SYNC flag for open().  However, when  that  flag  was  specified,
       most  filesystems  actually provided the equivalent of synchronized I/O data integrity completion (i.e., O_SYNC was
       actually implemented as the equivalent of O_DSYNC).

       Since Linux 2.6.33, proper O_SYNC support is provided.  However, to ensure backward binary  compatibility,  O_DSYNC
       was defined with the same value as the historical O_SYNC, and O_SYNC was defined as a new (two-bit) flag value that
       includes the O_DSYNC flag value.  This ensures that applications compiled against new headers get at least  O_DSYNC
       semantics on pre-2.6.33 kernels.

   C library/kernel differences
       Since  version  2.26,  the glibc wrapper function for open() employs the openat() system call, rather than the ker‐
       nel's open() system call.  For certain architectures, this is also true in glibc versions before 2.26.

   NFS
       There are many infelicities in the protocol underlying NFS, affecting amongst others O_SYNC and O_NDELAY.

       On NFS filesystems with UID mapping enabled, open() may return a file descriptor but, for example, read(2) requests
       are denied with EACCES.  This is because the client performs open() by checking the permissions, but UID mapping is
       performed by the server upon read and write requests.

   FIFOs
       Opening the read or write end of a FIFO blocks until the other end is also opened (by another process  or  thread).
       See fifo(7) for further details.

   File access mode
       Unlike  the  other  values that can be specified in flags, the access mode values O_RDONLY, O_WRONLY, and O_RDWR do
       not specify individual bits.  Rather, they define the low order two bits of flags, and are defined respectively  as
       0,  1,  and 2.  In other words, the combination O_RDONLY | O_WRONLY is a logical error, and certainly does not have
       the same meaning as O_RDWR.

       Linux reserves the special, nonstandard access mode 3 (binary 11) in flags to mean: check for read and  write  per‐
       mission  on  the  file  and  return  a file descriptor that can't be used for reading or writing.  This nonstandard
       access mode is used by some Linux drivers to return a file descriptor that is to be used only  for  device-specific
       ioctl(2) operations.

   Rationale for openat() and other directory file descriptor APIs
       openat()  and  the  other  system calls and library functions that take a directory file descriptor argument (i.e.,
       execveat(2), faccessat(2), fanotify_mark(2), fchmodat(2), fchownat(2), fstatat(2), futimesat(2),  linkat(2),  mkdi‐
       rat(2),  mknodat(2), name_to_handle_at(2), readlinkat(2), renameat(2), statx(2), symlinkat(2), unlinkat(2), utimen‐
       sat(2), mkfifoat(3), and scandirat(3)) address two problems with the older interfaces that  preceded  them.   Here,
       the explanation is in terms of the openat() call, but the rationale is analogous for the other interfaces.

       First,  openat() allows an application to avoid race conditions that could occur when using open() to open files in
       directories other than the current working directory.  These race conditions result from the fact that some  compo‐
       nent  of  the  directory prefix given to open() could be changed in parallel with the call to open().  Suppose, for
       example, that we wish to create the file dir1/dir2/xxx.dep if the file dir1/dir2/xxx exists.  The problem  is  that
       between the existence check and the file-creation step, dir1 or dir2 (which might be symbolic links) could be modi‐
       fied to point to a different location.  Such races can be avoided by opening  a  file  descriptor  for  the  target
       directory,  and  then  specifying that file descriptor as the dirfd argument of (say) fstatat(2) and openat().  The
       use of the dirfd file descriptor also has other benefits:

       *  the file descriptor is a stable reference to the directory, even if the directory is renamed; and

       *  the open file descriptor prevents the underlying filesystem from being dismounted, just as when a process has  a
          current working directory on a filesystem.

       Second,  openat()  allows  the  implementation  of a per-thread "current working directory", via file descriptor(s)
       maintained by the application.   (This  functionality  can  also  be  obtained  by  tricks  based  on  the  use  of
       /proc/self/fd/dirfd, but less efficiently.)

   O_DIRECT
       The  O_DIRECT  flag  may impose alignment restrictions on the length and address of user-space buffers and the file
       offset of I/Os.  In Linux alignment restrictions vary  by  filesystem  and  kernel  version  and  might  be  absent
       entirely.   However  there  is  currently  no filesystem-independent interface for an application to discover these
       restrictions for a given file or filesystem.  Some filesystems provide their own interfaces for doing so, for exam‐
       ple the XFS_IOC_DIOINFO operation in xfsctl(3).

       Under  Linux 2.4, transfer sizes, and the alignment of the user buffer and the file offset must all be multiples of
       the logical block size of the filesystem.  Since Linux 2.6.0, alignment to the logical block size of the underlying
       storage  (typically  512  bytes)  suffices.   The logical block size can be determined using the ioctl(2) BLKSSZGET
       operation or from the shell using the command:

           blockdev --getss

       O_DIRECT I/Os should never be run concurrently with the fork(2) system call, if the memory buffer is a private map‐
       ping  (i.e.,  any mapping created with the mmap(2) MAP_PRIVATE flag; this includes memory allocated on the heap and
       statically allocated buffers).  Any such I/Os, whether submitted via an asynchronous I/O interface or from  another
       thread  in  the process, should be completed before fork(2) is called.  Failure to do so can result in data corrup‐
       tion and undefined behavior in parent and child processes.  This restriction does not apply when the memory  buffer
       for  the  O_DIRECT  I/Os was created using shmat(2) or mmap(2) with the MAP_SHARED flag.  Nor does this restriction
       apply when the memory buffer has been advised as MADV_DONTFORK with madvise(2), ensuring that it will not be avail‐
       able to the child after fork(2).

       The  O_DIRECT  flag  was introduced in SGI IRIX, where it has alignment restrictions similar to those of Linux 2.4.
       IRIX has also a fcntl(2) call to query appropriate alignments, and sizes.  FreeBSD 4.x introduced  a  flag  of  the
       same name, but without alignment restrictions.

       O_DIRECT  support  was  added  under  Linux in kernel version 2.4.10.  Older Linux kernels simply ignore this flag.
       Some filesystems may not implement the flag, in which case open() fails with the error EINVAL if it is used.

       Applications should avoid mixing O_DIRECT and normal I/O to the same  file,  and  especially  to  overlapping  byte
       regions in the same file.  Even when the filesystem correctly handles the coherency issues in this situation, over‐
       all I/O throughput is likely to be slower than using either mode alone.  Likewise, applications should avoid mixing
       mmap(2) of files with direct I/O to the same files.

       The behavior of O_DIRECT with NFS will differ from local filesystems.  Older kernels, or kernels configured in cer‐
       tain ways, may not support this combination.  The NFS protocol does not support passing the flag to the server,  so
       O_DIRECT  I/O  will  bypass the page cache only on the client; the server may still cache the I/O.  The client asks
       the server to make the I/O synchronous to preserve the synchronous semantics of O_DIRECT.  Some servers  will  per‐
       form poorly under these circumstances, especially if the I/O size is small.  Some servers may also be configured to
       lie to clients about the I/O having reached stable storage; this will avoid the performance penalty at some risk to
       data  integrity  in  the  event  of server power failure.  The Linux NFS client places no alignment restrictions on
       O_DIRECT I/O.

       In summary, O_DIRECT is a potentially powerful tool that should be used  with  caution.   It  is  recommended  that
       applications treat use of O_DIRECT as a performance option which is disabled by default.

              "The  thing  that has always disturbed me about O_DIRECT is that the whole interface is just stupid, and was
              probably designed by a deranged monkey on some serious mind-controlling substances."—Linus

BUGS
       Currently, it is not possible to enable signal-driven I/O by specifying O_ASYNC when calling open();  use  fcntl(2)
       to enable this flag.

       One  must  check for two different error codes, EISDIR and ENOENT, when trying to determine whether the kernel sup‐
       ports O_TMPFILE functionality.

       When both O_CREAT and O_DIRECTORY are specified in flags and the file specified by pathname does not exist,  open()
       will create a regular file (i.e., O_DIRECTORY is ignored).

SEE ALSO
       chmod(2),  chown(2),  close(2),  dup(2),  fcntl(2),  link(2),  lseek(2),  mknod(2), mmap(2), mount(2), open_by_han‐
       dle_at(2), read(2), socket(2),  stat(2),  umask(2),  unlink(2),  write(2),  fopen(3),  acl(5),  fifo(7),  inode(7),
       path_resolution(7), symlink(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                                 OPEN(2)
</pre>
<pre zoom>
<span xsmall>2 shmget</span>
SHMGET(2)                                        Linux Programmer's Manual                                       SHMGET(2)

NAME
       shmget - allocates a System V shared memory segment

SYNOPSIS
       #include <sys/ipc.h>
       #include <sys/shm.h>

       int shmget(key_t key, size_t size, int shmflg);

DESCRIPTION
       shmget()  returns  the  identifier  of the System V shared memory segment associated with the value of the argument
       key.  It may be used either to obtain the identifier of a previously created shared memory segment (when shmflg  is
       zero and key does not have the value IPC_PRIVATE), or to create a new set.

       A new shared memory segment, with size equal to the value of size rounded up to a multiple of PAGE_SIZE, is created
       if key has the value IPC_PRIVATE or key isn't IPC_PRIVATE, no shared memory segment corresponding  to  key  exists,
       and IPC_CREAT is specified in shmflg.

       If  shmflg  specifies both IPC_CREAT and IPC_EXCL and a shared memory segment already exists for key, then shmget()
       fails with errno set to EEXIST.  (This is analogous to the effect of the combination O_CREAT | O_EXCL for open(2).)

       The value shmflg is composed of:

       IPC_CREAT   Create a new segment.  If this flag is not used, then shmget() will find the  segment  associated  with
                   key and check to see if the user has permission to access the segment.

       IPC_EXCL    This  flag is used with IPC_CREAT to ensure that this call creates the segment.  If the segment already
                   exists, the call fails.

       SHM_HUGETLB (since Linux 2.6)
                   Allocate the segment using "huge pages."  See the Linux kernel  source  file  Documentation/vm/hugetlb‐
                   page.txt for further information.

       SHM_HUGE_2MB, SHM_HUGE_1GB (since Linux 3.8)
                   Used  in  conjunction with SHM_HUGETLB to select alternative hugetlb page sizes (respectively, 2 MB and
                   1 GB) on systems that support multiple hugetlb page sizes.

                   More generally, the desired huge page size can be configured by encoding the base-2  logarithm  of  the
                   desired  page  size  in  the  six bits at the offset SHM_HUGE_SHIFT.  Thus, the above two constants are
                   defined as:

                       #define SHM_HUGE_2MB    (21 << SHM_HUGE_SHIFT)
                       #define SHM_HUGE_1GB    (30 << SHM_HUGE_SHIFT)

                   For some additional details, see the discussion of the similarly named constants in mmap(2).

       SHM_NORESERVE (since Linux 2.6.15)
                   This flag serves the same purpose as the mmap(2) MAP_NORESERVE flag.  Do not  reserve  swap  space  for
                   this  segment.   When  swap  space is reserved, one has the guarantee that it is possible to modify the
                   segment.  When swap space is not reserved one might get SIGSEGV upon a write if no physical  memory  is
                   available.  See also the discussion of the file /proc/sys/vm/overcommit_memory in proc(5).

       In  addition  to  the  above  flags,  the least significant 9 bits of shmflg specify the permissions granted to the
       owner, group, and others.  These bits have the same format, and the same meaning, as the mode argument of  open(2).
       Presently, execute permissions are not used by the system.

       When  a  new shared memory segment is created, its contents are initialized to zero values, and its associated data
       structure, shmid_ds (see shmctl(2)), is initialized as follows:

              shm_perm.cuid and shm_perm.uid are set to the effective user ID of the calling process.

              shm_perm.cgid and shm_perm.gid are set to the effective group ID of the calling process.

              The least significant 9 bits of shm_perm.mode are set to the least significant 9 bit of shmflg.

              shm_segsz is set to the value of size.

              shm_lpid, shm_nattch, shm_atime, and shm_dtime are set to 0.

              shm_ctime is set to the current time.

       If the shared memory segment already exists, the permissions are verified, and a check is made  to  see  if  it  is
       marked for destruction.

RETURN VALUE
       On  success,  a valid shared memory identifier is returned.  On error, -1 is returned, and errno is set to indicate
       the error.

ERRORS
       On failure, errno is set to one of the following:

       EACCES The user does not have permission to access the shared memory segment, and does not have  the  CAP_IPC_OWNER
              capability in the user namespace that governs its IPC namespace.

       EEXIST IPC_CREAT and IPC_EXCL were specified in shmflg, but a shared memory segment already exists for key.

       EINVAL A new segment was to be created and size is less than SHMMIN or greater than SHMMAX.

       EINVAL A segment for the given key exists, but size is greater than the size of that segment.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENOENT No segment exists for the given key, and IPC_CREAT was not specified.

       ENOMEM No memory could be allocated for segment overhead.

       ENOSPC All possible shared memory IDs have been taken (SHMMNI), or allocating a segment of the requested size would
              cause the system to exceed the system-wide limit on shared memory (SHMALL).

       EPERM  The SHM_HUGETLB flag was specified, but the caller was not privileged (did not have the  CAP_IPC_LOCK  capa‐
              bility).

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

       SHM_HUGETLB and SHM_NORESERVE are Linux extensions.

NOTES
       The  inclusion  of <sys/types.h> and <sys/ipc.h> isn't required on Linux or by any version of POSIX.  However, some
       old implementations required the inclusion of these header files, and the SVID  also  documented  their  inclusion.
       Applications intended to be portable to such old systems may need to include these header files.

       IPC_PRIVATE  isn't  a  flag field but a key_t type.  If this special value is used for key, the system call ignores
       all but the least significant 9 bits of shmflg and creates a new shared memory segment.

   Shared memory limits
       The following limits on shared memory segment resources affect the shmget() call:

       SHMALL System-wide limit on the total amount of shared memory, measured in units of the system page size.

              On Linux, this limit can be read and modified via /proc/sys/kernel/shmall.  Since Linux  3.16,  the  default
              value for this limit is:

                  ULONG_MAX - 2^24

              The  effect  of this value (which is suitable for both 32-bit and 64-bit systems) is to impose no limitation
              on allocations.  This value, rather than ULONG_MAX, was chosen as the default to prevent  some  cases  where
              historical  applications  simply  raised  the existing limit without first checking its current value.  Such
              applications would cause the value to overflow if the limit was set at ULONG_MAX.

              From Linux 2.4 up to Linux 3.15, the default value for this limit was:

                  SHMMAX / PAGE_SIZE * (SHMMNI / 16)

              If SHMMAX and SHMMNI were not modified, then multiplying the result of this formula by the page size (to get
              a  value  in  bytes) yielded a value of 8 GB as the limit on the total memory used by all shared memory seg‐
              ments.

       SHMMAX Maximum size in bytes for a shared memory segment.

              On Linux, this limit can be read and modified via /proc/sys/kernel/shmmax.  Since Linux  3.16,  the  default
              value for this limit is:

                  ULONG_MAX - 2^24

              The  effect  of this value (which is suitable for both 32-bit and 64-bit systems) is to impose no limitation
              on allocations.  See the description of SHMALL for a discussion of  why  this  default  value  (rather  than
              ULONG_MAX) is used.

              From Linux 2.2 up to Linux 3.15, the default value of this limit was 0x2000000 (32 MB).

              Because  it is not possible to map just part of a shared memory segment, the amount of virtual memory places
              another limit on the maximum size of a usable segment: for example, on i386 the largest segments that can be
              mapped have a size of around 2.8 GB, and on x86-64 the limit is around 127 TB.

       SHMMIN Minimum  size  in  bytes  for  a  shared  memory segment: implementation dependent (currently 1 byte, though
              PAGE_SIZE is the effective minimum size).

       SHMMNI System-wide limit on the number of shared memory segments.  In Linux 2.2, the default value for  this  limit
              was 128; since Linux 2.4, the default value is 4096.

              On Linux, this limit can be read and modified via /proc/sys/kernel/shmmni.

       The implementation has no specific limits for the per-process maximum number of shared memory segments (SHMSEG).

   Linux notes
       Until version 2.3.30, Linux would return EIDRM for a shmget() on a shared memory segment scheduled for deletion.

BUGS
       The name choice IPC_PRIVATE was perhaps unfortunate, IPC_NEW would more clearly show its function.

SEE ALSO
       memfd_create(2), shmat(2), shmctl(2), shmdt(2), ftok(3), capabilities(7), shm_overview(7), svipc(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                               SHMGET(2)
</pre>
<pre zoom>
<span xsmall>2 getuid</span>
GETUID(2)                                        Linux Programmer's Manual                                       GETUID(2)

NAME
       getuid, geteuid - get user identity

SYNOPSIS
       #include <unistd.h>
       #include <sys/types.h>

       uid_t getuid(void);
       uid_t geteuid(void);

DESCRIPTION
       getuid() returns the real user ID of the calling process.

       geteuid() returns the effective user ID of the calling process.

ERRORS
       These functions are always successful.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD.

NOTES
   History
       In UNIX V6 the getuid() call returned (euid << 8) + uid.  UNIX V7 introduced separate calls getuid() and geteuid().

       The  original  Linux  getuid()  and geteuid() system calls supported only 16-bit user IDs.  Subsequently, Linux 2.4
       added getuid32() and geteuid32(), supporting 32-bit IDs.  The glibc getuid() and geteuid() wrapper functions trans‐
       parently deal with the variations across kernel versions.

SEE ALSO
       getresuid(2), setreuid(2), setuid(2), credentials(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               GETUID(2)
</pre>
<pre zoom>
<span xsmall>2 _newselect</span>
SELECT(2)                                        Linux Programmer's Manual                                       SELECT(2)

NAME
       select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O multiplexing

SYNOPSIS
       /* According to POSIX.1-2001, POSIX.1-2008 */
       #include <sys/select.h>

       /* According to earlier standards */
       #include <sys/time.h>
       #include <sys/types.h>
       #include <unistd.h>

       int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);

       void FD_CLR(int fd, fd_set *set);
       int  FD_ISSET(int fd, fd_set *set);
       void FD_SET(int fd, fd_set *set);
       void FD_ZERO(fd_set *set);

       #include <sys/select.h>

       int pselect(int nfds, fd_set *readfds, fd_set *writefds,
                   fd_set *exceptfds, const struct timespec *timeout,
                   const sigset_t *sigmask);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pselect(): _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       select()  and pselect() allow a program to monitor multiple file descriptors, waiting until one or more of the file
       descriptors become "ready" for some class of I/O operation (e.g., input possible).  A file descriptor is considered
       ready if it is possible to perform a corresponding I/O operation (e.g., read(2) without blocking, or a sufficiently
       small write(2)).

       select() can monitor only file descriptors numbers that are less than FD_SETSIZE; poll(2) does not have this  limi‐
       tation.  See BUGS.

       The operation of select() and pselect() is identical, other than these three differences:

       (i)    select()  uses  a  timeout  that is a struct timeval (with seconds and microseconds), while pselect() uses a
              struct timespec (with seconds and nanoseconds).

       (ii)   select() may update the timeout argument to indicate how much time was left.  pselect() does not change this
              argument.

       (iii)  select() has no sigmask argument, and behaves as pselect() called with NULL sigmask.

       Three  independent sets of file descriptors are watched.  The file descriptors listed in readfds will be watched to
       see if characters become available for reading (more precisely, to see if a read will not block; in  particular,  a
       file descriptor is also ready on end-of-file).  The file descriptors in writefds will be watched to see if space is
       available for write (though a large write may still block).  The file descriptors in exceptfds will be watched  for
       exceptional conditions.  (For examples of some exceptional conditions, see the discussion of POLLPRI in poll(2).)

       On  exit, each of the file descriptor sets is modified in place to indicate which file descriptors actually changed
       status.  (Thus, if using select() within a loop, the sets must be reinitialized before each call.)

       Each of the three file descriptor sets may be specified as NULL if no file descriptors are to be  watched  for  the
       corresponding class of events.

       Four  macros  are provided to manipulate the sets.  FD_ZERO() clears a set.  FD_SET() and FD_CLR() respectively add
       and remove a given file descriptor from a set.  FD_ISSET() tests to see if a file descriptor is part  of  the  set;
       this is useful after select() returns.

       nfds  should  be  set to the highest-numbered file descriptor in any of the three sets, plus 1.  The indicated file
       descriptors in each set are checked, up to this limit (but see BUGS).

       The timeout argument specifies the interval that select() should block waiting for  a  file  descriptor  to  become
       ready.  The call will block until either:

       *  a file descriptor becomes ready;

       *  the call is interrupted by a signal handler; or

       *  the timeout expires.

       Note  that  the  timeout  interval will be rounded up to the system clock granularity, and kernel scheduling delays
       mean that the blocking interval may overrun by a small amount.  If both fields of the timeval structure  are  zero,
       then  select()  returns  immediately.  (This is useful for polling.)  If timeout is NULL (no timeout), select() can
       block indefinitely.

       sigmask is a pointer to a signal mask (see sigprocmask(2)); if it is not NULL, then pselect()  first  replaces  the
       current signal mask by the one pointed to by sigmask, then does the "select" function, and then restores the origi‐
       nal signal mask.

       Other than the difference in the precision of the timeout argument, the following pselect() call:

           ready = pselect(nfds, &readfds, &writefds, &exceptfds,
                           timeout, &sigmask);

       is equivalent to atomically executing the following calls:

           sigset_t origmask;

           pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);
           ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);
           pthread_sigmask(SIG_SETMASK, &origmask, NULL);

       The reason that pselect() is needed is that if one wants to wait for either a signal or for a  file  descriptor  to
       become  ready, then an atomic test is needed to prevent race conditions.  (Suppose the signal handler sets a global
       flag and returns.  Then a test of this global flag followed by a call of select() could hang  indefinitely  if  the
       signal arrived just after the test but just before the call.  By contrast, pselect() allows one to first block sig‐
       nals, handle the signals that have come in, then call pselect() with the desired sigmask, avoiding the race.)

   The timeout
       The time structures involved are defined in <sys/time.h> and look like

           struct timeval {
               long    tv_sec;         /* seconds */
               long    tv_usec;        /* microseconds */
           };

       and

           struct timespec {
               long    tv_sec;         /* seconds */
               long    tv_nsec;        /* nanoseconds */
           };

       (However, see below on the POSIX.1 versions.)

       Some code calls select() with all three sets empty, nfds zero, and a non-NULL timeout as a fairly portable  way  to
       sleep with subsecond precision.

       On  Linux,  select() modifies timeout to reflect the amount of time not slept; most other implementations do not do
       this.  (POSIX.1 permits either behavior.)  This causes problems both when Linux code which reads timeout is  ported
       to other operating systems, and when code is ported to Linux that reuses a struct timeval for multiple select()s in
       a loop without reinitializing it.  Consider timeout to be undefined after select() returns.

RETURN VALUE
       On success, select() and pselect() return the number of file descriptors contained in the three returned descriptor
       sets  (that  is,  the  total  number of bits that are set in readfds, writefds, exceptfds) which may be zero if the
       timeout expires before anything interesting happens.  On error, -1 is returned, and errno is set  to  indicate  the
       error; the file descriptor sets are unmodified, and timeout becomes undefined.

ERRORS
       EBADF  An  invalid  file  descriptor  was  given  in  one of the sets.  (Perhaps a file descriptor that was already
              closed, or one on which an error has occurred.)  However, see BUGS.

       EINTR  A signal was caught; see signal(7).

       EINVAL nfds is negative or exceeds the RLIMIT_NOFILE resource limit (see getrlimit(2)).

       EINVAL The value contained within timeout is invalid.

       ENOMEM Unable to allocate memory for internal tables.

VERSIONS
       pselect() was added to Linux in kernel 2.6.16.  Prior to this, pselect() was emulated in glibc (but see BUGS).

CONFORMING TO
       select() conforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD (select() first appeared in 4.2BSD).  Generally  porta‐
       ble to/from non-BSD systems supporting clones of the BSD socket layer (including System V variants).  However, note
       that the System V variant typically sets the timeout variable before exit, but the BSD variant does not.

       pselect() is defined in POSIX.1g, and in POSIX.1-2001 and POSIX.1-2008.

NOTES
       An fd_set is a fixed size buffer.  Executing FD_CLR() or FD_SET() with a value of fd that is negative or  is  equal
       to  or  larger  than  FD_SETSIZE will result in undefined behavior.  Moreover, POSIX requires fd to be a valid file
       descriptor.

       On some other UNIX systems, select() can fail with the error EAGAIN if the system fails to allocate kernel-internal
       resources, rather than ENOMEM as Linux does.  POSIX specifies this error for poll(2), but not for select().  Porta‐
       ble programs may wish to check for EAGAIN and loop, just as with EINTR.

       On systems that lack pselect(), reliable (and more portable) signal trapping can be achieved  using  the  self-pipe
       trick.  In this technique, a signal handler writes a byte to a pipe whose other end is monitored by select() in the
       main program.  (To avoid possibly blocking when writing to a pipe that may be full or reading from a pipe that  may
       be empty, nonblocking I/O is used when reading from and writing to the pipe.)

       Concerning  the  types involved, the classical situation is that the two fields of a timeval structure are typed as
       long (as shown above), and the structure is defined in <sys/time.h>.  The POSIX.1 situation is

           struct timeval {
               time_t         tv_sec;     /* seconds */
               suseconds_t    tv_usec;    /* microseconds */
           };

       where the structure is defined in <sys/select.h>  and  the  data  types  time_t  and  suseconds_t  are  defined  in
       <sys/types.h>.

       Concerning prototypes, the classical situation is that one should include <time.h> for select().  The POSIX.1 situ‐
       ation is that one should include <sys/select.h> for select() and pselect().

       Under glibc 2.0, <sys/select.h> gives the wrong prototype for pselect().  Under glibc 2.1 to 2.2.1, it  gives  pse‐
       lect() when _GNU_SOURCE is defined.  Since glibc 2.2.2, the requirements are as shown in the SYNOPSIS.

   Correspondence between select() and poll() notifications
       Within  the  Linux kernel source, we find the following definitions which show the correspondence between the read‐
       able, writable, and exceptional condition notifications of select() and the event notifications provided by poll(2)
       (and epoll(7)):

           #define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP |
                               POLLERR)
                              /* Ready for reading */
           #define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)
                              /* Ready for writing */
           #define POLLEX_SET (POLLPRI)
                              /* Exceptional condition */

   Multithreaded applications
       If  a  file descriptor being monitored by select() is closed in another thread, the result is unspecified.  On some
       UNIX systems, select() unblocks and returns, with an indication that the file descriptor is ready (a subsequent I/O
       operation  will  likely  fail  with an error, unless another the file descriptor reopened between the time select()
       returned and the I/O operations was performed).  On Linux (and some other systems), closing the file descriptor  in
       another thread has no effect on select().  In summary, any application that relies on a particular behavior in this
       scenario must be considered buggy.

   C library/kernel differences
       The Linux kernel allows file descriptor sets of arbitrary size, determining the length of the sets  to  be  checked
       from the value of nfds.  However, in the glibc implementation, the fd_set type is fixed in size.  See also BUGS.

       The  pselect() interface described in this page is implemented by glibc.  The underlying Linux system call is named
       pselect6().  This system call has somewhat different behavior from the glibc wrapper function.

       The Linux pselect6() system call modifies its timeout argument.  However, the glibc  wrapper  function  hides  this
       behavior  by  using  a  local variable for the timeout argument that is passed to the system call.  Thus, the glibc
       pselect() function does not modify its timeout argument; this is the behavior required by POSIX.1-2001.

       The final argument of the pselect6() system call is not a sigset_t * pointer, but is instead  a  structure  of  the
       form:

           struct {
               const kernel_sigset_t *ss;   /* Pointer to signal set */
               size_t ss_len;               /* Size (in bytes) of object
                                               pointed to by 'ss' */
           };

       This  allows  the  system call to obtain both a pointer to the signal set and its size, while allowing for the fact
       that most architectures support a maximum of 6 arguments to a system call.  See sigprocmask(2) for a discussion  of
       the difference between the kernel and libc notion of the signal set.

BUGS
       POSIX  allows  an  implementation to define an upper limit, advertised via the constant FD_SETSIZE, on the range of
       file descriptors that can be specified in a file descriptor set.  The Linux kernel imposes no fixed limit, but  the
       glibc implementation makes fd_set a fixed-size type, with FD_SETSIZE defined as 1024, and the FD_*() macros operat‐
       ing according to that limit.  To monitor file descriptors greater than 1023, use poll(2) instead.

       According to POSIX, select() should check all specified file descriptors in the three file descriptor sets,  up  to
       the  limit  nfds-1.   However, the current implementation ignores any file descriptor in these sets that is greater
       than the maximum file descriptor number that the process currently has open.  According to  POSIX,  any  such  file
       descriptor that is specified in one of the sets should result in the error EBADF.

       Glibc 2.0 provided a version of pselect() that did not take a sigmask argument.

       Starting  with  version 2.1, glibc provided an emulation of pselect() that was implemented using sigprocmask(2) and
       select().  This implementation remained vulnerable to the very race condition that pselect() was designed  to  pre‐
       vent.  Modern versions of glibc use the (race-free) pselect() system call on kernels where it is provided.

       Under  Linux,  select() may report a socket file descriptor as "ready for reading", while nevertheless a subsequent
       read blocks.  This could for example happen when data has arrived but upon examination has wrong  checksum  and  is
       discarded.   There  may be other circumstances in which a file descriptor is spuriously reported as ready.  Thus it
       may be safer to use O_NONBLOCK on sockets that should not block.

       On Linux, select() also modifies timeout if the call is interrupted by a signal  handler  (i.e.,  the  EINTR  error
       return).   This  is not permitted by POSIX.1.  The Linux pselect() system call has the same behavior, but the glibc
       wrapper hides this behavior by internally copying the timeout to a local variable and passing that variable to  the
       system call.

EXAMPLE
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/time.h>
       #include <sys/types.h>
       #include <unistd.h>

       int
       main(void)
       {
           fd_set rfds;
           struct timeval tv;
           int retval;

           /* Watch stdin (fd 0) to see when it has input. */

           FD_ZERO(&rfds);
           FD_SET(0, &rfds);

           /* Wait up to five seconds. */

           tv.tv_sec = 5;
           tv.tv_usec = 0;

           retval = select(1, &rfds, NULL, NULL, &tv);
           /* Don't rely on the value of tv now! */

           if (retval == -1)
               perror("select()");
           else if (retval)
               printf("Data is available now.\n");
               /* FD_ISSET(0, &rfds) will be true. */
           else
               printf("No data within five seconds.\n");

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       accept(2),  connect(2), poll(2), read(2), recv(2), restart_syscall(2), send(2), sigprocmask(2), write(2), epoll(7),
       time(7)

       For a tutorial with discussion and examples, see select_tut(2).

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SELECT(2)
</pre>
<pre zoom>
<span xsmall>2 getresgid</span>
GETRESUID(2)                                     Linux Programmer's Manual                                    GETRESUID(2)

NAME
       getresuid, getresgid - get real, effective and saved user/group IDs

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <unistd.h>

       int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
       int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);

DESCRIPTION
       getresuid() returns the real UID, the effective UID, and the saved set-user-ID of the calling process, in the argu‐
       ments ruid, euid, and suid, respectively.  getresgid() performs the analogous task for the process's group IDs.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT One of the arguments specified an address outside the calling program's address space.

VERSIONS
       These system calls appeared on Linux starting with kernel 2.1.44.

       The prototypes are given by glibc since version 2.3.2, provided _GNU_SOURCE is defined.

CONFORMING TO
       These calls are nonstandard; they also appear on HP-UX and some of the BSDs.

NOTES
       The original Linux getresuid() and getresgid() system calls supported only  16-bit  user  and  group  IDs.   Subse‐
       quently, Linux 2.4 added getresuid32() and getresgid32(), supporting 32-bit IDs.  The glibc getresuid() and getres‐
       gid() wrapper functions transparently deal with the variations across kernel versions.

SEE ALSO
       getuid(2), setresuid(2), setreuid(2), setuid(2), credentials(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            GETRESUID(2)
</pre>
<pre zoom>
<span xsmall>2 syscall</span>
SYSCALL(2)                                       Linux Programmer's Manual                                      SYSCALL(2)

NAME
       syscall - indirect system call

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <unistd.h>
       #include <sys/syscall.h>   /* For SYS_xxx definitions */

       long syscall(long number, ...);

DESCRIPTION
       syscall() is a small library function that invokes the system call whose assembly language interface has the speci‐
       fied number with the specified arguments.  Employing syscall() is useful, for example, when invoking a system  call
       that has no wrapper function in the C library.

       syscall()  saves  CPU  registers  before making the system call, restores the registers upon return from the system
       call, and stores any error code returned by the system call in errno(3) if an error occurs.

       Symbolic constants for system call numbers can be found in the header file <sys/syscall.h>.

RETURN VALUE
       The return value is defined by the system call being invoked.  In general, a 0 return value indicates  success.   A
       -1 return value indicates an error, and an error code is stored in errno.

NOTES
       syscall() first appeared in 4BSD.

   Architecture-specific requirements
       Each  architecture  ABI has its own requirements on how system call arguments are passed to the kernel.  For system
       calls that have a glibc wrapper (e.g., most system calls), glibc handles the details of copying  arguments  to  the
       right  registers  in  a manner suitable for the architecture.  However, when using syscall() to make a system call,
       the caller might need to handle architecture-dependent details; this requirement is most  commonly  encountered  on
       certain 32-bit architectures.

       For  example,  on  the ARM architecture Embedded ABI (EABI), a 64-bit value (e.g., long long) must be aligned to an
       even register pair.  Thus, using syscall() instead of the wrapper provided by glibc, the  readahead()  system  call
       would be invoked as follows on the ARM architecture with the EABI in little endian mode:

           syscall(SYS_readahead, fd, 0,
                   (unsigned int) (offset & 0xFFFFFFFF),
                   (unsigned int) (offset >> 32),
                   count);

       Since  the  offset argument is 64 bits, and the first argument (fd) is passed in r0, the caller must manually split
       and align the 64-bit value so that it is passed in the r2/r3 register pair.  That means  inserting  a  dummy  value
       into  r1 (the second argument of 0).  Care also must be taken so that the split follows endian conventions (accord‐
       ing to the C ABI for the platform).

       Similar issues can occur on MIPS with the O32 ABI, on PowerPC with the 32-bit ABI, and on Xtensa.

       Note that while the parisc C ABI also uses aligned register pairs, it uses a shim layer to hide the issue from user
       space.

       The  affected  system  calls are fadvise64_64(2), ftruncate64(2), posix_fadvise(2), pread64(2), pwrite64(2), reada‐
       head(2), sync_file_range(2), and truncate64(2).

       This does not affect syscalls that manually split  and  assemble  64-bit  values  such  as  _llseek(2),  preadv(2),
       preadv2(2), pwritev(2).  and pwritev2(2).  Welcome to the wonderful world of historical baggage.

   Architecture calling conventions
       Every architecture has its own way of invoking and passing arguments to the kernel.  The details for various archi‐
       tectures are listed in the two tables below.

       The first table lists the instruction used to transition to kernel mode (which might not be the fastest or best way
       to  transition to the kernel, so you might have to refer to vdso(7)), the register used to indicate the system call
       number, the register used to return the system call result, and the register used to signal an error.

       arch/ABI    instruction           syscall #  retval  error    Notes
       ────────────────────────────────────────────────────────────────────
       alpha       callsys               v0         a0      a3       [1]
       arc         trap0                 r8         r0      -
       arm/OABI    swi NR                -          a1      -        [2]
       arm/EABI    swi 0x0               r7         r0      -
       arm64       svc #0                x8         x0      -
       blackfin    excpt 0x0             P0         R0      -
       i386        int $0x80             eax        eax     -
       ia64        break 0x100000        r15        r8      r10      [1]
       m68k        trap #0               d0         d0      -
       microblaze  brki r14,8            r12        r3      -
       mips        syscall               v0         v0      a3       [1]
       nios2       trap                  r2         r2      r7
       parisc      ble 0x100(%sr2, %r0)  r20        r28     -
       powerpc     sc                    r0         r3      r0       [1]
       riscv       scall                 a7         a0      -
       s390        svc 0                 r1         r2      -        [3]
       s390x       svc 0                 r1         r2      -        [3]
       superh      trap #0x17            r3         r0      -        [4]
       sparc/32    t 0x10                g1         o0      psr/csr  [1]
       sparc/64    t 0x6d                g1         o0      psr/csr  [1]
       tile        swint1                R10        R00     R01      [1]
       x86-64      syscall               rax        rax     -        [5]
       x32         syscall               rax        rax     -        [5]
       xtensa      syscall               a2         a2      -

       Notes:

           [1] On a few architectures, a register is used as a boolean (0 indicating no error, and -1 indicating an error)
               to  signal  that the system call failed.  The actual error value is still contained in the return register.
               On sparc, the carry bit (csr) in the processor status register (psr) is used instead of a full register.

           [2] NR is the system call number.

           [3] For s390 and s390x, NR (the system call number) may be passed directly with svc NR if it is less than 256.

           [4] On SuperH, the trap number controls the maximum number of arguments passed.  A trap #0x10 can be used  with
               only  0-argument system calls, a trap #0x11 can be used with 0- or 1-argument system calls, and so on up to
               trap #0x17 for 7-argument system calls.

           [5] The x32 ABI uses the same instruction as the x86-64 ABI and is used on the same processors.  To differenti‐
               ate  between  them,  the  bit mask __X32_SYSCALL_BIT is bitwise-ORed into the system call number for system
               calls under the x32 ABI.  Both system call tables are available though, so setting the bit is  not  a  hard
               requirement.

       The second table shows the registers used to pass the system call arguments.

       arch/ABI      arg1  arg2  arg3  arg4  arg5  arg6  arg7  Notes
       ──────────────────────────────────────────────────────────────
       alpha         a0    a1    a2    a3    a4    a5    -
       arc           r0    r1    r2    r3    r4    r5    -
       arm/OABI      a1    a2    a3    a4    v1    v2    v3
       arm/EABI      r0    r1    r2    r3    r4    r5    r6
       arm64         x0    x1    x2    x3    x4    x5    -
       blackfin      R0    R1    R2    R3    R4    R5    -
       i386          ebx   ecx   edx   esi   edi   ebp   -
       ia64          out0  out1  out2  out3  out4  out5  -
       m68k          d1    d2    d3    d4    d5    a0    -
       microblaze    r5    r6    r7    r8    r9    r10   -

       mips/o32      a0    a1    a2    a3    -     -     -     [1]
       mips/n32,64   a0    a1    a2    a3    a4    a5    -
       nios2         r4    r5    r6    r7    r8    r9    -
       parisc        r26   r25   r24   r23   r22   r21   -
       powerpc       r3    r4    r5    r6    r7    r8    r9
       riscv         a0    a1    a2    a3    a4    a5    -
       s390          r2    r3    r4    r5    r6    r7    -
       s390x         r2    r3    r4    r5    r6    r7    -
       superh        r4    r5    r6    r7    r0    r1    r2
       sparc/32      o0    o1    o2    o3    o4    o5    -
       sparc/64      o0    o1    o2    o3    o4    o5    -
       tile          R00   R01   R02   R03   R04   R05   -
       x86-64        rdi   rsi   rdx   r10   r8    r9    -
       x32           rdi   rsi   rdx   r10   r8    r9    -
       xtensa        a6    a3    a4    a5    a8    a9    -

       Notes:

           [1] The mips/o32 system call convention passes arguments 5 through 8 on the user stack.

       Note  that  these  tables don't cover the entire calling convention—some architectures may indiscriminately clobber
       other registers not listed here.

EXAMPLE
       #define _GNU_SOURCE
       #include <unistd.h>
       #include <sys/syscall.h>
       #include <sys/types.h>
       #include <signal.h>

       int
       main(int argc, char *argv[])
       {
           pid_t tid;

           tid = syscall(SYS_gettid);
           syscall(SYS_tgkill, getpid(), tid, SIGHUP);
       }

SEE ALSO
       _syscall(2), intro(2), syscalls(2), errno(3), vdso(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                              SYSCALL(2)
</pre>
<pre zoom>
<span xsmall>2 outl</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 ipc</span>
IPC(2)                                           Linux Programmer's Manual                                          IPC(2)

NAME
       ipc - System V IPC system calls

SYNOPSIS
       int ipc(unsigned int call, int first, int second, int third,
               void *ptr, long fifth);

DESCRIPTION
       ipc()  is a common kernel entry point for the System V IPC calls for messages, semaphores, and shared memory.  call
       determines which IPC function to invoke; the other arguments are passed through to the appropriate call.

       User-space programs should call the appropriate functions by their usual names.  Only standard library implementors
       and kernel hackers need to know about ipc().

CONFORMING TO
       ipc() is Linux-specific, and should not be used in programs intended to be portable.

NOTES
       On some architectures—for example x86-64 and ARM—there is no ipc() system call; instead, msgctl(2), semctl(2), shm‐
       ctl(2), and so on really are implemented as separate system calls.

SEE ALSO
       msgctl(2), msgget(2), msgrcv(2), msgsnd(2), semctl(2), semget(2),  semop(2),  semtimedop(2),  shmat(2),  shmctl(2),
       shmdt(2), shmget(2), svipc(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                  IPC(2)
</pre>
<pre zoom>
<span xsmall>2 fchownat</span>
CHOWN(2)                                         Linux Programmer's Manual                                        CHOWN(2)

NAME
       chown, fchown, lchown, fchownat - change ownership of a file

SYNOPSIS
       #include <unistd.h>

       int chown(const char *pathname, uid_t owner, gid_t group);
       int fchown(int fd, uid_t owner, gid_t group);
       int lchown(const char *pathname, uid_t owner, gid_t group);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <unistd.h>

       int fchownat(int dirfd, const char *pathname,
                    uid_t owner, gid_t group, int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       fchown(), lchown():
           /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
               || _XOPEN_SOURCE >= 500
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE
       fchownat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  system  calls change the owner and group of a file.  The chown(), fchown(), and lchown() system calls differ
       only in how the file is specified:

       * chown() changes the ownership of the file specified by pathname, which is dereferenced if it is a symbolic link.

       * fchown() changes the ownership of the file referred to by the open file descriptor fd.

       * lchown() is like chown(), but does not dereference symbolic links.

       Only a privileged process (Linux: one with the CAP_CHOWN capability) may change the owner of a file.  The owner  of
       a file may change the group of the file to any group of which that owner is a member.  A privileged process (Linux:
       with CAP_CHOWN) may change the group arbitrarily.

       If the owner or group is specified as -1, then that ID is not changed.

       When the owner or group of an executable file is changed by an unprivileged user, the S_ISUID and S_ISGID mode bits
       are cleared.  POSIX does not specify whether this also should happen when root does the chown(); the Linux behavior
       depends on the kernel version, and since Linux 2.2.13, root is treated like other users.  In case of  a  non-group-
       executable  file  (i.e., one for which the S_IXGRP bit is not set) the S_ISGID bit indicates mandatory locking, and
       is not cleared by a chown().

       When the owner or group of an executable file is changed (by any user),  all  capability  sets  for  the  file  are
       cleared.

   fchownat()
       The fchownat() system call operates in exactly the same way as chown(), except for the differences described here.

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       chown() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like chown()).

       If pathname is absolute, then dirfd is ignored.

       The flags argument is a bit mask created by ORing together 0 or more of the following values;

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2)  O_PATH  flag).   In  this case, dirfd can refer to any type of file, not just a directory.  If
              dirfd is AT_FDCWD, the call operates on the current working directory.  This flag is Linux-specific;  define
              _GNU_SOURCE to obtain its definition.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a symbolic link, do not dereference it: instead operate on the link itself, like lchown().
              (By default, fchownat() dereferences symbolic links, like chown().)

       See openat(2) for an explanation of the need for fchownat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       Depending on the filesystem, errors other than those listed below can be returned.

       The more general errors for chown() are listed below.

       EACCES Search permission is denied on a component of the path prefix.  (See also path_resolution(7).)

       EFAULT pathname points outside your accessible address space.

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ENAMETOOLONG
              pathname is too long.

       ENOENT The file does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of the path prefix is not a directory.

       EPERM  The calling process did not have the required permissions (see above) to change owner and/or group.

       EPERM  The file is marked immutable or append-only.  (See ioctl_iflags(2).)

       EROFS  The named file resides on a read-only filesystem.

       The general errors for fchown() are listed below:

       EBADF  fd is not a valid open file descriptor.

       EIO    A low-level I/O error occurred while modifying the inode.

       ENOENT See above.

       EPERM  See above.

       EROFS  See above.

       The same errors that occur for chown() can also occur for fchownat().  The following additional  errors  can  occur
       for fchownat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fchownat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       chown(), fchown(), lchown(): 4.4BSD, SVr4, POSIX.1-2001, POSIX.1-2008.

       The 4.4BSD version can be used only by the superuser (that is, ordinary users cannot give away files).

       fchownat(): POSIX.1-2008.

NOTES
   Ownership of new files
       When  a  new  file  is created (by, for example, open(2) or mkdir(2)), its owner is made the same as the filesystem
       user ID of the creating process.  The group of the file depends on a  range  of  factors,  including  the  type  of
       filesystem,  the  options  used to mount the filesystem, and whether or not the set-group-ID mode bit is enabled on
       the parent directory.  If the filesystem supports the -o grpid (or, synonymously -o bsdgroups) and -o nogrpid  (or,
       synonymously -o sysvgroups) mount(8) options, then the rules are as follows:

       * If  the  filesystem is mounted with -o grpid, then the group of a new file is made the same as that of the parent
         directory.

       * If the filesystem is mounted with -o nogrpid and the set-group-ID bit is disabled on the parent  directory,  then
         the group of a new file is made the same as the process's filesystem GID.

       * If  the  filesystem  is mounted with -o nogrpid and the set-group-ID bit is enabled on the parent directory, then
         the group of a new file is made the same as that of the parent directory.

       As at Linux 4.12, the -o grpid and -o nogrpid mount options are supported by ext2, ext3, ext4, and  XFS.   Filesys‐
       tems that don't support these mount options follow the -o nogrpid rules.

   Glibc notes
       On  older  kernels where fchownat() is unavailable, the glibc wrapper function falls back to the use of chown() and
       lchown().  When pathname is a relative pathname, glibc  constructs  a  pathname  based  on  the  symbolic  link  in
       /proc/self/fd that corresponds to the dirfd argument.

   NFS
       The  chown()  semantics are deliberately violated on NFS filesystems which have UID mapping enabled.  Additionally,
       the semantics of all system calls which access the file contents are violated, because chown() may cause  immediate
       access  revocation on already open files.  Client side caching may lead to a delay between the time where ownership
       have been changed to allow access for a user and the time where the file can actually be accessed by  the  user  on
       other clients.

   Historical details
       The  original  Linux chown(), fchown(), and lchown() system calls supported only 16-bit user and group IDs.  Subse‐
       quently, Linux 2.4 added chown32(),  fchown32(),  and  lchown32(),  supporting  32-bit  IDs.   The  glibc  chown(),
       fchown(), and lchown() wrapper functions transparently deal with the variations across kernel versions.

       In  versions  of  Linux  prior  to 2.1.81 (and distinct from 2.1.46), chown() did not follow symbolic links.  Since
       Linux 2.1.81, chown() does follow symbolic links, and there is a new system call lchown() that does not follow sym‐
       bolic  links.   Since Linux 2.1.86, this new call (that has the same semantics as the old chown()) has got the same
       syscall number, and chown() got the newly introduced number.

EXAMPLE
       The following program changes the ownership of the file named in its second  command-line  argument  to  the  value
       specified  in its first command-line argument.  The new owner can be specified either as a numeric user ID, or as a
       username (which is converted to a user ID by using getpwnam(3) to perform a lookup in the system password file).

   Program source
       #include <pwd.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>

       int
       main(int argc, char *argv[])
       {
           uid_t uid;
           struct passwd *pwd;
           char *endptr;

           if (argc != 3 || argv[1][0] == '\0') {
               fprintf(stderr, "%s <owner> <file>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           uid = strtol(argv[1], &endptr, 10);  /* Allow a numeric string */

           if (*endptr != '\0') {         /* Was not pure numeric string */
               pwd = getpwnam(argv[1]);   /* Try getting UID for username */
               if (pwd == NULL) {
                   perror("getpwnam");
                   exit(EXIT_FAILURE);
               }

               uid = pwd->pw_uid;
           }

           if (chown(argv[2], uid, -1) == -1) {
               perror("chown");
               exit(EXIT_FAILURE);
           }

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       chgrp(1), chown(1), chmod(2), flock(2), path_resolution(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                CHOWN(2)
</pre>
<pre zoom>
<span xsmall>2 perfmonctl</span>
PERFMONCTL(2)                                    Linux Programmer's Manual                                   PERFMONCTL(2)

NAME
       perfmonctl - interface to IA-64 performance monitoring unit

SYNOPSIS
       #include <syscall.h>
       #include <perfmon.h>

       long perfmonctl(int fd, int cmd, void *arg, int narg);
       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       The  IA-64-specific  perfmonctl()  system call provides an interface to the PMU (performance monitoring unit).  The
       PMU consists of PMD (performance monitoring data) registers and PMC  (performance  monitoring  control)  registers,
       which gather hardware statistics.

       perfmonctl() applies the operation cmd to the input arguments specified by arg.  The number of arguments is defined
       by narg.  The fd argument specifies the perfmon context to operate on.

       Supported values for cmd are:

       PFM_CREATE_CONTEXT
              perfmonctl(int fd, PFM_CREATE_CONTEXT, pfarg_context_t *ctxt, 1);
              Set up a context.

              The fd parameter is ignored.  A new perfmon context is created as specified in ctxt and its file  descriptor
              is returned in ctxt->ctx_fd.

              The  file descriptor can be used in subsequent calls to perfmonctl() and can be used to read event notifica‐
              tions (type pfm_msg_t) using read(2).  The  file  descriptor  is  pollable  using  select(2),  poll(2),  and
              epoll(7).

              The context can be destroyed by calling close(2) on the file descriptor.

       PFM_WRITE_PMCS
              perfmonctl(int fd, PFM_WRITE_PMCS, pfarg_reg_t *pmcs, n);
              Set PMC registers.

       PFM_WRITE_PMDS
              perfmonctl(int fd, PFM_WRITE_PMDS, pfarg_reg_t *pmds, n);
              Set PMD registers.

       PFM_READ_PMDS
              perfmonctl(int fd, PFM_READ_PMDS, pfarg_reg_t *pmds, n);
              Read PMD registers.

       PFM_START
              perfmonctl(int fd, PFM_START, NULL, 0);
              Start monitoring.

       PFM_STOP
              perfmonctl(int fd, PFM_STOP, NULL, 0);
              Stop monitoring.

       PFM_LOAD_CONTEXT
              perfmonctl(int fd, PFM_LOAD_CONTEXT, pfarg_load_t *largs, 1);
              Attach the context to a thread.

       PFM_UNLOAD_CONTEXT
              perfmonctl(int fd, PFM_UNLOAD_CONTEXT, NULL, 0);
              Detach the context from a thread.

       PFM_RESTART
              perfmonctl(int fd, PFM_RESTART, NULL, 0);
              Restart monitoring after receiving an overflow notification.

       PFM_GET_FEATURES
              perfmonctl(int fd, PFM_GET_FEATURES, pfarg_features_t *arg, 1);

       PFM_DEBUG
              perfmonctl(int fd, PFM_DEBUG, val, 0);
              If val is nonzero, enable debugging mode, otherwise disable.

       PFM_GET_PMC_RESET_VAL
              perfmonctl(int fd, PFM_GET_PMC_RESET_VAL, pfarg_reg_t *req, n);
              Reset PMC registers to default values.

RETURN VALUE
       perfmonctl()  returns zero when the operation is successful.  On error, -1 is returned and errno is set to indicate
       the cause of the error.

VERSIONS
       perfmonctl() is available since Linux 2.4.

CONFORMING TO
       perfmonctl() is Linux-specific and is available only on the IA-64 architecture.

NOTES
       Glibc does not provide a wrapper for this system call; call it using syscall(2).

SEE ALSO
       gprof(1)

       The perfmon2 interface specification

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           PERFMONCTL(2)
</pre>
<pre zoom>
<span xsmall>2 sendmsg</span>
SEND(2)                                          Linux Programmer's Manual                                         SEND(2)

NAME
       send, sendto, sendmsg - send a message on a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       ssize_t send(int sockfd, const void *buf, size_t len, int flags);

       ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);

       ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);

DESCRIPTION
       The system calls send(), sendto(), and sendmsg() are used to transmit a message to another socket.

       The send() call may be used only when the socket is in a connected state (so that the intended recipient is known).
       The only difference between send() and write(2) is the presence of flags.  With a zero flags  argument,  send()  is
       equivalent to write(2).  Also, the following call

           send(sockfd, buf, len, flags);

       is equivalent to

           sendto(sockfd, buf, len, flags, NULL, 0);

       The argument sockfd is the file descriptor of the sending socket.

       If  sendto() is used on a connection-mode (SOCK_STREAM, SOCK_SEQPACKET) socket, the arguments dest_addr and addrlen
       are ignored (and the error EISCONN may be returned when they are not  NULL  and  0),  and  the  error  ENOTCONN  is
       returned  when  the  socket was not actually connected.  Otherwise, the address of the target is given by dest_addr
       with addrlen specifying its size.  For sendmsg(), the  address  of  the  target  is  given  by  msg.msg_name,  with
       msg.msg_namelen specifying its size.

       For  send() and sendto(), the message is found in buf and has length len.  For sendmsg(), the message is pointed to
       by the elements of the array msg.msg_iov.  The sendmsg() call also allows sending ancillary  data  (also  known  as
       control information).

       If  the message is too long to pass atomically through the underlying protocol, the error EMSGSIZE is returned, and
       the message is not transmitted.

       No indication of failure to deliver is implicit in a send().  Locally detected errors are  indicated  by  a  return
       value of -1.

       When  the  message  does  not fit into the send buffer of the socket, send() normally blocks, unless the socket has
       been placed in nonblocking I/O mode.  In nonblocking mode it would fail with the error  EAGAIN  or  EWOULDBLOCK  in
       this case.  The select(2) call may be used to determine when it is possible to send more data.

   The flags argument
       The flags argument is the bitwise OR of zero or more of the following flags.

       MSG_CONFIRM (since Linux 2.3.15)
              Tell  the link layer that forward progress happened: you got a successful reply from the other side.  If the
              link layer doesn't get this it will regularly reprobe the neighbor (e.g., via a unicast ARP).  Valid only on
              SOCK_DGRAM and SOCK_RAW sockets and currently implemented only for IPv4 and IPv6.  See arp(7) for details.

       MSG_DONTROUTE
              Don't use a gateway to send out the packet, send to hosts only on directly connected networks.  This is usu‐
              ally used only by diagnostic or routing programs.  This is defined only for protocol  families  that  route;
              packet sockets don't.

       MSG_DONTWAIT (since Linux 2.2)
              Enables  nonblocking  operation; if the operation would block, EAGAIN or EWOULDBLOCK is returned.  This pro‐
              vides similar behavior to setting the O_NONBLOCK flag (via the fcntl(2) F_SETFL operation), but  differs  in
              that  MSG_DONTWAIT  is  a per-call option, whereas O_NONBLOCK is a setting on the open file description (see
              open(2)), which will affect all threads in the calling process and as well as other processes that hold file
              descriptors referring to the same open file description.

       MSG_EOR (since Linux 2.2)
              Terminates a record (when this notion is supported, as for sockets of type SOCK_SEQPACKET).

       MSG_MORE (since Linux 2.4.4)
              The  caller  has  more  data  to  send.  This flag is used with TCP sockets to obtain the same effect as the
              TCP_CORK socket option (see tcp(7)), with the difference that this flag can be set on a per-call basis.

              Since Linux 2.6, this flag is also supported for UDP sockets, and informs the kernel to package all  of  the
              data  sent  in calls with this flag set into a single datagram which is transmitted only when a call is per‐
              formed that does not specify this flag.  (See also the UDP_CORK socket option described in udp(7).)

       MSG_NOSIGNAL (since Linux 2.2)
              Don't generate a SIGPIPE signal if the peer on a stream-oriented socket  has  closed  the  connection.   The
              EPIPE error is still returned.  This provides similar behavior to using sigaction(2) to ignore SIGPIPE, but,
              whereas MSG_NOSIGNAL is a per-call feature, ignoring SIGPIPE sets  a  process  attribute  that  affects  all
              threads in the process.

       MSG_OOB
              Sends  out-of-band data on sockets that support this notion (e.g., of type SOCK_STREAM); the underlying pro‐
              tocol must also support out-of-band data.

   sendmsg()
       The definition of the msghdr structure employed by sendmsg() is as follows:

           struct msghdr {
               void         *msg_name;       /* optional address */
               socklen_t     msg_namelen;    /* size of address */
               struct iovec *msg_iov;        /* scatter/gather array */
               size_t        msg_iovlen;     /* # elements in msg_iov */
               void         *msg_control;    /* ancillary data, see below */
               size_t        msg_controllen; /* ancillary data buffer len */
               int           msg_flags;      /* flags (unused) */
           };

       The msg_name field is used on an unconnected socket to specify the target address for a datagram.  It points  to  a
       buffer  containing  the  address;  the msg_namelen field should be set to the size of the address.  For a connected
       socket, these fields should be specified as NULL and 0, respectively.

       The msg_iov and msg_iovlen fields specify scatter-gather locations, as for writev(2).

       You may send control information using the msg_control and msg_controllen  members.   The  maximum  control  buffer
       length the kernel can process is limited per socket by the value in /proc/sys/net/core/optmem_max; see socket(7).

       The msg_flags field is ignored.

RETURN VALUE
       On success, these calls return the number of bytes sent.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       These are some standard errors generated by the socket layer.  Additional errors may be generated and returned from
       the underlying protocol modules; see their respective manual pages.

       EACCES (For UNIX domain sockets, which are identified by pathname) Write permission is denied  on  the  destination
              socket  file,  or search permission is denied for one of the directories the path prefix.  (See path_resolu‐
              tion(7).)

              (For UDP sockets) An attempt was made to send to a network/broadcast address as  though  it  was  a  unicast
              address.

       EAGAIN or EWOULDBLOCK
              The  socket is marked nonblocking and the requested operation would block.  POSIX.1-2001 allows either error
              to be returned for this case, and does not require these constants to have the same  value,  so  a  portable
              application should check for both possibilities.

       EAGAIN (Internet  domain  datagram  sockets)  The  socket referred to by sockfd had not previously been bound to an
              address and, upon attempting to bind it to an ephemeral port, it was determined that all port numbers in the
              ephemeral  port range are currently in use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range in
              ip(7).

       EALREADY
              Another Fast Open is in progress.

       EBADF  sockfd is not a valid open file descriptor.

       ECONNRESET
              Connection reset by peer.

       EDESTADDRREQ
              The socket is not connection-mode, and no peer address is set.

       EFAULT An invalid user space address was specified for an argument.

       EINTR  A signal occurred before any data was transmitted; see signal(7).

       EINVAL Invalid argument passed.

       EISCONN
              The connection-mode socket was connected already but a recipient was specified.  (Now either this  error  is
              returned, or the recipient specification is ignored.)

       EMSGSIZE
              The  socket  type requires that message be sent atomically, and the size of the message to be sent made this
              impossible.

       ENOBUFS
              The output queue for a network interface was full.  This generally indicates that the interface has  stopped
              sending,  but  may be caused by transient congestion.  (Normally, this does not occur in Linux.  Packets are
              just silently dropped when a device queue overflows.)

       ENOMEM No memory available.

       ENOTCONN
              The socket is not connected, and no target has been given.

       ENOTSOCK
              The file descriptor sockfd does not refer to a socket.

       EOPNOTSUPP
              Some bit in the flags argument is inappropriate for the socket type.

       EPIPE  The local end has been shut down on a connection oriented socket.  In  this  case,  the  process  will  also
              receive a SIGPIPE unless MSG_NOSIGNAL is set.

CONFORMING TO
       4.4BSD, SVr4, POSIX.1-2001.  These interfaces first appeared in 4.2BSD.

       POSIX.1-2001 describes only the MSG_OOB and MSG_EOR flags.  POSIX.1-2008 adds a specification of MSG_NOSIGNAL.  The
       MSG_CONFIRM flag is a Linux extension.

NOTES
       According to POSIX.1-2001, the msg_controllen field of the msghdr structure should be typed as socklen_t, but glibc
       currently types it as size_t.

       See  sendmmsg(2) for information about a Linux-specific system call that can be used to transmit multiple datagrams
       in a single call.

BUGS
       Linux may return EPIPE instead of ENOTCONN.

EXAMPLE
       An example of the use of sendto() is shown in getaddrinfo(3).

SEE ALSO
       fcntl(2), getsockopt(2), recv(2), select(2), sendfile(2), sendmmsg(2), shutdown(2), socket(2),  write(2),  cmsg(3),
       ip(7), ipv6(7), socket(7), tcp(7), udp(7), unix(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 SEND(2)
</pre>
<pre zoom>
<span xsmall>2 ioctl_list</span>
IOCTL_LIST(2)                                    Linux Programmer's Manual                                   IOCTL_LIST(2)

NAME
       ioctl_list - list of ioctl calls in Linux/i386 kernel

DESCRIPTION
       This  is  Ioctl  List  1.3.27,  a  list  of  ioctl  calls in Linux/i386 kernel 1.3.27.  It contains 421 ioctls from
       </usr/include/{asm,linux}/*.h>.  For each ioctl, its numerical value, its name, and its argument type are given.

       An argument type of const struct foo * means the argument is input to the kernel.  struct foo *  means  the  kernel
       outputs the argument.  If the kernel uses the argument for both input and output, this is marked with // I-O.

       Some  ioctls take more arguments or return more values than a single structure.  These are marked // MORE and docu‐
       mented further in a separate section.

       This list is very incomplete.

   ioctl structure
       Ioctl command values are 32-bit constants.  In principle these constants are completely arbitrary, but people  have
       tried to build some structure into them.

       The  old  Linux situation was that of mostly 16-bit constants, where the last byte is a serial number, and the pre‐
       ceding byte(s) give a type indicating the driver.  Sometimes the major number was used: 0x03 for the HDIO_* ioctls,
       0x06  for  the  LP*  ioctls.   And  sometimes  one  or more ASCII letters were used.  For example, TCGETS has value
       0x00005401, with 0x54 = 'T' indicating the terminal driver, and CYGETTIMEOUT has value 0x00435906, with 0x43 0x59 =
       'C' 'Y' indicating the cyclades driver.

       Later (0.98p5) some more information was built into the number.  One has 2 direction bits (00: none, 01: write, 10:
       read, 11: read/write) followed by 14 size bits (giving the size of the argument), followed by an 8-bit  type  (col‐
       lecting the ioctls in groups for a common purpose or a common driver), and an 8-bit serial number.

       The    macros    describing    this    structure    live    in    <asm/ioctl.h>    and    are    _IO(type,nr)   and
       {_IOR,_IOW,_IOWR}(type,nr,size).  They use sizeof(size) so that size is a misnomer here: this third argument  is  a
       data type.

       Note  that the size bits are very unreliable: in lots of cases they are wrong, either because of buggy macros using
       sizeof(sizeof(struct)), or because of legacy values.

       Thus, it seems that the new structure only gave disadvantages: it does not help in checking, but it causes  varying
       values for the various architectures.

RETURN VALUE
       Decent  ioctls  return  0  on success and -1 on error, while any output value is stored via the argument.  However,
       quite a few ioctls in fact return an output value.  This is not yet indicated below.

       // Main table.

       // <include/asm-i386/socket.h>

       0x00008901   FIOSETOWN    const int *
       0x00008902   SIOCSPGRP    const int *
       0x00008903   FIOGETOWN    int *
       0x00008904   SIOCGPGRP    int *
       0x00008905   SIOCATMAR    int *
       0x00008906   SIOCGSTAMP   timeval *

       // <include/asm-i386/termios.h>

       0x00005401   TCGETS           struct termios *
       0x00005402   TCSETS           const struct termios *
       0x00005403   TCSETSW          const struct termios *
       0x00005404   TCSETSF          const struct termios *
       0x00005405   TCGETA           struct termio *

       0x00005406   TCSETA           const struct termio *
       0x00005407   TCSETAW          const struct termio *
       0x00005408   TCSETAF          const struct termio *
       0x00005409   TCSBRK           int
       0x0000540A   TCXONC           int
       0x0000540B   TCFLSH           int
       0x0000540C   TIOCEXCL         void
       0x0000540D   TIOCNXCL         void
       0x0000540E   TIOCSCTTY        int
       0x0000540F   TIOCGPGRP        pid_t *
       0x00005410   TIOCSPGRP        const pid_t *
       0x00005411   TIOCOUTQ         int *
       0x00005412   TIOCSTI          const char *
       0x00005413   TIOCGWINSZ       struct winsize *
       0x00005414   TIOCSWINSZ       const struct winsize *
       0x00005415   TIOCMGET         int *
       0x00005416   TIOCMBIS         const int *
       0x00005417   TIOCMBIC         const int *
       0x00005418   TIOCMSET         const int *
       0x00005419   TIOCGSOFTCAR     int *
       0x0000541A   TIOCSSOFTCAR     const int *
       0x0000541B   FIONREAD         int *
       0x0000541B   TIOCINQ          int *
       0x0000541C   TIOCLINUX        const char *                   // MORE
       0x0000541D   TIOCCONS         void
       0x0000541E   TIOCGSERIAL      struct serial_struct *
       0x0000541F   TIOCSSERIAL      const struct serial_struct *
       0x00005420   TIOCPKT          const int *
       0x00005421   FIONBIO          const int *
       0x00005422   TIOCNOTTY        void
       0x00005423   TIOCSETD         const int *
       0x00005424   TIOCGETD         int *
       0x00005425   TCSBRKP          int
       0x00005426   TIOCTTYGSTRUCT   struct tty_struct *
       0x00005450   FIONCLEX         void
       0x00005451   FIOCLEX          void
       0x00005452   FIOASYNC         const int *
       0x00005453   TIOCSERCONFIG    void
       0x00005454   TIOCSERGWILD     int *
       0x00005455   TIOCSERSWILD     const int *
       0x00005456   TIOCGLCKTRMIOS   struct termios *
       0x00005457   TIOCSLCKTRMIOS   const struct termios *
       0x00005458   TIOCSERGSTRUCT   struct async_struct *
       0x00005459   TIOCSERGETLSR    int *

       0x0000545A   TIOCSERGETMULTI   struct serial_multiport_struct *
       0x0000545B   TIOCSERSETMULTI   const struct serial_multiport_struct *

       // <include/linux/ax25.h>

       0x000089E0   SIOCAX25GETUID     const struct sockaddr_ax25 *
       0x000089E1   SIOCAX25ADDUID     const struct sockaddr_ax25 *
       0x000089E2   SIOCAX25DELUID     const struct sockaddr_ax25 *
       0x000089E3   SIOCAX25NOUID      const int *
       0x000089E4   SIOCAX25DIGCTL     const int *
       0x000089E5   SIOCAX25GETPARMS   struct ax25_parms_struct *     // I-O

       0x000089E6   SIOCAX25SETPARMS   const struct ax25_parms_struct *

       // <include/linux/cdk.h>

       0x00007314   STL_BINTR    void
       0x00007315   STL_BSTART   void
       0x00007316   STL_BSTOP    void
       0x00007317   STL_BRESET   void

       // <include/linux/cdrom.h>

       0x00005301   CDROMPAUSE        void
       0x00005302   CDROMRESUME       void
       0x00005303   CDROMPLAYMSF      const struct cdrom_msf *
       0x00005304   CDROMPLAYTRKIND   const struct cdrom_ti *
       0x00005305   CDROMREADTOCHDR   struct cdrom_tochdr *

       0x00005306   CDROMREADTOCENTRY   struct cdrom_tocentry *   // I-O

       0x00005307   CDROMSTOP        void
       0x00005308   CDROMSTART       void
       0x00005309   CDROMEJECT       void
       0x0000530A   CDROMVOLCTRL     const struct cdrom_volctrl *
       0x0000530B   CDROMSUBCHNL     struct cdrom_subchnl *            // I-O
       0x0000530C   CDROMREADMODE2   const struct cdrom_msf *          // MORE
       0x0000530D   CDROMREADMODE1   const struct cdrom_msf *          // MORE
       0x0000530E   CDROMREADAUDIO   const struct cdrom_read_audio *   // MORE
       0x0000530F   CDROMEJECT_SW    int

       0x00005310   CDROMMULTISESSION   struct cdrom_multisession *   // I-O

       0x00005311   CDROM_GET_UPC     struct { char [8]; } *
       0x00005312   CDROMRESET        void
       0x00005313   CDROMVOLREAD      struct cdrom_volctrl *
       0x00005314   CDROMREADRAW      const struct cdrom_msf *   // MORE
       0x00005315   CDROMREADCOOKED   const struct cdrom_msf *   // MORE
       0x00005316   CDROMSEEK         const struct cdrom_msf *

       // <include/linux/cm206.h>

       0x00002000   CM206CTL_GET_STAT        int
       0x00002001   CM206CTL_GET_LAST_STAT   int

       // <include/linux/cyclades.h>

       0x00435901   CYGETMON          struct cyclades_monitor *
       0x00435902   CYGETTHRESH       int *
       0x00435903   CYSETTHRESH       int
       0x00435904   CYGETDEFTHRESH    int *
       0x00435905   CYSETDEFTHRESH    int
       0x00435906   CYGETTIMEOUT      int *
       0x00435907   CYSETTIMEOUT      int
       0x00435908   CYGETDEFTIMEOUT   int *
       0x00435909   CYSETDEFTIMEOUT   int

       // <include/linux/fd.h>

       0x00000000   FDCLRPRM         void
       0x00000001   FDSETPRM         const struct floppy_struct *
       0x00000002   FDDEFPRM         const struct floppy_struct *
       0x00000003   FDGETPRM         struct floppy_struct *
       0x00000004   FDMSGON          void
       0x00000005   FDMSGOFF         void
       0x00000006   FDFMTBEG         void
       0x00000007   FDFMTTRK         const struct format_descr *
       0x00000008   FDFMTEND         void
       0x0000000A   FDSETEMSGTRESH   int
       0x0000000B   FDFLUSH          void
       0x0000000C   FDSETMAXERRS     const struct floppy_max_errors *
       0x0000000E   FDGETMAXERRS     struct floppy_max_errors *
       0x00000010   FDGETDRVTYP      struct { char [16]; } *
       0x00000014   FDSETDRVPRM      const struct floppy_drive_params *
       0x00000015   FDGETDRVPRM      struct floppy_drive_params *
       0x00000016   FDGETDRVSTAT     struct floppy_drive_struct *

       0x00000017   FDPOLLDRVSTAT    struct floppy_drive_struct *
       0x00000018   FDRESET          int
       0x00000019   FDGETFDCSTAT     struct floppy_fdc_state *
       0x0000001B   FDWERRORCLR      void
       0x0000001C   FDWERRORGET      struct floppy_write_errors *

       0x0000001E   FDRAWCMD    struct floppy_raw_cmd *   // MORE // I-O
       0x00000028   FDTWADDLE   void

       // <include/linux/fs.h>

       0x0000125D   BLKROSET              const int *
       0x0000125E   BLKROGET              int *
       0x0000125F   BLKRRPART             void
       0x00001260   BLKGETSIZE            unsigned long *
       0x00001261   BLKFLSBUF             void
       0x00001262   BLKRASET              unsigned long
       0x00001263   BLKRAGET              unsigned long *
       0x00000001   FIBMAP                int *             // I-O
       0x00000002   FIGETBSZ              int *
       0x80086601   FS_IOC_GETFLAGS       int *
       0x40086602   FS_IOC_SETFLAGS       int *
       0x80087601   FS_IOC_GETVERSION     int *
       0x40087602   FS_IOC_SETVERSION     int *
       0xC020660B   FS_IOC_FIEMAP         struct fiemap *
       0x40086602   FS_IOC32_SETFLAGS     int *
       0x40086602   FS_IOC32_SETFLAGS     int *
       0x80047601   FS_IOC32_GETVERSION   int *
       0x40047602   FS_IOC32_SETVERSION   int *

       // <include/linux/hdreg.h>

       0x00000301   HDIO_GETGEO             struct hd_geometry *
       0x00000302   HDIO_GET_UNMASKINTR     int *
       0x00000304   HDIO_GET_MULTCOUNT      int *
       0x00000307   HDIO_GET_IDENTITY       struct hd_driveid *
       0x00000308   HDIO_GET_KEEPSETTINGS   int *
       0x00000309   HDIO_GET_CHIPSET        int *
       0x0000030A   HDIO_GET_NOWERR         int *
       0x0000030B   HDIO_GET_DMA            int *
       0x0000031F   HDIO_DRIVE_CMD          int *                  // I-O
       0x00000321   HDIO_SET_MULTCOUNT      int
       0x00000322   HDIO_SET_UNMASKINTR     int
       0x00000323   HDIO_SET_KEEPSETTINGS   int
       0x00000324   HDIO_SET_CHIPSET        int
       0x00000325   HDIO_SET_NOWERR         int
       0x00000326   HDIO_SET_DMA            int

       // <include/linux/if_eql.h>

       0x000089F0   EQL_ENSLAVE       struct ifreq *   // MORE // I-O
       0x000089F1   EQL_EMANCIPATE    struct ifreq *   // MORE // I-O
       0x000089F2   EQL_GETSLAVECFG   struct ifreq *   // MORE // I-O
       0x000089F3   EQL_SETSLAVECFG   struct ifreq *   // MORE // I-O
       0x000089F4   EQL_GETMASTRCFG   struct ifreq *   // MORE // I-O
       0x000089F5   EQL_SETMASTRCFG   struct ifreq *   // MORE // I-O

       // <include/linux/if_plip.h>

       0x000089F0   SIOCDEVPLIP   struct ifreq *   // I-O

       // <include/linux/if_ppp.h>

       0x00005490   PPPIOCGFLAGS       int *
       0x00005491   PPPIOCSFLAGS       const int *

       0x00005492   PPPIOCGASYNCMAP    int *
       0x00005493   PPPIOCSASYNCMAP    const int *
       0x00005494   PPPIOCGUNIT        int *
       0x00005495   PPPIOCSINPSIG      const int *
       0x00005497   PPPIOCSDEBUG       const int *
       0x00005498   PPPIOCGDEBUG       int *
       0x00005499   PPPIOCGSTAT        struct ppp_stats *
       0x0000549A   PPPIOCGTIME        struct ppp_ddinfo *
       0x0000549B   PPPIOCGXASYNCMAP   struct { int [8]; } *
       0x0000549C   PPPIOCSXASYNCMAP   const struct { int [8]; } *
       0x0000549D   PPPIOCSMRU         const int *
       0x0000549E   PPPIOCRASYNCMAP    const int *
       0x0000549F   PPPIOCSMAXCID      const int *

       // <include/linux/ipx.h>

       0x000089E0   SIOCAIPXITFCRT   const char *
       0x000089E1   SIOCAIPXPRISLT   const char *
       0x000089E2   SIOCIPXCFGDATA   struct ipx_config_data *

       // <include/linux/kd.h>

       0x00004B60   GIO_FONT   struct { char [8192]; } *
       0x00004B61   PIO_FONT   const struct { char [8192]; } *

       0x00004B6B  GIO_FONTX  struct console_font_desc *        // MORE // I-O
       0x00004B6C  PIO_FONTX  const struct console_font_desc *  //MORE

       0x00004B70   GIO_CMAP   struct { char [48]; } *
       0x00004B71   PIO_CMAP   const struct { char [48]; }

       0x00004B2F   KIOCSOUND     int
       0x00004B30   KDMKTONE      int
       0x00004B31   KDGETLED      char *
       0x00004B32   KDSETLED      int
       0x00004B33   KDGKBTYPE     char *
       0x00004B34   KDADDIO       int                            // MORE
       0x00004B35   KDDELIO       int                            // MORE
       0x00004B36   KDENABIO      void                           // MORE
       0x00004B37   KDDISABIO     void                           // MORE
       0x00004B3A   KDSETMODE     int
       0x00004B3B   KDGETMODE     int *
       0x00004B3C   KDMAPDISP     void                           // MORE
       0x00004B3D   KDUNMAPDISP   void                           // MORE
       0x00004B40   GIO_SCRNMAP   struct { char [E_TABSZ]; } *

       0x00004B41   PIO_SCRNMAP      const struct { char [E_TABSZ]; } *
       0x00004B69   GIO_UNISCRNMAP   struct { short [E_TABSZ]; } *
       0x00004B6A   PIO_UNISCRNMAP   const struct { short [E_TABSZ]; } *

       0x00004B66   GIO_UNIMAP      struct unimapdesc *         // MORE // I-O
       0x00004B67   PIO_UNIMAP      const struct unimapdesc *   // MORE
       0x00004B68   PIO_UNIMAPCLR   const struct unimapinit *
       0x00004B44   KDGKBMODE       int *
       0x00004B45   KDSKBMODE       int
       0x00004B62   KDGKBMETA       int *
       0x00004B63   KDSKBMETA       int
       0x00004B64   KDGKBLED        int *
       0x00004B65   KDSKBLED        int
       0x00004B46   KDGKBENT        struct kbentry *            // I-O
       0x00004B47   KDSKBENT        const struct kbentry *
       0x00004B48   KDGKBSENT       struct kbsentry *           // I-O
       0x00004B49   KDSKBSENT       const struct kbsentry *
       0x00004B4A   KDGKBDIACR      struct kbdiacrs *
       0x00004B4B   KDSKBDIACR      const struct kbdiacrs *

       0x00004B4C   KDGETKEYCODE    struct kbkeycode *          // I-O
       0x00004B4D   KDSETKEYCODE    const struct kbkeycode *
       0x00004B4E   KDSIGACCEPT     int

       // <include/linux/lp.h>

       0x00000601   LPCHAR        int
       0x00000602   LPTIME        int
       0x00000604   LPABORT       int
       0x00000605   LPSETIRQ      int
       0x00000606   LPGETIRQ      int *
       0x00000608   LPWAIT        int
       0x00000609   LPCAREFUL     int
       0x0000060A   LPABORTOPEN   int
       0x0000060B   LPGETSTATUS   int *
       0x0000060C   LPRESET       void
       0x0000060D   LPGETSTATS    struct lp_stats *

       // <include/linux/mroute.h>

       0x000089E0   SIOCGETVIFCNT   struct sioc_vif_req *   // I-O
       0x000089E1   SIOCGETSGCNT    struct sioc_sg_req *    // I-O

       // <include/linux/msdos_fs.h> see ioctl_fat(2)

       0x82307201   VFAT_IOCTL_READDIR_BOTH    struct dirent [2]
       0x82307202   VFAT_IOCTL_READDIR_SHORT   struct dirent [2]
       0x80047210   FAT_IOCTL_GET_ATTRIBUTES   __u32 *
       0x40047211   FAT_IOCTL_SET_ATTRIBUTES   const __u32 *
       0x80047213   FAT_IOCTL_GET_VOLUME_ID    __u32 *

       // <include/linux/mtio.h>

       0x40086D01   MTIOCTOP         const struct mtop *
       0x801C6D02   MTIOCGET         struct mtget *
       0x80046D03   MTIOCPOS         struct mtpos *
       0x80206D04   MTIOCGETCONFIG   struct mtconfiginfo *
       0x40206D05   MTIOCSETCONFIG   const struct mtconfiginfo *

       // <include/linux/netrom.h>

       0x000089E0   SIOCNRGETPARMS   struct nr_parms_struct *         // I-O
       0x000089E1   SIOCNRSETPARMS   const struct nr_parms_struct *
       0x000089E2   SIOCNRDECOBS     void
       0x000089E3   SIOCNRRTCTL      const int *

       // <include/uapi/linux/wireless.h>
       // This API is deprecated.
       // It is being replaced by nl80211 and cfg80211.  See
       // https://wireless.wiki.kernel.org/en/developers/documentation/nl80211

       x00008b00   SIOCSIWCOMMIT      struct iwreq *
       x00008b01   SIOCGIWNAME        struct iwreq *
       x00008b02   SIOCSIWNWID        struct iwreq *
       x00008b03   SIOCGIWNWID        struct iwreq *
       x00008b04   SIOCSIWFREQ        struct iwreq *
       x00008b05   SIOCGIWFREQ        struct iwreq *
       x00008b06   SIOCSIWMODE        struct iwreq *
       x00008b07   SIOCGIWMODE        struct iwreq *
       x00008b08   SIOCSIWSENS        struct iwreq *
       x00008b09   SIOCGIWSENS        struct iwreq *
       x00008b0a   SIOCSIWRANGE       struct iwreq *
       x00008b0b   SIOCGIWRANGE       struct iwreq *
       x00008b0c   SIOCSIWPRIV        struct iwreq *
       x00008b0d   SIOCGIWPRIV        struct iwreq *

       x00008b0e   SIOCSIWSTATS       struct iwreq *
       x00008b0f   SIOCGIWSTATS       struct iwreq *
       x00008b10   SIOCSIWSPY         struct iwreq *
       x00008b11   SIOCGIWSPY         struct iwreq *
       x00008b12   SIOCSIWTHRSPY      struct iwreq *
       x00008b13   SIOCGIWTHRSPY      struct iwreq *
       x00008b14   SIOCSIWAP          struct iwreq *
       x00008b15   SIOCGIWAP          struct iwreq *
       x00008b17   SIOCGIWAPLIST      struct iwreq *
       x00008b18   SIOCSIWSCAN        struct iwreq *
       x00008b19   SIOCGIWSCAN        struct iwreq *
       x00008b1a   SIOCSIWESSID       struct iwreq *
       x00008b1b   SIOCGIWESSID       struct iwreq *
       x00008b1c   SIOCSIWNICKN       struct iwreq *
       x00008b1d   SIOCGIWNICKN       struct iwreq *
       x00008b20   SIOCSIWRATE        struct iwreq *
       x00008b21   SIOCGIWRATE        struct iwreq *
       x00008b22   SIOCSIWRTS         struct iwreq *
       x00008b23   SIOCGIWRTS         struct iwreq *
       x00008b24   SIOCSIWFRAG        struct iwreq *
       x00008b25   SIOCGIWFRAG        struct iwreq *
       x00008b26   SIOCSIWTXPOW       struct iwreq *
       x00008b27   SIOCGIWTXPOW       struct iwreq *
       x00008b28   SIOCSIWRETRY       struct iwreq *
       x00008b29   SIOCGIWRETRY       struct iwreq *
       x00008b2a   SIOCSIWENCODE      struct iwreq *
       x00008b2b   SIOCGIWENCODE      struct iwreq *
       x00008b2c   SIOCSIWPOWER       struct iwreq *
       x00008b2d   SIOCGIWPOWER       struct iwreq *
       x00008b30   SIOCSIWGENIE       struct iwreq *
       x00008b31   SIOCGIWGENIE       struct iwreq *
       x00008b16   SIOCSIWMLME        struct iwreq *
       x00008b32   SIOCSIWAUTH        struct iwreq *
       x00008b33   SIOCGIWAUTH        struct iwreq *
       x00008b34   SIOCSIWENCODEEXT   struct iwreq *
       x00008b35   SIOCGIWENCODEEXT   struct iwreq *
       x00008b36   SIOCSIWPMKSA       struct iwreq *

       // <include/linux/sbpcd.h>

       0x00009000   DDIOCSDBG          const int *
       0x00005382   CDROMAUDIOBUFSIZ   int

       // <include/linux/scc.h>

       0x00005470   TIOCSCCINI    void
       0x00005471   TIOCCHANINI   const struct scc_modem *
       0x00005472   TIOCGKISS     struct ioctl_command *         // I-O
       0x00005473   TIOCSKISS     const struct ioctl_command *
       0x00005474   TIOCSCCSTAT   struct scc_stat *

       // <include/linux/scsi.h>

       0x00005382   SCSI_IOCTL_GET_IDLUN       struct { int [2]; } *
       0x00005383   SCSI_IOCTL_TAGGED_ENABLE   void
       0x00005384   SCSI_IOCTL_TAGGED_DISABLE  void

       0x00005385   SCSI_IOCTL_PROBE_HOST   const int *   // MORE

       // <include/linux/smb_fs.h>

       0x80027501   SMB_IOC_GETMOUNTUID   uid_t *

       // <include/uapi/linux/sockios.h> see netdevice(7)

       0x0000890B   SIOCADDRT        const struct rtentry *   // MORE
       0x0000890C   SIOCDELRT        const struct rtentry *   // MORE
       0x00008910   SIOCGIFNAME      char []
       0x00008911   SIOCSIFLINK      void
       0x00008912   SIOCGIFCONF      struct ifconf *          // MORE // I-O
       0x00008913   SIOCGIFFLAGS     struct ifreq *           // I-O
       0x00008914   SIOCSIFFLAGS     const struct ifreq *
       0x00008915   SIOCGIFADDR      struct ifreq *           // I-O
       0x00008916   SIOCSIFADDR      const struct ifreq *
       0x00008917   SIOCGIFDSTADDR   struct ifreq *           // I-O
       0x00008918   SIOCSIFDSTADDR   const struct ifreq *
       0x00008919   SIOCGIFBRDADDR   struct ifreq *           // I-O
       0x0000891A   SIOCSIFBRDADDR   const struct ifreq *
       0x0000891B   SIOCGIFNETMASK   struct ifreq *           // I-O
       0x0000891C   SIOCSIFNETMASK   const struct ifreq *
       0x0000891D   SIOCGIFMETRIC    struct ifreq *           // I-O
       0x0000891E   SIOCSIFMETRIC    const struct ifreq *
       0x0000891F   SIOCGIFMEM       struct ifreq *           // I-O
       0x00008920   SIOCSIFMEM       const struct ifreq *
       0x00008921   SIOCGIFMTU       struct ifreq *           // I-O
       0x00008922   SIOCSIFMTU       const struct ifreq *

       0x00008923   OLD_SIOCGIFHWADDR   struct ifreq *          // I-O
       0x00008924   SIOCSIFHWADDR       const struct ifreq *    // MORE
       0x00008925   SIOCGIFENCAP        int *
       0x00008926   SIOCSIFENCAP        const int *
       0x00008927   SIOCGIFHWADDR       struct ifreq *          // I-O
       0x00008929   SIOCGIFSLAVE        void
       0x00008930   SIOCSIFSLAVE        void
       0x00008931   SIOCADDMULTI        const struct ifreq *
       0x00008932   SIOCDELMULTI        const struct ifreq *
       0x00008940   SIOCADDRTOLD        void
       0x00008941   SIOCDELRTOLD        void
       0x00008950   SIOCDARP            const struct arpreq *
       0x00008951   SIOCGARP            struct arpreq *         // I-O
       0x00008952   SIOCSARP            const struct arpreq *
       0x00008960   SIOCDRARP           const struct arpreq *
       0x00008961   SIOCGRARP           struct arpreq *         // I-O
       0x00008962   SIOCSRARP           const struct arpreq *
       0x00008970   SIOCGIFMAP          struct ifreq *          // I-O
       0x00008971   SIOCSIFMAP          const struct ifreq *

       // <include/linux/soundcard.h>

       0x00005100   SNDCTL_SEQ_RESET   void
       0x00005101   SNDCTL_SEQ_SYNC    void

       0xC08C5102   SNDCTL_SYNTH_INFO        struct synth_info *   // I-O
       0xC0045103   SNDCTL_SEQ_CTRLRATE      int *                 // I-O
       0x80045104   SNDCTL_SEQ_GETOUTCOUNT   int *
       0x80045105   SNDCTL_SEQ_GETINCOUNT    int *
       0x40045106   SNDCTL_SEQ_PERCMODE      void

       0x40285107   SNDCTL_FM_LOAD_INSTR   const struct sbi_instrument *

       0x40045108   SNDCTL_SEQ_TESTMIDI       const int *
       0x40045109   SNDCTL_SEQ_RESETSAMPLES   const int *
       0x8004510A   SNDCTL_SEQ_NRSYNTHS       int *
       0x8004510B   SNDCTL_SEQ_NRMIDIS        int *
       0xC074510C   SNDCTL_MIDI_INFO          struct midi_info *     // I-O
       0x4004510D   SNDCTL_SEQ_THRESHOLD      const int *
       0xC004510E   SNDCTL_SYNTH_MEMAVL       int *                  // I-O
       0x4004510F   SNDCTL_FM_4OP_ENABLE      const int *
       0xCFB85110   SNDCTL_PMGR_ACCESS        struct patmgr_info *   // I-O
       0x00005111   SNDCTL_SEQ_PANIC          void

       0x40085112   SNDCTL_SEQ_OUTOFBAND   const struct seq_event_rec *

       0xC0045401   SNDCTL_TMR_TIMEBASE    int *                  // I-O
       0x00005402   SNDCTL_TMR_START       void
       0x00005403   SNDCTL_TMR_STOP        void
       0x00005404   SNDCTL_TMR_CONTINUE    void
       0xC0045405   SNDCTL_TMR_TEMPO       int *                  // I-O
       0xC0045406   SNDCTL_TMR_SOURCE      int *                  // I-O
       0x40045407   SNDCTL_TMR_METRONOME   const int *
       0x40045408   SNDCTL_TMR_SELECT      int *                  // I-O
       0xCFB85001   SNDCTL_PMGR_IFACE      struct patmgr_info *   // I-O
       0xC0046D00   SNDCTL_MIDI_PRETIME    int *                  // I-O
       0xC0046D01   SNDCTL_MIDI_MPUMODE    const int *

       0xC0216D02   SNDCTL_MIDI_MPUCMD   struct mpu_command_rec *   // I-O

       0x00005000   SNDCTL_DSP_RESET           void
       0x00005001   SNDCTL_DSP_SYNC            void
       0xC0045002   SNDCTL_DSP_SPEED           int *   // I-O
       0xC0045003   SNDCTL_DSP_STEREO          int *   // I-O
       0xC0045004   SNDCTL_DSP_GETBLKSIZE      int *   // I-O
       0xC0045006   SOUND_PCM_WRITE_CHANNELS   int *   // I-O
       0xC0045007   SOUND_PCM_WRITE_FILTER     int *   // I-O
       0x00005008   SNDCTL_DSP_POST            void
       0xC0045009   SNDCTL_DSP_SUBDIVIDE       int *   // I-O
       0xC004500A   SNDCTL_DSP_SETFRAGMENT     int *   // I-O
       0x8004500B   SNDCTL_DSP_GETFMTS         int *
       0xC0045005   SNDCTL_DSP_SETFMT          int *   // I-O

       0x800C500C   SNDCTL_DSP_GETOSPACE      struct audio_buf_info *
       0x800C500D   SNDCTL_DSP_GETISPACE      struct audio_buf_info *
       0x0000500E   SNDCTL_DSP_NONBLOCK       void
       0x80045002   SOUND_PCM_READ_RATE       int *
       0x80045006   SOUND_PCM_READ_CHANNELS   int *
       0x80045005   SOUND_PCM_READ_BITS       int *
       0x80045007   SOUND_PCM_READ_FILTER     int *
       0x00004300   SNDCTL_COPR_RESET         void
       0xCFB04301   SNDCTL_COPR_LOAD          const struct copr_buffer *

       0xC0144302   SNDCTL_COPR_RDATA   struct copr_debug_buf *   // I-O
       0xC0144303   SNDCTL_COPR_RCODE   struct copr_debug_buf *   // I-O

       0x40144304   SNDCTL_COPR_WDATA   const struct copr_debug_buf *
       0x40144305   SNDCTL_COPR_WCODE   const struct copr_debug_buf *

       0xC0144306   SNDCTL_COPR_RUN    struct copr_debug_buf *   // I-O
       0xC0144307   SNDCTL_COPR_HALT   struct copr_debug_buf *   // I-O

       0x4FA44308   SNDCTL_COPR_SENDMSG           const struct copr_msg *
       0x8FA44309   SNDCTL_COPR_RCVMSG            struct copr_msg *
       0x80044D00   SOUND_MIXER_READ_VOLUME       int *
       0x80044D01   SOUND_MIXER_READ_BASS         int *
       0x80044D02   SOUND_MIXER_READ_TREBLE       int *
       0x80044D03   SOUND_MIXER_READ_SYNTH        int *
       0x80044D04   SOUND_MIXER_READ_PCM          int *
       0x80044D05   SOUND_MIXER_READ_SPEAKER      int *
       0x80044D06   SOUND_MIXER_READ_LINE         int *
       0x80044D07   SOUND_MIXER_READ_MIC          int *
       0x80044D08   SOUND_MIXER_READ_CD           int *
       0x80044D09   SOUND_MIXER_READ_IMIX         int *
       0x80044D0A   SOUND_MIXER_READ_ALTPCM       int *
       0x80044D0B   SOUND_MIXER_READ_RECLEV       int *
       0x80044D0C   SOUND_MIXER_READ_IGAIN        int *
       0x80044D0D   SOUND_MIXER_READ_OGAIN        int *
       0x80044D0E   SOUND_MIXER_READ_LINE1        int *

       0x80044D0F   SOUND_MIXER_READ_LINE2        int *
       0x80044D10   SOUND_MIXER_READ_LINE3        int *
       0x80044D1C   SOUND_MIXER_READ_MUTE         int *
       0x80044D1D   SOUND_MIXER_READ_ENHANCE      int *
       0x80044D1E   SOUND_MIXER_READ_LOUD         int *
       0x80044DFF   SOUND_MIXER_READ_RECSRC       int *
       0x80044DFE   SOUND_MIXER_READ_DEVMASK      int *
       0x80044DFD   SOUND_MIXER_READ_RECMASK      int *
       0x80044DFB   SOUND_MIXER_READ_STEREODEVS   int *
       0x80044DFC   SOUND_MIXER_READ_CAPS         int *

       0xC0044D00   SOUND_MIXER_WRITE_VOLUME    int *   // I-O
       0xC0044D01   SOUND_MIXER_WRITE_BASS      int *   // I-O
       0xC0044D02   SOUND_MIXER_WRITE_TREBLE    int *   // I-O
       0xC0044D03   SOUND_MIXER_WRITE_SYNTH     int *   // I-O
       0xC0044D04   SOUND_MIXER_WRITE_PCM       int *   // I-O
       0xC0044D05   SOUND_MIXER_WRITE_SPEAKER   int *   // I-O
       0xC0044D06   SOUND_MIXER_WRITE_LINE      int *   // I-O
       0xC0044D07   SOUND_MIXER_WRITE_MIC       int *   // I-O
       0xC0044D08   SOUND_MIXER_WRITE_CD        int *   // I-O
       0xC0044D09   SOUND_MIXER_WRITE_IMIX      int *   // I-O
       0xC0044D0A   SOUND_MIXER_WRITE_ALTPCM    int *   // I-O
       0xC0044D0B   SOUND_MIXER_WRITE_RECLEV    int *   // I-O
       0xC0044D0C   SOUND_MIXER_WRITE_IGAIN     int *   // I-O
       0xC0044D0D   SOUND_MIXER_WRITE_OGAIN     int *   // I-O
       0xC0044D0E   SOUND_MIXER_WRITE_LINE1     int *   // I-O
       0xC0044D0F   SOUND_MIXER_WRITE_LINE2     int *   // I-O
       0xC0044D10   SOUND_MIXER_WRITE_LINE3     int *   // I-O
       0xC0044D1C   SOUND_MIXER_WRITE_MUTE      int *   // I-O
       0xC0044D1D   SOUND_MIXER_WRITE_ENHANCE   int *   // I-O
       0xC0044D1E   SOUND_MIXER_WRITE_LOUD      int *   // I-O
       0xC0044DFF   SOUND_MIXER_WRITE_RECSRC    int *   // I-O

       // <include/linux/timerfd.h> see timerfd_create(2)

       0x40085400   TFD_IOC_SET_TICKS   uint64_t *

       // <include/linux/umsdos_fs.h>

       0x000004D2   UMSDOS_READDIR_DOS   struct umsdos_ioctl *         // I-O
       0x000004D3   UMSDOS_UNLINK_DOS    const struct umsdos_ioctl *
       0x000004D4   UMSDOS_RMDIR_DOS     const struct umsdos_ioctl *
       0x000004D5   UMSDOS_STAT_DOS      struct umsdos_ioctl *         // I-O
       0x000004D6   UMSDOS_CREAT_EMD     const struct umsdos_ioctl *
       0x000004D7   UMSDOS_UNLINK_EMD    const struct umsdos_ioctl *
       0x000004D8   UMSDOS_READDIR_EMD   struct umsdos_ioctl *         // I-O
       0x000004D9   UMSDOS_GETVERSION    struct umsdos_ioctl *
       0x000004DA   UMSDOS_INIT_EMD      void
       0x000004DB   UMSDOS_DOS_SETUP     const struct umsdos_ioctl *
       0x000004DC   UMSDOS_RENAME_DOS    const struct umsdos_ioctl *

       // <include/linux/vt.h>

       0x00005600   VT_OPENQRY       int *
       0x00005601   VT_GETMODE       struct vt_mode *
       0x00005602   VT_SETMODE       const struct vt_mode *
       0x00005603   VT_GETSTATE      struct vt_stat *
       0x00005604   VT_SENDSIG       void
       0x00005605   VT_RELDISP       int
       0x00005606   VT_ACTIVATE      int
       0x00005607   VT_WAITACTIVE    int
       0x00005608   VT_DISALLOCATE   int
       0x00005609   VT_RESIZE        const struct vt_sizes *
       0x0000560A   VT_RESIZEX       const struct vt_consize *

       // More arguments.  Some ioctl's take a pointer to a structure which contains additional pointers.  These are docu‐
       mented here in alphabetical order.

       CDROMREADAUDIO takes an input pointer const struct cdrom_read_audio *.  The buf field points to an output buffer of
       length nframes * CD_FRAMESIZE_RAW.

       CDROMREADCOOKED, CDROMREADMODE1, CDROMREADMODE2, and CDROMREADRAW take an input pointer const  struct  cdrom_msf *.
       They use the same pointer as an output pointer to char [].  The length varies by request.  For CDROMREADMODE1, most
       drivers use CD_FRAMESIZE, but the Optics Storage driver uses OPT_BLOCKSIZE instead (both have the  numerical  value
       2048).

           CDROMREADCOOKED    char [CD_FRAMESIZE]
           CDROMREADMODE1     char [CD_FRAMESIZE or OPT_BLOCKSIZE]
           CDROMREADMODE2     char [CD_FRAMESIZE_RAW0]
           CDROMREADRAW       char [CD_FRAMESIZE_RAW]

       EQL_ENSLAVE, EQL_EMANCIPATE, EQL_GETSLAVECFG, EQL_SETSLAVECFG, EQL_GETMASTERCFG, and EQL_SETMASTERCFG take a struct
       ifreq *.  The ifr_data field is a pointer to another structure as follows:

           EQL_ENSLAVE         const struct slaving_request *
           EQL_EMANCIPATE      const struct slaving_request *
           EQL_GETSLAVECFG     struct slave_config *           // I-O
           EQL_SETSLAVECFG     const struct slave_config *
           EQL_GETMASTERCFG    struct master_config *
           EQL_SETMASTERCFG    const struct master_config *

       FDRAWCMD takes a struct floppy raw_cmd *.  If flags & FD_RAW_WRITE is nonzero, then data points to an input  buffer
       of length length.  If flags & FD_RAW_READ is nonzero, then data points to an output buffer of length length.

       GIO_FONTX  and  PIO_FONTX  take  a  struct console_font_desc * or a const struct console_font_desc *, respectively.
       chardata points to a buffer of char [charcount].  This is an output buffer for GIO_FONTX and an  input  buffer  for
       PIO_FONTX.

       GIO_UNIMAP  and PIO_UNIMAP take a struct unimapdesc * or a const struct unimapdesc *, respectively.  entries points
       to a buffer of struct unipair [entry_ct].  This is an  output  buffer  for  GIO_UNIMAP  and  an  input  buffer  for
       PIO_UNIMAP.

       KDADDIO,  KDDELIO,  KDDISABIO,  and KDENABIO enable or disable access to I/O ports.  They are essentially alternate
       interfaces to 'ioperm'.

       KDMAPDISP and KDUNMAPDISP enable or disable memory mappings or I/O port access.  They are not  implemented  in  the
       kernel.

       SCSI_IOCTL_PROBE_HOST takes an input pointer const int *, which is a length.  It uses the same pointer as an output
       pointer to a char [] buffer of this length.

       SIOCADDRT and SIOCDELRT take an input pointer whose type depends on the protocol:

           Most protocols      const struct rtentry *
           AX.25               const struct ax25_route *
           NET/ROM             const struct nr_route_struct *
           INET6               const struct in6_rtmsg *

       SIOCGIFCONF takes a struct ifconf *.  The ifc_buf field points to a buffer of length ifc_len bytes, into which  the
       kernel writes a list of type struct ifreq [].

       SIOCSIFHWADDR takes an input pointer whose type depends on the protocol:

           Most protocols      const struct ifreq *
           AX.25               const char [AX25_ADDR_LEN]

       TIOCLINUX takes a const char *.  It uses this to distinguish several independent subcases.  In the table below, N +
       foo means foo after an N-byte pad.  struct selection is implicitly defined in drivers/char/selection.c

           TIOCLINUX-2         1 + const struct selection *
           TIOCLINUX-3         void
           TIOCLINUX-4         void
           TIOCLINUX-5         4 + const struct { long [8]; } *
           TIOCLINUX-6         char *
           TIOCLINUX-7         char *
           TIOCLINUX-10        1 + const char *

       // Duplicate ioctls

       This list does not include ioctls in the range SIOCDEVPRIVATE and SIOCPROTOPRIVATE.

       0x00000001   FDSETPRM              FIBMAP
       0x00000002   FDDEFPRM              FIGETBSZ
       0x00005382   CDROMAUDIOBUFSIZ      SCSI_IOCTL_GET_IDLUN
       0x00005402   SNDCTL_TMR_START      TCSETS
       0x00005403   SNDCTL_TMR_STOP       TCSETSW
       0x00005404   SNDCTL_TMR_CONTINUE   TCSETSF

SEE ALSO
       ioctl(2), ioctl_fat(2), netdevice(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           IOCTL_LIST(2)
</pre>
<pre zoom>
<span xsmall>2 accept</span>
ACCEPT(2)                                        Linux Programmer's Manual                                       ACCEPT(2)

NAME
       accept, accept4 - accept a connection on a socket

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>

       int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <sys/socket.h>

       int accept4(int sockfd, struct sockaddr *addr,
                   socklen_t *addrlen, int flags);

DESCRIPTION
       The accept() system call is used with connection-based socket types (SOCK_STREAM, SOCK_SEQPACKET).  It extracts the
       first connection request on the queue of pending connections for the listening socket, sockfd, creates a  new  con‐
       nected  socket, and returns a new file descriptor referring to that socket.  The newly created socket is not in the
       listening state.  The original socket sockfd is unaffected by this call.

       The argument sockfd is a socket that has been created with socket(2), bound to a local address with bind(2), and is
       listening for connections after a listen(2).

       The  argument  addr is a pointer to a sockaddr structure.  This structure is filled in with the address of the peer
       socket, as known to the communications layer.  The exact format of the address returned addr is determined  by  the
       socket's  address  family  (see  socket(2)  and  the respective protocol man pages).  When addr is NULL, nothing is
       filled in; in this case, addrlen is not used, and should also be NULL.

       The addrlen argument is a value-result argument: the caller must initialize it to contain the size  (in  bytes)  of
       the structure pointed to by addr; on return it will contain the actual size of the peer address.

       The  returned  address  is truncated if the buffer provided is too small; in this case, addrlen will return a value
       greater than was supplied to the call.

       If no pending connections are present on the queue, and the socket is not marked as  nonblocking,  accept()  blocks
       the  caller  until  a  connection  is  present.  If the socket is marked nonblocking and no pending connections are
       present on the queue, accept() fails with the error EAGAIN or EWOULDBLOCK.

       In order to be notified of incoming connections on a socket, you can use select(2), poll(2), or epoll(7).  A  read‐
       able  event will be delivered when a new connection is attempted and you may then call accept() to get a socket for
       that connection.  Alternatively, you can set the socket to deliver SIGIO when activity  occurs  on  a  socket;  see
       socket(7) for details.

       If flags is 0, then accept4() is the same as accept().  The following values can be bitwise ORed in flags to obtain
       different behavior:

       SOCK_NONBLOCK   Set the O_NONBLOCK file status flag on the new open file description.  Using this flag saves  extra
                       calls to fcntl(2) to achieve the same result.

       SOCK_CLOEXEC    Set  the  close-on-exec  (FD_CLOEXEC)  flag on the new file descriptor.  See the description of the
                       O_CLOEXEC flag in open(2) for reasons why this may be useful.

RETURN VALUE
       On success, these system calls return a nonnegative integer that is a file descriptor for the accepted socket.   On
       error, -1 is returned, and errno is set appropriately.

   Error handling
       Linux  accept()  (and  accept4())  passes  already-pending  network  errors on the new socket as an error code from
       accept().  This behavior differs from other BSD socket implementations.  For  reliable  operation  the  application
       should  detect  the  network errors defined for the protocol after accept() and treat them like EAGAIN by retrying.
       In the case of TCP/IP, these are ENETDOWN, EPROTO, ENOPROTOOPT, EHOSTDOWN, ENONET,  EHOSTUNREACH,  EOPNOTSUPP,  and
       ENETUNREACH.

ERRORS
       EAGAIN or EWOULDBLOCK
              The  socket  is  marked  nonblocking  and  no  connections  are  present  to  be accepted.  POSIX.1-2001 and
              POSIX.1-2008 allow either error to be returned for this case, and do not require these constants to have the
              same value, so a portable application should check for both possibilities.

       EBADF  sockfd is not an open file descriptor.

       ECONNABORTED
              A connection has been aborted.

       EFAULT The addr argument is not in a writable part of the user address space.

       EINTR  The  system  call  was  interrupted  by a signal that was caught before a valid connection arrived; see sig‐
              nal(7).

       EINVAL Socket is not listening for connections, or addrlen is invalid (e.g., is negative).

       EINVAL (accept4()) invalid value in flags.

       EMFILE The per-process limit on the number of open file descriptors has been reached.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENOBUFS, ENOMEM
              Not enough free memory.  This often means that the memory allocation is limited by the socket buffer limits,
              not by the system memory.

       ENOTSOCK
              The file descriptor sockfd does not refer to a socket.

       EOPNOTSUPP
              The referenced socket is not of type SOCK_STREAM.

       EPROTO Protocol error.

       In addition, Linux accept() may fail if:

       EPERM  Firewall rules forbid connection.

       In addition, network errors for the new socket and as defined for the protocol may be returned.  Various Linux ker‐
       nels can return other errors such as ENOSR, ESOCKTNOSUPPORT, EPROTONOSUPPORT, ETIMEDOUT.  The value ERESTARTSYS may
       be seen during a trace.

VERSIONS
       The accept4() system call is available starting with Linux 2.6.28; support in glibc is available starting with ver‐
       sion 2.10.

CONFORMING TO
       accept(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (accept() first appeared in 4.2BSD).

       accept4() is a nonstandard Linux extension.

       On Linux, the new socket returned by accept() does not inherit file status flags such  as  O_NONBLOCK  and  O_ASYNC
       from the listening socket.  This behavior differs from the canonical BSD sockets implementation.  Portable programs
       should not rely on inheritance or noninheritance of file status flags and always explicitly set all required  flags
       on the socket returned from accept().

NOTES
       POSIX.1-2001  does not require the inclusion of <sys/types.h>, and this header file is not required on Linux.  How‐
       ever, some historical (BSD) implementations required this header file, and portable applications are probably  wise
       to include it.

       There may not always be a connection waiting after a SIGIO is delivered or select(2), poll(2), or epoll(7) return a
       readability event because the connection might have been removed by an asynchronous network error or another thread
       before  accept()  is  called.  If this happens, then the call will block waiting for the next connection to arrive.
       To ensure that accept() never blocks, the passed  socket  sockfd  needs  to  have  the  O_NONBLOCK  flag  set  (see
       socket(7)).

       For  certain protocols which require an explicit confirmation, such as DECnet, accept() can be thought of as merely
       dequeuing the next connection request and not implying confirmation.  Confirmation can be implied by a normal  read
       or  write on the new file descriptor, and rejection can be implied by closing the new socket.  Currently, only DEC‐
       net has these semantics on Linux.

   The socklen_t type
       In the original BSD sockets implementation (and on other older systems) the third argument of accept() was declared
       as  an  int *.  A POSIX.1g draft standard wanted to change it into a size_t *C; later POSIX standards and glibc 2.x
       have socklen_t * .

EXAMPLE
       See bind(2).

SEE ALSO
       bind(2), connect(2), listen(2), select(2), socket(2), socket(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2016-10-08                                               ACCEPT(2)
</pre>
<pre zoom>
<span xsmall>2 utimensat</span>
UTIMENSAT(2)                                     Linux Programmer's Manual                                    UTIMENSAT(2)

NAME
       utimensat, futimens - change file timestamps with nanosecond precision

SYNOPSIS
       #include <fcntl.h> /* Definition of AT_* constants */
       #include <sys/stat.h>

       int utimensat(int dirfd, const char *pathname,
                     const struct timespec times[2], int flags);

       int futimens(int fd, const struct timespec times[2]);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       utimensat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE
       futimens():
           Since glibc 2.10:
                  _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
                  _GNU_SOURCE

DESCRIPTION
       utimensat() and futimens() update the timestamps of a file with nanosecond precision.  This contrasts with the his‐
       torical utime(2) and utimes(2), which permit only second and microsecond precision, respectively, when setting file
       timestamps.

       With  utimensat()  the  file is specified via the pathname given in pathname.  With futimens() the file whose time‐
       stamps are to be updated is specified via an open file descriptor, fd.

       For both calls, the new file timestamps are specified in the array times: times[0] specifies the new  "last  access
       time"  (atime);  times[1] specifies the new "last modification time" (mtime).  Each of the elements of times speci‐
       fies a time as the number of seconds and nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).  This infor‐
       mation is conveyed in a structure of the following form:

           struct timespec {
               time_t tv_sec;        /* seconds */
               long   tv_nsec;       /* nanoseconds */
           };

       Updated  file  timestamps  are  set  to the greatest value supported by the filesystem that is not greater than the
       specified time.

       If the tv_nsec field of one of the timespec structures has the special value UTIME_NOW, then the corresponding file
       timestamp is set to the current time.  If the tv_nsec field of one of the timespec structures has the special value
       UTIME_OMIT, then the corresponding file timestamp is left unchanged.  In both of these cases, the value of the cor‐
       responding tv_sec field is ignored.

       If times is NULL, then both timestamps are set to the current time.

   Permissions requirements
       To  set  both  file timestamps to the current time (i.e., times is NULL, or both tv_nsec fields specify UTIME_NOW),
       either:

       1. the caller must have write access to the file;

       2. the caller's effective user ID must match the owner of the file; or

       3. the caller must have appropriate privileges.

       To make any change other than setting both timestamps to the current time (i.e., times is  not  NULL,  and  neither
       tv_nsec field is UTIME_NOW and neither tv_nsec field is UTIME_OMIT), either condition 2 or 3 above must apply.

       If  both tv_nsec fields are specified as UTIME_OMIT, then no file ownership or permission checks are performed, and
       the file timestamps are not modified, but other error conditions may still be detected.

   utimensat() specifics
       If pathname is relative, then by default it is interpreted relative to the directory referred to by the  open  file
       descriptor,  dirfd  (rather  than  relative  to the current working directory of the calling process, as is done by
       utimes(2) for a relative pathname).  See openat(2) for an explanation of why this can be useful.

       If pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the  cur‐
       rent working directory of the calling process (like utimes(2)).

       If pathname is absolute, then dirfd is ignored.

       The flags field is a bit mask that may be 0, or include the following constant, defined in <fcntl.h>:

       AT_SYMLINK_NOFOLLOW
              If pathname specifies a symbolic link, then update the timestamps of the link, rather than the file to which
              it refers.

RETURN VALUE
       On success, utimensat() and futimens() return 0.  On error, -1 is returned and errno is set to indicate the error.

ERRORS
       EACCES times is NULL, or both tv_nsec values are UTIME_NOW, and either:

              *  the effective user ID of the caller does not match the owner of the file, the caller does not have  write
                 access  to  the file, and the caller is not privileged (Linux: does not have either the CAP_FOWNER or the
                 CAP_DAC_OVERRIDE capability); or,

              *  the file is marked immutable (see chattr(1)).

       EBADF  (futimens()) fd is not a valid file descriptor.

       EBADF  (utimensat()) pathname is a relative pathname, but dirfd is neither AT_FDCWD nor a valid file descriptor.

       EFAULT times pointed to an invalid address; or, dirfd was AT_FDCWD, and pathname is NULL or an invalid address.

       EINVAL Invalid value in flags.

       EINVAL Invalid value in one of the tv_nsec fields (value outside range 0  to  999,999,999,  and  not  UTIME_NOW  or
              UTIME_OMIT); or an invalid value in one of the tv_sec fields.

       EINVAL pathname is NULL, dirfd is not AT_FDCWD, and flags contains AT_SYMLINK_NOFOLLOW.

       ELOOP  (utimensat()) Too many symbolic links were encountered in resolving pathname.

       ENAMETOOLONG
              (utimensat()) pathname is too long.

       ENOENT (utimensat())  A  component  of  pathname does not refer to an existing directory or file, or pathname is an
              empty string.

       ENOTDIR
              (utimensat()) pathname is a relative pathname, but dirfd is neither AT_FDCWD nor a file descriptor referring
              to a directory; or, one of the prefix components of pathname is not a directory.

       EPERM  The  caller  attempted to change one or both timestamps to a value other than the current time, or to change
              one of the timestamps to the current time while leaving the other timestamp unchanged, (i.e., times  is  not
              NULL, neither tv_nsec field is UTIME_NOW, and neither tv_nsec field is UTIME_OMIT) and either:

              *  the caller's effective user ID does not match the owner of file, and the caller is not privileged (Linux:
                 does not have the CAP_FOWNER capability); or,

              *  the file is marked append-only or immutable (see chattr(1)).

       EROFS  The file is on a read-only filesystem.

       ESRCH  (utimensat()) Search permission is denied for one of the prefix components of pathname.

VERSIONS
       utimensat() was added to Linux in kernel 2.6.22; glibc support was added with version 2.6.

       Support for futimens() first appeared in glibc 2.6.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌────────────────────────┬───────────────┬─────────┐
       │Interface               │ Attribute     │ Value   │
       ├────────────────────────┼───────────────┼─────────┤
       │utimensat(), futimens() │ Thread safety │ MT-Safe │
       └────────────────────────┴───────────────┴─────────┘

CONFORMING TO
       futimens() and utimensat() are specified in POSIX.1-2008.

NOTES
       utimensat() obsoletes futimesat(2).

       On Linux, timestamps cannot be changed for a file marked immutable, and the only change permitted for files  marked
       append-only  is  to  set  the  timestamps to the current time.  (This is consistent with the historical behavior of
       utime(2) and utimes(2) on Linux.)

       If both tv_nsec fields are specified as UTIME_OMIT, then the Linux implementation of utimensat() succeeds  even  if
       the file referred to by dirfd and pathname does not exist.

   C library/kernel ABI differences
       On Linux, futimens() is a library function implemented on top of the utimensat() system call.  To support this, the
       Linux utimensat() system call implements a nonstandard feature: if pathname is NULL, then  the  call  modifies  the
       timestamps  of the file referred to by the file descriptor dirfd (which may refer to any type of file).  Using this
       feature, the call futimens(fd, times) is implemented as:

           utimensat(fd, NULL, times, 0);

       Note, however, that the glibc wrapper for utimensat() disallows passing NULL as the value for pathname: the wrapper
       function returns the error EINVAL in this case.

BUGS
       Several  bugs  afflict  utimensat() and futimens() on kernels before 2.6.26.  These bugs are either nonconformances
       with the POSIX.1 draft specification or inconsistencies with historical Linux behavior.

       *  POSIX.1 specifies that if one of the tv_nsec fields has the value UTIME_NOW or UTIME_OMIT, then the value of the
          corresponding  tv_sec  field  should be ignored.  Instead, the value of the tv_sec field is required to be 0 (or
          the error EINVAL results).

       *  Various bugs mean that for the purposes of permission checking, the case where both tv_nsec fields  are  set  to
          UTIME_NOW  isn't  always  treated  the same as specifying times as NULL, and the case where one tv_nsec value is
          UTIME_NOW and the other is UTIME_OMIT isn't treated the same as specifying times as a pointer  to  an  array  of
          structures containing arbitrary time values.  As a result, in some cases: a) file timestamps can be updated by a
          process that shouldn't have permission to perform updates; b) file timestamps can't be updated by a process that
          should have permission to perform updates; and c) the wrong errno value is returned in case of an error.

       *  POSIX.1  says that a process that has write access to the file can make a call with times as NULL, or with times
          pointing to an array of structures in which both tv_nsec fields are UTIME_NOW, in order  to  update  both  time‐
          stamps  to  the current time.  However, futimens() instead checks whether the access mode of the file descriptor
          allows writing.

SEE ALSO
       chattr(1), touch(1), futimesat(2), openat(2), stat(2), utimes(2), futimes(3),  inode(7),  path_resolution(7),  sym‐
       link(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            UTIMENSAT(2)
</pre>
<pre zoom>
<span xsmall>2 prof</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 getdents64</span>
GETDENTS(2)                                      Linux Programmer's Manual                                     GETDENTS(2)

NAME
       getdents, getdents64 - get directory entries

SYNOPSIS
       int getdents(unsigned int fd, struct linux_dirent *dirp,
                    unsigned int count);
       int getdents64(unsigned int fd, struct linux_dirent64 *dirp,
                    unsigned int count);

       Note: There are no glibc wrappers for these system calls; see NOTES.

DESCRIPTION
       These  are  not the interfaces you are interested in.  Look at readdir(3) for the POSIX-conforming C library inter‐
       face.  This page documents the bare kernel system call interfaces.

   getdents()
       The system call getdents() reads several linux_dirent structures from the directory referred to by  the  open  file
       descriptor fd into the buffer pointed to by dirp.  The argument count specifies the size of that buffer.

       The linux_dirent structure is declared as follows:

           struct linux_dirent {
               unsigned long  d_ino;     /* Inode number */
               unsigned long  d_off;     /* Offset to next linux_dirent */
               unsigned short d_reclen;  /* Length of this linux_dirent */
               char           d_name[];  /* Filename (null-terminated) */
                                 /* length is actually (d_reclen - 2 -
                                    offsetof(struct linux_dirent, d_name)) */
               /*
               char           pad;       // Zero padding byte
               char           d_type;    // File type (only since Linux
                                         // 2.6.4); offset is (d_reclen - 1)
               */
           }

       d_ino  is  an  inode  number.   d_off  is  the  distance  from  the start of the directory to the start of the next
       linux_dirent.  d_reclen is the size of this entire linux_dirent.  d_name is a null-terminated filename.

       d_type is a byte at the end of the structure that indicates the file type.  It contains one of the following values
       (defined in <dirent.h>):

       DT_BLK      This is a block device.

       DT_CHR      This is a character device.

       DT_DIR      This is a directory.

       DT_FIFO     This is a named pipe (FIFO).

       DT_LNK      This is a symbolic link.

       DT_REG      This is a regular file.

       DT_SOCK     This is a UNIX domain socket.

       DT_UNKNOWN  The file type is unknown.

       The  d_type  field is implemented since Linux 2.6.4.  It occupies a space that was previously a zero-filled padding
       byte in the linux_dirent structure.  Thus, on kernels up to and including 2.6.3, attempting to  access  this  field
       always provides the value 0 (DT_UNKNOWN).

       Currently, only some filesystems (among them: Btrfs, ext2, ext3, and ext4) have full support for returning the file
       type in d_type.  All applications must properly handle a return of DT_UNKNOWN.

   getdents64()
       The original Linux getdents() system call did not handle large filesystems and large file  offsets.   Consequently,
       Linux  2.4 added getdents64(), with wider types for the d_ino and d_off fields.  In addition, getdents64() supports
       an explicit d_type field.

       The getdents64() system call is like getdents(), except that its second argument is a pointer to a buffer  contain‐
       ing structures of the following type:

           struct linux_dirent64 {
               ino64_t        d_ino;    /* 64-bit inode number */
               off64_t        d_off;    /* 64-bit offset to next structure */
               unsigned short d_reclen; /* Size of this dirent */
               unsigned char  d_type;   /* File type */
               char           d_name[]; /* Filename (null-terminated) */
           };

RETURN VALUE
       On  success,  the number of bytes read is returned.  On end of directory, 0 is returned.  On error, -1 is returned,
       and errno is set appropriately.

ERRORS
       EBADF  Invalid file descriptor fd.

       EFAULT Argument points outside the calling process's address space.

       EINVAL Result buffer is too small.

       ENOENT No such directory.

       ENOTDIR
              File descriptor does not refer to a directory.

CONFORMING TO
       SVr4.

NOTES
       Glibc does not provide a wrapper for these system calls; call them using syscall(2).  You will need to  define  the
       linux_dirent or linux_dirent64 structure yourself.  However, you probably want to use readdir(3) instead.

       These calls supersede readdir(2).

EXAMPLE
       The  program  below  demonstrates the use of getdents().  The following output shows an example of what we see when
       running this program on an ext2 directory:

           $ ./a.out /testfs/
           --------------- nread=120 ---------------
           inode#    file type  d_reclen  d_off   d_name
                  2  directory    16         12  .
                  2  directory    16         24  ..
                 11  directory    24         44  lost+found
                 12  regular      16         56  a
             228929  directory    16         68  sub
              16353  directory    16         80  sub2
             130817  directory    16       4096  sub3

   Program source

       #define _GNU_SOURCE
       #include <dirent.h>     /* Defines DT_* constants */
       #include <fcntl.h>
       #include <stdio.h>
       #include <unistd.h>
       #include <stdlib.h>
       #include <sys/stat.h>
       #include <sys/syscall.h>

       #define handle_error(msg) \
               do { perror(msg); exit(EXIT_FAILURE); } while (0)

       struct linux_dirent {
           long           d_ino;
           off_t          d_off;
           unsigned short d_reclen;
           char           d_name[];
       };

       #define BUF_SIZE 1024

       int
       main(int argc, char *argv[])
       {
           int fd, nread;
           char buf[BUF_SIZE];
           struct linux_dirent *d;
           int bpos;
           char d_type;

           fd = open(argc > 1 ? argv[1] : ".", O_RDONLY | O_DIRECTORY);
           if (fd == -1)
               handle_error("open");

           for ( ; ; ) {
               nread = syscall(SYS_getdents, fd, buf, BUF_SIZE);
               if (nread == -1)
                   handle_error("getdents");

               if (nread == 0)
                   break;

               printf("--------------- nread=%d ---------------\n", nread);
               printf("inode#    file type  d_reclen  d_off   d_name\n");
               for (bpos = 0; bpos < nread;) {
                   d = (struct linux_dirent *) (buf + bpos);
                   printf("%8ld  ", d->d_ino);
                   d_type = *(buf + bpos + d->d_reclen - 1);
                   printf("%-10s ", (d_type == DT_REG) ?  "regular" :
                                    (d_type == DT_DIR) ?  "directory" :
                                    (d_type == DT_FIFO) ? "FIFO" :
                                    (d_type == DT_SOCK) ? "socket" :
                                    (d_type == DT_LNK) ?  "symlink" :
                                    (d_type == DT_BLK) ?  "block dev" :
                                    (d_type == DT_CHR) ?  "char dev" : "???");
                   printf("%4d %10lld  %s\n", d->d_reclen,
                           (long long) d->d_off, d->d_name);
                   bpos += d->d_reclen;
               }
           }

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       readdir(2), readdir(3), inode(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             GETDENTS(2)
</pre>
<pre zoom>
<span xsmall>2 socketcall</span>
SOCKETCALL(2)                                    Linux Programmer's Manual                                   SOCKETCALL(2)

NAME
       socketcall - socket system calls

SYNOPSIS
       #include <linux/net.h>

       int socketcall(int call, unsigned long *args);

DESCRIPTION
       socketcall()  is a common kernel entry point for the socket system calls.  call determines which socket function to
       invoke.  args points to a block containing the actual arguments, which are passed through to the appropriate call.

       User programs should call the appropriate functions by their usual names.  Only standard library  implementors  and
       kernel hackers need to know about socketcall().

       call              Man page
       SYS_SOCKET        socket(2)
       SYS_BIND          bind(2)
       SYS_CONNECT       connect(2)
       SYS_LISTEN        listen(2)
       SYS_ACCEPT        accept(2)
       SYS_GETSOCKNAME   getsockname(2)
       SYS_GETPEERNAME   getpeername(2)
       SYS_SOCKETPAIR    socketpair(2)
       SYS_SEND          send(2)
       SYS_RECV          recv(2)
       SYS_SENDTO        sendto(2)
       SYS_RECVFROM      recvfrom(2)
       SYS_SHUTDOWN      shutdown(2)
       SYS_SETSOCKOPT    setsockopt(2)
       SYS_GETSOCKOPT    getsockopt(2)
       SYS_SENDMSG       sendmsg(2)
       SYS_RECVMSG       recvmsg(2)
       SYS_ACCEPT4       accept4(2)
       SYS_RECVMMSG      recvmmsg(2)
       SYS_SENDMMSG      sendmmsg(2)

CONFORMING TO
       This call is specific to Linux, and should not be used in programs intended to be portable.

NOTES
       On  a  some  architectures—for  example,  x86-64  and  ARM—there is no socketcall() system call; instead socket(2),
       accept(2), bind(2), and so on really are implemented as separate system calls.

       On x86-32, socketcall() was historically the only entry point for the sockets API.  However, starting in Linux 4.3,
       direct  system  calls are provided on x86-32 for the sockets API.  This facilitates the creation of seccomp(2) fil‐
       ters that filter sockets system calls (for new user-space binaries that are compiled to use the new  entry  points)
       and also provides a (very) small performance improvement.

SEE ALSO
       accept(2),  bind(2),  connect(2),  getpeername(2),  getsockname(2), getsockopt(2), listen(2), recv(2), recvfrom(2),
       recvmsg(2), send(2), sendmsg(2), sendto(2), setsockopt(2), shutdown(2), socket(2), socketpair(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           SOCKETCALL(2)
</pre>
<pre zoom>
<span xsmall>2 security</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 getpriority</span>
GETPRIORITY(2)                                   Linux Programmer's Manual                                  GETPRIORITY(2)

NAME
       getpriority, setpriority - get/set program scheduling priority

SYNOPSIS
       #include <sys/time.h>
       #include <sys/resource.h>

       int getpriority(int which, id_t who);
       int setpriority(int which, id_t who, int prio);

DESCRIPTION
       The  scheduling priority of the process, process group, or user, as indicated by which and who is obtained with the
       getpriority() call and set with the setpriority() call.  The process attribute dealt with by these system calls  is
       the same attribute (also known as the "nice" value) that is dealt with by nice(2).

       The  value  which  is  one  of  PRIO_PROCESS,  PRIO_PGRP, or PRIO_USER, and who is interpreted relative to which (a
       process identifier for PRIO_PROCESS, process group identifier for PRIO_PGRP, and a user ID for PRIO_USER).  A  zero
       value  for  who  denotes  (respectively) the calling process, the process group of the calling process, or the real
       user ID of the calling process.

       The prio argument is a value in the range -20 to 19 (but see NOTES below).  with -20 being the highest priority and
       19  being  the  lowest  priority.  Attempts to set a priority outside this range are silently clamped to the range.
       The default priority is 0; lower values give a process a higher scheduling priority.

       The getpriority() call returns the highest priority (lowest numerical value) enjoyed by any of the  specified  pro‐
       cesses.  The setpriority() call sets the priorities of all of the specified processes to the specified value.

       Traditionally,  only a privileged process could lower the nice value (i.e., set a higher priority).  However, since
       Linux 2.6.12, an unprivileged process can decrease the  nice  value  of  a  target  process  that  has  a  suitable
       RLIMIT_NICE soft limit; see getrlimit(2) for details.

RETURN VALUE
       On  success,  getpriority()  returns the calling thread's nice value, which may be a negative number.  On error, it
       returns -1 and sets errno to indicate the cause of the error.  Since a successful call to getpriority() can legiti‐
       mately  return  the value -1, it is necessary to clear the external variable errno prior to the call, then check it
       afterward to determine if -1 is an error or a legitimate value.

       setpriority() returns 0 on success.  On error, it returns -1 and sets errno to indicate the cause of the error.

ERRORS
       EINVAL which was not one of PRIO_PROCESS, PRIO_PGRP, or PRIO_USER.

       ESRCH  No process was located using the which and who values specified.

       In addition to the errors indicated above, setpriority() may fail if:

       EACCES The caller attempted to set a lower nice value (i.e., a higher process  priority),  but  did  not  have  the
              required privilege (on Linux: did not have the CAP_SYS_NICE capability).

       EPERM  A  process  was located, but its effective user ID did not match either the effective or the real user ID of
              the caller, and was not privileged (on Linux: did not have the  CAP_SYS_NICE  capability).   But  see  NOTES
              below.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (these interfaces first appeared in 4.2BSD).

NOTES
       For further details on the nice value, see sched(7).

       Note:  the  addition  of the "autogroup" feature in Linux 2.6.38 means that the nice value no longer has its tradi‐
       tional effect in many circumstances.  For details, see sched(7).

       A child created by fork(2) inherits its parent's nice value.  The nice value is preserved across execve(2).

       The details on the condition for EPERM depend on the system.  The above description is what POSIX.1-2001 says,  and
       seems to be followed on all System V-like systems.  Linux kernels before 2.6.12 required the real or effective user
       ID of the caller to match the real user of the process who (instead of its effective user ID).   Linux  2.6.12  and
       later  require  the effective user ID of the caller to match the real or effective user ID of the process who.  All
       BSD-like systems (SunOS 4.1.3, Ultrix 4.2, 4.3BSD, FreeBSD 4.3, OpenBSD-2.5, ...) behave  in  the  same  manner  as
       Linux 2.6.12 and later.

       Including  <sys/time.h>  is  not required these days, but increases portability.  (Indeed, <sys/resource.h> defines
       the rusage structure with fields of type struct timeval defined in <sys/time.h>.)

   C library/kernel differences
       Within the kernel, nice values are actually represented using the range 40..1 (since  negative  numbers  are  error
       codes)  and  these  are the values employed by the setpriority() and getpriority() system calls.  The glibc wrapper
       functions for these system calls handle the translations between the user-land and kernel  representations  of  the
       nice  value  according to the formula unice = 20 - knice.  (Thus, the kernel's 40..1 range corresponds to the range
       -20..19 as seen by user space.)

BUGS
       According to POSIX, the nice value is a per-process setting.  However, under the current Linux/NPTL  implementation
       of  POSIX threads, the nice value is a per-thread attribute: different threads in the same process can have differ‐
       ent nice values.  Portable applications should avoid relying on the Linux behavior, which  may  be  made  standards
       conformant in the future.

SEE ALSO
       nice(1), renice(1), fork(2), capabilities(7), sched(7)

       Documentation/scheduler/sched-nice-design.txt in the Linux kernel source tree (since Linux 2.6.23)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                          GETPRIORITY(2)
</pre>
<pre zoom>
<span xsmall>2 getgroups32</span>
GETGROUPS(2)                                     Linux Programmer's Manual                                    GETGROUPS(2)

NAME
       getgroups, setgroups - get/set list of supplementary group IDs

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int getgroups(int size, gid_t list[]);

       #include <grp.h>

       int setgroups(size_t size, const gid_t *list);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       setgroups():
           Since glibc 2.19:
               _DEFAULT_SOURCE
           Glibc 2.19 and earlier:
               _BSD_SOURCE

DESCRIPTION
       getgroups() returns the supplementary group IDs of the calling process in list.  The argument size should be set to
       the maximum number of items that can be stored in the buffer pointed to by list.  If the calling process is a  mem‐
       ber  of  more than size supplementary groups, then an error results.  It is unspecified whether the effective group
       ID of the calling process is included in the returned list.  (Thus, an application should also call getegid(2)  and
       add or remove the resulting value.)

       If size is zero, list is not modified, but the total number of supplementary group IDs for the process is returned.
       This allows the caller to determine the size of a dynamically allocated list to be used in a further call  to  get‐
       groups().

       setgroups() sets the supplementary group IDs for the calling process.  Appropriate privileges are required (see the
       description of the EPERM error, below).  The size argument specifies the number of supplementary group IDs  in  the
       buffer pointed to by list.

RETURN VALUE
       On  success, getgroups() returns the number of supplementary group IDs.  On error, -1 is returned, and errno is set
       appropriately.

       On success, setgroups() returns 0.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT list has an invalid address.

       getgroups() can additionally fail with the following error:

       EINVAL size is less than the number of supplementary group IDs, but is not zero.

       setgroups() can additionally fail with the following errors:

       EINVAL size is greater than NGROUPS_MAX (32 before Linux 2.6.4; 65536 since Linux 2.6.4).

       ENOMEM Out of memory.

       EPERM  The calling process has insufficient privilege (the caller does not have the CAP_SETGID  capability  in  the
              user namespace in which it resides).

       EPERM (since Linux 3.19)
              The  use  of  setgroups() is denied in this user namespace.  See the description of /proc/[pid]/setgroups in
              user_namespaces(7).

CONFORMING TO
       getgroups(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       setgroups(): SVr4, 4.3BSD.  Since setgroups() requires privilege, it is not covered by POSIX.1.

NOTES
       A process can have up to NGROUPS_MAX supplementary group IDs in addition to the effective group ID.   The  constant
       NGROUPS_MAX is defined in <limits.h>.  The set of supplementary group IDs is inherited from the parent process, and
       preserved across an execve(2).

       The maximum number of supplementary group IDs can be found at run time using sysconf(3):

           long ngroups_max;
           ngroups_max = sysconf(_SC_NGROUPS_MAX);

       The maximum return value of getgroups() cannot be larger than one more than this value.   Since  Linux  2.6.4,  the
       maximum  number  of  supplementary  group IDs is also exposed via the Linux-specific read-only file, /proc/sys/ker‐
       nel/ngroups_max.

       The original Linux getgroups() system call supported only 16-bit group IDs.  Subsequently,  Linux  2.4  added  get‐
       groups32(),  supporting  32-bit IDs.  The glibc getgroups() wrapper function transparently deals with the variation
       across kernel versions.

   C library/kernel differences
       At the kernel level, user IDs and group IDs are a per-thread attribute.  However, POSIX requires that  all  threads
       in  a process share the same credentials.  The NPTL threading implementation handles the POSIX requirements by pro‐
       viding wrapper functions for the various system calls that change process UIDs and GIDs.  These  wrapper  functions
       (including  the one for setgroups()) employ a signal-based technique to ensure that when one thread changes creden‐
       tials, all of the other threads in the process also change their credentials.  For details, see nptl(7).

SEE ALSO
       getgid(2), setgid(2), getgrouplist(3), group_member(3), initgroups(3), capabilities(7), credentials(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            GETGROUPS(2)
</pre>
<pre zoom>
<span xsmall>2 outsb</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 migrate_pages</span>
MIGRATE_PAGES(2)                                 Linux Programmer's Manual                                MIGRATE_PAGES(2)

NAME
       migrate_pages - move all pages in a process to another set of nodes

SYNOPSIS
       #include <numaif.h>

       long migrate_pages(int pid, unsigned long maxnode,
                          const unsigned long *old_nodes,
                          const unsigned long *new_nodes);

       Link with -lnuma.

DESCRIPTION
       migrate_pages()  attempts  to  move  all  pages of the process pid that are in memory nodes old_nodes to the memory
       nodes in new_nodes.  Pages not located in any node in old_nodes will not be migrated.  As far as possible, the ker‐
       nel maintains the relative topology relationship inside old_nodes during the migration to new_nodes.

       The  old_nodes  and  new_nodes arguments are pointers to bit masks of node numbers, with up to maxnode bits in each
       mask.  These masks are maintained as arrays of unsigned long integers (in the last long integer,  the  bits  beyond
       those  specified by maxnode are ignored).  The maxnode argument is the maximum node number in the bit mask plus one
       (this is the same as in mbind(2), but different from select(2)).

       The pid argument is the ID of the process whose pages are to be moved.  To move pages in another process, the call‐
       er must be privileged (CAP_SYS_NICE) or the real or effective user ID of the calling process must match the real or
       saved-set user ID of the target process.  If pid is 0, then migrate_pages() moves pages of the calling process.

       Pages shared with another process will be moved only if the initiating process has the CAP_SYS_NICE privilege.

RETURN VALUE
       On success migrate_pages() returns the number of pages that could not be moved (i.e., a return of zero  means  that
       all pages were successfully moved).  On error, it returns -1, and sets errno to indicate the error.

ERRORS
       EFAULT Part  or all of the memory range specified by old_nodes/new_nodes and maxnode points outside your accessible
              address space.

       EINVAL The value specified by maxnode exceeds a kernel-imposed limit.  Or, old_nodes or new_nodes specifies one  or
              more  node  IDs  that are greater than the maximum supported node ID.  Or, none of the node IDs specified by
              new_nodes are on-line and allowed by the process's current cpuset context, or none of  the  specified  nodes
              contain memory.

       EPERM  Insufficient  privilege (CAP_SYS_NICE) to move pages of the process specified by pid, or insufficient privi‐
              lege (CAP_SYS_NICE) to access the specified target nodes.

       ESRCH  No process matching pid could be found.

VERSIONS
       The migrate_pages() system call first appeared on Linux in version 2.6.16.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       For information on library support, see numa(7).

       Use get_mempolicy(2) with the MPOL_F_MEMS_ALLOWED flag to obtain the set of nodes that are allowed by  the  calling
       process's  cpuset.  Note that this information is subject to change at any time by manual or automatic reconfigura‐
       tion of the cpuset.

       Use of migrate_pages() may result in pages whose location (node) violates the memory  policy  established  for  the
       specified  addresses  (see  mbind(2))  and/or the specified process (see set_mempolicy(2)).  That is, memory policy
       does not constrain the destination nodes used by migrate_pages().

       The <numaif.h> header is not included with glibc, but requires installing libnuma-devel or a similar package.

SEE ALSO
       get_mempolicy(2), mbind(2), set_mempolicy(2), numa(3), numa_maps(5), cpuset(7),  numa(7),  migratepages(8),  numas‐
       tat(8)

       Documentation/vm/page_migration in the Linux kernel source tree

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        MIGRATE_PAGES(2)
</pre>
<pre zoom>
<span xsmall>2 execve</span>
EXECVE(2)                                        Linux Programmer's Manual                                       EXECVE(2)

NAME
       execve - execute program

SYNOPSIS
       #include <unistd.h>

       int execve(const char *filename, char *const argv[],
                  char *const envp[]);

DESCRIPTION
       execve()  executes  the program pointed to by filename.  This causes the program that is currently being run by the
       calling process to be replaced with a new program, with newly initialized stack, heap, and (initialized and  unini‐
       tialized) data segments.

       filename must be either a binary executable, or a script starting with a line of the form:

           #! interpreter [optional-arg]

       For details of the latter case, see "Interpreter scripts" below.

       argv  is  an array of argument strings passed to the new program.  By convention, the first of these strings (i.e.,
       argv[0]) should contain the filename associated with the file being executed.  envp is an array of strings, conven‐
       tionally  of the form key=value, which are passed as environment to the new program.  The argv and envp arrays must
       each include a null pointer at the end of the array.

       The argument vector and environment can be accessed by the called program's main function, when it is defined as:

           int main(int argc, char *argv[], char *envp[])

       Note, however, that the use of a third argument to the main function is not  specified  in  POSIX.1;  according  to
       POSIX.1, the environment should be accessed via the external variable environ(7).

       execve()  does  not  return  on success, and the text, initialized data, uninitialized data (bss), and stack of the
       calling process are overwritten according to the contents of the newly loaded program.

       If the current program is being ptraced, a SIGTRAP signal is sent to it after a successful execve().

       If the set-user-ID bit is set on the program file pointed to by filename, then the effective user ID of the calling
       process  is  changed to that of the owner of the program file.  Similarly, when the set-group-ID bit of the program
       file is set the effective group ID of the calling process is set to the group of the program file.

       The aforementioned transformations of the effective IDs are not performed (i.e., the set-user-ID  and  set-group-ID
       bits are ignored) if any of the following is true:

       *  the no_new_privs attribute is set for the calling thread (see prctl(2));

       *  the underlying filesystem is mounted nosuid (the MS_NOSUID flag for mount(2)); or

       *  the calling process is being ptraced.

       The capabilities of the program file (see capabilities(7)) are also ignored if any of the above are true.

       The  effective  user  ID  of  the  process is copied to the saved set-user-ID; similarly, the effective group ID is
       copied to the saved set-group-ID.  This copying takes place after any effective ID changes that  occur  because  of
       the set-user-ID and set-group-ID mode bits.

       The process's real UID and real GID, as well its supplementary group IDs, are unchanged by a call to execve().

       If  the  executable  is  an  a.out  dynamically linked binary executable containing shared-library stubs, the Linux
       dynamic linker ld.so(8) is called at the start of execution to bring needed shared objects into memory and link the
       executable with them.

       If the executable is a dynamically linked ELF executable, the interpreter named in the PT_INTERP segment is used to
       load the needed shared objects.  This interpreter is typically /lib/ld-linux.so.2 for binaries  linked  with  glibc
       (see ld-linux.so(8)).

       All process attributes are preserved during an execve(), except the following:

       *  The dispositions of any signals that are being caught are reset to the default (signal(7)).

       *  Any alternate signal stack is not preserved (sigaltstack(2)).

       *  Memory mappings are not preserved (mmap(2)).

       *  Attached System V shared memory segments are detached (shmat(2)).

       *  POSIX shared memory regions are unmapped (shm_open(3)).

       *  Open POSIX message queue descriptors are closed (mq_overview(7)).

       *  Any open POSIX named semaphores are closed (sem_overview(7)).

       *  POSIX timers are not preserved (timer_create(2)).

       *  Any open directory streams are closed (opendir(3)).

       *  Memory locks are not preserved (mlock(2), mlockall(2)).

       *  Exit handlers are not preserved (atexit(3), on_exit(3)).

       *  The floating-point environment is reset to the default (see fenv(3)).

       The  process  attributes  in the preceding list are all specified in POSIX.1.  The following Linux-specific process
       attributes are also not preserved during an execve():

       *  The prctl(2) PR_SET_DUMPABLE flag is set, unless a set-user-ID or set-group ID program  is  being  executed,  in
          which case it is cleared.

       *  The prctl(2) PR_SET_KEEPCAPS flag is cleared.

       *  (Since  Linux 2.4.36 / 2.6.23) If a set-user-ID or set-group-ID program is being executed, then the parent death
          signal set by prctl(2) PR_SET_PDEATHSIG flag is cleared.

       *  The process name, as set by prctl(2) PR_SET_NAME (and displayed by ps -o comm), is reset to the name of the  new
          executable file.

       *  The SECBIT_KEEP_CAPS securebits flag is cleared.  See capabilities(7).

       *  The termination signal is reset to SIGCHLD (see clone(2)).

       *  The file descriptor table is unshared, undoing the effect of the CLONE_FILES flag of clone(2).

       Note the following further points:

       *  All  threads  other than the calling thread are destroyed during an execve().  Mutexes, condition variables, and
          other pthreads objects are not preserved.

       *  The equivalent of setlocale(LC_ALL, "C") is executed at program start-up.

       *  POSIX.1 specifies that the dispositions of any signals  that  are  ignored  or  set  to  the  default  are  left
          unchanged.   POSIX.1  specifies one exception: if SIGCHLD is being ignored, then an implementation may leave the
          disposition unchanged or reset it to the default; Linux does the former.

       *  Any outstanding asynchronous I/O operations are canceled (aio_read(3), aio_write(3)).

       *  For the handling of capabilities during execve(), see capabilities(7).

       *  By default, file descriptors remain open across an execve().  File descriptors that are marked close-on-exec are
          closed;  see  the  description  of FD_CLOEXEC in fcntl(2).  (If a file descriptor is closed, this will cause the
          release of all record locks obtained on the underlying  file  by  this  process.   See  fcntl(2)  for  details.)
          POSIX.1 says that if file descriptors 0, 1, and 2 would otherwise be closed after a successful execve(), and the
          process would gain privilege because the set-user-ID or set-group_ID mode bit was set on the executed file, then
          the system may open an unspecified file for each of these file descriptors.  As a general principle, no portable
          program, whether privileged or not, can assume that these three file descriptors will remain  closed  across  an
          execve().

   Interpreter scripts
       An interpreter script is a text file that has execute permission enabled and whose first line is of the form:

           #! interpreter [optional-arg]

       The interpreter must be a valid pathname for an executable file.  If the filename argument of execve() specifies an
       interpreter script, then interpreter will be invoked with the following arguments:

           interpreter [optional-arg] filename arg...

       where arg...  is the series of words pointed to by the argv argument of execve(), starting at argv[1].

       For portable use, optional-arg should either be absent, or be specified as a single word (i.e., it should not  con‐
       tain white space); see NOTES below.

       Since  Linux  2.6.28,  the  kernel  permits  the interpreter of a script to itself be a script.  This permission is
       recursive, up to a limit of four recursions, so that the interpreter may be a script  which  is  interpreted  by  a
       script, and so on.

   Limits on size of arguments and environment
       Most  UNIX  implementations impose some limit on the total size of the command-line argument (argv) and environment
       (envp) strings that may be passed to a new program.  POSIX.1 allows an implementation to advertise this limit using
       the ARG_MAX constant (either defined in <limits.h> or available at run time using the call sysconf(_SC_ARG_MAX)).

       On  Linux  prior  to kernel 2.6.23, the memory used to store the environment and argument strings was limited to 32
       pages (defined by the kernel constant MAX_ARG_PAGES).  On architectures with a 4-kB page size, this yields a  maxi‐
       mum size of 128 kB.

       On  kernel  2.6.23  and  later, most architectures support a size limit derived from the soft RLIMIT_STACK resource
       limit (see getrlimit(2)) that is in force at the time of the execve() call.  (Architectures with no memory  manage‐
       ment  unit are excepted: they maintain the limit that was in effect before kernel 2.6.23.)  This change allows pro‐
       grams to have a much larger argument and/or environment list.  For these architectures, the total size  is  limited
       to  1/4  of  the  allowed  stack  size.  (Imposing the 1/4-limit ensures that the new program always has some stack
       space.)  Since Linux 2.6.25, the kernel places a floor of  32  pages  on  this  size  limit,  so  that,  even  when
       RLIMIT_STACK  is  set very low, applications are guaranteed to have at least as much argument and environment space
       as was provided by Linux 2.6.23 and earlier.  (This guarantee was not provided in Linux 2.6.23 and 2.6.24.)   Addi‐
       tionally,  the limit per string is 32 pages (the kernel constant MAX_ARG_STRLEN), and the maximum number of strings
       is 0x7FFFFFFF.

RETURN VALUE
       On success, execve() does not return, on error -1 is returned, and errno is set appropriately.

ERRORS
       E2BIG  The total number of bytes in the environment (envp) and argument list (argv) is too large.

       EACCES Search permission is denied on a component of the path prefix of filename or the name  of  a  script  inter‐
              preter.  (See also path_resolution(7).)

       EACCES The file or a script interpreter is not a regular file.

       EACCES Execute permission is denied for the file or a script or ELF interpreter.

       EACCES The filesystem is mounted noexec.

       EAGAIN (since Linux 3.1)
              Having  changed  its  real  UID  using one of the set*uid() calls, the caller was—and is now still—above its
              RLIMIT_NPROC resource limit (see setrlimit(2)).  For a more detailed explanation of this error, see NOTES.

       EFAULT filename or one of the pointers in the vectors argv or envp points outside your accessible address space.

       EINVAL An ELF executable had more than one PT_INTERP segment (i.e., tried to name more than one interpreter).

       EIO    An I/O error occurred.

       EISDIR An ELF interpreter was a directory.

       ELIBBAD
              An ELF interpreter was not in a recognized format.

       ELOOP  Too many symbolic links were encountered in resolving filename or the name of a script or ELF interpreter.

       ELOOP  The maximum recursion limit was reached during recursive script interpretation (see  "Interpreter  scripts",
              above).  Before Linux 3.8, the error produced for this case was ENOEXEC.

       EMFILE The per-process limit on the number of open file descriptors has been reached.

       ENAMETOOLONG
              filename is too long.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENOENT The  file filename or a script or ELF interpreter does not exist, or a shared library needed for the file or
              interpreter cannot be found.

       ENOEXEC
              An executable is not in a recognized format, is for the wrong architecture, or has some other  format  error
              that means it cannot be executed.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of the path prefix of filename or a script or ELF interpreter is not a directory.

       EPERM  The  filesystem  is  mounted nosuid, the user is not the superuser, and the file has the set-user-ID or set-
              group-ID bit set.

       EPERM  The process is being traced, the user is not the superuser and the file has the set-user-ID or  set-group-ID
              bit set.

       EPERM  A "capability-dumb" applications would not obtain the full set of permitted capabilities granted by the exe‐
              cutable file.  See capabilities(7).

       ETXTBSY
              The specified executable was open for writing by one or more processes.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX does not document the #! behavior, but it exists (with some varia‐
       tions) on other UNIX systems.

NOTES
       One sometimes sees execve() (and the related functions described in exec(3)) described as "executing a new process"
       (or similar).  This is a highly misleading description: there is no new process; many  attributes  of  the  calling
       process remain unchanged (in particular, its PID).  All that execve(2) does is arrange for an existing process (the
       calling process) to execute a new program.

       Set-user-ID and set-group-ID processes can not be ptrace(2)d.

       The result of mounting a filesystem nosuid varies across Linux kernel versions: some will refuse execution of  set-
       user-ID  and  set-group-ID  executables  when  this would give the user powers she did not have already (and return
       EPERM), some will just ignore the set-user-ID and set-group-ID bits and exec() successfully.

       On Linux, argv and envp can be specified as NULL.  In both cases, this has the same effect as specifying the  argu‐
       ment  as  a pointer to a list containing a single null pointer.  Do not take advantage of this nonstandard and non‐
       portable misfeature!  On many other UNIX systems, specifying argv as NULL will result in an error  (EFAULT).   Some
       other UNIX systems treat the envp==NULL case the same as Linux.

       POSIX.1 says that values returned by sysconf(3) should be invariant over the lifetime of a process.  However, since
       Linux 2.6.23, if the RLIMIT_STACK resource limit changes, then the value reported by _SC_ARG_MAX will also  change,
       to  reflect  the  fact  that  the  limit  on space for holding command-line arguments and environment variables has
       changed.

       In most cases where execve() fails, control returns to the original executable image, and the  caller  of  execve()
       can  then  handle the error.  However, in (rare) cases (typically caused by resource exhaustion), failure may occur
       past the point of no return: the original executable image has been torn down, but the new image could not be  com‐
       pletely built.  In such cases, the kernel kills the process with a SIGKILL signal.

   Interpreter scripts
       A maximum line length of 127 characters is allowed for the first line in an interpreter script.

       The  semantics  of  the  optional-arg argument of an interpreter script vary across implementations.  On Linux, the
       entire string following the interpreter name is passed as a single argument to the interpreter, and this string can
       include  white  space.  However, behavior differs on some other systems.  Some systems use the first white space to
       terminate optional-arg.  On some systems, an interpreter script can have multiple arguments, and  white  spaces  in
       optional-arg are used to delimit the arguments.

       Linux ignores the set-user-ID and set-group-ID bits on scripts.

   execve() and EAGAIN
       A  more  detailed explanation of the EAGAIN error that can occur (since Linux 3.1) when calling execve() is as fol‐
       lows.

       The EAGAIN error can occur when a preceding call to setuid(2), setreuid(2), or setresuid(2) caused the real user ID
       of  the  process to change, and that change caused the process to exceed its RLIMIT_NPROC resource limit (i.e., the
       number of processes belonging to the new real UID exceeds the resource limit).   From  Linux  2.6.0  to  3.0,  this
       caused  the  set*uid()  call  to fail.  (Prior to 2.6, the resource limit was not imposed on processes that changed
       their user IDs.)

       Since Linux 3.1, the scenario just described no longer causes the set*uid() call to fail, because it too often  led
       to  security  holes where buggy applications didn't check the return status and assumed that—if the caller had root
       privileges—the call would always succeed.  Instead, the set*uid() calls now successfully change the real  UID,  but
       the  kernel  sets  an internal flag, named PF_NPROC_EXCEEDED, to note that the RLIMIT_NPROC resource limit has been
       exceeded.  If the PF_NPROC_EXCEEDED flag is set and the resource limit is still exceeded at the time  of  a  subse‐
       quent  execve()  call,  that  call  fails  with  the error EAGAIN.  This kernel logic ensures that the RLIMIT_NPROC
       resource limit is still enforced for the common privileged daemon workflow—namely, fork(2) + set*uid() + execve().

       If the resource limit was not still exceeded at the time of the execve() call (because other processes belonging to
       this real UID terminated between the set*uid() call and the execve() call), then the execve() call succeeds and the
       kernel clears the PF_NPROC_EXCEEDED process flag.  The flag is also cleared if a subsequent call to fork(2) by this
       process succeeds.

   Historical
       With  UNIX V6, the argument list of an exec() call was ended by 0, while the argument list of main was ended by -1.
       Thus, this argument list was not directly usable in a further exec() call.  Since UNIX V7, both are NULL.

EXAMPLE
       The following program is designed to be execed by the second program below.  It just echoes its command-line  argu‐
       ments, one per line.

           /* myecho.c */

           #include <stdio.h>
           #include <stdlib.h>

           int
           main(int argc, char *argv[])
           {
               int j;

               for (j = 0; j < argc; j++)
                   printf("argv[%d]: %s\n", j, argv[j]);

               exit(EXIT_SUCCESS);
           }

       This program can be used to exec the program named in its command-line argument:

           /* execve.c */

           #include <stdio.h>
           #include <stdlib.h>
           #include <unistd.h>

           int
           main(int argc, char *argv[])
           {
               char *newargv[] = { NULL, "hello", "world", NULL };
               char *newenviron[] = { NULL };

               if (argc != 2) {
                   fprintf(stderr, "Usage: %s <file-to-exec>\n", argv[0]);
                   exit(EXIT_FAILURE);
               }

               newargv[0] = argv[1];

               execve(argv[1], newargv, newenviron);
               perror("execve");   /* execve() returns only on error */
               exit(EXIT_FAILURE);
           }

       We can use the second program to exec the first as follows:

           $ cc myecho.c -o myecho
           $ cc execve.c -o execve
           $ ./execve ./myecho
           argv[0]: ./myecho
           argv[1]: hello
           argv[2]: world

       We can also use these programs to demonstrate the use of a script interpreter.  To do this we create a script whose
       "interpreter" is our myecho program:

           $ cat > script
           #!./myecho script-arg
           ^D
           $ chmod +x script

       We can then use our program to exec the script:

           $ ./execve ./script
           argv[0]: ./myecho
           argv[1]: script-arg
           argv[2]: ./script
           argv[3]: hello
           argv[4]: world

SEE ALSO
       chmod(2), execveat(2), fork(2), get_robust_list(2), ptrace(2), execl(3), fexecve(3), getopt(3), system(3),  creden‐
       tials(7), environ(7), path_resolution(7), ld.so(8)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                               EXECVE(2)
</pre>
<pre zoom>
<span xsmall>2 connect</span>
CONNECT(2)                                       Linux Programmer's Manual                                      CONNECT(2)

NAME
       connect - initiate a connection on a socket

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>

       int connect(int sockfd, const struct sockaddr *addr,
                   socklen_t addrlen);

DESCRIPTION
       The connect() system call connects the socket referred to by the file descriptor sockfd to the address specified by
       addr.  The addrlen argument specifies the size of addr.  The format of the address in addr  is  determined  by  the
       address space of the socket sockfd; see socket(2) for further details.

       If  the  socket  sockfd is of type SOCK_DGRAM, then addr is the address to which datagrams are sent by default, and
       the only address from which datagrams are received.  If the socket is of type SOCK_STREAM or  SOCK_SEQPACKET,  this
       call attempts to make a connection to the socket that is bound to the address specified by addr.

       Generally,  connection-based protocol sockets may successfully connect() only once; connectionless protocol sockets
       may use connect() multiple times to change their association.  Connectionless sockets may dissolve the  association
       by connecting to an address with the sa_family member of sockaddr set to AF_UNSPEC (supported on Linux since kernel
       2.2).

RETURN VALUE
       If the connection or binding succeeds, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       The following are general socket errors only.  There may be other domain-specific error codes.

       EACCES For UNIX domain sockets, which are identified by pathname: Write permission is denied on the socket file, or
              search permission is denied for one of the directories in the path prefix.  (See also path_resolution(7).)

       EACCES, EPERM
              The  user  tried  to  connect to a broadcast address without having the socket broadcast flag enabled or the
              connection request failed because of a local firewall rule.

       EADDRINUSE
              Local address is already in use.

       EADDRNOTAVAIL
              (Internet domain sockets) The socket referred to by sockfd had not previously been bound to an address  and,
              upon  attempting  to  bind it to an ephemeral port, it was determined that all port numbers in the ephemeral
              port range are currently in use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).

       EAFNOSUPPORT
              The passed address didn't have the correct address family in its sa_family field.

       EAGAIN Insufficient entries in the routing cache.

       EALREADY
              The socket is nonblocking and a previous connection attempt has not yet been completed.

       EBADF  sockfd is not a valid open file descriptor.

       ECONNREFUSED
              A connect() on a stream socket found no one listening on the remote address.

       EFAULT The socket structure address is outside the user's address space.

       EINPROGRESS
              The socket is nonblocking and the connection cannot be completed immediately.  It is possible  to  select(2)
              or  poll(2)  for completion by selecting the socket for writing.  After select(2) indicates writability, use
              getsockopt(2) to read the SO_ERROR option at level SOL_SOCKET to determine whether connect() completed  suc‐
              cessfully  (SO_ERROR  is  zero)  or  unsuccessfully  (SO_ERROR  is one of the usual error codes listed here,
              explaining the reason for the failure).

       EINTR  The system call was interrupted by a signal that was caught; see signal(7).

       EISCONN
              The socket is already connected.

       ENETUNREACH
              Network is unreachable.

       ENOTSOCK
              The file descriptor sockfd does not refer to a socket.

       EPROTOTYPE
              The socket type does not support the requested communications protocol.  This error can occur, for  example,
              on an attempt to connect a UNIX domain datagram socket to a stream socket.

       ETIMEDOUT
              Timeout  while  attempting connection.  The server may be too busy to accept new connections.  Note that for
              IP sockets the timeout may be very long when syncookies are enabled on the server.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD, (connect() first appeared in 4.2BSD).

NOTES
       POSIX.1 does not require the inclusion of <sys/types.h>, and this header file is not required on  Linux.   However,
       some  historical  (BSD)  implementations  required this header file, and portable applications are probably wise to
       include it.

       For background on the socklen_t type, see accept(2).

       If connect() fails, consider the state of the socket as unspecified.  Portable applications should close the socket
       and create a new one for reconnecting.

EXAMPLE
       An example of the use of connect() is shown in getaddrinfo(3).

SEE ALSO
       accept(2), bind(2), getsockname(2), listen(2), socket(2), path_resolution(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              CONNECT(2)
</pre>
<pre zoom>
<span xsmall>2 mremap</span>
MREMAP(2)                                        Linux Programmer's Manual                                       MREMAP(2)

NAME
       mremap - remap a virtual memory address

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <sys/mman.h>

       void *mremap(void *old_address, size_t old_size,
                    size_t new_size, int flags, ... /* void *new_address */);

DESCRIPTION
       mremap() expands (or shrinks) an existing memory mapping, potentially moving it at the same time (controlled by the
       flags argument and the available virtual address space).

       old_address is the old address of the virtual memory block  that  you  want  to  expand  (or  shrink).   Note  that
       old_address  has  to  be  page  aligned.   old_size  is  the old size of the virtual memory block.  new_size is the
       requested size of the virtual memory block after the resize.  An optional fifth argument, new_address, may be  pro‐
       vided; see the description of MREMAP_FIXED below.

       If  the  value  of  old_size  is zero, and old_address refers to a shareable mapping (see mmap(2) MAP_SHARED), then
       mremap() will create a new mapping of the same pages.  new_size will be the size of the new mapping and  the  loca‐
       tion  of  the  new  mapping may be specified with new_address; see the description of MREMAP_FIXED below.  If a new
       mapping is requested via this method, then the MREMAP_MAYMOVE flag must also be specified.

       In Linux the memory is divided into pages.  A user process has (one or) several  linear  virtual  memory  segments.
       Each virtual memory segment has one or more mappings to real memory pages (in the page table).  Each virtual memory
       segment has its own protection (access rights), which may cause a segmentation violation if the memory is  accessed
       incorrectly  (e.g.,  writing  to  a read-only segment).  Accessing virtual memory outside of the segments will also
       cause a segmentation violation.

       mremap() uses the Linux page table scheme.  mremap() changes the  mapping  between  virtual  addresses  and  memory
       pages.  This can be used to implement a very efficient realloc(3).

       The flags bit-mask argument may be 0, or include the following flag:

       MREMAP_MAYMOVE
              By  default,  if  there  is  not sufficient space to expand a mapping at its current location, then mremap()
              fails.  If this flag is specified, then the kernel is permitted to relocate the mapping  to  a  new  virtual
              address,  if  necessary.   If the mapping is relocated, then absolute pointers into the old mapping location
              become invalid (offsets relative to the starting address of the mapping should be employed).

       MREMAP_FIXED (since Linux 2.3.31)
              This flag serves a similar purpose to the MAP_FIXED flag of  mmap(2).   If  this  flag  is  specified,  then
              mremap()  accepts  a  fifth argument, void *new_address, which specifies a page-aligned address to which the
              mapping must be moved.  Any previous mapping at the address range specified by new_address and  new_size  is
              unmapped.  If MREMAP_FIXED is specified, then MREMAP_MAYMOVE must also be specified.

       If  the  memory segment specified by old_address and old_size is locked (using mlock(2) or similar), then this lock
       is maintained when the segment is resized and/or relocated.  As a consequence, the amount of memory locked  by  the
       process may change.

RETURN VALUE
       On  success  mremap()  returns  a pointer to the new virtual memory area.  On error, the value MAP_FAILED (that is,
       (void *) -1) is returned, and errno is set appropriately.

ERRORS
       EAGAIN The caller tried to expand a memory segment that is locked, but this was not possible without exceeding  the
              RLIMIT_MEMLOCK resource limit.

       EFAULT "Segmentation  fault."  Some  address in the range old_address to old_address+old_size is an invalid virtual
              memory address for this process.  You can also get EFAULT even if there exist mappings that cover the  whole
              address space requested, but those mappings are of different types.

       EINVAL An invalid argument was given.  Possible causes are:

              *  old_address was not page aligned;

              *  a value other than MREMAP_MAYMOVE or MREMAP_FIXED was specified in flags;

              *  new_size was zero;

              *  new_size or new_address was invalid;

              *  the new address range specified by new_address and new_size overlapped the old address range specified by
                 old_address and old_size;

              *  MREMAP_FIXED was specified without also specifying MREMAP_MAYMOVE;

              *  old_size was zero and old_address does not refer to a shareable mapping (but see BUGS);

              *  old_size was zero and the MREMAP_MAYMOVE flag was not specified.

       ENOMEM The memory area cannot be expanded at the current virtual address, and the MREMAP_MAYMOVE flag is not set in
              flags.  Or, there is not enough (virtual) memory available.

CONFORMING TO
       This call is Linux-specific, and should not be used in programs intended to be portable.

NOTES
       Prior  to  version 2.4, glibc did not expose the definition of MREMAP_FIXED, and the prototype for mremap() did not
       allow for the new_address argument.

       If mremap() is used to move or expand an area locked with mlock(2) or equivalent, the mremap()  call  will  make  a
       best effort to populate the new area but will not fail with ENOMEM if the area cannot be populated.

BUGS
       Before  Linux  4.14, if old_size was zero and the mapping referred to by old_address was a private mapping (mmap(2)
       MAP_PRIVATE), mremap() created a new private mapping unrelated to the original mapping.  This  behavior  was  unin‐
       tended  and probably unexpected in user-space applications (since the intention of mremap() is to create a new map‐
       ping based on the original mapping).  Since Linux 4.14, mremap() fails with the error EINVAL in this scenario.

SEE ALSO
       brk(2), getpagesize(2), getrlimit(2), mlock(2), mmap(2), sbrk(2), malloc(3), realloc(3)

       Your favorite text book on operating systems for more information on paged memory (e.g., Modern  Operating  Systems
       by  Andrew  S.  Tanenbaum,  Inside  Linux by Randolf Bentson, The Design of the UNIX Operating System by Maurice J.
       Bach)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-25                                               MREMAP(2)
</pre>
<pre zoom>
<span xsmall>2 bdflush</span>
BDFLUSH(2)                                       Linux Programmer's Manual                                      BDFLUSH(2)

NAME
       bdflush - start, flush, or tune buffer-dirty-flush daemon

SYNOPSIS
       #include <sys/kdaemon.h>

       int bdflush(int func, long *address);
       int bdflush(int func, long data);

DESCRIPTION
       Note:  Since Linux 2.6, this system call is deprecated and does nothing.  It is likely to disappear altogether in a
       future kernel release.  Nowadays, the task performed by bdflush() is handled by the kernel pdflush thread.

       bdflush() starts, flushes, or tunes the buffer-dirty-flush  daemon.   Only  a  privileged  process  (one  with  the
       CAP_SYS_ADMIN capability) may call bdflush().

       If func is negative or 0, and no daemon has been started, then bdflush() enters the daemon code and never returns.

       If func is 1, some dirty buffers are written to disk.

       If func is 2 or more and is even (low bit is 0), then address is the address of a long word, and the tuning parame‐
       ter numbered (func-2)/2 is returned to the caller in that address.

       If func is 3 or more and is odd (low bit is 1), then data is a long word, and the kernel sets tuning parameter num‐
       bered (func-3)/2 to that value.

       The  set  of  parameters,  their values, and their valid ranges are defined in the Linux kernel source file fs/buf‐
       fer.c.

RETURN VALUE
       If func is negative or 0 and the daemon successfully starts, bdflush() never returns.  Otherwise, the return  value
       is 0 on success and -1 on failure, with errno set to indicate the error.

ERRORS
       EBUSY  An attempt was made to enter the daemon code after another process has already entered.

       EFAULT address points outside your accessible address space.

       EINVAL An  attempt was made to read or write an invalid parameter number, or to write an invalid value to a parame‐
              ter.

       EPERM  Caller does not have the CAP_SYS_ADMIN capability.

VERSIONS
       Since version 2.23, glibc no longer supports this obsolete system call.

CONFORMING TO
       bdflush() is Linux-specific and should not be used in programs intended to be portable.

SEE ALSO
       sync(1), fsync(2), sync(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2016-10-08                                              BDFLUSH(2)
</pre>
<pre zoom>
<span xsmall>2 sigreturn</span>
SIGRETURN(2)                                     Linux Programmer's Manual                                    SIGRETURN(2)

NAME
       sigreturn, rt_sigreturn - return from signal handler and cleanup stack frame

SYNOPSIS
       int sigreturn(...);

DESCRIPTION
       If the Linux kernel determines that an unblocked signal is pending for a process, then, at the next transition back
       to user mode in that process (e.g., upon return from a system call or when the  process  is  rescheduled  onto  the
       CPU),  it  creates  a new frame on the user-space stack where it saves various pieces of process context (processor
       status word, registers, signal mask, and signal stack settings).

       The kernel also arranges that, during the transition back to user mode, the signal handler  is  called,  and  that,
       upon return from the handler, control passes to a piece of user-space code commonly called the "signal trampoline".
       The signal trampoline code in turn calls sigreturn().

       This sigreturn() call undoes everything that was done—changing the process's signal mask, switching  signal  stacks
       (see  sigaltstack(2))—in  order  to invoke the signal handler.  Using the information that was earlier saved on the
       user-space stack sigreturn() restores the process's signal mask, switches stacks, and restores the  process's  con‐
       text  (processor  flags  and  registers,  including the stack pointer and instruction pointer), so that the process
       resumes execution at the point where it was interrupted by the signal.

RETURN VALUE
       sigreturn() never returns.

CONFORMING TO
       Many UNIX-type systems have a sigreturn() system call or near equivalent.  However, this call is not  specified  in
       POSIX, and details of its behavior vary across systems.

NOTES
       sigreturn()  exists  only  to  allow  the  implementation  of signal handlers.  It should never be called directly.
       (Indeed, a simple sigreturn() wrapper in the GNU C library simply returns -1, with errno set to  ENOSYS.)   Details
       of  the  arguments (if any) passed to sigreturn() vary depending on the architecture.  (On some architectures, such
       as x86-64, sigreturn() takes no arguments, since all of the information that it requires is available in the  stack
       frame that was previously created by the kernel on the user-space stack.)

       Once  upon a time, UNIX systems placed the signal trampoline code onto the user stack.  Nowadays, pages of the user
       stack are protected so as to disallow code execution.  Thus, on contemporary Linux systems, depending on the archi‐
       tecture,  the  signal  trampoline  code lives either in the vdso(7) or in the C library.  In the latter case, the C
       library's sigaction(2) wrapper function informs the kernel of the location of the trampoline code  by  placing  its
       address in the sa_restorer field of the sigaction structure, and sets the SA_RESTORER flag in the sa_flags field.

       The  saved  process context information is placed in a ucontext_t structure (see <sys/ucontext.h>).  That structure
       is visible within the signal handler as the third argument of a  handler  established  via  sigaction(2)  with  the
       SA_SIGINFO flag.

       On  some  other UNIX systems, the operation of the signal trampoline differs a little.  In particular, on some sys‐
       tems, upon transitioning back to user mode, the kernel passes control to the trampoline  (rather  than  the  signal
       handler), and the trampoline code calls the signal handler (and then calls sigreturn() once the handler returns).

   C library/kernel differences
       The  original  Linux  system  call was named sigreturn().  However, with the addition of real-time signals in Linux
       2.2, a new system call, rt_sigreturn() was added to support an enlarged sigset_t type.  The  GNU  C  library  hides
       these details from us, transparently employing rt_sigreturn() when the kernel provides it.

SEE ALSO
       kill(2), restart_syscall(2), sigaltstack(2), signal(2), getcontext(3), signal(7), vdso(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            SIGRETURN(2)
</pre>
<pre zoom>
<span xsmall>2 s390_runtime_instr</span>
S390_RUNTIME_INSTR(2)                               System Calls Manual                              S390_RUNTIME_INSTR(2)

NAME
       s390_runtime_instr - enable/disable s390 CPU run-time instrumentation

SYNOPSIS
       #include <asm/runtime_instr.h>

       int s390_runtime_instr(int command, int signum);

DESCRIPTION
       The s390_runtime_instr() system call starts or stops CPU run-time instrumentation for the calling thread.

       The  command argument controls whether run-time instrumentation is started (S390_RUNTIME_INSTR_START, 1) or stopped
       (S390_RUNTIME_INSTR_STOP, 2) for the calling thread.

       The signum argument specifies the number of a real-time signal.  The real-time signal is sent to the thread if  the
       run-time instrumentation buffer is full or if the run-time-instrumentation-halted interrupt occurred.

RETURN VALUE
       On  success,  s390_runtime_instr()  returns  0 and enables the thread for run-time instrumentation by assigning the
       thread a default run-time instrumentation control block.  The caller can then read and modify the control block and
       start  the  run-time  instrumentation.   On error, -1 is returned and errno is set to one of the error codes listed
       below.

ERRORS
       EINVAL The value specified in command is not a valid command or the value specified in signum is  not  a  real-time
              signal number.

       ENOMEM Allocating memory for the run-time instrumentation control block failed.

       EOPNOTSUPP
              The run-time instrumentation facility is not available.

VERSIONS
       This system call is available since Linux 3.7.

CONFORMING TO
       This  Linux-specific system call is available only on the s390 architecture.  The run-time instrumentation facility
       is available beginning with System z EC12.

NOTES
       Glibc does not provide a wrapper for this system call, use syscall(2) to call it.

SEE ALSO
       syscall(2), signal(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux Programmer's Manual                               2017-09-15                                   S390_RUNTIME_INSTR(2)
</pre>
<pre zoom>
<span xsmall>2 rt_sigprocmask</span>
SIGPROCMASK(2)                                   Linux Programmer's Manual                                  SIGPROCMASK(2)

NAME
       sigprocmask, rt_sigprocmask - examine and change blocked signals

SYNOPSIS
       #include <signal.h>

       /* Prototype for the glibc wrapper function */
       int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);

       /* Prototype for the underlying system call */
       int rt_sigprocmask(int how, const kernel_sigset_t *set,
                          kernel_sigset_t *oldset, size_t sigsetsize);

       /* Prototype for the legacy system call (deprecated) */
       int sigprocmask(int how, const old_kernel_sigset_t *set,
                       old_kernel_sigset_t *oldset);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       sigprocmask(): _POSIX_C_SOURCE

DESCRIPTION
       sigprocmask()  is used to fetch and/or change the signal mask of the calling thread.  The signal mask is the set of
       signals whose delivery is currently blocked for the caller (see also signal(7) for more details).

       The behavior of the call is dependent on the value of how, as follows.

       SIG_BLOCK
              The set of blocked signals is the union of the current set and the set argument.

       SIG_UNBLOCK
              The signals in set are removed from the current set of blocked signals.  It is  permissible  to  attempt  to
              unblock a signal which is not blocked.

       SIG_SETMASK
              The set of blocked signals is set to the argument set.

       If oldset is non-NULL, the previous value of the signal mask is stored in oldset.

       If  set is NULL, then the signal mask is unchanged (i.e., how is ignored), but the current value of the signal mask
       is nevertheless returned in oldset (if it is not NULL).

       A set of functions for modifying and inspecting variables of type sigset_t ("signal sets") is described  in  sigse‐
       tops(3).

       The use of sigprocmask() is unspecified in a multithreaded process; see pthread_sigmask(3).

RETURN VALUE
       sigprocmask() returns 0 on success and -1 on error.  In the event of an error, errno is set to indicate the cause.

ERRORS
       EFAULT The set or oldset argument points outside the process's allocated address space.

       EINVAL Either the value specified in how was invalid or the kernel does not support the size passed in sigsetsize.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       It is not possible to block SIGKILL or SIGSTOP.  Attempts to do so are silently ignored.

       Each of the threads in a process has its own signal mask.

       A  child  created  via  fork(2)  inherits  a  copy of its parent's signal mask; the signal mask is preserved across
       execve(2).

       If SIGBUS, SIGFPE, SIGILL, or SIGSEGV are generated while they are blocked, the result  is  undefined,  unless  the
       signal was generated by kill(2), sigqueue(3), or raise(3).

       See sigsetops(3) for details on manipulating signal sets.

       Note that it is permissible (although not very useful) to specify both set and oldset as NULL.

   C library/kernel differences
       The kernel's definition of sigset_t differs in size from that used by the C library.  In this manual page, the for‐
       mer is referred to as kernel_sigset_t (it is nevertheless named sigset_t in the kernel sources).

       The glibc wrapper function for sigprocmask() silently ignores attempts to block the two real-time signals that  are
       used internally by the NPTL threading implementation.  See nptl(7) for details.

       The  original  Linux system call was named sigprocmask().  However, with the addition of real-time signals in Linux
       2.2, the fixed-size, 32-bit sigset_t (referred to as old_kernel_sigset_t in this manual  page)  type  supported  by
       that  system  call  was no longer fit for purpose.  Consequently, a new system call, rt_sigprocmask(), was added to
       support an enlarged sigset_t type (referred to as kernel_sigset_t in this manual page).  The new system call  takes
       a fourth argument, size_t sigsetsize, which specifies the size in bytes of the signal sets in set and oldset.  This
       argument is currently required to have a fixed architecture specific value (equal to sizeof(kernel_sigset_t)).

       The glibc sigprocmask() wrapper function hides these details from us, transparently calling  rt_sigprocmask()  when
       the kernel provides it.

SEE ALSO
       kill(2),  pause(2),  sigaction(2), signal(2), sigpending(2), sigsuspend(2), pthread_sigmask(3), sigqueue(3), sigse‐
       tops(3), signal(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                          SIGPROCMASK(2)
</pre>
<pre zoom>
<span xsmall>2 pwrite64</span>
PREAD(2)                                         Linux Programmer's Manual                                        PREAD(2)

NAME
       pread, pwrite - read from or write to a file descriptor at a given offset

SYNOPSIS
       #include <unistd.h>

       ssize_t pread(int fd, void *buf, size_t count, off_t offset);

       ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pread(), pwrite():
           _XOPEN_SOURCE >= 500
           || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L

DESCRIPTION
       pread() reads up to count bytes from file descriptor fd at offset offset (from the start of the file) into the buf‐
       fer starting at buf.  The file offset is not changed.

       pwrite() writes up to count bytes from the buffer starting at buf to the file descriptor fd at offset offset.   The
       file offset is not changed.

       The file referenced by fd must be capable of seeking.

RETURN VALUE
       On  success, pread() returns the number of bytes read (a return of zero indicates end of file) and pwrite() returns
       the number of bytes written.

       Note that is not an error for a successful call to transfer fewer bytes than requested (see read(2) and write(2)).

       On error, -1 is returned and errno is set to indicate the cause of the error.

ERRORS
       pread() can fail and set errno to any error specified for read(2) or lseek(2).  pwrite() can fail and set errno  to
       any error specified for write(2) or lseek(2).

VERSIONS
       The  pread()  and  pwrite() system calls were added to Linux in version 2.1.60; the entries in the i386 system call
       table were added in 2.1.69.  C library support (including emulation using lseek(2) on  older  kernels  without  the
       system calls) was added in glibc 2.1.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       The  pread()  and  pwrite()  system calls are especially useful in multithreaded applications.  They allow multiple
       threads to perform I/O on the same file descriptor without being affected by changes to the file  offset  by  other
       threads.

   C library/kernel differences
       On  Linux,  the  underlying  system calls were renamed in kernel 2.6: pread() became pread64(), and pwrite() became
       pwrite64().  The system call numbers remained the same.  The glibc pread() and pwrite() wrapper functions transpar‐
       ently deal with the change.

       On  some  32-bit  architectures,  the calling signature for these system calls differ, for the reasons described in
       syscall(2).

BUGS
       POSIX requires that opening a file with the O_APPEND flag should have no effect on the location at  which  pwrite()
       writes  data.   However, on Linux, if a file is opened with O_APPEND, pwrite() appends data to the end of the file,
       regardless of the value of offset.

SEE ALSO
       lseek(2), read(2), readv(2), write(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                PREAD(2)
</pre>
<pre zoom>
<span xsmall>2 io_getevents</span>
IO_GETEVENTS(2)                                  Linux Programmer's Manual                                 IO_GETEVENTS(2)

NAME
       io_getevents - read asynchronous I/O events from the completion queue

SYNOPSIS
       #include <linux/aio_abi.h>         /* Defines needed types */
       #include <linux/time.h>            /* Defines 'struct timespec' */

       int io_getevents(aio_context_t ctx_id, long min_nr, long nr,
                        struct io_event *events, struct timespec *timeout);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       The  io_getevents()  system  call  attempts  to read at least min_nr events and up to nr events from the completion
       queue of the AIO context specified by ctx_id.

       The timeout argument specifies the amount of time to wait for events, and is specified as a relative timeout  in  a
       structure of the following form:

           struct timespec {
               time_t tv_sec;      /* seconds */
               long   tv_nsec;     /* nanoseconds [0 .. 999999999] */
           };

       The specified time will be rounded up to the system clock granularity and is guaranteed not to expire    early.

       Specifying timeout as NULL means block indefinitely until at least min_nr events have been obtained.

RETURN VALUE
       On  success,  io_getevents() returns the number of events read.  This may be 0, or a value less than min_nr, if the
       timeout expired.  It may also be a nonzero value less than min_nr, if the call was interrupted by a signal handler.

       For the failure return, see NOTES.

ERRORS
       EFAULT Either events or timeout is an invalid pointer.

       EINTR  Interrupted by a signal handler; see signal(7).

       EINVAL ctx_id is invalid.  min_nr is out of range or nr is out of range.

       ENOSYS io_getevents() is not implemented on this architecture.

VERSIONS
       The asynchronous I/O system calls first appeared in Linux 2.5.

CONFORMING TO
       io_getevents() is Linux-specific and should not be used in programs that are intended to be portable.

NOTES
       Glibc does not provide a wrapper function for this system  call.   You  could  invoke  it  using  syscall(2).   But
       instead, you probably want to use the io_getevents() wrapper function provided by libaio.

       Note that the libaio wrapper function uses a different type (io_context_t) for the ctx_id argument.  Note also that
       the libaio wrapper does not follow the usual C library conventions for indicating errors: on  error  it  returns  a
       negated  error  number  (the  negative  of  one of the values listed in ERRORS).  If the system call is invoked via
       syscall(2), then the return value follows the usual conventions for indicating an error: -1, with errno  set  to  a
       (positive) value that indicates the error.

BUGS
       An invalid ctx_id may cause a segmentation fault instead of generating the error EINVAL.

SEE ALSO
       io_cancel(2), io_destroy(2), io_setup(2), io_submit(2), aio(7), time(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                         IO_GETEVENTS(2)
</pre>
<pre zoom>
<span xsmall>2 query_module</span>
QUERY_MODULE(2)                                  Linux Programmer's Manual                                 QUERY_MODULE(2)

NAME
       query_module - query the kernel for various bits pertaining to modules

SYNOPSIS
       #include <linux/module.h>

       int query_module(const char *name, int which, void *buf,
                        size_t bufsize, size_t *ret);

       Note: No declaration of this system call is provided in glibc headers; see NOTES.

DESCRIPTION
       Note: This system call is present only in kernels before Linux 2.6.

       query_module()  requests information from the kernel about loadable modules.  The returned information is placed in
       the buffer pointed to by buf.  The caller must specify the size of buf in bufsize.  The precise nature  and  format
       of the returned information depend on the operation specified by which.  Some operations require name to identify a
       currently loaded module, some allow name to be NULL, indicating the kernel proper.

       The following values can be specified for which:

       0      Returns success, if the kernel supports query_module().  Used to probe for availability of the system call.

       QM_MODULES
              Returns the names of all loaded modules.  The returned buffer consists  of  a  sequence  of  null-terminated
              strings; ret is set to the number of modules.

       QM_DEPS
              Returns  the  names of all modules used by the indicated module.  The returned buffer consists of a sequence
              of null-terminated strings; ret is set to the number of modules.

       QM_REFS
              Returns the names of all modules using the indicated module.  This is the inverse of QM_DEPS.  The  returned
              buffer consists of a sequence of null-terminated strings; ret is set to the number of modules.

       QM_SYMBOLS
              Returns  the  symbols  and values exported by the kernel or the indicated module.  The returned buffer is an
              array of structures of the following form

                  struct module_symbol {
                      unsigned long value;
                      unsigned long name;
                  };

              followed by null-terminated strings.  The value of name is the character offset of the  string  relative  to
              the start of buf; ret is set to the number of symbols.

       QM_INFO
              Returns miscellaneous information about the indicated module.  The output buffer format is:

                  struct module_info {
                      unsigned long address;
                      unsigned long size;
                      unsigned long flags;
                  };

              where  address  is  the kernel address at which the module resides, size is the size of the module in bytes,
              and flags is a mask of MOD_RUNNING, MOD_AUTOCLEAN, and so on, that indicates the current status of the  mod‐
              ule  (see  the  Linux kernel source file include/linux/module.h).  ret is set to the size of the module_info
              structure.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned and errno is set appropriately.

ERRORS
       EFAULT At least one of name, buf, or ret was outside the program's accessible address space.

       EINVAL Invalid which; or name is NULL (indicating "the kernel"), but this is not permitted with the specified value
              of which.

       ENOENT No module by that name exists.

       ENOSPC The buffer size provided was too small.  ret is set to the minimum size needed.

       ENOSYS query_module() is not supported in this version of the kernel (e.g., the kernel is version 2.6 or later).

VERSIONS
       This system call is present on Linux only up until kernel 2.4; it was removed in Linux 2.6.

CONFORMING TO
       query_module() is Linux-specific.

NOTES
       Some  of  the  information  that  was  formerly  available  via  query_module() can be obtained from /proc/modules,
       /proc/kallsyms, and the files under the directory /sys/module.

       The query_module() system call is not supported by glibc.  No  declaration  is  provided  in  glibc  headers,  but,
       through a quirk of history, glibc does export an ABI for this system call.  Therefore, in order to employ this sys‐
       tem call, it is sufficient to manually declare the interface in your code; alternatively, you can invoke the system
       call using syscall(2).

SEE ALSO
       create_module(2), delete_module(2), get_kernel_syms(2), init_module(2), lsmod(8), modinfo(8)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                         QUERY_MODULE(2)
</pre>
<pre zoom>
<span xsmall>2 truncate</span>
TRUNCATE(2)                                      Linux Programmer's Manual                                     TRUNCATE(2)

NAME
       truncate, ftruncate - truncate a file to a specified length

SYNOPSIS
       #include <unistd.h>
       #include <sys/types.h>

       int truncate(const char *path, off_t length);
       int ftruncate(int fd, off_t length);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       truncate():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

       ftruncate():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.3.5: */ _POSIX_C_SOURCE >= 200112L
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       The  truncate()  and ftruncate() functions cause the regular file named by path or referenced by fd to be truncated
       to a size of precisely length bytes.

       If the file previously was larger than this size, the extra data is lost.  If the file previously was  shorter,  it
       is extended, and the extended part reads as null bytes ('\0').

       The file offset is not changed.

       If  the  size  changed, then the st_ctime and st_mtime fields (respectively, time of last status change and time of
       last modification; see inode(7)) for the file are updated, and the set-user-ID and set-group-ID mode  bits  may  be
       cleared.

       With ftruncate(), the file must be open for writing; with truncate(), the file must be writable.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       For truncate():

       EACCES Search  permission  is  denied  for a component of the path prefix, or the named file is not writable by the
              user.  (See also path_resolution(7).)

       EFAULT The argument path points outside the process's allocated address space.

       EFBIG  The argument length is larger than the maximum file size. (XSI)

       EINTR  While blocked waiting to complete, the call was interrupted by a signal handler; see fcntl(2) and signal(7).

       EINVAL The argument length is negative or larger than the maximum file size.

       EIO    An I/O error occurred updating the inode.

       EISDIR The named file is a directory.

       ELOOP  Too many symbolic links were encountered in translating the pathname.

       ENAMETOOLONG
              A component of a pathname exceeded 255 characters, or an entire pathname exceeded 1023 characters.

       ENOENT The named file does not exist.

       ENOTDIR
              A component of the path prefix is not a directory.

       EPERM  The underlying filesystem does not support extending a file beyond its current size.

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       EROFS  The named file resides on a read-only filesystem.

       ETXTBSY
              The file is an executable file that is being executed.

       For ftruncate() the same errors apply, but instead of things that can be wrong with path, we now have  things  that
       can be wrong with the file descriptor, fd:

       EBADF  fd is not a valid file descriptor.

       EBADF or EINVAL
              fd is not open for writing.

       EINVAL fd does not reference a regular file or a POSIX shared memory object.

       EINVAL or EBADF
              The  file  descriptor  fd  is not open for writing.  POSIX permits, and portable applications should handle,
              either error for this case.  (Linux produces EINVAL.)

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.4BSD, SVr4 (these calls first appeared in 4.2BSD).

NOTES
       ftruncate() can also be used to set the size of a POSIX shared memory object; see shm_open(7).

       The details in DESCRIPTION are for XSI-compliant systems.  For non-XSI-compliant systems, the POSIX standard allows
       two  behaviors for ftruncate() when length exceeds the file length (note that truncate() is not specified at all in
       such an environment): either returning an error, or extending the file.  Like most UNIX implementations, Linux fol‐
       lows  the  XSI requirement when dealing with native filesystems.  However, some nonnative filesystems do not permit
       truncate() and ftruncate() to be used to extend a file beyond its current length: a notable  example  on  Linux  is
       VFAT.

       The  original Linux truncate() and ftruncate() system calls were not designed to handle large file offsets.  Conse‐
       quently, Linux 2.4 added truncate64() and ftruncate64() system calls  that  handle  large  files.   However,  these
       details  can  be  ignored by applications using glibc, whose wrapper functions transparently employ the more recent
       system calls where they are available.

       On some 32-bit architectures, the calling signature for these system calls differ, for  the  reasons  described  in
       syscall(2).

BUGS
       A  header file bug in glibc 2.12 meant that the minimum value of _POSIX_C_SOURCE required to expose the declaration
       of ftruncate() was 200809L instead of 200112L.  This has been fixed in later glibc versions.

SEE ALSO
       truncate(1), open(2), stat(2), path_resolution(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             TRUNCATE(2)
</pre>
<pre zoom>
<span xsmall>2 setresuid</span>
SETRESUID(2)                                     Linux Programmer's Manual                                    SETRESUID(2)

NAME
       setresuid, setresgid - set real, effective and saved user or group ID

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <unistd.h>

       int setresuid(uid_t ruid, uid_t euid, uid_t suid);
       int setresgid(gid_t rgid, gid_t egid, gid_t sgid);

DESCRIPTION
       setresuid() sets the real user ID, the effective user ID, and the saved set-user-ID of the calling process.

       An  unprivileged process may change its real UID, effective UID, and saved set-user-ID, each to one of: the current
       real UID, the current effective UID or the current saved set-user-ID.

       A privileged process (on Linux, one having the CAP_SETUID capability) may set its  real  UID,  effective  UID,  and
       saved set-user-ID to arbitrary values.

       If one of the arguments equals -1, the corresponding value is not changed.

       Regardless  of  what  changes are made to the real UID, effective UID, and saved set-user-ID, the filesystem UID is
       always set to the same value as the (possibly new) effective UID.

       Completely analogously, setresgid() sets the real GID, effective GID, and saved set-group-ID of the calling process
       (and  always  modifies  the  filesystem  GID  to  be the same as the effective GID), with the same restrictions for
       unprivileged processes.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

       Note: there are cases where setresuid() can fail even when the caller is UID 0; it is a  grave  security  error  to
       omit checking for a failure return from setresuid().

ERRORS
       EAGAIN The call would change the caller's real UID (i.e., ruid does not match the caller's real UID), but there was
              a temporary failure allocating the necessary kernel data structures.

       EAGAIN ruid does not match the caller's real UID and this call would bring the number of processes belonging to the
              real user ID ruid over the caller's RLIMIT_NPROC resource limit.  Since Linux 3.1, this error case no longer
              occurs (but robust applications should check for this error); see the description of EAGAIN in execve(2).

       EINVAL One or more of the target user or group IDs is not valid in this user namespace.

       EPERM  The calling process is not privileged (did not have the necessary capability  in  its  user  namespace)  and
              tried  to  change  the  IDs  to values that are not permitted.  For setresuid(), the necessary capability is
              CAP_SETUID; for setresgid(), it is CAP_SETGID.

VERSIONS
       These calls are available under Linux since Linux 2.1.44.

CONFORMING TO
       These calls are nonstandard; they also appear on HP-UX and some of the BSDs.

NOTES
       Under HP-UX and FreeBSD, the prototype is found in <unistd.h>.  Under Linux, the prototype  is  provided  by  glibc
       since version 2.3.2.

       The  original  Linux  setresuid()  and  setresgid()  system calls supported only 16-bit user and group IDs.  Subse‐
       quently, Linux 2.4 added setresuid32() and setresgid32(), supporting 32-bit IDs.  The glibc setresuid() and setres‐
       gid() wrapper functions transparently deal with the variations across kernel versions.

   C library/kernel differences
       At  the  kernel level, user IDs and group IDs are a per-thread attribute.  However, POSIX requires that all threads
       in a process share the same credentials.  The NPTL threading implementation handles the POSIX requirements by  pro‐
       viding  wrapper  functions for the various system calls that change process UIDs and GIDs.  These wrapper functions
       (including those for setresuid() and setresgid()) employ a signal-based technique to ensure that  when  one  thread
       changes  credentials,  all  of  the  other  threads in the process also change their credentials.  For details, see
       nptl(7).

SEE ALSO
       getresuid(2),  getuid(2),  setfsgid(2),  setfsuid(2),  setreuid(2),  setuid(2),  capabilities(7),   credentials(7),
       user_namespaces(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            SETRESUID(2)
</pre>
<pre zoom>
<span xsmall>2 move_pages</span>
MOVE_PAGES(2)                                    Linux Programmer's Manual                                   MOVE_PAGES(2)

NAME
       move_pages - move individual pages of a process to another node

SYNOPSIS
       #include <numaif.h>

       long move_pages(int pid, unsigned long count, void **pages,
                       const int *nodes, int *status, int flags);

       Link with -lnuma.

DESCRIPTION
       move_pages()  moves  the  specified pages of the process pid to the memory nodes specified by nodes.  The result of
       the move is reflected in status.  The flags indicate constraints on the pages to be moved.

       pid is the ID of the process in which pages are to be moved.  If pid is 0, then move_pages()  moves  pages  of  the
       calling process.

       To move pages in another process requires the following privileges:

       *  In kernels up to and including Linux 4.12: the caller must be privileged (CAP_SYS_NICE) or the real or effective
          user ID of the calling process must match the real or saved-set user ID of the target process.

       *  The older rules allowed the caller to discover various virtual address choices made by  the  kernel  that  could
          lead  to the defeat of address-space-layout randomization for a process owned by the same UID as the caller, the
          rules were changed starting with Linux 4.13.  Since Linux 4.13, permission is governed by a ptrace  access  mode
          PTRACE_MODE_READ_REALCREDS check with respect to the target process; see ptrace(2).

       count is the number of pages to move.  It defines the size of the three arrays pages, nodes, and status.

       pages is an array of pointers to the pages that should be moved.  These are pointers that should be aligned to page
       boundaries.  Addresses are specified as seen by the process specified by pid.

       nodes is an array of integers that specify the desired location for each page.  Each element in the array is a node
       number.   nodes  can  also  be NULL, in which case move_pages() does not move any pages but instead will return the
       node where each page currently resides, in the status array.  Obtaining the status of each page may be necessary to
       determine pages that need to be moved.

       status  is  an  array  of  integers  that  return the status of each page.  The array contains valid values only if
       move_pages() did not return an error.

       flags specify what types of pages to move.  MPOL_MF_MOVE means that only pages that are in  exclusive  use  by  the
       process  are  to  be moved.  MPOL_MF_MOVE_ALL means that pages shared between multiple processes can also be moved.
       The process must be privileged (CAP_SYS_NICE) to use MPOL_MF_MOVE_ALL.

   Page states in the status array
       The following values can be returned in each element of the status array.

       0..MAX_NUMNODES
              Identifies the node on which the page resides.

       -EACCES
              The page is mapped by multiple processes and can be moved only if MPOL_MF_MOVE_ALL is specified.

       -EBUSY The page is currently busy and cannot be moved.  Try again later.  This occurs if a page is  undergoing  I/O
              or another kernel subsystem is holding a reference to the page.

       -EFAULT
              This is a zero page or the memory area is not mapped by the process.

       -EIO   Unable  to  write  back a page.  The page has to be written back in order to move it since the page is dirty
              and the filesystem does not provide a migration function that would allow the move of dirty pages.

       -EINVAL
              A dirty page cannot be moved.  The filesystem does not provide a migration function and has  no  ability  to
              write back pages.

       -ENOENT
              The page is not present.

       -ENOMEM
              Unable to allocate memory on target node.

RETURN VALUE
       On success move_pages() returns zero.  On error, it returns -1, and sets errno to indicate the error.

ERRORS
       E2BIG  Too many pages to move.

       EACCES One of the target nodes is not allowed by the current cpuset.

       EFAULT Parameter array could not be accessed.

       EINVAL Flags  other than MPOL_MF_MOVE and MPOL_MF_MOVE_ALL was specified or an attempt was made to migrate pages of
              a kernel thread.

       ENODEV One of the target nodes is not online.

       ENOENT No pages were found that require moving.  All pages are either already on the target node, not present,  had
              an invalid address or could not be moved because they were mapped by multiple processes.

       EPERM  The  caller  specified  MPOL_MF_MOVE_ALL  without  sufficient  privileges  (CAP_SYS_NICE).   Or,  the caller
              attempted to move pages of a process belonging to  another  user  but  did  not  have  privilege  to  do  so
              (CAP_SYS_NICE).

       ESRCH  Process does not exist.

VERSIONS
       move_pages() first appeared on Linux in version 2.6.18.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       For information on library support, see numa(7).

       Use  get_mempolicy(2)  with the MPOL_F_MEMS_ALLOWED flag to obtain the set of nodes that are allowed by the current
       cpuset.  Note that this information is subject to change at any time by manual or automatic reconfiguration of  the
       cpuset.

       Use of this function may result in pages whose location (node) violates the memory policy established for the spec‐
       ified addresses (See mbind(2)) and/or the specified process (See set_mempolicy(2)).  That is,  memory  policy  does
       not constrain the destination nodes used by move_pages().

       The <numaif.h> header is not included with glibc, but requires installing libnuma-devel or a similar package.

SEE ALSO
       get_mempolicy(2),  mbind(2),  set_mempolicy(2),  numa(3), numa_maps(5), cpuset(7), numa(7), migratepages(8), numas‐
       tat(8)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           MOVE_PAGES(2)
</pre>
<pre zoom>
<span xsmall>2 send</span>
SEND(2)                                          Linux Programmer's Manual                                         SEND(2)

NAME
       send, sendto, sendmsg - send a message on a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       ssize_t send(int sockfd, const void *buf, size_t len, int flags);

       ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);

       ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);

DESCRIPTION
       The system calls send(), sendto(), and sendmsg() are used to transmit a message to another socket.

       The send() call may be used only when the socket is in a connected state (so that the intended recipient is known).
       The only difference between send() and write(2) is the presence of flags.  With a zero flags  argument,  send()  is
       equivalent to write(2).  Also, the following call

           send(sockfd, buf, len, flags);

       is equivalent to

           sendto(sockfd, buf, len, flags, NULL, 0);

       The argument sockfd is the file descriptor of the sending socket.

       If  sendto() is used on a connection-mode (SOCK_STREAM, SOCK_SEQPACKET) socket, the arguments dest_addr and addrlen
       are ignored (and the error EISCONN may be returned when they are not  NULL  and  0),  and  the  error  ENOTCONN  is
       returned  when  the  socket was not actually connected.  Otherwise, the address of the target is given by dest_addr
       with addrlen specifying its size.  For sendmsg(), the  address  of  the  target  is  given  by  msg.msg_name,  with
       msg.msg_namelen specifying its size.

       For  send() and sendto(), the message is found in buf and has length len.  For sendmsg(), the message is pointed to
       by the elements of the array msg.msg_iov.  The sendmsg() call also allows sending ancillary  data  (also  known  as
       control information).

       If  the message is too long to pass atomically through the underlying protocol, the error EMSGSIZE is returned, and
       the message is not transmitted.

       No indication of failure to deliver is implicit in a send().  Locally detected errors are  indicated  by  a  return
       value of -1.

       When  the  message  does  not fit into the send buffer of the socket, send() normally blocks, unless the socket has
       been placed in nonblocking I/O mode.  In nonblocking mode it would fail with the error  EAGAIN  or  EWOULDBLOCK  in
       this case.  The select(2) call may be used to determine when it is possible to send more data.

   The flags argument
       The flags argument is the bitwise OR of zero or more of the following flags.

       MSG_CONFIRM (since Linux 2.3.15)
              Tell  the link layer that forward progress happened: you got a successful reply from the other side.  If the
              link layer doesn't get this it will regularly reprobe the neighbor (e.g., via a unicast ARP).  Valid only on
              SOCK_DGRAM and SOCK_RAW sockets and currently implemented only for IPv4 and IPv6.  See arp(7) for details.

       MSG_DONTROUTE
              Don't use a gateway to send out the packet, send to hosts only on directly connected networks.  This is usu‐
              ally used only by diagnostic or routing programs.  This is defined only for protocol  families  that  route;
              packet sockets don't.

       MSG_DONTWAIT (since Linux 2.2)
              Enables  nonblocking  operation; if the operation would block, EAGAIN or EWOULDBLOCK is returned.  This pro‐
              vides similar behavior to setting the O_NONBLOCK flag (via the fcntl(2) F_SETFL operation), but  differs  in
              that  MSG_DONTWAIT  is  a per-call option, whereas O_NONBLOCK is a setting on the open file description (see
              open(2)), which will affect all threads in the calling process and as well as other processes that hold file
              descriptors referring to the same open file description.

       MSG_EOR (since Linux 2.2)
              Terminates a record (when this notion is supported, as for sockets of type SOCK_SEQPACKET).

       MSG_MORE (since Linux 2.4.4)
              The  caller  has  more  data  to  send.  This flag is used with TCP sockets to obtain the same effect as the
              TCP_CORK socket option (see tcp(7)), with the difference that this flag can be set on a per-call basis.

              Since Linux 2.6, this flag is also supported for UDP sockets, and informs the kernel to package all  of  the
              data  sent  in calls with this flag set into a single datagram which is transmitted only when a call is per‐
              formed that does not specify this flag.  (See also the UDP_CORK socket option described in udp(7).)

       MSG_NOSIGNAL (since Linux 2.2)
              Don't generate a SIGPIPE signal if the peer on a stream-oriented socket  has  closed  the  connection.   The
              EPIPE error is still returned.  This provides similar behavior to using sigaction(2) to ignore SIGPIPE, but,
              whereas MSG_NOSIGNAL is a per-call feature, ignoring SIGPIPE sets  a  process  attribute  that  affects  all
              threads in the process.

       MSG_OOB
              Sends  out-of-band data on sockets that support this notion (e.g., of type SOCK_STREAM); the underlying pro‐
              tocol must also support out-of-band data.

   sendmsg()
       The definition of the msghdr structure employed by sendmsg() is as follows:

           struct msghdr {
               void         *msg_name;       /* optional address */
               socklen_t     msg_namelen;    /* size of address */
               struct iovec *msg_iov;        /* scatter/gather array */
               size_t        msg_iovlen;     /* # elements in msg_iov */
               void         *msg_control;    /* ancillary data, see below */
               size_t        msg_controllen; /* ancillary data buffer len */
               int           msg_flags;      /* flags (unused) */
           };

       The msg_name field is used on an unconnected socket to specify the target address for a datagram.  It points  to  a
       buffer  containing  the  address;  the msg_namelen field should be set to the size of the address.  For a connected
       socket, these fields should be specified as NULL and 0, respectively.

       The msg_iov and msg_iovlen fields specify scatter-gather locations, as for writev(2).

       You may send control information using the msg_control and msg_controllen  members.   The  maximum  control  buffer
       length the kernel can process is limited per socket by the value in /proc/sys/net/core/optmem_max; see socket(7).

       The msg_flags field is ignored.

RETURN VALUE
       On success, these calls return the number of bytes sent.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       These are some standard errors generated by the socket layer.  Additional errors may be generated and returned from
       the underlying protocol modules; see their respective manual pages.

       EACCES (For UNIX domain sockets, which are identified by pathname) Write permission is denied  on  the  destination
              socket  file,  or search permission is denied for one of the directories the path prefix.  (See path_resolu‐
              tion(7).)

              (For UDP sockets) An attempt was made to send to a network/broadcast address as  though  it  was  a  unicast
              address.

       EAGAIN or EWOULDBLOCK
              The  socket is marked nonblocking and the requested operation would block.  POSIX.1-2001 allows either error
              to be returned for this case, and does not require these constants to have the same  value,  so  a  portable
              application should check for both possibilities.

       EAGAIN (Internet  domain  datagram  sockets)  The  socket referred to by sockfd had not previously been bound to an
              address and, upon attempting to bind it to an ephemeral port, it was determined that all port numbers in the
              ephemeral  port range are currently in use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range in
              ip(7).

       EALREADY
              Another Fast Open is in progress.

       EBADF  sockfd is not a valid open file descriptor.

       ECONNRESET
              Connection reset by peer.

       EDESTADDRREQ
              The socket is not connection-mode, and no peer address is set.

       EFAULT An invalid user space address was specified for an argument.

       EINTR  A signal occurred before any data was transmitted; see signal(7).

       EINVAL Invalid argument passed.

       EISCONN
              The connection-mode socket was connected already but a recipient was specified.  (Now either this  error  is
              returned, or the recipient specification is ignored.)

       EMSGSIZE
              The  socket  type requires that message be sent atomically, and the size of the message to be sent made this
              impossible.

       ENOBUFS
              The output queue for a network interface was full.  This generally indicates that the interface has  stopped
              sending,  but  may be caused by transient congestion.  (Normally, this does not occur in Linux.  Packets are
              just silently dropped when a device queue overflows.)

       ENOMEM No memory available.

       ENOTCONN
              The socket is not connected, and no target has been given.

       ENOTSOCK
              The file descriptor sockfd does not refer to a socket.

       EOPNOTSUPP
              Some bit in the flags argument is inappropriate for the socket type.

       EPIPE  The local end has been shut down on a connection oriented socket.  In  this  case,  the  process  will  also
              receive a SIGPIPE unless MSG_NOSIGNAL is set.

CONFORMING TO
       4.4BSD, SVr4, POSIX.1-2001.  These interfaces first appeared in 4.2BSD.

       POSIX.1-2001 describes only the MSG_OOB and MSG_EOR flags.  POSIX.1-2008 adds a specification of MSG_NOSIGNAL.  The
       MSG_CONFIRM flag is a Linux extension.

NOTES
       According to POSIX.1-2001, the msg_controllen field of the msghdr structure should be typed as socklen_t, but glibc
       currently types it as size_t.

       See  sendmmsg(2) for information about a Linux-specific system call that can be used to transmit multiple datagrams
       in a single call.

BUGS
       Linux may return EPIPE instead of ENOTCONN.

EXAMPLE
       An example of the use of sendto() is shown in getaddrinfo(3).

SEE ALSO
       fcntl(2), getsockopt(2), recv(2), select(2), sendfile(2), sendmmsg(2), shutdown(2), socket(2),  write(2),  cmsg(3),
       ip(7), ipv6(7), socket(7), tcp(7), udp(7), unix(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 SEND(2)
</pre>
<pre zoom>
<span xsmall>2 fstat64</span>
STAT(2)                                          Linux Programmer's Manual                                         STAT(2)

NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       int fstat(int fd, struct stat *statbuf);
       int lstat(const char *pathname, struct stat *statbuf);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
                   int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       lstat():
           /* glibc 2.19 and earlier */ _BSD_SOURCE
               || /* Since glibc 2.20 */ _DEFAULT_SOURCE
               || _XOPEN_SOURCE >= 500
               || /* Since glibc 2.10: */ _POSIX_C_SOURCE >= 200112L

       fstatat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  functions return information about a file, in the buffer pointed to by statbuf.  No permissions are required
       on the file itself, but—in the case of stat(), fstatat(), and lstat()—execute (search) permission  is  required  on
       all of the directories in pathname that lead to the file.

       stat()  and fstatat() retrieve information about the file pointed to by pathname; the differences for fstatat() are
       described below.

       lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information  about  the
       link itself, not the file that it refers to.

       fstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the
       file descriptor fd.

   The stat structure
       All of these system calls return a stat structure, which contains the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

       Note: the order of fields in the stat structure varies somewhat across architectures.  In addition, the  definition
       above  does  not  show the padding bytes that may be present between some fields on various architectures.  Consult
       the glibc and kernel source code if you need to know the details.

       Note: for performance and simplicity reasons, different fields in the stat structure may contain state  information
       from  different  moments  during the execution of the system call.  For example, if st_mode or st_uid is changed by
       another process by calling chmod(2) or chown(2), stat() might return the old st_mode together with the new  st_uid,
       or the old st_uid together with the new st_mode.

       The fields in the stat structure are as follows:

       st_dev This field describes the device on which this file resides.  (The major(3) and minor(3) macros may be useful
              to decompose the device ID in this field.)

       st_ino This field contains the file's inode number.

       st_mode
              This field contains the file type and mode.  See inode(7) for further information.

       st_nlink
              This field contains the number of hard links to the file.

       st_uid This field contains the user ID of the owner of the file.

       st_gid This field contains the ID of the group owner of the file.

       st_rdev
              This field describes the device that this file (inode) represents.

       st_size
              This field gives the size of the file (if it is a regular file or a symbolic link) in bytes.  The size of  a
              symbolic link is the length of the pathname it contains, without a terminating null byte.

       st_blksize
              This field gives the "preferred" block size for efficient filesystem I/O.

       st_blocks
              This  field  indicates  the number of blocks allocated to the file, in 512-byte units.  (This may be smaller
              than st_size/512 when the file has holes.)

       st_atime
              This is the file's last access timestamp.

       st_mtime
              This is the file's last modification timestamp.

       st_ctime
              This is the file's last status change timestamp.

       For further information on the above fields, see inode(7).

   fstatat()
       The fstatat() system call is a more general interface for  accessing  file  information  which  can  still  provide
       exactly the behavior of each of stat(), lstat(), and fstat().

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       stat() and lstat() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like stat() and lstat()).

       If pathname is absolute, then dirfd is ignored.

       flags can either be 0, or include one or more of the following flags ORed:

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2) O_PATH flag).  In this case, dirfd can refer to any type of file, not just a directory, and the
              behavior of fstatat() is similar to that of fstat().  If dirfd is AT_FDCWD, the call operates on the current
              working directory.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.

       AT_NO_AUTOMOUNT (since Linux 2.6.38)
              Don't  automount  the  terminal ("basename") component of pathname if it is a directory that is an automount
              point.  This allows the caller to gather attributes of an automount point (rather than the location it would
              mount).   Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand directory such as used
              for automounter indirect maps.  This flag can be used in tools that scan directories to  prevent  mass-auto‐
              mounting  of a directory of automount points.  The AT_NO_AUTOMOUNT flag has no effect if the mount point has
              already been mounted over.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.   Both
              stat() and lstat() act as though AT_NO_AUTOMOUNT was set.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a  symbolic link, do not dereference it: instead return information about the link itself,
              like lstat().  (By default, fstatat() dereferences symbolic links, like stat().)

       See openat(2) for an explanation of the need for fstatat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Search permission is denied for one of the directories in the path prefix of pathname.  (See also path_reso‐
              lution(7).)

       EBADF  fd is not a valid open file descriptor.

       EFAULT Bad address.

       ELOOP  Too many symbolic links encountered while traversing the path.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A  component  of pathname does not exist, or pathname is an empty string and AT_EMPTY_PATH was not specified
              in flags.

       ENOMEM Out of memory (i.e., kernel memory).

       ENOTDIR
              A component of the path prefix of pathname is not a directory.

       EOVERFLOW
              pathname or fd refers to a file whose size, inode number, or number of  blocks  cannot  be  represented  in,
              respectively,  the  types off_t, ino_t, or blkcnt_t.  This error can occur when, for example, an application
              compiled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 calls stat()  on  a  file  whose  size  exceeds
              (1<<31)-1 bytes.

       The following additional errors can occur for fstatat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fstatat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       stat(), fstat(), lstat(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.

       fstatat(): POSIX.1-2008.

       According  to  POSIX.1-2001, lstat() on a symbolic link need return valid information only in the st_size field and
       the file type of the st_mode field of the stat  structure.   POSIX.1-2008  tightens  the  specification,  requiring
       lstat() to return valid information in all fields except the mode bits in st_mode.

       Use of the st_blocks and st_blksize fields may be less portable.  (They were introduced in BSD.  The interpretation
       differs between systems, and possibly on a single system when NFS mounts are involved.)

NOTES
   Timestamp fields
       Older kernels and older standards did not support nanosecond timestamp fields.  Instead, there were three timestamp
       fields—st_atime, st_mtime, and st_ctime—typed as time_t that recorded timestamps with one-second precision.

       Since  kernel  2.5.48,  the stat structure supports nanosecond resolution for the three file timestamp fields.  The
       nanosecond components of each timestamp are available via names of the form st_atim.tv_nsec,  if  suitable  feature
       test macros are defined.  Nanosecond timestamps were standardized in POSIX.1-2008, and, starting with version 2.12,
       glibc exposes the nanosecond component names if _POSIX_C_SOURCE is defined with the value 200809L  or  greater,  or
       _XOPEN_SOURCE  is  defined  with  the value 700 or greater.  Up to and including glibc 2.19, the definitions of the
       nanoseconds components are also defined if _BSD_SOURCE or _SVID_SOURCE is defined.  If none of  the  aforementioned
       macros are defined, then the nanosecond values are exposed with names of the form st_atimensec.

   C library/kernel differences
       Over  time, increases in the size of the stat structure have led to three successive versions of stat(): sys_stat()
       (slot __NR_oldstat), sys_newstat() (slot __NR_stat), and sys_stat64() (slot __NR_stat64) on 32-bit  platforms  such
       as  i386.   The  first  two  versions were already present in Linux 1.0 (albeit with different names); the last was
       added in Linux 2.4.  Similar remarks apply for fstat() and lstat().

       The kernel-internal versions of the stat structure dealt with by the different versions are, respectively:

       __old_kernel_stat
              The original structure, with rather narrow fields, and no padding.

       stat   Larger st_ino field and padding added to various parts of the structure to allow for future expansion.

       stat64 Even larger st_ino field, larger st_uid and st_gid fields to accommodate the Linux-2.4 expansion of UIDs and
              GIDs  to  32 bits, and various other enlarged fields and further padding in the structure.  (Various padding
              bytes were eventually consumed in Linux 2.6, with the advent of 32-bit device IDs and nanosecond  components
              for the timestamp fields.)

       The  glibc  stat()  wrapper function hides these details from applications, invoking the most recent version of the
       system call provided by the kernel, and repacking the returned information if required for old binaries.

       On modern 64-bit systems, life is simpler: there is a single stat() system call and the kernel deals  with  a  stat
       structure that contains fields of a sufficient size.

       The  underlying  system call employed by the glibc fstatat() wrapper function is actually called fstatat64() or, on
       some architectures, newfstatat().

EXAMPLE
       The following program calls lstat() and displays selected fields in the returned stat structure.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/sysmacros.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           printf("ID of containing device:  [%lx,%lx]\n",
                (long) major(sb.st_dev), (long) minor(sb.st_dev));

           printf("File type:                ");

           switch (sb.st_mode & S_IFMT) {
           case S_IFBLK:  printf("block device\n");            break;
           case S_IFCHR:  printf("character device\n");        break;
           case S_IFDIR:  printf("directory\n");               break;
           case S_IFIFO:  printf("FIFO/pipe\n");               break;
           case S_IFLNK:  printf("symlink\n");                 break;
           case S_IFREG:  printf("regular file\n");            break;
           case S_IFSOCK: printf("socket\n");                  break;
           default:       printf("unknown?\n");                break;
           }

           printf("I-node number:            %ld\n", (long) sb.st_ino);

           printf("Mode:                     %lo (octal)\n",
                   (unsigned long) sb.st_mode);

           printf("Link count:               %ld\n", (long) sb.st_nlink);
           printf("Ownership:                UID=%ld   GID=%ld\n",
                   (long) sb.st_uid, (long) sb.st_gid);

           printf("Preferred I/O block size: %ld bytes\n",
                   (long) sb.st_blksize);
           printf("File size:                %lld bytes\n",
                   (long long) sb.st_size);
           printf("Blocks allocated:         %lld\n",
                   (long long) sb.st_blocks);

           printf("Last status change:       %s", ctime(&sb.st_ctime));
           printf("Last file access:         %s", ctime(&sb.st_atime));
           printf("Last file modification:   %s", ctime(&sb.st_mtime));

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ls(1), stat(1), access(2), chmod(2), chown(2), readlink(2), utime(2), capabilities(7), inode(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 STAT(2)
</pre>
<pre zoom>
<span xsmall>2 getunwind</span>
GETUNWIND(2)                                     Linux Programmer's Manual                                    GETUNWIND(2)

NAME
       getunwind - copy the unwind data to caller's buffer

SYNOPSIS
       #include <syscall.h>
       #include <linux/unwind.h>

       long getunwind(void *buf, size_t buf_size);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       Note: this function is obsolete.

       The IA-64-specific getunwind() system call copies the kernel's call frame unwind data into the buffer pointed to by
       buf and returns the size of the unwind data; this data describes the gate page (kernel code  that  is  mapped  into
       user space).

       The  size of the buffer buf is specified in buf_size.  The data is copied only if buf_size is greater than or equal
       to the size of the unwind data and buf is not NULL; otherwise, no data is copied, and the call succeeds,  returning
       the size that would be needed to store the unwind data.

       The  first  part of the unwind data contains an unwind table.  The rest contains the associated unwind information,
       in no particular order.  The unwind table contains entries of the following form:

           u64 start;      (64-bit address of start of function)
           u64 end;        (64-bit address of end of function)
           u64 info;       (BUF-relative offset to unwind info)

       An entry whose start value is zero indicates the end of the table.  For more information about the format, see  the
       IA-64 Software Conventions and Runtime Architecture manual.

RETURN VALUE
       On success, getunwind() returns the size of the unwind data.  On error, -1 is returned and errno is set to indicate
       the error.

ERRORS
       getunwind() fails with the error EFAULT if the unwind info can't be stored in the space specified by buf.

VERSIONS
       This system call is available since Linux 2.4.

CONFORMING TO
       This system call is Linux-specific, and is available only on the IA-64 architecture.

NOTES
       This system call has been deprecated.  The modern way to obtain the kernel's unwind data is via the vdso(7).

       Glibc does not provide a wrapper for this system call; in the  unlikely  event  that  you  want  to  call  it,  use
       syscall(2).

SEE ALSO
       getauxval(3)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            GETUNWIND(2)
</pre>
<pre zoom>
<span xsmall>2 remap_file_pages</span>
REMAP_FILE_PAGES(2)                              Linux Programmer's Manual                             REMAP_FILE_PAGES(2)

NAME
       remap_file_pages - create a nonlinear file mapping

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <sys/mman.h>

       int remap_file_pages(void *addr, size_t size, int prot,
                            size_t pgoff, int flags);

DESCRIPTION
       Note:  this  system  call  was marked as deprecated starting with Linux 3.16.  In Linux 4.0, the implementation was
       replaced by a slower in-kernel emulation.  Those few applications that use this system call should consider migrat‐
       ing  to  alternatives.   This  change  was made because the kernel code for this system call was complex, and it is
       believed to be little used or perhaps even completely unused.  While it had some use cases in database applications
       on 32-bit systems, those use cases don't exist on 64-bit systems.

       The  remap_file_pages() system call is used to create a nonlinear mapping, that is, a mapping in which the pages of
       the file are mapped into a nonsequential order in memory.  The advantage of  using  remap_file_pages()  over  using
       repeated calls to mmap(2) is that the former approach does not require the kernel to create additional VMA (Virtual
       Memory Area) data structures.

       To create a nonlinear mapping we perform the following steps:

       1. Use mmap(2) to create a mapping (which is initially linear).  This mapping must be created with  the  MAP_SHARED
          flag.

       2. Use one or more calls to remap_file_pages() to rearrange the correspondence between the pages of the mapping and
          the pages of the file.  It is possible to map the same page of a file into multiple locations within the  mapped
          region.

       The  pgoff and size arguments specify the region of the file that is to be relocated within the mapping: pgoff is a
       file offset in units of the system page size; size is the length of the region in bytes.

       The addr argument serves two purposes.  First, it identifies the mapping whose pages we want to  rearrange.   Thus,
       addr  must be an address that falls within a region previously mapped by a call to mmap(2).  Second, addr specifies
       the address at which the file pages identified by pgoff and size will be placed.

       The values specified in addr and size should be multiples of the system page size.  If they are not, then the  ker‐
       nel rounds both values down to the nearest multiple of the page size.

       The prot argument must be specified as 0.

       The flags argument has the same meaning as for mmap(2), but all flags other than MAP_NONBLOCK are ignored.

RETURN VALUE
       On success, remap_file_pages() returns 0.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EINVAL addr does not refer to a valid mapping created with the MAP_SHARED flag.

       EINVAL addr, size, prot, or pgoff is invalid.

VERSIONS
       The remap_file_pages() system call appeared in Linux 2.5.46; glibc support was added in version 2.3.3.

CONFORMING TO
       The remap_file_pages() system call is Linux-specific.

NOTES
       Since  Linux 2.6.23, remap_file_pages() creates non-linear mappings only on in-memory filesystems such as tmpfs(5),
       hugetlbfs or ramfs.  On filesystems with a backing store, remap_file_pages() is not much more efficient than  using
       mmap(2) to adjust which parts of the file are mapped to which addresses.

SEE ALSO
       getpagesize(2), mmap(2), mmap2(2), mprotect(2), mremap(2), msync(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                     REMAP_FILE_PAGES(2)
</pre>
<pre zoom>
<span xsmall>2 alloc_hugepages</span>
ALLOC_HUGEPAGES(2)                               Linux Programmer's Manual                              ALLOC_HUGEPAGES(2)

NAME
       alloc_hugepages, free_hugepages - allocate or free huge pages

SYNOPSIS
       void *alloc_hugepages(int key, void *addr, size_t len,
                             int prot, int flag);

       int free_hugepages(void *addr);

DESCRIPTION
       The  system  calls  alloc_hugepages()  and  free_hugepages()  were  introduced in Linux 2.5.36 and removed again in
       2.5.54.  They existed only on i386 and ia64 (when built with CONFIG_HUGETLB_PAGE).  In Linux  2.4.20,  the  syscall
       numbers exist, but the calls fail with the error ENOSYS.

       On  i386  the memory management hardware knows about ordinary pages (4 KiB) and huge pages (2 or 4 MiB).  Similarly
       ia64 knows about huge pages of several sizes.  These system calls serve to map huge pages into the process's memory
       or to free them again.  Huge pages are locked into memory, and are not swapped.

       The  key argument is an identifier.  When zero the pages are private, and not inherited by children.  When positive
       the pages are shared with other applications using the same key, and inherited by child processes.

       The addr argument of free_hugepages() tells which page is being freed: it  was  the  return  value  of  a  call  to
       alloc_hugepages().   (The  memory  is  first actually freed when all users have released it.)  The addr argument of
       alloc_hugepages() is a hint, that the kernel may or may not follow.  Addresses must be properly aligned.

       The len argument is the length of the required segment.  It must be a multiple of the huge page size.

       The prot argument specifies the memory protection of the segment.  It is one of PROT_READ, PROT_WRITE, PROT_EXEC.

       The flag argument is ignored, unless key is positive.  In that case, if flag is IPC_CREAT, then  a  new  huge  page
       segment  is created when none with the given key existed.  If this flag is not set, then ENOENT is returned when no
       segment with the given key exists.

RETURN VALUE
       On success, alloc_hugepages() returns the allocated virtual address, and free_hugepages() returns zero.  On  error,
       -1 is returned, and errno is set appropriately.

ERRORS
       ENOSYS The system call is not supported on this kernel.

FILES
       /proc/sys/vm/nr_hugepages
              Number of configured hugetlb pages.  This can be read and written.

       /proc/meminfo
              Gives  info  on  the  number  of  configured  hugetlb  pages  and  on  their  size  in  the  three variables
              HugePages_Total, HugePages_Free, Hugepagesize.

CONFORMING TO
       These calls are specific to Linux on Intel processors, and should not be used in programs intended to be portable.

NOTES
       These system calls are gone; they existed only in Linux 2.5.36 through to 2.5.54.  Now the hugetlbfs filesystem can
       be  used instead.  Memory backed by huge pages (if the CPU supports them) is obtained by using mmap(2) to map files
       in this virtual filesystem.

       The maximal number of huge pages can be specified using the hugepages= boot parameter.

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                      ALLOC_HUGEPAGES(2)
</pre>
<pre zoom>
<span xsmall>2 syncfs</span>
SYNC(2)                                          Linux Programmer's Manual                                         SYNC(2)

NAME
       sync, syncfs - commit filesystem caches to disk

SYNOPSIS
       #include <unistd.h>

       void sync(void);

       int syncfs(int fd);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       sync():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.19: */ _DEFAULT_SOURCE
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

       syncfs():
           _GNU_SOURCE

DESCRIPTION
       sync() causes all pending modifications to filesystem metadata and cached file data to be written to the underlying
       filesystems.

       syncfs() is like sync(), but synchronizes just the filesystem containing file referred to by the open file descrip‐
       tor fd.

RETURN VALUE
       syncfs() returns 0 on success; on error, it returns -1 and sets errno to indicate the error.

ERRORS
       sync() is always successful.

       syncfs() can fail for at least the following reason:

       EBADF  fd is not a valid file descriptor.

VERSIONS
       syncfs() first appeared in Linux 2.6.39; library support was added to glibc in version 2.14.

CONFORMING TO
       sync(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

       syncfs() is Linux-specific.

NOTES
       Since  glibc  2.2.2,  the Linux prototype for sync() is as listed above, following the various standards.  In glibc
       2.2.1 and earlier, it was "int sync(void)", and sync() always returned 0.

       According to the standard specification (e.g., POSIX.1-2001), sync() schedules the writes, but  may  return  before
       the  actual writing is done.  However Linux waits for I/O completions, and thus sync() or syncfs() provide the same
       guarantees as fsync called on every file in the system or filesystem respectively.

BUGS
       Before version 1.3.20 Linux did not wait for I/O to complete before returning.

SEE ALSO
       sync(1), fdatasync(2), fsync(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 SYNC(2)
</pre>
<pre zoom>
<span xsmall>2 setresgid32</span>
SETRESUID(2)                                     Linux Programmer's Manual                                    SETRESUID(2)

NAME
       setresuid, setresgid - set real, effective and saved user or group ID

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <unistd.h>

       int setresuid(uid_t ruid, uid_t euid, uid_t suid);
       int setresgid(gid_t rgid, gid_t egid, gid_t sgid);

DESCRIPTION
       setresuid() sets the real user ID, the effective user ID, and the saved set-user-ID of the calling process.

       An  unprivileged process may change its real UID, effective UID, and saved set-user-ID, each to one of: the current
       real UID, the current effective UID or the current saved set-user-ID.

       A privileged process (on Linux, one having the CAP_SETUID capability) may set its  real  UID,  effective  UID,  and
       saved set-user-ID to arbitrary values.

       If one of the arguments equals -1, the corresponding value is not changed.

       Regardless  of  what  changes are made to the real UID, effective UID, and saved set-user-ID, the filesystem UID is
       always set to the same value as the (possibly new) effective UID.

       Completely analogously, setresgid() sets the real GID, effective GID, and saved set-group-ID of the calling process
       (and  always  modifies  the  filesystem  GID  to  be the same as the effective GID), with the same restrictions for
       unprivileged processes.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

       Note: there are cases where setresuid() can fail even when the caller is UID 0; it is a  grave  security  error  to
       omit checking for a failure return from setresuid().

ERRORS
       EAGAIN The call would change the caller's real UID (i.e., ruid does not match the caller's real UID), but there was
              a temporary failure allocating the necessary kernel data structures.

       EAGAIN ruid does not match the caller's real UID and this call would bring the number of processes belonging to the
              real user ID ruid over the caller's RLIMIT_NPROC resource limit.  Since Linux 3.1, this error case no longer
              occurs (but robust applications should check for this error); see the description of EAGAIN in execve(2).

       EINVAL One or more of the target user or group IDs is not valid in this user namespace.

       EPERM  The calling process is not privileged (did not have the necessary capability  in  its  user  namespace)  and
              tried  to  change  the  IDs  to values that are not permitted.  For setresuid(), the necessary capability is
              CAP_SETUID; for setresgid(), it is CAP_SETGID.

VERSIONS
       These calls are available under Linux since Linux 2.1.44.

CONFORMING TO
       These calls are nonstandard; they also appear on HP-UX and some of the BSDs.

NOTES
       Under HP-UX and FreeBSD, the prototype is found in <unistd.h>.  Under Linux, the prototype  is  provided  by  glibc
       since version 2.3.2.

       The  original  Linux  setresuid()  and  setresgid()  system calls supported only 16-bit user and group IDs.  Subse‐
       quently, Linux 2.4 added setresuid32() and setresgid32(), supporting 32-bit IDs.  The glibc setresuid() and setres‐
       gid() wrapper functions transparently deal with the variations across kernel versions.

   C library/kernel differences
       At  the  kernel level, user IDs and group IDs are a per-thread attribute.  However, POSIX requires that all threads
       in a process share the same credentials.  The NPTL threading implementation handles the POSIX requirements by  pro‐
       viding  wrapper  functions for the various system calls that change process UIDs and GIDs.  These wrapper functions
       (including those for setresuid() and setresgid()) employ a signal-based technique to ensure that  when  one  thread
       changes  credentials,  all  of  the  other  threads in the process also change their credentials.  For details, see
       nptl(7).

SEE ALSO
       getresuid(2),  getuid(2),  setfsgid(2),  setfsuid(2),  setreuid(2),  setuid(2),  capabilities(7),   credentials(7),
       user_namespaces(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            SETRESUID(2)
</pre>
<pre zoom>
<span xsmall>2 ioctl_ns</span>
IOCTL_NS(2)                                      Linux Programmer's Manual                                     IOCTL_NS(2)

NAME
       ioctl_ns - ioctl() operations for Linux namespaces

DESCRIPTION
   Discovering namespace relationships
       The  following  ioctl(2)  operations  are  provided  to allow discovery of namespace relationships (see user_names‐
       paces(7) and pid_namespaces(7)).  The form of the calls is:

           new_fd = ioctl(fd, request);

       In each case, fd refers to a /proc/[pid]/ns/* file.  Both operations return a new file descriptor on success.

       NS_GET_USERNS (since Linux 4.9)
              Returns a file descriptor that refers to the owning user namespace for the namespace referred to by fd.

       NS_GET_PARENT (since Linux 4.9)
              Returns a file descriptor that refers to the parent namespace of the namespace  referred  to  by  fd.   This
              operation  is  valid only for hierarchical namespaces (i.e., PID and user namespaces).  For user namespaces,
              NS_GET_PARENT is synonymous with NS_GET_USERNS.

       The new file descriptor returned by these operations is opened with the O_RDONLY and O_CLOEXEC (close-on-exec;  see
       fcntl(2)) flags.

       By  applying  fstat(2) to the returned file descriptor, one obtains a stat structure whose st_dev (resident device)
       and st_ino (inode number) fields together identify the owning/parent namespace.  This inode number can  be  matched
       with  the  inode  number  of  another /proc/[pid]/ns/{pid,user} file to determine whether that is the owning/parent
       namespace.

       Either of these ioctl(2) operations can fail with the following errors:

       EPERM  The requested namespace is outside of the caller's namespace scope.  This error can occur if,  for  example,
              the  owning  user  namespace  is  an  ancestor of the caller's current user namespace.  It can also occur on
              attempts to obtain the parent of the initial user or PID namespace.

       ENOTTY The operation is not supported by this kernel version.

       Additionally, the NS_GET_PARENT operation can fail with the following error:

       EINVAL fd refers to a nonhierarchical namespace.

       See the EXAMPLE section for an example of the use of these operations.

   Discovering the namespace type
       The NS_GET_NSTYPE operation (available since Linux 4.11) can be used to discover the type of namespace referred  to
       by the file descriptor fd:

           nstype = ioctl(fd, NS_GET_NSTYPE);

       fd refers to a /proc/[pid]/ns/* file.

       The return value is one of the CLONE_NEW* values that can be specified to clone(2) or unshare(2) in order to create
       a namespace.

   Discovering the owner of a user namespace
       The NS_GET_OWNER_UID operation (available since Linux 4.11) can be used to discover the owner user  ID  of  a  user
       namespace (i.e., the effective user ID of the process that created the user namespace).  The form of the call is:

           uid_t uid;
           ioctl(fd, NS_GET_OWNER_UID, &uid);

       fd refers to a /proc/[pid]/ns/user file.

       The owner user ID is returned in the uid_t pointed to by the third argument.

       This operation can fail with the following error:

       EINVAL fd does not refer to a user namespace.

ERRORS
       Any of the above ioctl() operations can return the following errors:

       ENOTTY fd does not refer to a /proc/[pid]/ns/* file.

CONFORMING TO
       Namespaces and the operations described on this page are a Linux-specific.

EXAMPLE
       The example shown below uses the ioctl(2) operations described above to perform simple discovery of namespace rela‐
       tionships.  The following shell sessions show various examples of the use of this program.

       Trying to get the parent of the initial user namespace fails, since it has no parent:

           $ ./ns_show /proc/self/ns/user p
           The parent namespace is outside your namespace scope

       Create a process running sleep(1) that resides in new user and UTS namespaces, and show that the new UTS  namespace
       is associated with the new user namespace:

           $ unshare -Uu sleep 1000 &
           [1] 23235
           $ ./ns_show /proc/23235/ns/uts u
           Device/Inode of owning user namespace is: [0,3] / 4026532448
           $ readlink /proc/23235/ns/user
           user:[4026532448]

       Then show that the parent of the new user namespace in the preceding example is the initial user namespace:

           $ readlink /proc/self/ns/user
           user:[4026531837]
           $ ./ns_show /proc/23235/ns/user p
           Device/Inode of parent namespace is: [0,3] / 4026531837

       Start  a  shell  in  a new user namespace, and show that from within this shell, the parent user namespace can't be
       discovered.  Similarly, the UTS namespace (which is associated with the initial user namespace)  can't  be  discov‐
       ered.

           $ PS1="sh2$ " unshare -U bash
           sh2$ ./ns_show /proc/self/ns/user p
           The parent namespace is outside your namespace scope
           sh2$ ./ns_show /proc/self/ns/uts u
           The owning user namespace is outside your namespace scope

   Program source

       /* ns_show.c

          Licensed under the GNU General Public License v2 or later.
       */
       #include <stdlib.h>
       #include <unistd.h>
       #include <stdio.h>
       #include <fcntl.h>
       #include <string.h>
       #include <sys/stat.h>
       #include <sys/ioctl.h>
       #include <errno.h>
       #include <sys/sysmacros.h>

       #ifndef NS_GET_USERNS
       #define NSIO    0xb7
       #define NS_GET_USERNS   _IO(NSIO, 0x1)
       #define NS_GET_PARENT   _IO(NSIO, 0x2)
       #endif

       int
       main(int argc, char *argv[])
       {
           int fd, userns_fd, parent_fd;
           struct stat sb;

           if (argc < 2) {
               fprintf(stderr, "Usage: %s /proc/[pid]/ns/[file] [p|u]\n",
                       argv[0]);
               fprintf(stderr, "\nDisplay the result of one or both "
                       "of NS_GET_USERNS (u) or NS_GET_PARENT (p)\n"
                       "for the specified /proc/[pid]/ns/[file]. If neither "
                       "'p' nor 'u' is specified,\n"
                       "NS_GET_USERNS is the default.\n");
               exit(EXIT_FAILURE);
           }

           /* Obtain a file descriptor for the 'ns' file specified
              in argv[1] */

           fd = open(argv[1], O_RDONLY);
           if (fd == -1) {
               perror("open");
               exit(EXIT_FAILURE);
           }

           /* Obtain a file descriptor for the owning user namespace and
              then obtain and display the inode number of that namespace */

           if (argc < 3 || strchr(argv[2], 'u')) {
               userns_fd = ioctl(fd, NS_GET_USERNS);

               if (userns_fd == -1) {
                   if (errno == EPERM)
                       printf("The owning user namespace is outside "
                               "your namespace scope\n");
                   else
                      perror("ioctl-NS_GET_USERNS");
                   exit(EXIT_FAILURE);
                }

               if (fstat(userns_fd, &sb) == -1) {
                   perror("fstat-userns");
                   exit(EXIT_FAILURE);
               }
               printf("Device/Inode of owning user namespace is: "
                       "[%lx,%lx] / %ld\n",
                       (long) major(sb.st_dev), (long) minor(sb.st_dev),
                       (long) sb.st_ino);

               close(userns_fd);
           }

           /* Obtain a file descriptor for the parent namespace and
              then obtain and display the inode number of that namespace */

           if (argc > 2 && strchr(argv[2], 'p')) {
               parent_fd = ioctl(fd, NS_GET_PARENT);

               if (parent_fd == -1) {
                   if (errno == EINVAL)
                       printf("Can' get parent namespace of a "
                               "nonhierarchical namespace\n");
                   else if (errno == EPERM)
                       printf("The parent namespace is outside "
                               "your namespace scope\n");
                   else
                       perror("ioctl-NS_GET_PARENT");
                   exit(EXIT_FAILURE);
               }

               if (fstat(parent_fd, &sb) == -1) {
                   perror("fstat-parentns");
                   exit(EXIT_FAILURE);
               }
               printf("Device/Inode of parent namespace is: [%lx,%lx] / %ld\n",
                       (long) major(sb.st_dev), (long) minor(sb.st_dev),
                       (long) sb.st_ino);

               close(parent_fd);
           }

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       fstat(2), ioctl(2), proc(5), namespaces(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             IOCTL_NS(2)
</pre>
<pre zoom>
<span xsmall>2 seteuid</span>
SETEUID(2)                                       Linux Programmer's Manual                                      SETEUID(2)

NAME
       seteuid, setegid - set effective user or group ID

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int seteuid(uid_t euid);
       int setegid(gid_t egid);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       seteuid(), setegid():
           _POSIX_C_SOURCE >= 200112L
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       seteuid()  sets  the  effective  user ID of the calling process.  Unprivileged processes may only set the effective
       user ID to the real user ID, the effective user ID or the saved set-user-ID.

       Precisely the same holds for setegid() with "group" instead of "user".

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

       Note: there are cases where seteuid() can fail even when the caller is UID 0; it is a grave security error to  omit
       checking for a failure return from seteuid().

ERRORS
       EINVAL The target user or group ID is not valid in this user namespace.

       EPERM  In  the case of seteuid(): the calling process is not privileged (does not have the CAP_SETUID capability in
              its user namespace) and euid does not match the current real user ID, current effective user ID, or  current
              saved set-user-ID.

              In  the case of setegid(): the calling process is not privileged (does not have the CAP_SETGID capability in
              its user namespace) and egid does not match the current real group ID, current effective group ID,  or  cur‐
              rent saved set-group-ID.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD.

NOTES
       Setting  the effective user (group) ID to the saved set-user-ID (saved set-group-ID) is possible since Linux 1.1.37
       (1.1.38).  On an arbitrary system one should check _POSIX_SAVED_IDS.

       Under glibc 2.0, seteuid(euid) is equivalent to setreuid(-1, euid) and hence  may  change  the  saved  set-user-ID.
       Under  glibc  2.1  and  later, it is equivalent to setresuid(-1, euid, -1) and hence does not change the saved set-
       user-ID.  Analogous remarks hold for setegid(),  with  the  difference  that  the  change  in  implementation  from
       setregid(-1,  egid)  to  setresgid(-1,  egid, -1) occurred in glibc 2.2 or 2.3 (depending on the hardware architec‐
       ture).

       According to POSIX.1, seteuid() (setegid()) need not permit euid (egid) to be the same value as the current  effec‐
       tive user (group) ID, and some implementations do not permit this.

   C library/kernel differences
       On  Linux,  seteuid()  and  setegid() are implemented as library functions that call, respectively, setreuid(2) and
       setregid(2).

SEE ALSO
       geteuid(2), setresuid(2), setreuid(2), setuid(2), capabilities(7), credentials(7), user_namespaces(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              SETEUID(2)
</pre>
<pre zoom>
<span xsmall>2 _exit</span>
_EXIT(2)                                         Linux Programmer's Manual                                        _EXIT(2)

NAME
       _exit, _Exit - terminate the calling process

SYNOPSIS
       #include <unistd.h>

       void _exit(int status);

       #include <stdlib.h>

       void _Exit(int status);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       _Exit():
           _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       The  function  _exit()  terminates  the  calling process "immediately".  Any open file descriptors belonging to the
       process are closed.  Any children of the process are inherited by init(1) (or by the nearest "subreaper" process as
       defined  through the use of the prctl(2) PR_SET_CHILD_SUBREAPER operation).  The process's parent is sent a SIGCHLD
       signal.

       The value status & 0377 is returned to the parent process as the process's exit status, and can be collected  using
       one of the wait(2) family of calls.

       The function _Exit() is equivalent to _exit().

RETURN VALUE
       These functions do not return.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  The function _Exit() was introduced by C99.

NOTES
       For a discussion on the effects of an exit, the transmission of exit status, zombie processes, signals sent, and so
       on, see exit(3).

       The function _exit() is like exit(3), but does not call any functions  registered  with  atexit(3)  or  on_exit(3).
       Open  stdio(3)  streams are not flushed.  On the other hand, _exit() does close open file descriptors, and this may
       cause an unknown delay, waiting for pending output to finish.  If the delay is undesired, it may be useful to  call
       functions  like  tcflush(3) before calling _exit().  Whether any pending I/O is canceled, and which pending I/O may
       be canceled upon _exit(), is implementation-dependent.

   C library/kernel differences
       In glibc up to version 2.3, the _exit() wrapper function invoked the kernel system call of the  same  name.   Since
       glibc 2.3, the wrapper function invokes exit_group(2), in order to terminate all of the threads in a process.

SEE ALSO
       execve(2),  exit_group(2),  fork(2),  kill(2),  wait(2),  wait4(2),  waitpid(2),  atexit(3),  exit(3),  on_exit(3),
       termios(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-05-03                                                _EXIT(2)
</pre>
<pre zoom>
<span xsmall>2 setreuid</span>
SETREUID(2)                                      Linux Programmer's Manual                                     SETREUID(2)

NAME
       setreuid, setregid - set real and/or effective user or group ID

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int setreuid(uid_t ruid, uid_t euid);
       int setregid(gid_t rgid, gid_t egid);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       setreuid(), setregid():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.19: */ _DEFAULT_SOURCE
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       setreuid() sets real and effective user IDs of the calling process.

       Supplying a value of -1 for either the real or effective user ID forces the system to leave that ID unchanged.

       Unprivileged  processes may only set the effective user ID to the real user ID, the effective user ID, or the saved
       set-user-ID.

       Unprivileged users may only set the real user ID to the real user ID or the effective user ID.

       If the real user ID is set (i.e., ruid is not -1) or the effective user ID is set to a value not equal to the  pre‐
       vious real user ID, the saved set-user-ID will be set to the new effective user ID.

       Completely  analogously, setregid() sets real and effective group ID's of the calling process, and all of the above
       holds with "group" instead of "user".

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

       Note: there are cases where setreuid() can fail even when the caller is UID 0; it is a grave security error to omit
       checking for a failure return from setreuid().

ERRORS
       EAGAIN The call would change the caller's real UID (i.e., ruid does not match the caller's real UID), but there was
              a temporary failure allocating the necessary kernel data structures.

       EAGAIN ruid does not match the caller's real UID and this call would bring the number of processes belonging to the
              real user ID ruid over the caller's RLIMIT_NPROC resource limit.  Since Linux 3.1, this error case no longer
              occurs (but robust applications should check for this error); see the description of EAGAIN in execve(2).

       EINVAL One or more of the target user or group IDs is not valid in this user namespace.

       EPERM  The calling process is not privileged (on Linux, does not have the necessary capability in its  user  names‐
              pace: CAP_SETUID in the case of setreuid(), or CAP_SETGID in the case of setregid()) and a change other than
              (i) swapping the effective user (group) ID with the real user (group) ID, or (ii) setting one to  the  value
              of  the  other  or  (iii) setting the effective user (group) ID to the value of the saved set-user-ID (saved
              set-group-ID) was specified.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD (setreuid() and setregid() first appeared in 4.2BSD).

NOTES
       Setting the effective user (group) ID to the saved set-user-ID (saved set-group-ID) is possible since Linux  1.1.37
       (1.1.38).

       POSIX.1  does  not  specify all of the UID changes that Linux permits for an unprivileged process.  For setreuid(),
       the effective user ID can be made the same as the real user ID or the saved  set-user-ID,  and  it  is  unspecified
       whether  unprivileged  processes  may set the real user ID to the real user ID, the effective user ID, or the saved
       set-user-ID.  For setregid(), the real group ID can be changed to the value of  the  saved  set-group-ID,  and  the
       effective group ID can be changed to the value of the real group ID or the saved set-group-ID.  The precise details
       of what ID changes are permitted vary across implementations.

       POSIX.1 makes no specification about the effect of these calls on the saved set-user-ID and saved set-group-ID.

       The original Linux setreuid() and setregid() system calls supported only 16-bit user and group IDs.   Subsequently,
       Linux  2.4 added setreuid32() and setregid32(), supporting 32-bit IDs.  The glibc setreuid() and setregid() wrapper
       functions transparently deal with the variations across kernel versions.

   C library/kernel differences
       At the kernel level, user IDs and group IDs are a per-thread attribute.  However, POSIX requires that  all  threads
       in  a process share the same credentials.  The NPTL threading implementation handles the POSIX requirements by pro‐
       viding wrapper functions for the various system calls that change process UIDs and GIDs.  These  wrapper  functions
       (including  those  for  setreuid()  and  setregid()) employ a signal-based technique to ensure that when one thread
       changes credentials, all of the other threads in the process also  change  their  credentials.   For  details,  see
       nptl(7).

SEE ALSO
       getgid(2),  getuid(2), seteuid(2), setgid(2), setresuid(2), setuid(2), capabilities(7), credentials(7), user_names‐
       paces(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             SETREUID(2)
</pre>
<pre zoom>
<span xsmall>2 userfaultfd</span>
USERFAULTFD(2)                                   Linux Programmer's Manual                                  USERFAULTFD(2)

NAME
       userfaultfd - create a file descriptor for handling page faults in user space

SYNOPSIS
       #include <sys/types.h>
       #include <linux/userfaultfd.h>

       int userfaultfd(int flags);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       userfaultfd()  creates  a  new userfaultfd object that can be used for delegation of page-fault handling to a user-
       space application, and returns a file descriptor that refers to the new object.  The new userfaultfd object is con‐
       figured using ioctl(2).

       Once  the  userfaultfd  object is configured, the application can use read(2) to receive userfaultfd notifications.
       The reads from userfaultfd may be blocking or non-blocking, depending on the value of flags used for  the  creation
       of the userfaultfd or subsequent calls to fcntl(2).

       The following values may be bitwise ORed in flags to change the behavior of userfaultfd():

       O_CLOEXEC
              Enable the close-on-exec flag for the new userfaultfd file descriptor.  See the description of the O_CLOEXEC
              flag in open(2).

       O_NONBLOCK
              Enables non-blocking operation for the userfaultfd object.  See the description of the  O_NONBLOCK  flag  in
              open(2).

       When  the  last file descriptor referring to a userfaultfd object is closed, all memory ranges that were registered
       with the object are unregistered and unread events are flushed.

   Usage
       The userfaultfd mechanism is designed to allow a thread in a multithreaded program to perform user-space paging for
       the  other  threads  in the process.  When a page fault occurs for one of the regions registered to the userfaultfd
       object, the faulting thread is put to sleep and an event is generated that can be read  via  the  userfaultfd  file
       descriptor.   The  fault-handling  thread reads events from this file descriptor and services them using the opera‐
       tions described in ioctl_userfaultfd(2).  When servicing the page fault events, the fault-handling thread can trig‐
       ger a wake-up for the sleeping thread.

       It  is  possible  for  the  faulting threads and the fault-handling threads to run in the context of different pro‐
       cesses.  In this case, these threads may belong to different programs, and the program that executes  the  faulting
       threads  will  not  necessarily  cooperate  with the program that handles the page faults.  In such non-cooperative
       mode, the process that monitors userfaultfd and handles page faults needs to be aware of the changes in the virtual
       memory layout of the faulting process to avoid memory corruption.

       Starting  from Linux 4.11, userfaultfd can also notify the fault-handling threads about changes in the virtual mem‐
       ory layout of the faulting process.  In addition, if the faulting process invokes fork(2), the userfaultfd  objects
       associated  with  the  parent may be duplicated into the child process and the userfaultfd monitor will be notified
       (via the UFFD_EVENT_FORK described below) about the file descriptor associated with the userfault  objects  created
       for  the  child  process,  which allows the userfaultfd monitor to perform user-space paging for the child process.
       Unlike page faults which have to be synchronous and require an explicit or implicit wakeup, all  other  events  are
       delivered  asynchronously and the non-cooperative process resumes execution as soon as the userfaultfd manager exe‐
       cutes read(2).  The userfaultfd manager should carefully synchronize calls to UFFDIO_COPY with  the  processing  of
       events.

       The  current  asynchronous  model  of the event delivery is optimal for single threaded non-cooperative userfaultfd
       manager implementations.

   Userfaultfd operation
       After the userfaultfd object is created with userfaultfd(), the application must enable  it  using  the  UFFDIO_API
       ioctl(2)  operation.  This operation allows a handshake between the kernel and user space to determine the API ver‐
       sion and supported features.  This operation must  be  performed  before  any  of  the  other  ioctl(2)  operations
       described below (or those operations fail with the EINVAL error).

       After a successful UFFDIO_API operation, the application then registers memory address ranges using the UFFDIO_REG‐
       ISTER ioctl(2) operation.  After successful completion of a UFFDIO_REGISTER operation, a page  fault  occurring  in
       the requested memory range, and satisfying the mode defined at the registration time, will be forwarded by the ker‐
       nel to the user-space application.  The application can then use the UFFDIO_COPY or UFFDIO_ZERO ioctl(2) operations
       to resolve the page fault.

       Starting  from  Linux  4.14,  if  the  application  sets  the  UFFD_FEATURE_SIGBUS feature bit using the UFFDIO_API
       ioctl(2), no page-fault notification will be forwarded to user space.  Instead a SIGBUS signal is delivered to  the
       faulting process.  With this feature, userfaultfd can be used for robustness purposes to simply catch any access to
       areas within the registered address range that do not have pages allocated, without having to listen to userfaultfd
       events.   No userfaultfd monitor will be required for dealing with such memory accesses.  For example, this feature
       can be useful for applications that want to prevent the kernel from  automatically  allocating  pages  and  filling
       holes in sparse files when the hole is accessed through a memory mapping.

       The  UFFD_FEATURE_SIGBUS  feature  is  implicitly  inherited  through fork(2) if used in combination with UFFD_FEA‐
       TURE_FORK.

       Details of the various ioctl(2) operations can be found in ioctl_userfaultfd(2).

       Since Linux 4.11, events other than page-fault may enabled during UFFDIO_API operation.

       Up to Linux 4.11, userfaultfd can be used only with anonymous private memory mappings.   Since  Linux  4.11,  user‐
       faultfd can be also used with hugetlbfs and shared memory mappings.

   Reading from the userfaultfd structure
       Each  read(2) from the userfaultfd file descriptor returns one or more uffd_msg structures, each of which describes
       a page-fault event or an event required for the non-cooperative userfaultfd usage:

           struct uffd_msg {
               __u8  event;            /* Type of event */
               ...
               union {
                   struct {
                       __u64 flags;    /* Flags describing fault */
                       __u64 address;  /* Faulting address */
                   } pagefault;

                   struct {            /* Since Linux 4.11 */
                       __u32 ufd;      /* Userfault file descriptor
                                          of the child process */
                   } fork;

                   struct {            /* Since Linux 4.11 */
                       __u64 from;     /* Old address of remapped area */
                       __u64 to;       /* New address of remapped area */
                       __u64 len;      /* Original mapping length */
                   } remap;

                   struct {            /* Since Linux 4.11 */
                       __u64 start;    /* Start address of removed area */
                       __u64 end;      /* End address of removed area */
                   } remove;
                   ...
               } arg;

               /* Padding fields omitted */
           } __packed;

       If multiple events are available and the supplied buffer is large enough, read(2) returns as many  events  as  will
       fit  in the supplied buffer.  If the buffer supplied to read(2) is smaller than the size of the uffd_msg structure,
       the read(2) fails with the error EINVAL.

       The fields set in the uffd_msg structure are as follows:

       event  The type of event.  Depending of the event type,  different  fields  of  the  arg  union  represent  details
              required for the event processing.  The non-page-fault events are generated only when appropriate feature is
              enabled during API handshake with UFFDIO_API ioctl(2).

              The following values can appear in the event field:

              UFFD_EVENT_PAGEFAULT (since Linux 4.3)
                     A page-fault event.  The page-fault details are available in the pagefault field.

              UFFD_EVENT_FORK (since Linux 4.11)
                     Generated when the faulting process invokes fork(2) (or clone(2) without  the  CLONE_VM  flag).   The
                     event details are available in the fork field.

              UFFD_EVENT_REMAP (since Linux 4.11)
                     Generated  when the faulting process invokes mremap(2).  The event details are available in the remap
                     field.

              UFFD_EVENT_REMOVE (since Linux 4.11)
                     Generated when the faulting process invokes madvise(2) with MADV_DONTNEED or MADV_REMOVE advice.  The
                     event details are available in the remove field.

              UFFD_EVENT_UNMAP (since Linux 4.11)
                     Generated  when  the  faulting  process  unmaps  a memory range, either explicitly using munmap(2) or
                     implicitly during mmap(2) or mremap(2).  The event details are available in the remove field.

       pagefault.address
              The address that triggered the page fault.

       pagefault.flags
              A bit mask of flags that describe the event.  For UFFD_EVENT_PAGEFAULT, the following flag may appear:

              UFFD_PAGEFAULT_FLAG_WRITE
                     If the address is in a range that was registered  with  the  UFFDIO_REGISTER_MODE_MISSING  flag  (see
                     ioctl_userfaultfd(2)) and this flag is set, this a write fault; otherwise it is a read fault.

       fork.ufd
              The file descriptor associated with the userfault object created for the child created by fork(2).

       remap.from
              The original address of the memory range that was remapped using mremap(2).

       remap.to
              The new address of the memory range that was remapped using mremap(2).

       remap.len
              The original length of the memory range that was remapped using mremap(2).

       remove.start
              The start address of the memory range that was freed using madvise(2) or unmapped

       remove.end
              The end address of the memory range that was freed using madvise(2) or unmapped

       A read(2) on a userfaultfd file descriptor can fail with the following errors:

       EINVAL The userfaultfd object has not yet been enabled using the UFFDIO_API ioctl(2) operation

       If  the  O_NONBLOCK flag is enabled in the associated open file description, the userfaultfd file descriptor can be
       monitored with poll(2), select(2), and epoll(7).  When events are available, the file descriptor indicates as read‐
       able.   If  the O_NONBLOCK flag is not enabled, then poll(2) (always) indicates the file as having a POLLERR condi‐
       tion, and select(2) indicates the file descriptor as both readable and writable.

RETURN VALUE
       On success, userfaultfd() returns a new file descriptor that refers to the userfaultfd object.   On  error,  -1  is
       returned, and errno is set appropriately.

ERRORS
       EINVAL An unsupported value was specified in flags.

       EMFILE The per-process limit on the number of open file descriptors has been reached

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENOMEM Insufficient kernel memory was available.

VERSIONS
       The userfaultfd() system call first appeared in Linux 4.3.

       The support for hugetlbfs and shared memory areas and non-page-fault events was added in Linux 4.11

CONFORMING TO
       userfaultfd() is Linux-specific and should not be used in programs intended to be portable.

NOTES
       Glibc does not provide a wrapper for this system call; call it using syscall(2).

       The  userfaultfd  mechanism  can be used as an alternative to traditional user-space paging techniques based on the
       use of the SIGSEGV signal and mmap(2).  It can also be used to implement lazy restore for checkpoint/restore mecha‐
       nisms,  as well as post-copy migration to allow (nearly) uninterrupted execution when transferring virtual machines
       and Linux containers from one host to another.

BUGS
       If the UFFD_FEATURE_EVENT_FORK is enabled and a system call from the fork(2) family is interrupted by a  signal  or
       failed,  a  stale userfaultfd descriptor might be created.  In this case, a spurious UFFD_EVENT_FORK will be deliv‐
       ered to the userfaultfd monitor.

EXAMPLE
       The program below demonstrates the use of the userfaultfd mechanism.  The program creates two threads, one of which
       acts as the page-fault handler for the process, for the pages in a demand-page zero region created using mmap(2).

       The  program  takes one command-line argument, which is the number of pages that will be created in a mapping whose
       page faults will be handled via userfaultfd.  After creating a userfaultfd object,  the  program  then  creates  an
       anonymous  private  mapping  of  the  specified size and registers the address range of that mapping using the UFF‐
       DIO_REGISTER ioctl(2) operation.  The program then creates a second thread that will perform the task  of  handling
       page faults.

       The  main  thread  then  walks  through the pages of the mapping fetching bytes from successive pages.  Because the
       pages have not yet been accessed, the first access of a byte in each page will trigger a page-fault  event  on  the
       userfaultfd file descriptor.

       Each of the page-fault events is handled by the second thread, which sits in a loop processing input from the user‐
       faultfd file descriptor.  In each loop iteration, the second thread first calls poll(2) to check the state  of  the
       file  descriptor, and then reads an event from the file descriptor.  All such events should be UFFD_EVENT_PAGEFAULT
       events, which the thread handles by copying a page of data into the faulting region using the UFFDIO_COPY  ioctl(2)
       operation.

       The following is an example of what we see when running the program:

           $ ./userfaultfd_demo 3
           Address returned by mmap() = 0x7fd30106c000

           fault_handler_thread():
               poll() returns: nready = 1; POLLIN = 1; POLLERR = 0
               UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106c00f
                   (uffdio_copy.copy returned 4096)
           Read address 0x7fd30106c00f in main(): A
           Read address 0x7fd30106c40f in main(): A
           Read address 0x7fd30106c80f in main(): A
           Read address 0x7fd30106cc0f in main(): A

           fault_handler_thread():
               poll() returns: nready = 1; POLLIN = 1; POLLERR = 0
               UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106d00f
                   (uffdio_copy.copy returned 4096)
           Read address 0x7fd30106d00f in main(): B
           Read address 0x7fd30106d40f in main(): B
           Read address 0x7fd30106d80f in main(): B
           Read address 0x7fd30106dc0f in main(): B

           fault_handler_thread():
               poll() returns: nready = 1; POLLIN = 1; POLLERR = 0
               UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106e00f
                   (uffdio_copy.copy returned 4096)
           Read address 0x7fd30106e00f in main(): C
           Read address 0x7fd30106e40f in main(): C
           Read address 0x7fd30106e80f in main(): C
           Read address 0x7fd30106ec0f in main(): C

   Program source

       /* userfaultfd_demo.c

          Licensed under the GNU General Public License version 2 or later.
       */
       #define _GNU_SOURCE
       #include <sys/types.h>
       #include <stdio.h>
       #include <linux/userfaultfd.h>
       #include <pthread.h>
       #include <errno.h>
       #include <unistd.h>
       #include <stdlib.h>
       #include <fcntl.h>
       #include <signal.h>
       #include <poll.h>
       #include <string.h>
       #include <sys/mman.h>
       #include <sys/syscall.h>
       #include <sys/ioctl.h>
       #include <poll.h>

       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       static int page_size;

       static void *
       fault_handler_thread(void *arg)
       {
           static struct uffd_msg msg;   /* Data read from userfaultfd */
           static int fault_cnt = 0;     /* Number of faults so far handled */
           long uffd;                    /* userfaultfd file descriptor */
           static char *page = NULL;
           struct uffdio_copy uffdio_copy;
           ssize_t nread;

           uffd = (long) arg;

           /* Create a page that will be copied into the faulting region */

           if (page == NULL) {
               page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
               if (page == MAP_FAILED)
                   errExit("mmap");
           }

           /* Loop, handling incoming events on the userfaultfd
              file descriptor */

           for (;;) {

               /* See what poll() tells us about the userfaultfd */

               struct pollfd pollfd;
               int nready;
               pollfd.fd = uffd;
               pollfd.events = POLLIN;
               nready = poll(&pollfd, 1, -1);
               if (nready == -1)
                   errExit("poll");

               printf("\nfault_handler_thread():\n");
               printf("    poll() returns: nready = %d; "
                       "POLLIN = %d; POLLERR = %d\n", nready,
                       (pollfd.revents & POLLIN) != 0,
                       (pollfd.revents & POLLERR) != 0);

               /* Read an event from the userfaultfd */

               nread = read(uffd, &msg, sizeof(msg));
               if (nread == 0) {
                   printf("EOF on userfaultfd!\n");
                   exit(EXIT_FAILURE);
               }

               if (nread == -1)
                   errExit("read");

               /* We expect only one kind of event; verify that assumption */

               if (msg.event != UFFD_EVENT_PAGEFAULT) {
                   fprintf(stderr, "Unexpected event on userfaultfd\n");
                   exit(EXIT_FAILURE);
               }

               /* Display info about the page-fault event */

               printf("    UFFD_EVENT_PAGEFAULT event: ");
               printf("flags = %llx; ", msg.arg.pagefault.flags);
               printf("address = %llx\n", msg.arg.pagefault.address);

               /* Copy the page pointed to by 'page' into the faulting
                  region. Vary the contents that are copied in, so that it
                  is more obvious that each fault is handled separately. */

               memset(page, 'A' + fault_cnt % 20, page_size);
               fault_cnt++;

               uffdio_copy.src = (unsigned long) page;

               /* We need to handle page faults in units of pages(!).
                  So, round faulting address down to page boundary */

               uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                                  ~(page_size - 1);
               uffdio_copy.len = page_size;
               uffdio_copy.mode = 0;
               uffdio_copy.copy = 0;
               if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
                   errExit("ioctl-UFFDIO_COPY");

               printf("        (uffdio_copy.copy returned %lld)\n",
                       uffdio_copy.copy);
           }
       }

       int
       main(int argc, char *argv[])
       {
           long uffd;          /* userfaultfd file descriptor */
           char *addr;         /* Start of region handled by userfaultfd */
           unsigned long len;  /* Length of region handled by userfaultfd */
           pthread_t thr;      /* ID of thread that handles page faults */
           struct uffdio_api uffdio_api;
           struct uffdio_register uffdio_register;
           int s;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s num-pages\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           page_size = sysconf(_SC_PAGE_SIZE);
           len = strtoul(argv[1], NULL, 0) * page_size;

           /* Create and enable userfaultfd object */

           uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
           if (uffd == -1)
               errExit("userfaultfd");

           uffdio_api.api = UFFD_API;
           uffdio_api.features = 0;
           if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
               errExit("ioctl-UFFDIO_API");

           /* Create a private anonymous mapping. The memory will be
              demand-zero paged--that is, not yet allocated. When we
              actually touch the memory, it will be allocated via
              the userfaultfd. */

           addr = mmap(NULL, len, PROT_READ | PROT_WRITE,
                       MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
           if (addr == MAP_FAILED)
               errExit("mmap");

           printf("Address returned by mmap() = %p\n", addr);

           /* Register the memory range of the mapping we just created for
              handling by the userfaultfd object. In mode, we request to track
              missing pages (i.e., pages that have not yet been faulted in). */

           uffdio_register.range.start = (unsigned long) addr;
           uffdio_register.range.len = len;
           uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
           if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
               errExit("ioctl-UFFDIO_REGISTER");

           /* Create a thread that will process the userfaultfd events */

           s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);
           if (s != 0) {
               errno = s;
               errExit("pthread_create");
           }

           /* Main thread now touches memory in the mapping, touching
              locations 1024 bytes apart. This will trigger userfaultfd
              events for all pages in the region. */

           int l;
           l = 0xf;    /* Ensure that faulting address is not on a page
                          boundary, in order to test that we correctly
                          handle that case in fault_handling_thread() */
           while (l < len) {
               char c = addr[l];
               printf("Read address %p in main(): ", addr + l);
               printf("%c\n", c);
               l += 1024;
               usleep(100000);         /* Slow things down a little */
           }

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       fcntl(2), ioctl(2), ioctl_userfaultfd(2), madvise(2), mmap(2)

       Documentation/vm/userfaultfd.txt in the Linux kernel source tree

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                          USERFAULTFD(2)
</pre>
<pre zoom>
<span xsmall>2 inotify_init1</span>
INOTIFY_INIT(2)                                  Linux Programmer's Manual                                 INOTIFY_INIT(2)

NAME
       inotify_init, inotify_init1 - initialize an inotify instance

SYNOPSIS
       #include <sys/inotify.h>

       int inotify_init(void);
       int inotify_init1(int flags);

DESCRIPTION
       For an overview of the inotify API, see inotify(7).

       inotify_init() initializes a new inotify instance and returns a file descriptor associated with a new inotify event
       queue.

       If flags is 0, then inotify_init1() is the same as inotify_init().  The following values can  be  bitwise  ORed  in
       flags to obtain different behavior:

       IN_NONBLOCK Set  the  O_NONBLOCK  file  status  flag on the new open file description.  Using this flag saves extra
                   calls to fcntl(2) to achieve the same result.

       IN_CLOEXEC  Set the close-on-exec (FD_CLOEXEC) flag on the  new  file  descriptor.   See  the  description  of  the
                   O_CLOEXEC flag in open(2) for reasons why this may be useful.

RETURN VALUE
       On  success,  these system calls return a new file descriptor.  On error, -1 is returned, and errno is set to indi‐
       cate the error.

ERRORS
       EINVAL (inotify_init1()) An invalid value was specified in flags.

       EMFILE The user limit on the total number of inotify instances has been reached.

       EMFILE The per-process limit on the number of open file descriptors has been reached.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENOMEM Insufficient kernel memory is available.

VERSIONS
       inotify_init() first appeared in Linux 2.6.13; library support was added to glibc in version 2.4.   inotify_init1()
       was added in Linux 2.6.27; library support was added to glibc in version 2.9.

CONFORMING TO
       These system calls are Linux-specific.

SEE ALSO
       inotify_add_watch(2), inotify_rm_watch(2), inotify(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                         INOTIFY_INIT(2)
</pre>
<pre zoom>
<span xsmall>2 init_module</span>
INIT_MODULE(2)                                   Linux Programmer's Manual                                  INIT_MODULE(2)

NAME
       init_module, finit_module - load a kernel module

SYNOPSIS
       int init_module(void *module_image, unsigned long len,
                       const char *param_values);

       int finit_module(int fd, const char *param_values,
                        int flags);

       Note:  glibc  provides  no header file declaration of init_module() and no wrapper function for finit_module(); see
       NOTES.

DESCRIPTION
       init_module() loads an ELF image into kernel space, performs any necessary symbol relocations,  initializes  module
       parameters  to  values provided by the caller, and then runs the module's init function.  This system call requires
       privilege.

       The module_image argument points to a buffer containing the binary image to be loaded; len specifies  the  size  of
       that buffer.  The module image should be a valid ELF image, built for the running kernel.

       The param_values argument is a string containing space-delimited specifications of the values for module parameters
       (defined inside the module using module_param() and module_param_array()).  The kernel parses this string and  ini‐
       tializes the specified parameters.  Each of the parameter specifications has the form:

               name[=value[,value...]]

       The parameter name is one of those defined within the module using module_param() (see the Linux kernel source file
       include/linux/moduleparam.h).  The parameter value is optional in the case of bool and invbool parameters.   Values
       for array parameters are specified as a comma-separated list.

   finit_module()
       The  finit_module()  system  call is like init_module(), but reads the module to be loaded from the file descriptor
       fd.  It is useful when the authenticity of a kernel module can be determined from its location in  the  filesystem;
       in cases where that is possible, the overhead of using cryptographically signed modules to determine the authentic‐
       ity of a module can be avoided.  The param_values argument is as for init_module().

       The flags argument modifies the operation of finit_module().  It is a bit mask value created by ORing together zero
       or more of the following flags:

       MODULE_INIT_IGNORE_MODVERSIONS
              Ignore symbol version hashes.

       MODULE_INIT_IGNORE_VERMAGIC
              Ignore kernel version magic.

       There  are  some safety checks built into a module to ensure that it matches the kernel against which it is loaded.
       These checks are recorded when the module is built and verified when the  module  is  loaded.   First,  the  module
       records  a  "vermagic"  string  containing the kernel version number and prominent features (such as the CPU type).
       Second, if the module was built with the  CONFIG_MODVERSIONS  configuration  option  enabled,  a  version  hash  is
       recorded  for  each  symbol the module uses.  This hash is based on the types of the arguments and return value for
       the function named by the symbol.  In this case, the kernel version number within the "vermagic" string is ignored,
       as the symbol version hashes are assumed to be sufficiently reliable.

       Using  the  MODULE_INIT_IGNORE_VERMAGIC  flag  indicates  that the "vermagic" string is to be ignored, and the MOD‐
       ULE_INIT_IGNORE_MODVERSIONS flag indicates that the symbol version hashes are to be  ignored.   If  the  kernel  is
       built  to permit forced loading (i.e., configured with CONFIG_MODULE_FORCE_LOAD), then loading continues, otherwise
       it fails with the error ENOEXEC as expected for malformed modules.

RETURN VALUE
       On success, these system calls return 0.  On error, -1 is returned and errno is set appropriately.

ERRORS
       EBADMSG (since Linux 3.7)
              Module signature is misformatted.

       EBUSY  Timeout while trying to resolve a symbol reference by this module.

       EFAULT An address argument referred to a location that is outside the process's accessible address space.

       ENOKEY (since Linux 3.7)
              Module signature is invalid or the kernel does not have a key for this module.  This error is returned  only
              if  the  kernel  was  configured  with  CONFIG_MODULE_SIG_FORCE;  if the kernel was not configured with this
              option, then an invalid or unsigned module simply taints the kernel.

       ENOMEM Out of memory.

       EPERM  The caller was not privileged (did not have the CAP_SYS_MODULE capability), or module  loading  is  disabled
              (see /proc/sys/kernel/modules_disabled in proc(5)).

       The following errors may additionally occur for init_module():

       EEXIST A module with this name is already loaded.

       EINVAL param_values is invalid, or some part of the ELF image in module_image contains inconsistencies.

       ENOEXEC
              The  binary  image supplied in module_image is not an ELF image, or is an ELF image that is invalid or for a
              different architecture.

       The following errors may additionally occur for finit_module():

       EBADF  The file referred to by fd is not opened for reading.

       EFBIG  The file referred to by fd is too large.

       EINVAL flags is invalid.

       ENOEXEC
              fd does not refer to an open file.

       In addition to the above errors, if the module's init function is executed and returns an error, then init_module()
       or finit_module() fails and errno is set to the value returned by the init function.

VERSIONS
       finit_module() is available since Linux 3.8.

CONFORMING TO
       init_module() and finit_module() are Linux-specific.

NOTES
       The init_module() system call is not supported by glibc.  No declaration is provided in glibc headers, but, through
       a quirk of history, glibc versions before 2.23 did export an ABI for this system  call.   Therefore,  in  order  to
       employ  this  system  call,  it  is  (before glibc 2.23) sufficient to manually declare the interface in your code;
       alternatively, you can invoke the system call using syscall(2).

       Glibc does not provide a wrapper for finit_module(); call it using syscall(2).

       Information about currently loaded modules can be found in /proc/modules and in the file trees under the per-module
       subdirectories under /sys/module.

       See the Linux kernel source file include/linux/module.h for some useful background information.

   Linux 2.4 and earlier
       In Linux 2.4 and earlier, the init_module() system call was rather different:

           #include <linux/module.h>

           int init_module(const char *name, struct module *image);

       (User-space applications can detect which version of init_module() is available by calling query_module(); the lat‐
       ter call fails with the error ENOSYS on Linux 2.6 and later.)

       The older version of the system call loads the relocated module image pointed to by image  into  kernel  space  and
       runs the module's init function.  The caller is responsible for providing the relocated image (since Linux 2.6, the
       init_module() system call does the relocation).

       The module image begins with a module structure and is followed by code and data as appropriate.  Since Linux  2.2,
       the module structure is defined as follows:

           struct module {
               unsigned long         size_of_struct;
               struct module        *next;
               const char           *name;
               unsigned long         size;
               long                  usecount;
               unsigned long         flags;
               unsigned int          nsyms;
               unsigned int          ndeps;
               struct module_symbol *syms;
               struct module_ref    *deps;
               struct module_ref    *refs;
               int                 (*init)(void);
               void                (*cleanup)(void);
               const struct exception_table_entry *ex_table_start;
               const struct exception_table_entry *ex_table_end;
           #ifdef __alpha__
               unsigned long gp;
           #endif
           };

       All of the pointer fields, with the exception of next and refs, are expected to point within the module body and be
       initialized as appropriate for kernel space, that is, relocated with the rest of the module.

SEE ALSO
       create_module(2), delete_module(2), query_module(2), lsmod(8), modprobe(8)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                          INIT_MODULE(2)
</pre>
<pre zoom>
<span xsmall>2 getpagesize</span>
GETPAGESIZE(2)                                   Linux Programmer's Manual                                  GETPAGESIZE(2)

NAME
       getpagesize - get memory page size

SYNOPSIS
       #include <unistd.h>

       int getpagesize(void);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       getpagesize():
           Since glibc 2.19:
               _DEFAULT_SOURCE || ! (_POSIX_C_SOURCE >= 200112L)
           From glibc 2.12 to 2.19:
               _BSD_SOURCE || ! (_POSIX_C_SOURCE >= 200112L)
           Before glibc 2.12:
               _BSD_SOURCE || _XOPEN_SOURCE >= 500

DESCRIPTION
       The  function getpagesize() returns the number of bytes in a memory page, where "page" is a fixed-length block, the
       unit for memory allocation and file mapping performed by mmap(2).

CONFORMING TO
       SVr4, 4.4BSD, SUSv2.  In SUSv2 the getpagesize() call is labeled LEGACY, and in POSIX.1-2001 it has  been  dropped;
       HP-UX does not have this call.

NOTES
       Portable applications should employ sysconf(_SC_PAGESIZE) instead of getpagesize():

           #include <unistd.h>
           long sz = sysconf(_SC_PAGESIZE);

       (Most systems allow the synonym _SC_PAGE_SIZE for _SC_PAGESIZE.)

       Whether getpagesize() is present as a Linux system call depends on the architecture.  If it is, it returns the ker‐
       nel symbol PAGE_SIZE, whose value depends on the architecture and machine model.  Generally, one uses binaries that
       are  dependent  on the architecture but not on the machine model, in order to have a single binary distribution per
       architecture.  This means that a user program should not find PAGE_SIZE at compile time from a header file, but use
       an  actual  system call, at least for those architectures (like sun4) where this dependency exists.  Here glibc 2.0
       fails because its getpagesize() returns a statically derived value, and does not use a system call.  Things are  OK
       in glibc 2.1.

SEE ALSO
       mmap(2), sysconf(3)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                          GETPAGESIZE(2)
</pre>
<pre zoom>
<span xsmall>2 getrusage</span>
GETRUSAGE(2)                                     Linux Programmer's Manual                                    GETRUSAGE(2)

NAME
       getrusage - get resource usage

SYNOPSIS
       #include <sys/time.h>
       #include <sys/resource.h>

       int getrusage(int who, struct rusage *usage);

DESCRIPTION
       getrusage() returns resource usage measures for who, which can be one of the following:

       RUSAGE_SELF
              Return  resource usage statistics for the calling process, which is the sum of resources used by all threads
              in the process.

       RUSAGE_CHILDREN
              Return resource usage statistics for all children of the calling  process  that  have  terminated  and  been
              waited  for.  These statistics will include the resources used by grandchildren, and further removed descen‐
              dants, if all of the intervening descendants waited on their terminated children.

       RUSAGE_THREAD (since Linux 2.6.26)
              Return resource usage statistics for the calling thread.  The _GNU_SOURCE feature test macro must be defined
              (before including any header file) in order to obtain the definition of this constant from <sys/resource.h>.

       The resource usages are returned in the structure pointed to by usage, which has the following form:

           struct rusage {
               struct timeval ru_utime; /* user CPU time used */
               struct timeval ru_stime; /* system CPU time used */
               long   ru_maxrss;        /* maximum resident set size */
               long   ru_ixrss;         /* integral shared memory size */
               long   ru_idrss;         /* integral unshared data size */
               long   ru_isrss;         /* integral unshared stack size */
               long   ru_minflt;        /* page reclaims (soft page faults) */
               long   ru_majflt;        /* page faults (hard page faults) */
               long   ru_nswap;         /* swaps */
               long   ru_inblock;       /* block input operations */
               long   ru_oublock;       /* block output operations */
               long   ru_msgsnd;        /* IPC messages sent */
               long   ru_msgrcv;        /* IPC messages received */
               long   ru_nsignals;      /* signals received */
               long   ru_nvcsw;         /* voluntary context switches */
               long   ru_nivcsw;        /* involuntary context switches */
           };

       Not all fields are completed; unmaintained fields are set to zero by the kernel.  (The unmaintained fields are pro‐
       vided for compatibility with other systems, and because they may one day be supported on Linux.)   The  fields  are
       interpreted as follows:

       ru_utime
              This  is  the  total  amount of time spent executing in user mode, expressed in a timeval structure (seconds
              plus microseconds).

       ru_stime
              This is the total amount of time spent executing in kernel mode, expressed in a timeval  structure  (seconds
              plus microseconds).

       ru_maxrss (since Linux 2.6.32)
              This  is  the  maximum resident set size used (in kilobytes).  For RUSAGE_CHILDREN, this is the resident set
              size of the largest child, not the maximum resident set size of the process tree.

       ru_ixrss (unmaintained)
              This field is currently unused on Linux.

       ru_idrss (unmaintained)
              This field is currently unused on Linux.

       ru_isrss (unmaintained)
              This field is currently unused on Linux.

       ru_minflt
              The number of page faults serviced without any I/O activity; here I/O activity is avoided by “reclaiming”  a
              page frame from the list of pages awaiting reallocation.

       ru_majflt
              The number of page faults serviced that required I/O activity.

       ru_nswap (unmaintained)
              This field is currently unused on Linux.

       ru_inblock (since Linux 2.6.22)
              The number of times the filesystem had to perform input.

       ru_oublock (since Linux 2.6.22)
              The number of times the filesystem had to perform output.

       ru_msgsnd (unmaintained)
              This field is currently unused on Linux.

       ru_msgrcv (unmaintained)
              This field is currently unused on Linux.

       ru_nsignals (unmaintained)
              This field is currently unused on Linux.

       ru_nvcsw (since Linux 2.6)
              The  number  of  times a context switch resulted due to a process voluntarily giving up the processor before
              its time slice was completed (usually to await availability of a resource).

       ru_nivcsw (since Linux 2.6)
              The number of times a context switch resulted due to a higher priority process becoming runnable or  because
              the current process exceeded its time slice.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT usage points outside the accessible address space.

       EINVAL who is invalid.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌────────────┬───────────────┬─────────┐
       │Interface   │ Attribute     │ Value   │
       ├────────────┼───────────────┼─────────┤
       │getrusage() │ Thread safety │ MT-Safe │
       └────────────┴───────────────┴─────────┘

CONFORMING TO
       POSIX.1-2001,  POSIX.1-2008,  SVr4,  4.3BSD.  POSIX.1 specifies getrusage(), but specifies only the fields ru_utime
       and ru_stime.

       RUSAGE_THREAD is Linux-specific.

NOTES
       Resource usage metrics are preserved across an execve(2).

       Including <sys/time.h> is not required these days, but increases portability.  (Indeed, struct timeval  is  defined
       in <sys/time.h>.)

       In  Linux kernel versions before 2.6.9, if the disposition of SIGCHLD is set to SIG_IGN then the resource usages of
       child processes are automatically included in the value returned by RUSAGE_CHILDREN, although POSIX.1-2001  explic‐
       itly prohibits this.  This nonconformance is rectified in Linux 2.6.9 and later.

       The structure definition shown at the start of this page was taken from 4.3BSD Reno.

       Ancient  systems  provided  a vtimes() function with a similar purpose to getrusage().  For backward compatibility,
       glibc also provides vtimes().  All new applications should be written using getrusage().

       See also the description of /proc/[pid]/stat in proc(5).

SEE ALSO
       clock_gettime(2), getrlimit(2), times(2), wait(2), wait4(2), clock(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            GETRUSAGE(2)
</pre>
<pre zoom>
<span xsmall>2 readdir</span>
READDIR(2)                                       Linux Programmer's Manual                                      READDIR(2)

NAME
       readdir - read directory entry

SYNOPSIS
       int readdir(unsigned int fd, struct old_linux_dirent *dirp,
                   unsigned int count);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       This  is  not the function you are interested in.  Look at readdir(3) for the POSIX conforming C library interface.
       This page documents the bare kernel system call interface, which is superseded by getdents(2).

       readdir() reads one old_linux_dirent structure from the directory referred to by the file descriptor  fd  into  the
       buffer pointed to by dirp.  The argument count is ignored; at most one old_linux_dirent structure is read.

       The old_linux_dirent structure is declared as follows:

           struct old_linux_dirent {
               long  d_ino;              /* inode number */
               off_t d_off;              /* offset to this old_linux_dirent */
               unsigned short d_reclen;  /* length of this d_name */
               char  d_name[NAME_MAX+1]; /* filename (null-terminated) */
           }

       d_ino  is  an  inode  number.   d_off  is  the  distance  from the start of the directory to this old_linux_dirent.
       d_reclen is the size of d_name, not counting the terminating null byte ('\0').  d_name is a  null-terminated  file‐
       name.

RETURN VALUE
       On  success, 1 is returned.  On end of directory, 0 is returned.  On error, -1 is returned, and errno is set appro‐
       priately.

ERRORS
       EBADF  Invalid file descriptor fd.

       EFAULT Argument points outside the calling process's address space.

       EINVAL Result buffer is too small.

       ENOENT No such directory.

       ENOTDIR
              File descriptor does not refer to a directory.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       Glibc does not provide a wrapper for this system call; call it using syscall(2).   You  will  need  to  define  the
       old_linux_dirent structure yourself.  However, probably you should use readdir(3) instead.

       This system call does not exist on x86-64.

SEE ALSO
       getdents(2), readdir(3)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              READDIR(2)
</pre>
<pre zoom>
<span xsmall>2 fstatvfs</span>
STATVFS(3)                                       Linux Programmer's Manual                                      STATVFS(3)

NAME
       statvfs, fstatvfs - get filesystem statistics

SYNOPSIS
       #include <sys/statvfs.h>

       int statvfs(const char *path, struct statvfs *buf);
       int fstatvfs(int fd, struct statvfs *buf);

DESCRIPTION
       The function statvfs() returns information about a mounted filesystem.  path is the pathname of any file within the
       mounted filesystem.  buf is a pointer to a statvfs structure defined approximately as follows:

           struct statvfs {
               unsigned long  f_bsize;    /* Filesystem block size */
               unsigned long  f_frsize;   /* Fragment size */
               fsblkcnt_t     f_blocks;   /* Size of fs in f_frsize units */
               fsblkcnt_t     f_bfree;    /* Number of free blocks */
               fsblkcnt_t     f_bavail;   /* Number of free blocks for
                                             unprivileged users */
               fsfilcnt_t     f_files;    /* Number of inodes */
               fsfilcnt_t     f_ffree;    /* Number of free inodes */
               fsfilcnt_t     f_favail;   /* Number of free inodes for
                                             unprivileged users */
               unsigned long  f_fsid;     /* Filesystem ID */
               unsigned long  f_flag;     /* Mount flags */
               unsigned long  f_namemax;  /* Maximum filename length */
           };

       Here the types fsblkcnt_t and fsfilcnt_t are defined in <sys/types.h>.  Both used to be unsigned long.

       The field f_flag is a bit mask indicating various options that were employed when  mounting  this  filesystem.   It
       contains zero or more of the following flags:

       ST_MANDLOCK
              Mandatory locking is permitted on the filesystem (see fcntl(2)).

       ST_NOATIME
              Do not update access times; see mount(2).

       ST_NODEV
              Disallow access to device special files on this filesystem.

       ST_NODIRATIME
              Do not update directory access times; see mount(2).

       ST_NOEXEC
              Execution of programs is disallowed on this filesystem.

       ST_NOSUID
              The set-user-ID and set-group-ID bits are ignored by exec(3) for executable files on this filesystem

       ST_RDONLY
              This filesystem is mounted read-only.

       ST_RELATIME
              Update atime relative to mtime/ctime; see mount(2).

       ST_SYNCHRONOUS
              Writes are synched to the filesystem immediately (see the description of O_SYNC in open(2)).

       It is unspecified whether all members of the returned struct have meaningful values on all filesystems.

       fstatvfs() returns the same information about an open file referenced by descriptor fd.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES (statvfs())  Search permission is denied for a component of the path prefix of path.  (See also path_resolu‐
              tion(7).)

       EBADF  (fstatvfs()) fd is not a valid open file descriptor.

       EFAULT Buf or path points to an invalid address.

       EINTR  This call was interrupted by a signal; see signal(7).

       EIO    An I/O error occurred while reading from the filesystem.

       ELOOP  (statvfs()) Too many symbolic links were encountered in translating path.

       ENAMETOOLONG
              (statvfs()) path is too long.

       ENOENT (statvfs()) The file referred to by path does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOSYS The filesystem does not support this call.

       ENOTDIR
              (statvfs()) A component of the path prefix of path is not a directory.

       EOVERFLOW
              Some values were too large to be represented in the returned struct.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌──────────────────────┬───────────────┬─────────┐
       │Interface             │ Attribute     │ Value   │
       ├──────────────────────┼───────────────┼─────────┤
       │statvfs(), fstatvfs() │ Thread safety │ MT-Safe │
       └──────────────────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

       Only the ST_NOSUID and ST_RDONLY flags of the f_flag field are specified in POSIX.1.  To obtain definitions of  the
       remaining flags, one must define _GNU_SOURCE.

NOTES
       The Linux kernel has system calls statfs(2) and fstatfs(2) to support this library call.

       In glibc versions before 2.13, statvfs() populated the bits of the f_flag field by scanning the mount options shown
       in /proc/mounts.  However, starting with Linux 2.6.36, the underlying statfs(2) system call provides the  necessary
       information  via  the f_flags field, and since glibc version 2.13, the statvfs() function will use information from
       that field rather than scanning /proc/mounts.

       The glibc implementations of

           pathconf(path, _PC_REC_XFER_ALIGN);
           pathconf(path, _PC_ALLOC_SIZE_MIN);
           pathconf(path, _PC_REC_MIN_XFER_SIZE);

       respectively use the f_frsize, f_frsize, and f_bsize fields returned by a call to statvfs() with the argument path.

SEE ALSO
       statfs(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              STATVFS(3)
</pre>
<pre zoom>
<span xsmall>2 create_module</span>
CREATE_MODULE(2)                                 Linux Programmer's Manual                                CREATE_MODULE(2)

NAME
       create_module - create a loadable module entry

SYNOPSIS
       #include <linux/module.h>

       caddr_t create_module(const char *name, size_t size);

       Note: No declaration of this system call is provided in glibc headers; see NOTES.

DESCRIPTION
       Note: This system call is present only in kernels before Linux 2.6.

       create_module()  attempts  to  create  a loadable module entry and reserve the kernel memory that will be needed to
       hold the module.  This system call requires privilege.

RETURN VALUE
       On success, returns the kernel address at which the module will reside.  On error, -1 is returned and errno is  set
       appropriately.

ERRORS
       EEXIST A module by that name already exists.

       EFAULT name is outside the program's accessible address space.

       EINVAL The requested size is too small even for the module header information.

       ENOMEM The kernel could not allocate a contiguous block of memory large enough for the module.

       ENOSYS create_module() is not supported in this version of the kernel (e.g., the kernel is version 2.6 or later).

       EPERM  The caller was not privileged (did not have the CAP_SYS_MODULE capability).

VERSIONS
       This system call is present on Linux only up until kernel 2.4; it was removed in Linux 2.6.

CONFORMING TO
       create_module() is Linux-specific.

NOTES
       This  obsolete  system call is not supported by glibc.  No declaration is provided in glibc headers, but, through a
       quirk of history, glibc versions before 2.23 did export an ABI for this system call.  Therefore, in order to employ
       this system call, it was sufficient to manually declare the interface in your code; alternatively, you could invoke
       the system call using syscall(2).

SEE ALSO
       delete_module(2), init_module(2), query_module(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        CREATE_MODULE(2)
</pre>
<pre zoom>
<span xsmall>2 preadv2</span>
READV(2)                                         Linux Programmer's Manual                                        READV(2)

NAME
       readv, writev, preadv, pwritev, preadv2, pwritev2 - read or write data into multiple buffers

SYNOPSIS
       #include <sys/uio.h>

       ssize_t readv(int fd, const struct iovec *iov, int iovcnt);

       ssize_t writev(int fd, const struct iovec *iov, int iovcnt);

       ssize_t preadv(int fd, const struct iovec *iov, int iovcnt,
                      off_t offset);

       ssize_t pwritev(int fd, const struct iovec *iov, int iovcnt,
                       off_t offset);

       ssize_t preadv2(int fd, const struct iovec *iov, int iovcnt,
                       off_t offset, int flags);

       ssize_t pwritev2(int fd, const struct iovec *iov, int iovcnt,
                        off_t offset, int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       preadv(), pwritev():
           Since glibc 2.19:
               _DEFAULT_SOURCE
           Glibc 2.19 and earlier:
               _BSD_SOURCE

DESCRIPTION
       The  readv() system call reads iovcnt buffers from the file associated with the file descriptor fd into the buffers
       described by iov ("scatter input").

       The writev() system call writes iovcnt buffers of data described by iov  to  the  file  associated  with  the  file
       descriptor fd ("gather output").

       The pointer iov points to an array of iovec structures, defined in <sys/uio.h> as:

           struct iovec {
               void  *iov_base;    /* Starting address */
               size_t iov_len;     /* Number of bytes to transfer */
           };

       The readv() system call works just like read(2) except that multiple buffers are filled.

       The writev() system call works just like write(2) except that multiple buffers are written out.

       Buffers are processed in array order.  This means that readv() completely fills iov[0] before proceeding to iov[1],
       and so on.  (If there is insufficient data, then not all buffers pointed to by  iov  may  be  filled.)   Similarly,
       writev() writes out the entire contents of iov[0] before proceeding to iov[1], and so on.

       The  data transfers performed by readv() and writev() are atomic: the data written by writev() is written as a sin‐
       gle block that is not intermingled with output from writes in other processes (but see pipe(7) for  an  exception);
       analogously,  readv() is guaranteed to read a contiguous block of data from the file, regardless of read operations
       performed in other threads or processes that have file descriptors referring to the same open file description (see
       open(2)).

   preadv() and pwritev()
       The preadv() system call combines the functionality of readv() and pread(2).  It performs the same task as readv(),
       but adds a fourth argument, offset, which specifies the file offset at which the input  operation  is  to  be  per‐
       formed.

       The  pwritev()  system  call  combines  the  functionality of writev() and pwrite(2).  It performs the same task as
       writev(), but adds a fourth argument, offset, which specifies the file offset at which the output operation  is  to
       be performed.

       The file offset is not changed by these system calls.  The file referred to by fd must be capable of seeking.

   preadv2() and pwritev2()
       These system calls are similar to preadv() and pwritev() calls, but add a fifth argument, flags, which modifies the
       behavior on a per-call basis.

       Unlike preadv() and pwritev(), if the offset argument is -1, then the current file offset is used and updated.

       The flags argument contains a bitwise OR of zero or more of the following flags:

       RWF_DSYNC (since Linux 4.7)
              Provide a per-write equivalent of the O_DSYNC open(2) flag.  This flag is meaningful  only  for  pwritev2(),
              and its effect applies only to the data range written by the system call.

       RWF_HIPRI (since Linux 4.6)
              High priority read/write.  Allows block-based filesystems to use polling of the device, which provides lower
              latency, but may use additional resources.  (Currently, this feature is usable only  on  a  file  descriptor
              opened using the O_DIRECT flag.)

       RWF_SYNC (since Linux 4.7)
              Provide a per-write equivalent of the O_SYNC open(2) flag.  This flag is meaningful only for pwritev2(), and
              its effect applies only to the data range written by the system call.

       RWF_NOWAIT (since Linux 4.14)
              Do not wait for data which is not immediately available.  If this flag is specified,  the  preadv2()  system
              call  will  return  instantly if it would have to read data from the backing storage or wait for a lock.  If
              some data was successfully read, it will return the number of bytes read.  If no bytes were  read,  it  will
              return -1 and set errno to EAGAIN.  Currently, this flag is meaningful only for preadv2().

       RWF_APPEND (since Linux 4.16)
              Provide  a  per-write equivalent of the O_APPEND open(2) flag.  This flag is meaningful only for pwritev2(),
              and its effect applies only to the data range written by the system call.   The  offset  argument  does  not
              affect  the  write  operation;  the  data is always appended to the end of the file.  However, if the offset
              argument is -1, the current file offset is updated.

RETURN VALUE
       On success, readv(), preadv() and preadv2() return the number of bytes read;  writev(),  pwritev()  and  pwritev2()
       return the number of bytes written.

       Note  that  it  is  not  an  error  for  a  successful call to transfer fewer bytes than requested (see read(2) and
       write(2)).

       On error, -1 is returned, and errno is set appropriately.

ERRORS
       The errors are as given for read(2) and write(2).  Furthermore, preadv(), preadv2(), pwritev(), and pwritev2()  can
       also fail for the same reasons as lseek(2).  Additionally, the following errors are defined:

       EINVAL The sum of the iov_len values overflows an ssize_t value.

       EINVAL The vector count, iovcnt, is less than zero or greater than the permitted maximum.

       EINVAL An unknown flag is specified in flags.

VERSIONS
       preadv() and pwritev() first appeared in Linux 2.6.30; library support was added in glibc 2.10.

       preadv2() and pwritev2() first appeared in Linux 4.6.  Library support was added in glibc 2.26.

CONFORMING TO
       readv(), writev(): POSIX.1-2001, POSIX.1-2008, 4.4BSD (these system calls first appeared in 4.2BSD).

       preadv(), pwritev(): nonstandard, but present also on the modern BSDs.

       preadv2(), pwritev2(): nonstandard Linux extension.

NOTES
       POSIX.1 allows an implementation to place a limit on the number of items that can be passed in iov.  An implementa‐
       tion can advertise its limit by defining  IOV_MAX  in  <limits.h>  or  at  run  time  via  the  return  value  from
       sysconf(_SC_IOV_MAX).  On modern Linux systems, the limit is 1024.  Back in Linux 2.0 days, this limit was 16.

   C library/kernel differences
       The  raw preadv() and pwritev() system calls have call signatures that differ slightly from that of the correspond‐
       ing GNU C library wrapper functions shown in the SYNOPSIS.  The final argument, offset, is unpacked by the  wrapper
       functions into two arguments in the system calls:

           unsigned long pos_l, unsigned long pos

       These arguments contain, respectively, the low order and high order 32 bits of offset.

   Historical C library/kernel differences
       To  deal  with the fact that IOV_MAX was so low on early versions of Linux, the glibc wrapper functions for readv()
       and writev() did some extra work if they detected that the underlying kernel system call failed because this  limit
       was  exceeded.   In  the case of readv(), the wrapper function allocated a temporary buffer large enough for all of
       the items specified by iov, passed that buffer in a call to read(2), copied data from the buffer to  the  locations
       specified  by  the  iov_base  fields  of  the elements of iov, and then freed the buffer.  The wrapper function for
       writev() performed the analogous task using a temporary buffer and a call to write(2).

       The need for this extra effort in the glibc wrapper functions went away with Linux 2.2 and later.   However,  glibc
       continued to provide this behavior until version 2.10.  Starting with glibc version 2.9, the wrapper functions pro‐
       vide this behavior only if the library detects that the system is running a Linux kernel older than version  2.6.18
       (an  arbitrarily  selected kernel version).  And since glibc 2.20 (which requires a minimum Linux kernel version of
       2.6.32), the glibc wrapper functions always just directly invoke the system calls.

EXAMPLE
       The following code sample demonstrates the use of writev():

           char *str0 = "hello ";
           char *str1 = "world\n";
           struct iovec iov[2];
           ssize_t nwritten;

           iov[0].iov_base = str0;
           iov[0].iov_len = strlen(str0);
           iov[1].iov_base = str1;
           iov[1].iov_len = strlen(str1);

           nwritten = writev(STDOUT_FILENO, iov, 2);

SEE ALSO
       pread(2), read(2), write(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                                READV(2)
</pre>
<pre zoom>
<span xsmall>2 faccessat</span>
ACCESS(2)                                        Linux Programmer's Manual                                       ACCESS(2)

NAME
       access, faccessat - check user's permissions for a file

SYNOPSIS
       #include <unistd.h>

       int access(const char *pathname, int mode);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <unistd.h>

       int faccessat(int dirfd, const char *pathname, int mode, int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       faccessat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       access()  checks  whether  the calling process can access the file pathname.  If pathname is a symbolic link, it is
       dereferenced.

       The mode specifies the accessibility check(s) to be performed, and is either the value F_OK, or a  mask  consisting
       of  the  bitwise OR of one or more of R_OK, W_OK, and X_OK.  F_OK tests for the existence of the file.  R_OK, W_OK,
       and X_OK test whether the file exists and grants read, write, and execute permissions, respectively.

       The check is done using the calling process's real UID and GID, rather than the effective IDs as is done when actu‐
       ally  attempting an operation (e.g., open(2)) on the file.  Similarly, for the root user, the check uses the set of
       permitted capabilities rather than the set of effective capabilities; and for non-root users,  the  check  uses  an
       empty set of capabilities.

       This allows set-user-ID programs and capability-endowed programs to easily determine the invoking user's authority.
       In other words, access() does not answer the "can I read/write/execute this file?" question.  It answers a slightly
       different  question:  "(assuming  I'm  a setuid binary) can the user who invoked me read/write/execute this file?",
       which gives set-user-ID programs the possibility to prevent malicious users from causing them to read  files  which
       users shouldn't be able to read.

       If  the  calling process is privileged (i.e., its real UID is zero), then an X_OK check is successful for a regular
       file if execute permission is enabled for any of the file owner, group, or other.

   faccessat()
       The faccessat() system call operates in exactly the same way as access(),  except  for  the  differences  described
       here.

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       access() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like access()).

       If pathname is absolute, then dirfd is ignored.

       flags is constructed by ORing together zero or more of the following values:

       AT_EACCESS
              Perform access checks using the effective user and group IDs.  By default, faccessat()  uses  the  real  IDs
              (like access()).

       AT_SYMLINK_NOFOLLOW
              If pathname is a symbolic link, do not dereference it: instead return information about the link itself.

       See openat(2) for an explanation of the need for faccessat().

RETURN VALUE
       On  success  (all  requested permissions granted, or mode is F_OK and the file exists), zero is returned.  On error
       (at least one bit in mode asked for a permission that is denied, or mode is F_OK and the file does  not  exist,  or
       some other error occurred), -1 is returned, and errno is set appropriately.

ERRORS
       access() and faccessat() shall fail if:

       EACCES The  requested access would be denied to the file, or search permission is denied for one of the directories
              in the path prefix of pathname.  (See also path_resolution(7).)

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A component of pathname does not exist or is a dangling symbolic link.

       ENOTDIR
              A component used as a directory in pathname is not, in fact, a directory.

       EROFS  Write permission was requested for a file on a read-only filesystem.

       access() and faccessat() may fail if:

       EFAULT pathname points outside your accessible address space.

       EINVAL mode was incorrectly specified.

       EIO    An I/O error occurred.

       ENOMEM Insufficient kernel memory was available.

       ETXTBSY
              Write access was requested to an executable which is being executed.

       The following additional errors can occur for faccessat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       faccessat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       access(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       faccessat(): POSIX.1-2008.

NOTES
       Warning: Using these calls to check if a user is authorized to, for example, open a file before actually  doing  so
       using  open(2) creates a security hole, because the user might exploit the short time interval between checking and
       opening the file to manipulate it.  For this reason, the use of this system call should be avoided.  (In the  exam‐
       ple  just described, a safer alternative would be to temporarily switch the process's effective user ID to the real
       ID and then call open(2).)

       access() always dereferences symbolic links.  If you need to check the permissions on a symbolic link, use  facces‐
       sat() with the flag AT_SYMLINK_NOFOLLOW.

       These calls return an error if any of the access types in mode is denied, even if some of the other access types in
       mode are permitted.

       If the calling process has appropriate privileges (i.e., is superuser), POSIX.1-2001 permits an  implementation  to
       indicate  success  for  an  X_OK check even if none of the execute file permission bits are set.  Linux does not do
       this.

       A file is accessible only if the permissions on each of the directories in the path prefix of pathname grant search
       (i.e.,  execute) access.  If any directory is inaccessible, then the access() call fails, regardless of the permis‐
       sions on the file itself.

       Only access bits are checked, not the file type or contents.  Therefore, if a directory is found to be writable, it
       probably  means  that  files  can be created in the directory, and not that the directory can be written as a file.
       Similarly, a DOS file may be found to be "executable," but the execve(2) call will still fail.

       These calls may not work correctly on NFSv2 filesystems with UID mapping enabled, because UID mapping  is  done  on
       the  server  and hidden from the client, which checks permissions.  (NFS versions 3 and higher perform the check on
       the server.)  Similar problems can occur to FUSE mounts.

   C library/kernel differences
       The raw faccessat() system call takes only the first three arguments.  The AT_EACCESS and AT_SYMLINK_NOFOLLOW flags
       are actually implemented within the glibc wrapper function for faccessat().  If either of these flags is specified,
       then the wrapper function employs fstatat(2) to determine access permissions.

   Glibc notes
       On older kernels where faccessat() is unavailable (and when the AT_EACCESS and AT_SYMLINK_NOFOLLOW  flags  are  not
       specified),  the  glibc  wrapper function falls back to the use of access().  When pathname is a relative pathname,
       glibc constructs a pathname based on the symbolic link in /proc/self/fd that corresponds to the dirfd argument.

BUGS
       In kernel 2.4 (and earlier) there is some strangeness in the handling of X_OK tests for superuser.   If  all  cate‐
       gories  of  execute permission are disabled for a nondirectory file, then the only access() test that returns -1 is
       when mode is specified as just X_OK; if R_OK or W_OK is also specified in mode, then access() returns  0  for  such
       files.  Early 2.6 kernels (up to and including 2.6.3) also behaved in the same way as kernel 2.4.

       In  kernels  before  2.6.20,  these  calls  ignored the effect of the MS_NOEXEC flag if it was used to mount(2) the
       underlying filesystem.  Since kernel 2.6.20, the MS_NOEXEC flag is honored.

SEE ALSO
       chmod(2), chown(2), open(2), setgid(2), setuid(2), stat(2), euidaccess(3), credentials(7), path_resolution(7), sym‐
       link(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2016-03-15                                               ACCESS(2)
</pre>
<pre zoom>
<span xsmall>2 setuid</span>
SETUID(2)                                        Linux Programmer's Manual                                       SETUID(2)

NAME
       setuid - set user identity

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int setuid(uid_t uid);

DESCRIPTION
       setuid()  sets the effective user ID of the calling process.  If the calling process is privileged (more precisely:
       if the process has the CAP_SETUID capability in its user namespace), the real UID and saved  set-user-ID  are  also
       set.

       Under  Linux, setuid() is implemented like the POSIX version with the _POSIX_SAVED_IDS feature.  This allows a set-
       user-ID (other than root) program to drop all of its user privileges, do some un-privileged work, and then reengage
       the original effective user ID in a secure manner.

       If  the  user is root or the program is set-user-ID-root, special care must be taken: setuid() checks the effective
       user ID of the caller and if it is the superuser, all process-related user ID's are set to  uid.   After  this  has
       occurred, it is impossible for the program to regain root privileges.

       Thus,  a  set-user-ID-root  program wishing to temporarily drop root privileges, assume the identity of an unprivi‐
       leged user, and then regain  root  privileges  afterward  cannot  use  setuid().   You  can  accomplish  this  with
       seteuid(2).

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

       Note:  there  are cases where setuid() can fail even when the caller is UID 0; it is a grave security error to omit
       checking for a failure return from setuid().

ERRORS
       EAGAIN The call would change the caller's real UID (i.e., uid does not match the caller's real UID), but there  was
              a temporary failure allocating the necessary kernel data structures.

       EAGAIN uid  does not match the real user ID of the caller and this call would bring the number of processes belong‐
              ing to the real user ID uid over the caller's RLIMIT_NPROC resource limit.  Since Linux 3.1, this error case
              no  longer  occurs  (but  robust applications should check for this error); see the description of EAGAIN in
              execve(2).

       EINVAL The user ID specified in uid is not valid in this user namespace.

       EPERM  The user is not privileged (Linux: does not have the CAP_SETUID capability) and uid does not match the  real
              UID or saved set-user-ID of the calling process.

CONFORMING TO
       POSIX.1-2001,  POSIX.1-2008,  SVr4.   Not quite compatible with the 4.4BSD call, which sets all of the real, saved,
       and effective user IDs.

NOTES
       Linux has the concept of the filesystem user ID, normally equal to the effective user ID.  The setuid()  call  also
       sets the filesystem user ID of the calling process.  See setfsuid(2).

       If uid is different from the old effective UID, the process will be forbidden from leaving core dumps.

       The  original  Linux setuid() system call supported only 16-bit user IDs.  Subsequently, Linux 2.4 added setuid32()
       supporting 32-bit IDs.  The glibc setuid() wrapper function transparently deals with the  variation  across  kernel
       versions.

   C library/kernel differences
       At  the  kernel level, user IDs and group IDs are a per-thread attribute.  However, POSIX requires that all threads
       in a process share the same credentials.  The NPTL threading implementation handles the POSIX requirements by  pro‐
       viding  wrapper  functions for the various system calls that change process UIDs and GIDs.  These wrapper functions
       (including the one for setuid()) employ a signal-based technique to ensure that when  one  thread  changes  creden‐
       tials, all of the other threads in the process also change their credentials.  For details, see nptl(7).

SEE ALSO
       getuid(2), seteuid(2), setfsuid(2), setreuid(2), capabilities(7), credentials(7), user_namespaces(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SETUID(2)
</pre>
<pre zoom>
<span xsmall>2 umount2</span>
UMOUNT(2)                                        Linux Programmer's Manual                                       UMOUNT(2)

NAME
       umount, umount2 - unmount filesystem

SYNOPSIS
       #include <sys/mount.h>

       int umount(const char *target);

       int umount2(const char *target, int flags);

DESCRIPTION
       umount() and umount2() remove the attachment of the (topmost) filesystem mounted on target.

       Appropriate privilege (Linux: the CAP_SYS_ADMIN capability) is required to unmount filesystems.

       Linux 2.1.116 added the umount2() system call, which, like umount(), unmounts a target, but allows additional flags
       controlling the behavior of the operation:

       MNT_FORCE (since Linux 2.1.116)
              Ask the filesystem to abort pending requests before attempting the unmount.  This may allow the  unmount  to
              complete  without  waiting  for  an  inaccessible  server,  but  could  cause data loss.  If, after aborting
              requests, some processes still have active references to the filesystem, the unmount will still fail.  As at
              Linux  4.12,  MNT_FORCE is supported only on the following filesystems: 9p (since Linux 2.6.16), ceph (since
              Linux 2.6.34), cifs (since Linux 2.6.12), fuse (since Linux 2.6.16), lustre  (since  Linux  3.11),  and  NFS
              (since Linux 2.1.116).

       MNT_DETACH (since Linux 2.4.11)
              Perform  a  lazy  unmount:  make  the  mount  point unavailable for new accesses, immediately disconnect the
              filesystem and all filesystems mounted below it from each other and from the mount table, and actually  per‐
              form the unmount when the mount point ceases to be busy.

       MNT_EXPIRE (since Linux 2.6.8)
              Mark  the  mount  point  as  expired.   If  a  mount  point is not currently in use, then an initial call to
              umount2() with this flag fails with the error EAGAIN, but marks the mount point as expired.  The mount point
              remains  expired as long as it isn't accessed by any process.  A second umount2() call specifying MNT_EXPIRE
              unmounts an expired mount point.  This flag cannot be specified with either MNT_FORCE or MNT_DETACH.

       UMOUNT_NOFOLLOW (since Linux 2.6.34)
              Don't dereference target if it is a symbolic link.  This flag allows security problems to be avoided in set-
              user-ID-root programs that allow unprivileged users to unmount filesystems.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       The error values given below result from filesystem type independent errors.  Each filesystem type may have its own
       special errors and its own special behavior.  See the Linux kernel source code for details.

       EAGAIN A call to umount2() specifying MNT_EXPIRE successfully marked an unbusy filesystem as expired.

       EBUSY  target could not be unmounted because it is busy.

       EFAULT target points outside the user address space.

       EINVAL target is not a mount point.

       EINVAL umount2() was called with MNT_EXPIRE and either MNT_DETACH or MNT_FORCE.

       EINVAL (since Linux 2.6.34)
              umount2() was called with an invalid flag value in flags.

       ENAMETOOLONG
              A pathname was longer than MAXPATHLEN.

       ENOENT A pathname was empty or had a nonexistent component.

       ENOMEM The kernel could not allocate a free page to copy filenames or data into.

       EPERM  The caller does not have the required privileges.

VERSIONS
       MNT_DETACH and MNT_EXPIRE are available in glibc since version 2.11.

CONFORMING TO
       These functions are Linux-specific and should not be used in programs intended to be portable.

NOTES
   umount() and shared mount points
       Shared mount points cause any mount activity on a mount point, including umount() operations, to  be  forwarded  to
       every  shared  mount point in the peer group and every slave mount of that peer group.  This means that umount() of
       any peer in a set of shared mounts will cause all of its peers to be unmounted  and  all  of  their  slaves  to  be
       unmounted as well.

       This propagation of unmount activity can be particularly surprising on systems where every mount point is shared by
       default.  On such systems, recursively bind mounting the root directory of the filesystem onto a  subdirectory  and
       then  later unmounting that subdirectory with MNT_DETACH will cause every mount in the mount namespace to be lazily
       unmounted.

       To ensure umount() does not propagate in this fashion, the mount point may be remounted using a mount() call with a
       mount_flags argument that includes both MS_REC and MS_PRIVATE prior to umount() being called.

   Historical details
       The  original  umount()  function  was called as umount(device) and would return ENOTBLK when called with something
       other than a block device.  In Linux 0.98p4, a call umount(dir) was added, in order to support  anonymous  devices.
       In  Linux  2.3.99-pre7,  the  call  umount(device)  was removed, leaving only umount(dir) (since now devices can be
       mounted in more than one place, so specifying the device does not suffice).

SEE ALSO
       mount(2), mount_namespaces(7), path_resolution(7), mount(8), umount(8)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               UMOUNT(2)
</pre>
<pre zoom>
<span xsmall>2 unlinkat</span>
UNLINK(2)                                        Linux Programmer's Manual                                       UNLINK(2)

NAME
       unlink, unlinkat - delete a name and possibly the file it refers to

SYNOPSIS
       #include <unistd.h>

       int unlink(const char *pathname);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <unistd.h>

       int unlinkat(int dirfd, const char *pathname, int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       unlinkat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       unlink()  deletes  a  name from the filesystem.  If that name was the last link to a file and no processes have the
       file open, the file is deleted and the space it was using is made available for reuse.

       If the name was the last link to a file but any processes still have the file open, the file will remain  in  exis‐
       tence until the last file descriptor referring to it is closed.

       If the name referred to a symbolic link, the link is removed.

       If  the  name referred to a socket, FIFO, or device, the name for it is removed but processes which have the object
       open may continue to use it.

   unlinkat()
       The unlinkat() system call operates in exactly the same way as either unlink() or rmdir(2) (depending on whether or
       not flags includes the AT_REMOVEDIR flag) except for the differences described here.

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       unlink() and rmdir(2) for a relative pathname).

       If the pathname given in pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted
       relative to the current working directory of the calling process (like unlink() and rmdir(2)).

       If the pathname given in pathname is absolute, then dirfd is ignored.

       flags is a bit mask that can either be specified as 0, or by ORing together flag values that control the  operation
       of unlinkat().  Currently, only one such flag is defined:

       AT_REMOVEDIR
              By  default, unlinkat() performs the equivalent of unlink() on pathname.  If the AT_REMOVEDIR flag is speci‐
              fied, then performs the equivalent of rmdir(2) on pathname.

       See openat(2) for an explanation of the need for unlinkat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Write access to the directory containing pathname is not allowed for the process's effective UID, or one  of
              the directories in pathname did not allow search permission.  (See also path_resolution(7).)

       EBUSY  The file pathname cannot be unlinked because it is being used by the system or another process; for example,
              it is a mount point or the NFS client software created it to represent  an  active  but  otherwise  nameless
              inode ("NFS silly renamed").

       EFAULT pathname points outside your accessible address space.

       EIO    An I/O error occurred.

       EISDIR pathname refers to a directory.  (This is the non-POSIX value returned by Linux since 2.1.132.)

       ELOOP  Too many symbolic links were encountered in translating pathname.

       ENAMETOOLONG
              pathname was too long.

       ENOENT A component in pathname does not exist or is a dangling symbolic link, or pathname is empty.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component used as a directory in pathname is not, in fact, a directory.

       EPERM  The system does not allow unlinking of directories, or unlinking of directories requires privileges that the
              calling process doesn't have.  (This is the POSIX prescribed error return; as  noted  above,  Linux  returns
              EISDIR for this case.)

       EPERM (Linux only)
              The filesystem does not allow unlinking of files.

       EPERM or EACCES
              The  directory  containing pathname has the sticky bit (S_ISVTX) set and the process's effective UID is nei‐
              ther the UID of the file to be deleted nor that of the directory containing it, and the process is not priv‐
              ileged (Linux: does not have the CAP_FOWNER capability).

       EPERM  The file to be unlinked is marked immutable or append-only.  (See ioctl_iflags(2).)

       EROFS  pathname refers to a file on a read-only filesystem.

       The  same  errors  that  occur  for  unlink() and rmdir(2) can also occur for unlinkat().  The following additional
       errors can occur for unlinkat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL An invalid flag value was specified in flags.

       EISDIR pathname refers to a directory, and AT_REMOVEDIR was not specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       unlinkat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       unlink(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       unlinkat(): POSIX.1-2008.

NOTES
   Glibc notes
       On older kernels where unlinkat() is unavailable, the glibc wrapper function falls back to the use of  unlink()  or
       rmdir(2).   When  pathname  is  a  relative  pathname,  glibc  constructs  a pathname based on the symbolic link in
       /proc/self/fd that corresponds to the dirfd argument.

BUGS
       Infelicities in the protocol underlying NFS can cause the unexpected disappearance of files which are  still  being
       used.

SEE ALSO
       rm(1),  unlink(1),  chmod(2),  link(2),  mknod(2), open(2), rename(2), rmdir(2), mkfifo(3), remove(3), path_resolu‐
       tion(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               UNLINK(2)
</pre>
<pre zoom>
<span xsmall>2 fallocate</span>
FALLOCATE(2)                                     Linux Programmer's Manual                                    FALLOCATE(2)

NAME
       fallocate - manipulate file space

SYNOPSIS
       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <fcntl.h>

       int fallocate(int fd, int mode, off_t offset, off_t len);

DESCRIPTION
       This  is  a  nonportable,  Linux-specific system call.  For the portable, POSIX.1-specified method of ensuring that
       space is allocated for a file, see posix_fallocate(3).

       fallocate() allows the caller to directly manipulate the allocated disk space for the file referred to  by  fd  for
       the byte range starting at offset and continuing for len bytes.

       The mode argument determines the operation to be performed on the given range.  Details of the supported operations
       are given in the subsections below.

   Allocating disk space
       The default operation (i.e., mode is zero) of fallocate() allocates the disk space within the  range  specified  by
       offset  and  len.   The  file  size (as reported by stat(2)) will be changed if offset+len is greater than the file
       size.  Any subregion within the range specified by offset and len that did not contain data before the call will be
       initialized  to zero.  This default behavior closely resembles the behavior of the posix_fallocate(3) library func‐
       tion, and is intended as a method of optimally implementing that function.

       After a successful call, subsequent writes into the range specified by offset and len are guaranteed  not  to  fail
       because of lack of disk space.

       If  the  FALLOC_FL_KEEP_SIZE flag is specified in mode, the behavior of the call is similar, but the file size will
       not be changed even if offset+len is greater than the file size.  Preallocating zeroed blocks beyond the end of the
       file in this manner is useful for optimizing append workloads.

       If  the  FALLOC_FL_UNSHARE  flag is specified in mode, shared file data extents will be made private to the file to
       guarantee that a subsequent write will not fail due to lack of space.  Typically, this will be done by performing a
       copy-on-write operation on all shared data in the file.  This flag may not be supported by all filesystems.

       Because  allocation  is  done  in block size chunks, fallocate() may allocate a larger range of disk space than was
       specified.

   Deallocating file space
       Specifying the FALLOC_FL_PUNCH_HOLE flag (available since Linux 2.6.38) in mode deallocates space (i.e., creates  a
       hole)  in  the  byte  range  starting  at offset and continuing for len bytes.  Within the specified range, partial
       filesystem blocks are zeroed, and whole filesystem blocks are removed from the file.  After a successful call, sub‐
       sequent reads from this range will return zeros.

       The FALLOC_FL_PUNCH_HOLE flag must be ORed with FALLOC_FL_KEEP_SIZE in mode; in other words, even when punching off
       the end of the file, the file size (as reported by stat(2)) does not change.

       Not all filesystems support FALLOC_FL_PUNCH_HOLE; if a filesystem  doesn't  support  the  operation,  an  error  is
       returned.  The operation is supported on at least the following filesystems:

       *  XFS (since Linux 2.6.38)

       *  ext4 (since Linux 3.0)

       *  Btrfs (since Linux 3.7)

       *  tmpfs(5) (since Linux 3.5)

   Collapsing file space
       Specifying the FALLOC_FL_COLLAPSE_RANGE flag (available since Linux 3.15) in mode removes a byte range from a file,
       without leaving a hole.  The byte range to be collapsed starts at offset and continues for len bytes.  At the  com‐
       pletion  of  the  operation,  the  contents of the file starting at the location offset+len will be appended at the
       location offset, and the file will be len bytes smaller.

       A filesystem may place limitations on the granularity of the operation, in order to  ensure  efficient  implementa‐
       tion.  Typically, offset and len must be a multiple of the filesystem logical block size, which varies according to
       the filesystem type and configuration.  If a filesystem has such a requirement, fallocate() fails  with  the  error
       EINVAL if this requirement is violated.

       If  the  region  specified by offset plus len reaches or passes the end of file, an error is returned; instead, use
       ftruncate(2) to truncate a file.

       No other flags may be specified in mode in conjunction with FALLOC_FL_COLLAPSE_RANGE.

       As at Linux 3.15, FALLOC_FL_COLLAPSE_RANGE is supported by ext4 (only for extent-based files) and XFS.

   Zeroing file space
       Specifying the FALLOC_FL_ZERO_RANGE flag (available since Linux 3.15) in mode zeros space in the byte range  start‐
       ing  at  offset  and continuing for len bytes.  Within the specified range, blocks are preallocated for the regions
       that span the holes in the file.  After a successful call, subsequent reads from this range will return zeros.

       Zeroing is done within the filesystem preferably by converting the range into  unwritten  extents.   This  approach
       means  that  the  specified range will not be physically zeroed out on the device (except for partial blocks at the
       either end of the range), and I/O is (otherwise) required only to update metadata.

       If the FALLOC_FL_KEEP_SIZE flag is additionally specified in mode, the behavior of the call  is  similar,  but  the
       file  size will not be changed even if offset+len is greater than the file size.  This behavior is the same as when
       preallocating space with FALLOC_FL_KEEP_SIZE specified.

       Not all filesystems support FALLOC_FL_ZERO_RANGE; if a filesystem  doesn't  support  the  operation,  an  error  is
       returned.  The operation is supported on at least the following filesystems:

       *  XFS (since Linux 3.15)

       *  ext4, for extent-based files (since Linux 3.15)

       *  SMB3 (since Linux 3.17)

       *  Btrfs (since Linux 4.16)

   Increasing file space
       Specifying  the FALLOC_FL_INSERT_RANGE flag (available since Linux 4.1) in mode increases the file space by insert‐
       ing a hole within the file size without overwriting any existing data.  The hole will start at offset and  continue
       for  len  bytes.   When inserting the hole inside file, the contents of the file starting at offset will be shifted
       upward (i.e., to a higher file offset) by len bytes.  Inserting a hole inside a file increases the file size by len
       bytes.

       This  mode has the same limitations as FALLOC_FL_COLLAPSE_RANGE regarding the granularity of the operation.  If the
       granularity requirements are not met, fallocate() fails with the error EINVAL.   If  the  offset  is  equal  to  or
       greater  than  the  end  of  file, an error is returned.  For such operations (i.e., inserting a hole at the end of
       file), ftruncate(2) should be used.

       No other flags may be specified in mode in conjunction with FALLOC_FL_INSERT_RANGE.

       FALLOC_FL_INSERT_RANGE requires filesystem support.  Filesystems that support this  operation  include  XFS  (since
       Linux 4.1) and ext4 (since Linux 4.2).

RETURN VALUE
       On success, fallocate() returns zero.  On error, -1 is returned and errno is set to indicate the error.

ERRORS
       EBADF  fd is not a valid file descriptor, or is not opened for writing.

       EFBIG  offset+len exceeds the maximum file size.

       EFBIG  mode is FALLOC_FL_INSERT_RANGE, and the current file size+len exceeds the maximum file size.

       EINTR  A signal was caught during execution; see signal(7).

       EINVAL offset was less than 0, or len was less than or equal to 0.

       EINVAL mode is FALLOC_FL_COLLAPSE_RANGE and the range specified by offset plus len reaches or passes the end of the
              file.

       EINVAL mode is FALLOC_FL_INSERT_RANGE and the range specified by offset reaches or passes the end of the file.

       EINVAL mode is FALLOC_FL_COLLAPSE_RANGE or FALLOC_FL_INSERT_RANGE, but either offset or len is not  a  multiple  of
              the filesystem block size.

       EINVAL mode contains one of FALLOC_FL_COLLAPSE_RANGE or FALLOC_FL_INSERT_RANGE and also other flags; no other flags
              are permitted with FALLOC_FL_COLLAPSE_RANGE or FALLOC_FL_INSERT_RANGE.

       EINVAL mode is FALLOC_FL_COLLAPSE_RANGE or FALLOC_FL_ZERO_RANGE or FALLOC_FL_INSERT_RANGE, but the file referred to
              by fd is not a regular file.

       EIO    An I/O error occurred while reading from or writing to a filesystem.

       ENODEV fd does not refer to a regular file or a directory.  (If fd is a pipe or FIFO, a different error results.)

       ENOSPC There is not enough space left on the device containing the file referred to by fd.

       ENOSYS This kernel does not implement fallocate().

       EOPNOTSUPP
              The  filesystem  containing  the  file referred to by fd does not support this operation; or the mode is not
              supported by the filesystem containing the file referred to by fd.

       EPERM  The file referred to by fd is marked immutable (see chattr(1)).

       EPERM  mode specifies FALLOC_FL_PUNCH_HOLE or  FALLOC_FL_COLLAPSE_RANGE  or  FALLOC_FL_INSERT_RANGE  and  the  file
              referred to by fd is marked append-only (see chattr(1)).

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       ESPIPE fd refers to a pipe or FIFO.

       ETXTBSY
              mode  specifies  FALLOC_FL_COLLAPSE_RANGE  or FALLOC_FL_INSERT_RANGE, but the file referred to by fd is cur‐
              rently being executed.

VERSIONS
       fallocate() is available on Linux since kernel 2.6.23.  Support is provided by glibc since version 2.10.  The  FAL‐
       LOC_FL_* flags are defined in glibc headers only since version 2.18.

CONFORMING TO
       fallocate() is Linux-specific.

SEE ALSO
       fallocate(1), ftruncate(2), posix_fadvise(3), posix_fallocate(3)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                            FALLOCATE(2)
</pre>
<pre zoom>
<span xsmall>2 outsl</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 rt_sigtimedwait</span>
SIGWAITINFO(2)                                   Linux Programmer's Manual                                  SIGWAITINFO(2)

NAME
       sigwaitinfo, sigtimedwait, rt_sigtimedwait - synchronously wait for queued signals

SYNOPSIS
       #include <signal.h>

       int sigwaitinfo(const sigset_t *set, siginfo_t *info);

       int sigtimedwait(const sigset_t *set, siginfo_t *info,
                        const struct timespec *timeout);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       sigwaitinfo(), sigtimedwait(): _POSIX_C_SOURCE >= 199309L

DESCRIPTION
       sigwaitinfo()  suspends  execution  of the calling thread until one of the signals in set is pending (If one of the
       signals in set is already pending for the calling thread, sigwaitinfo() will return immediately.)

       sigwaitinfo() removes the signal from the set of pending signals and returns the  signal  number  as  its  function
       result.   If the info argument is not NULL, then the buffer that it points to is used to return a structure of type
       siginfo_t (see sigaction(2)) containing information about the signal.

       If multiple signals in set are pending for the caller, the signal that is retrieved by sigwaitinfo() is  determined
       according to the usual ordering rules; see signal(7) for further details.

       sigtimedwait()  operates  in exactly the same way as sigwaitinfo() except that it has an additional argument, time‐
       out, which specifies the interval for which the thread is suspended waiting for a signal.  (This interval  will  be
       rounded  up  to  the system clock granularity, and kernel scheduling delays mean that the interval may overrun by a
       small amount.)  This argument is of the following type:

           struct timespec {
               long    tv_sec;         /* seconds */
               long    tv_nsec;        /* nanoseconds */
           }

       If both fields of this structure are specified as 0, a  poll  is  performed:  sigtimedwait()  returns  immediately,
       either  with information about a signal that was pending for the caller, or with an error if none of the signals in
       set was pending.

RETURN VALUE
       On success, both sigwaitinfo() and sigtimedwait() return a signal number (i.e., a value  greater  than  zero).   On
       failure both calls return -1, with errno set to indicate the error.

ERRORS
       EAGAIN No signal in set was became pending within the timeout period specified to sigtimedwait().

       EINTR  The  wait was interrupted by a signal handler; see signal(7).  (This handler was for a signal other than one
              of those in set.)

       EINVAL timeout was invalid.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       In normal usage, the calling program blocks the signals in set via a prior call  to  sigprocmask(2)  (so  that  the
       default  disposition  for  these signals does not occur if they become pending between successive calls to sigwait‐
       info() or sigtimedwait()) and does not establish handlers for these signals.  In a multithreaded program, the  sig‐
       nal  should be blocked in all threads, in order to prevent the signal being treated according to its default dispo‐
       sition in a thread other than the one calling sigwaitinfo() or sigtimedwait()).

       The set of signals that is pending for a given thread is the union of the set of signals that is  pending  specifi‐
       cally for that thread and the set of signals that is pending for the process as a whole (see signal(7)).

       Attempts to wait for SIGKILL and SIGSTOP are silently ignored.

       If  multiple  threads  of  a process are blocked waiting for the same signal(s) in sigwaitinfo() or sigtimedwait(),
       then exactly one of the threads will actually receive the signal if it becomes pending for the process as a  whole;
       which of the threads receives the signal is indeterminate.

       sigwaitinfo()  or  sigtimedwait(),  can't  be used to receive signals that are synchronously generated, such as the
       SIGSEGV signal that results from accessing an invalid memory address or the SIGFPE  signal  that  results  from  an
       arithmetic error.  Such signals can be caught only via signal handler.

       POSIX  leaves  the  meaning  of a NULL value for the timeout argument of sigtimedwait() unspecified, permitting the
       possibility that this has the same meaning as a call to sigwaitinfo(), and indeed this is what is done on Linux.

   C library/kernel differences
       On Linux, sigwaitinfo() is a library function implemented on top of sigtimedwait().

       The glibc wrapper functions for sigwaitinfo() and sigtimedwait() silently ignore attempts to wait for the two real-
       time signals that are used internally by the NPTL threading implementation.  See nptl(7) for details.

       The  original Linux system call was named sigtimedwait().  However, with the addition of real-time signals in Linux
       2.2, the fixed-size, 32-bit sigset_t type supported by that system call was no  longer  fit  for  purpose.   Conse‐
       quently, a new system call, rt_sigtimedwait(), was added to support an enlarged sigset_t type.  The new system call
       takes a fourth argument, size_t sigsetsize, which specifies the size in bytes of the signal set in set.  This argu‐
       ment  is  currently required to have the value sizeof(sigset_t) (or the error EINVAL results).  The glibc sigtimed‐
       wait() wrapper function hides these details from us, transparently calling rt_sigtimedwait() when the  kernel  pro‐
       vides it.

SEE ALSO
       kill(2),  sigaction(2),  signal(2),  signalfd(2),  sigpending(2),  sigprocmask(2),  sigqueue(3), sigsetops(3), sig‐
       wait(3), signal(7), time(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                          SIGWAITINFO(2)
</pre>
<pre zoom>
<span xsmall>2 futex</span>
FUTEX(2)                                         Linux Programmer's Manual                                        FUTEX(2)

NAME
       futex - fast user-space locking

SYNOPSIS
       #include <linux/futex.h>
       #include <sys/time.h>

       int futex(int *uaddr, int futex_op, int val,
                 const struct timespec *timeout,   /* or: uint32_t val2 */
                 int *uaddr2, int val3);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       The futex() system call provides a method for waiting until a certain condition becomes true.  It is typically used
       as a blocking construct in the context of shared-memory synchronization.  When using futexes, the majority  of  the
       synchronization  operations are performed in user space.  A user-space program employs the futex() system call only
       when it is likely that the program has to block for a longer time until the condition becomes true.  Other  futex()
       operations can be used to wake any processes or threads waiting for a particular condition.

       A  futex  is a 32-bit value—referred to below as a futex word—whose address is supplied to the futex() system call.
       (Futexes are 32 bits in size on all platforms, including 64-bit systems.)  All futex  operations  are  governed  by
       this value.  In order to share a futex between processes, the futex is placed in a region of shared memory, created
       using (for example) mmap(2) or shmat(2).  (Thus, the futex word may have different virtual addresses  in  different
       processes,  but these addresses all refer to the same location in physical memory.)  In a multithreaded program, it
       is sufficient to place the futex word in a global variable shared by all threads.

       When executing a futex operation that requests to block a thread, the kernel will block only if the futex word  has
       the  value  that the calling thread supplied (as one of the arguments of the futex() call) as the expected value of
       the futex word.  The loading of the futex word's value, the comparison of that value with the expected  value,  and
       the  actual  blocking will happen atomically and will be totally ordered with respect to concurrent operations per‐
       formed by other threads on the same futex word.  Thus, the futex word is used to  connect  the  synchronization  in
       user space with the implementation of blocking by the kernel.  Analogously to an atomic compare-and-exchange opera‐
       tion that potentially changes shared memory, blocking via a futex is an atomic compare-and-block operation.

       One use of futexes is for implementing locks.  The state of the lock (i.e., acquired or not acquired) can be repre‐
       sented as an atomically accessed flag in shared memory.  In the uncontended case, a thread can access or modify the
       lock state with atomic instructions, for example atomically changing it from not  acquired  to  acquired  using  an
       atomic  compare-and-exchange  instruction.   (Such instructions are performed entirely in user mode, and the kernel
       maintains no information about the lock state.)  On the other hand, a thread  may  be  unable  to  acquire  a  lock
       because  it  is already acquired by another thread.  It then may pass the lock's flag as a futex word and the value
       representing the acquired state as the expected value to a futex() wait operation.   This  futex()  operation  will
       block  if  and  only  if  the lock is still acquired (i.e., the value in the futex word still matches the "acquired
       state").  When releasing the lock, a thread has to first reset the lock state to not acquired and  then  execute  a
       futex  operation that wakes threads blocked on the lock flag used as a futex word (this can be further optimized to
       avoid unnecessary wake-ups).  See futex(7) for more detail on how to use futexes.

       Besides the basic wait and wake-up futex functionality, there are further futex operations aimed at supporting more
       complex use cases.

       Note  that  no  explicit  initialization  or  destruction is necessary to use futexes; the kernel maintains a futex
       (i.e., the kernel-internal implementation artifact) only while operations such as FUTEX_WAIT, described below,  are
       being performed on a particular futex word.

   Arguments
       The uaddr argument points to the futex word.  On all platforms, futexes are four-byte integers that must be aligned
       on a four-byte boundary.  The operation to perform on the futex is specified in the futex_op  argument;  val  is  a
       value whose meaning and purpose depends on futex_op.

       The remaining arguments (timeout, uaddr2, and val3) are required only for certain of the futex operations described
       below.  Where one of these arguments is not required, it is ignored.

       For several blocking operations, the timeout argument is a pointer to a timespec structure that specifies a timeout
       for the operation.  However,  notwithstanding the prototype shown above, for some operations, the least significant
       four bytes of this argument are instead used as an integer whose meaning is determined by the operation.  For these
       operations,  the  kernel  casts the timeout value first to unsigned long, then to uint32_t, and in the remainder of
       this page, this argument is referred to as val2 when interpreted in this fashion.

       Where it is required, the uaddr2 argument is a pointer to a second futex word that is employed by the operation.

       The interpretation of the final integer argument, val3, depends on the operation.

   Futex operations
       The futex_op argument consists of two parts: a command that specifies the operation to be performed, bit-wise  ORed
       with zero or more options that modify the behaviour of the operation.  The options that may be included in futex_op
       are as follows:

       FUTEX_PRIVATE_FLAG (since Linux 2.6.22)
              This option bit can be employed with all futex operations.  It tells the kernel that the futex  is  process-
              private and not shared with another process (i.e., it is being used for synchronization only between threads
              of the same process).  This allows the kernel to make some additional performance optimizations.

              As a convenience, <linux/futex.h> defines a set of constants with the suffix _PRIVATE that  are  equivalents
              of  all of the operations listed below, but with the FUTEX_PRIVATE_FLAG ORed into the constant value.  Thus,
              there are FUTEX_WAIT_PRIVATE, FUTEX_WAKE_PRIVATE, and so on.

       FUTEX_CLOCK_REALTIME (since Linux 2.6.28)
              This option bit can be employed only with the FUTEX_WAIT_BITSET,  FUTEX_WAIT_REQUEUE_PI,  and  (since  Linux
              4.5) FUTEX_WAIT operations.

              If this option is set, the kernel measures the timeout against the CLOCK_REALTIME clock.

              If this option is not set, the kernel measures the timeout against the CLOCK_MONOTONIC clock.

       The operation specified in futex_op is one of the following:

       FUTEX_WAIT (since Linux 2.6.0)
              This  operation  tests  that  the value at the futex word pointed to by the address uaddr still contains the
              expected value val, and if so, then sleeps waiting for a FUTEX_WAKE operation on the futex word.   The  load
              of  the  value  of the futex word is an atomic memory access (i.e., using atomic machine instructions of the
              respective architecture).  This load, the comparison with the expected value, and starting to sleep are per‐
              formed atomically and totally ordered with respect to other futex operations on the same futex word.  If the
              thread starts to sleep, it is considered a waiter on this futex word.  If the futex  value  does  not  match
              val, then the call fails immediately with the error EAGAIN.

              The  purpose  of  the  comparison  with  the  expected value is to prevent lost wake-ups.  If another thread
              changed the value of the futex word after the calling thread decided to block based on the prior value,  and
              if  the  other thread executed a FUTEX_WAKE operation (or similar wake-up) after the value change and before
              this FUTEX_WAIT operation, then the calling thread will observe the value  change  and  will  not  start  to
              sleep.

              If  the  timeout  is  not NULL, the structure it points to specifies a timeout for the wait.  (This interval
              will be rounded up to the system clock granularity, and is guaranteed not to expire early.)  The timeout  is
              by  default  measured according to the CLOCK_MONOTONIC clock, but, since Linux 4.5, the CLOCK_REALTIME clock
              can be selected by specifying FUTEX_CLOCK_REALTIME in futex_op.  If timeout is NULL, the call blocks indefi‐
              nitely.

              Note: for FUTEX_WAIT, timeout is interpreted as a relative value.  This differs from other futex operations,
              where timeout is interpreted as an absolute value.  To obtain the equivalent of FUTEX_WAIT with an  absolute
              timeout, employ FUTEX_WAIT_BITSET with val3 specified as FUTEX_BITSET_MATCH_ANY.

              The arguments uaddr2 and val3 are ignored.

       FUTEX_WAKE (since Linux 2.6.0)
              This operation wakes at most val of the waiters that are waiting (e.g., inside FUTEX_WAIT) on the futex word
              at the address uaddr.  Most commonly, val is specified as either 1 (wake up  a  single  waiter)  or  INT_MAX
              (wake  up  all  waiters).   No  guarantee  is provided about which waiters are awoken (e.g., a waiter with a
              higher scheduling priority is not guaranteed to be awoken in preference to a waiter with a lower priority).

              The arguments timeout, uaddr2, and val3 are ignored.

       FUTEX_FD (from Linux 2.6.0 up to and including Linux 2.6.25)
              This operation creates a file descriptor that is associated with the futex at uaddr.  The caller must  close
              the  returned  file descriptor after use.  When another process or thread performs a FUTEX_WAKE on the futex
              word, the file descriptor indicates as being readable with select(2), poll(2), and epoll(7)

              The file descriptor can be used to obtain asynchronous notifications: if val is nonzero, then, when  another
              process or thread executes a FUTEX_WAKE, the caller will receive the signal number that was passed in val.

              The arguments timeout, uaddr2 and val3 are ignored.

              Because it was inherently racy, FUTEX_FD has been removed from Linux 2.6.26 onward.

       FUTEX_REQUEUE (since Linux 2.6.0)
              This  operation  performs the same task as FUTEX_CMP_REQUEUE (see below), except that no check is made using
              the value in val3.  (The argument val3 is ignored.)

       FUTEX_CMP_REQUEUE (since Linux 2.6.7)
              This operation first checks whether the location uaddr still contains the value val3.  If not, the operation
              fails with the error EAGAIN.  Otherwise, the operation wakes up a maximum of val waiters that are waiting on
              the futex at uaddr.  If there are more than val waiters, then the remaining waiters  are  removed  from  the
              wait queue of the source futex at uaddr and added to the wait queue of the target futex at uaddr2.  The val2
              argument specifies an upper limit on the number of waiters that are requeued to the futex at uaddr2.

              The load from uaddr is an atomic memory access (i.e., using atomic machine instructions  of  the  respective
              architecture).   This load, the comparison with val3, and the requeueing of any waiters are performed atomi‐
              cally and totally ordered with respect to other operations on the same futex word.

              Typical values to specify for val are 0 or 1.  (Specifying INT_MAX is not useful, because it would make  the
              FUTEX_CMP_REQUEUE  operation  equivalent  to  FUTEX_WAKE.)   The limit value specified via val2 is typically
              either  1  or  INT_MAX.   (Specifying  the  argument  as  0  is  not  useful,  because  it  would  make  the
              FUTEX_CMP_REQUEUE operation equivalent to FUTEX_WAIT.)

              The FUTEX_CMP_REQUEUE operation was added as a replacement for the earlier FUTEX_REQUEUE.  The difference is
              that the check of the value at uaddr can be used to ensure that requeueing happens only under certain condi‐
              tions, which allows race conditions to be avoided in certain use cases.

              Both  FUTEX_REQUEUE  and  FUTEX_CMP_REQUEUE can be used to avoid "thundering herd" wake-ups that could occur
              when using FUTEX_WAKE in cases where all of the waiters that are woken need to acquire another futex.   Con‐
              sider the following scenario, where multiple waiter threads are waiting on B, a wait queue implemented using
              a futex:

                  lock(A)
                  while (!check_value(V)) {
                      unlock(A);
                      block_on(B);
                      lock(A);
                  };
                  unlock(A);

              If a waker thread used FUTEX_WAKE, then all waiters waiting on B would be woken up, and they would  all  try
              to  acquire lock A.  However, waking all of the threads in this manner would be pointless because all except
              one of the threads would immediately block on lock A again.  By contrast, a requeue operation wakes just one
              waiter  and  moves the other waiters to lock A, and when the woken waiter unlocks A then the next waiter can
              proceed.

       FUTEX_WAKE_OP (since Linux 2.6.14)
              This operation was added to support some user-space use cases where more than one futex must be  handled  at
              the  same  time.   The  most notable example is the implementation of pthread_cond_signal(3), which requires
              operations on two futexes, the one used to implement the mutex and the one used in the implementation of the
              wait  queue associated with the condition variable.  FUTEX_WAKE_OP allows such cases to be implemented with‐
              out leading to high rates of contention and context switching.

              The FUTEX_WAKE_OP operation is equivalent to executing the following code  atomically  and  totally  ordered
              with respect to other futex operations on any of the two supplied futex words:

                  int oldval = *(int *) uaddr2;
                  *(int *) uaddr2 = oldval op oparg;
                  futex(uaddr, FUTEX_WAKE, val, 0, 0, 0);
                  if (oldval cmp cmparg)
                      futex(uaddr2, FUTEX_WAKE, val2, 0, 0, 0);

              In other words, FUTEX_WAKE_OP does the following:

              *  saves the original value of the futex word at uaddr2 and performs an operation to modify the value of the
                 futex at uaddr2; this is an atomic read-modify-write memory access (i.e., using atomic  machine  instruc‐
                 tions of the respective architecture)

              *  wakes up a maximum of val waiters on the futex for the futex word at uaddr; and

              *  dependent  on the results of a test of the original value of the futex word at uaddr2, wakes up a maximum
                 of val2 waiters on the futex for the futex word at uaddr2.

              The operation and comparison that are to be performed are encoded in the bits of the argument val3.   Picto‐
              rially, the encoding is:

                      +---+---+-----------+-----------+
                      |op |cmp|   oparg   |  cmparg   |
                      +---+---+-----------+-----------+
                        4   4       12          12    <== # of bits

              Expressed in code, the encoding is:

                  #define FUTEX_OP(op, oparg, cmp, cmparg) \
                                  (((op & 0xf) << 28) | \
                                  ((cmp & 0xf) << 24) | \
                                  ((oparg & 0xfff) << 12) | \
                                  (cmparg & 0xfff))

              In  the  above, op and cmp are each one of the codes listed below.  The oparg and cmparg components are lit‐
              eral numeric values, except as noted below.

              The op component has one of the following values:

                  FUTEX_OP_SET        0  /* uaddr2 = oparg; */
                  FUTEX_OP_ADD        1  /* uaddr2 += oparg; */
                  FUTEX_OP_OR         2  /* uaddr2 |= oparg; */
                  FUTEX_OP_ANDN       3  /* uaddr2 &= ~oparg; */
                  FUTEX_OP_XOR        4  /* uaddr2 ^= oparg; */

              In addition, bit-wise ORing the following value into op causes (1 << oparg) to be used as the operand:

                  FUTEX_OP_ARG_SHIFT  8  /* Use (1 << oparg) as operand */

              The cmp field is one of the following:

                  FUTEX_OP_CMP_EQ     0  /* if (oldval == cmparg) wake */
                  FUTEX_OP_CMP_NE     1  /* if (oldval != cmparg) wake */
                  FUTEX_OP_CMP_LT     2  /* if (oldval < cmparg) wake */
                  FUTEX_OP_CMP_LE     3  /* if (oldval <= cmparg) wake */
                  FUTEX_OP_CMP_GT     4  /* if (oldval > cmparg) wake */
                  FUTEX_OP_CMP_GE     5  /* if (oldval >= cmparg) wake */

              The return value of FUTEX_WAKE_OP is the sum of the number of waiters woken on the futex uaddr plus the num‐
              ber of waiters woken on the futex uaddr2.

       FUTEX_WAIT_BITSET (since Linux 2.6.25)
              This operation is like FUTEX_WAIT except that val3 is used to provide a 32-bit bit mask to the kernel.  This
              bit mask, in which at least one bit must be set, is stored in the kernel-internal state of the waiter.   See
              the description of FUTEX_WAKE_BITSET for further details.

              If timeout is not NULL, the structure it points to specifies an absolute timeout for the wait operation.  If
              timeout is NULL, the operation can block indefinitely.

              The uaddr2 argument is ignored.

       FUTEX_WAKE_BITSET (since Linux 2.6.25)
              This operation is the same as FUTEX_WAKE except that the val3 argument is used to provide a 32-bit bit  mask
              to the kernel.  This bit mask, in which at least one bit must be set, is used to select which waiters should
              be woken up.  The selection is done by a bit-wise AND of the "wake" bit mask (i.e., the value in  val3)  and
              the  bit  mask  which  is stored in the kernel-internal state of the waiter (the "wait" bit mask that is set
              using FUTEX_WAIT_BITSET).  All of the waiters for which the result of the AND is nonzero are woken  up;  the
              remaining waiters are left sleeping.

              The  effect of FUTEX_WAIT_BITSET and FUTEX_WAKE_BITSET is to allow selective wake-ups among multiple waiters
              that are blocked on the same futex.  However, note that, depending on the use case, employing this  bit-mask
              multiplexing  feature on a futex can be less efficient than simply using multiple futexes, because employing
              bit-mask multiplexing requires the kernel to check all waiters on a futex,  including  those  that  are  not
              interested in being woken up (i.e., they do not have the relevant bit set in their "wait" bit mask).

              The  constant  FUTEX_BITSET_MATCH_ANY,  which corresponds to all 32 bits set in the bit mask, can be used as
              the val3 argument for FUTEX_WAIT_BITSET and FUTEX_WAKE_BITSET.  Other than differences in  the  handling  of
              the  timeout  argument,  the  FUTEX_WAIT operation is equivalent to FUTEX_WAIT_BITSET with val3 specified as
              FUTEX_BITSET_MATCH_ANY; that is, allow a wake-up by any waker.  The FUTEX_WAKE operation  is  equivalent  to
              FUTEX_WAKE_BITSET with val3 specified as FUTEX_BITSET_MATCH_ANY; that is, wake up any waiter(s).

              The uaddr2 and timeout arguments are ignored.

   Priority-inheritance futexes
       Linux supports priority-inheritance (PI) futexes in order to handle priority-inversion problems that can be encoun‐
       tered with normal futex locks.  Priority inversion is the problem that occurs when a high-priority task is  blocked
       waiting to acquire a lock held by a low-priority task, while tasks at an intermediate priority continuously preempt
       the low-priority task from the CPU.  Consequently, the low-priority task makes no  progress  toward  releasing  the
       lock, and the high-priority task remains blocked.

       Priority  inheritance  is a mechanism for dealing with the priority-inversion problem.  With this mechanism, when a
       high-priority task becomes blocked by a lock held by a low-priority task, the priority of the low-priority task  is
       temporarily  raised to that of the high-priority task, so that it is not preempted by any intermediate level tasks,
       and can thus make progress toward releasing the lock.  To be effective, priority inheritance  must  be  transitive,
       meaning  that  if  a  high-priority task blocks on a lock held by a lower-priority task that is itself blocked by a
       lock held by another intermediate-priority task (and so on, for chains of arbitrary length),  then  both  of  those
       tasks  (or  more  generally,  all  of the tasks in a lock chain) have their priorities raised to be the same as the
       high-priority task.

       From a user-space perspective, what makes a futex PI-aware is a policy agreement  (described  below)  between  user
       space  and  the kernel about the value of the futex word, coupled with the use of the PI-futex operations described
       below.  (Unlike the other futex operations described above, the PI-futex operations are designed for the  implemen‐
       tation of very specific IPC mechanisms.)

       The  PI-futex  operations  described below differ from the other futex operations in that they impose policy on the
       use of the value of the futex word:

       *  If the lock is not acquired, the futex word's value shall be 0.

       *  If the lock is acquired, the futex word's value shall be the thread  ID  (TID;  see  gettid(2))  of  the  owning
          thread.

       *  If  the  lock is owned and there are threads contending for the lock, then the FUTEX_WAITERS bit shall be set in
          the futex word's value; in other words, this value is:

              FUTEX_WAITERS | TID

          (Note that is invalid for a PI futex word to have no owner and FUTEX_WAITERS set.)

       With this policy in place, a user-space application can acquire an unacquired lock or release a lock  using  atomic
       instructions  executed  in  user mode (e.g., a compare-and-swap operation such as cmpxchg on the x86 architecture).
       Acquiring a lock simply consists of using compare-and-swap to atomically set the futex word's value to the caller's
       TID if its previous value was 0.  Releasing a lock requires using compare-and-swap to set the futex word's value to
       0 if the previous value was the expected TID.

       If a futex is already acquired (i.e., has a nonzero value), waiters must  employ  the  FUTEX_LOCK_PI  operation  to
       acquire the lock.  If other threads are waiting for the lock, then the FUTEX_WAITERS bit is set in the futex value;
       in this case, the lock owner must employ the FUTEX_UNLOCK_PI operation to release the lock.

       In the cases where callers are forced into the kernel (i.e., required to perform a futex() call),  they  then  deal
       directly  with  a so-called RT-mutex, a kernel locking mechanism which implements the required priority-inheritance
       semantics.  After the RT-mutex is acquired, the futex value is  updated  accordingly,  before  the  calling  thread
       returns to user space.

       It is important to note that the kernel will update the futex word's value prior to returning to user space.  (This
       prevents the possibility of the futex word's value ending up in an invalid state, such as having an owner  but  the
       value being 0, or having waiters but not having the FUTEX_WAITERS bit set.)

       If  a  futex  has  an  associated  RT-mutex  in  the  kernel (i.e., there are blocked waiters) and the owner of the
       futex/RT-mutex dies unexpectedly, then the kernel cleans up the RT-mutex and hands it  over  to  the  next  waiter.
       This  in  turn  requires  that the user-space value is updated accordingly.  To indicate that this is required, the
       kernel sets the FUTEX_OWNER_DIED bit in the futex word along with the thread ID of the new owner.  User  space  can
       detect  this  situation  via  the  presence of the FUTEX_OWNER_DIED bit and is then responsible for cleaning up the
       stale state left over by the dead owner.

       PI futexes are operated on by specifying one of the values listed below in futex_op.  Note that the PI futex opera‐
       tions must be used as paired operations and are subject to some additional requirements:

       *  FUTEX_LOCK_PI  and  FUTEX_TRYLOCK_PI  pair with FUTEX_UNLOCK_PI.  FUTEX_UNLOCK_PI must be called only on a futex
          owned by the calling thread, as defined by the value policy, otherwise the error EPERM results.

       *  FUTEX_WAIT_REQUEUE_PI pairs with FUTEX_CMP_REQUEUE_PI.  This must be performed from a non-PI futex to a distinct
          PI futex (or the error EINVAL results).  Additionally, val (the number of waiters to be woken) must be 1 (or the
          error EINVAL results).

       The PI futex operations are as follows:

       FUTEX_LOCK_PI (since Linux 2.6.18)
              This operation is used after an attempt to acquire the lock  via  an  atomic  user-mode  instruction  failed
              because  the  futex word has a nonzero value—specifically, because it contained the (PID-namespace-specific)
              TID of the lock owner.

              The operation checks the value of the futex word at the address uaddr.  If the value is 0, then  the  kernel
              tries to atomically set the futex value to the caller's TID.  If the futex word's value is nonzero, the ker‐
              nel atomically sets the FUTEX_WAITERS bit, which signals the futex owner that it cannot unlock the futex  in
              user space atomically by setting the futex value to 0.  After that, the kernel:

              1. Tries to find the thread which is associated with the owner TID.

              2. Creates  or reuses kernel state on behalf of the owner.  (If this is the first waiter, there is no kernel
                 state for this futex, so kernel state is created by locking the RT-mutex and the futex owner is made  the
                 owner of the RT-mutex.  If there are existing waiters, then the existing state is reused.)

              3. Attaches the waiter to the futex (i.e., the waiter is enqueued on the RT-mutex waiter list).

              If more than one waiter exists, the enqueueing of the waiter is in descending priority order.  (For informa‐
              tion on priority ordering, see the discussion of the SCHED_DEADLINE,  SCHED_FIFO,  and  SCHED_RR  scheduling
              policies  in  sched(7).)   The  owner inherits either the waiter's CPU bandwidth (if the waiter is scheduled
              under the SCHED_DEADLINE policy) or the waiter's priority (if the waiter is scheduled under the SCHED_RR  or
              SCHED_FIFO  policy).   This  inheritance  follows  the lock chain in the case of nested locking and performs
              deadlock detection.

              The timeout argument provides a timeout for the lock attempt.  If timeout is  not  NULL,  the  structure  it
              points to specifies an absolute timeout, measured against the CLOCK_REALTIME clock.  If timeout is NULL, the
              operation will block indefinitely.

              The uaddr2, val, and val3 arguments are ignored.

       FUTEX_TRYLOCK_PI (since Linux 2.6.18)
              This operation tries to acquire the lock at uaddr.  It is invoked when a user-space atomic acquire  did  not
              succeed because the futex word was not 0.

              Because  the kernel has access to more state information than user space, acquisition of the lock might suc‐
              ceed if performed by the kernel in cases where the futex word (i.e., the  state  information  accessible  to
              use-space)  contains stale state (FUTEX_WAITERS and/or FUTEX_OWNER_DIED).  This can happen when the owner of
              the futex died.  User space cannot handle this condition in a race-free manner, but the kernel can fix  this
              up and acquire the futex.

              The uaddr2, val, timeout, and val3 arguments are ignored.

       FUTEX_UNLOCK_PI (since Linux 2.6.18)
              This  operation wakes the top priority waiter that is waiting in FUTEX_LOCK_PI on the futex address provided
              by the uaddr argument.

              This is called when the user-space value at uaddr cannot be changed atomically from a TID (of the owner)  to
              0.

              The uaddr2, val, timeout, and val3 arguments are ignored.

       FUTEX_CMP_REQUEUE_PI (since Linux 2.6.31)
              This  operation  is  a  PI-aware  variant  of  FUTEX_CMP_REQUEUE.   It requeues waiters that are blocked via
              FUTEX_WAIT_REQUEUE_PI on uaddr from a non-PI source futex (uaddr) to a PI target futex (uaddr2).

              As with FUTEX_CMP_REQUEUE, this operation wakes up a maximum of val waiters that are waiting on the futex at
              uaddr.  However, for FUTEX_CMP_REQUEUE_PI, val is required to be 1 (since the main point is to avoid a thun‐
              dering herd).  The remaining waiters are removed from the wait queue of the source futex at uaddr and  added
              to the wait queue of the target futex at uaddr2.

              The val2 and val3 arguments serve the same purposes as for FUTEX_CMP_REQUEUE.

       FUTEX_WAIT_REQUEUE_PI (since Linux 2.6.31)
              Wait on a non-PI futex at uaddr and potentially be requeued (via a FUTEX_CMP_REQUEUE_PI operation in another
              task) onto a PI futex at uaddr2.  The wait operation on uaddr is the same as for FUTEX_WAIT.

              The waiter can be removed from the wait on uaddr without requeueing on uaddr2 via a FUTEX_WAKE operation  in
              another task.  In this case, the FUTEX_WAIT_REQUEUE_PI operation fails with the error EAGAIN.

              If timeout is not NULL, the structure it points to specifies an absolute timeout for the wait operation.  If
              timeout is NULL, the operation can block indefinitely.

              The val3 argument is ignored.

              The FUTEX_WAIT_REQUEUE_PI and FUTEX_CMP_REQUEUE_PI were added to support a fairly specific use case: support
              for  priority-inheritance-aware POSIX threads condition variables.  The idea is that these operations should
              always be paired, in order to ensure that  user  space  and  the  kernel  remain  in  sync.   Thus,  in  the
              FUTEX_WAIT_REQUEUE_PI  operation,  the  user-space  application pre-specifies the target of the requeue that
              takes place in the FUTEX_CMP_REQUEUE_PI operation.

RETURN VALUE
       In the event of an error (and assuming that futex() was invoked via syscall(2)), all operations return -1  and  set
       errno to indicate the cause of the error.

       The return value on success depends on the operation, as described in the following list:

       FUTEX_WAIT
              Returns 0 if the caller was woken up.  Note that a wake-up can also be caused by common futex usage patterns
              in unrelated code that happened to have previously used the futex  word's  memory  location  (e.g.,  typical
              futex-based  implementations  of Pthreads mutexes can cause this under some conditions).  Therefore, callers
              should always conservatively assume that a return value of 0 can mean a spurious wake-up, and use the  futex
              word's value (i.e., the user-space synchronization scheme) to decide whether to continue to block or not.

       FUTEX_WAKE
              Returns the number of waiters that were woken up.

       FUTEX_FD
              Returns the new file descriptor associated with the futex.

       FUTEX_REQUEUE
              Returns the number of waiters that were woken up.

       FUTEX_CMP_REQUEUE
              Returns  the  total  number  of  waiters  that  were woken up or requeued to the futex for the futex word at
              uaddr2.  If this value is greater than val, then the difference is the number of  waiters  requeued  to  the
              futex for the futex word at uaddr2.

       FUTEX_WAKE_OP
              Returns  the  total  number  of waiters that were woken up.  This is the sum of the woken waiters on the two
              futexes for the futex words at uaddr and uaddr2.

       FUTEX_WAIT_BITSET
              Returns 0 if the caller was woken up.  See FUTEX_WAIT for how to interpret this correctly in practice.

       FUTEX_WAKE_BITSET
              Returns the number of waiters that were woken up.

       FUTEX_LOCK_PI
              Returns 0 if the futex was successfully locked.

       FUTEX_TRYLOCK_PI
              Returns 0 if the futex was successfully locked.

       FUTEX_UNLOCK_PI
              Returns 0 if the futex was successfully unlocked.

       FUTEX_CMP_REQUEUE_PI
              Returns the total number of waiters that were woken up or requeued to  the  futex  for  the  futex  word  at
              uaddr2.   If  this value is greater than val, then difference is the number of waiters requeued to the futex
              for the futex word at uaddr2.

       FUTEX_WAIT_REQUEUE_PI
              Returns 0 if the caller was successfully requeued to the futex for the futex word at uaddr2.

ERRORS
       EACCES No read access to the memory of a futex word.

       EAGAIN (FUTEX_WAIT, FUTEX_WAIT_BITSET, FUTEX_WAIT_REQUEUE_PI) The value pointed to by uaddr was not  equal  to  the
              expected value val at the time of the call.

              Note:  on  Linux,  the symbolic names EAGAIN and EWOULDBLOCK (both of which appear in different parts of the
              kernel futex code) have the same value.

       EAGAIN (FUTEX_CMP_REQUEUE, FUTEX_CMP_REQUEUE_PI) The value pointed to by uaddr is not equal to the  expected  value
              val3.

       EAGAIN (FUTEX_LOCK_PI,   FUTEX_TRYLOCK_PI,   FUTEX_CMP_REQUEUE_PI)   The  futex  owner  thread  ID  of  uaddr  (for
              FUTEX_CMP_REQUEUE_PI: uaddr2) is about to exit, but has not yet handled the  internal  state  cleanup.   Try
              again.

       EDEADLK
              (FUTEX_LOCK_PI,  FUTEX_TRYLOCK_PI,  FUTEX_CMP_REQUEUE_PI)  The  futex word at uaddr is already locked by the
              caller.

       EDEADLK
              (FUTEX_CMP_REQUEUE_PI) While requeueing a waiter to the PI futex for the futex word at  uaddr2,  the  kernel
              detected a deadlock.

       EFAULT A required pointer argument (i.e., uaddr, uaddr2, or timeout) did not point to a valid user-space address.

       EINTR  A  FUTEX_WAIT or FUTEX_WAIT_BITSET operation was interrupted by a signal (see signal(7)).  In kernels before
              Linux 2.6.22, this error could also be returned for a spurious wakeup; since Linux 2.6.22,  this  no  longer
              happens.

       EINVAL The  operation  in  futex_op  is  one of those that employs a timeout, but the supplied timeout argument was
              invalid (tv_sec was less than zero, or tv_nsec was not less than 1,000,000,000).

       EINVAL The operation specified in futex_op employs one or both of the pointers uaddr and uaddr2, but one  of  these
              does not point to a valid object—that is, the address is not four-byte-aligned.

       EINVAL (FUTEX_WAIT_BITSET, FUTEX_WAKE_BITSET) The bit mask supplied in val3 is zero.

       EINVAL (FUTEX_CMP_REQUEUE_PI) uaddr equals uaddr2 (i.e., an attempt was made to requeue to the same futex).

       EINVAL (FUTEX_FD) The signal number supplied in val is invalid.

       EINVAL (FUTEX_WAKE,  FUTEX_WAKE_OP,  FUTEX_WAKE_BITSET,  FUTEX_REQUEUE,  FUTEX_CMP_REQUEUE)  The kernel detected an
              inconsistency between the user-space state at uaddr and the kernel state—that is, it detected a waiter which
              waits in FUTEX_LOCK_PI on uaddr.

       EINVAL (FUTEX_LOCK_PI,  FUTEX_TRYLOCK_PI,  FUTEX_UNLOCK_PI)  The kernel detected an inconsistency between the user-
              space state at uaddr and the kernel state.  This indicates either state corruption or that the kernel  found
              a waiter on uaddr which is waiting via FUTEX_WAIT or FUTEX_WAIT_BITSET.

       EINVAL (FUTEX_CMP_REQUEUE_PI)  The  kernel detected an inconsistency between the user-space state at uaddr2 and the
              kernel state; that is, the kernel detected a waiter which  waits  via  FUTEX_WAIT  or  FUTEX_WAIT_BITSET  on
              uaddr2.

       EINVAL (FUTEX_CMP_REQUEUE_PI)  The  kernel  detected an inconsistency between the user-space state at uaddr and the
              kernel state; that is, the kernel detected a waiter which waits  via  FUTEX_WAIT  or  FUTEX_WAIT_BITESET  on
              uaddr.

       EINVAL (FUTEX_CMP_REQUEUE_PI)  The  kernel  detected an inconsistency between the user-space state at uaddr and the
              kernel state; that is, the kernel detected a waiter which waits  on  uaddr  via  FUTEX_LOCK_PI  (instead  of
              FUTEX_WAIT_REQUEUE_PI).

       EINVAL (FUTEX_CMP_REQUEUE_PI)  An  attempt was made to requeue a waiter to a futex other than that specified by the
              matching FUTEX_WAIT_REQUEUE_PI call for that waiter.

       EINVAL (FUTEX_CMP_REQUEUE_PI) The val argument is not 1.

       EINVAL Invalid argument.

       ENFILE (FUTEX_FD) The system-wide limit on the total number of open files has been reached.

       ENOMEM (FUTEX_LOCK_PI, FUTEX_TRYLOCK_PI, FUTEX_CMP_REQUEUE_PI) The kernel could not allocate memory to  hold  state
              information.

       ENOSYS Invalid operation specified in futex_op.

       ENOSYS The  FUTEX_CLOCK_REALTIME  option  was  specified  in  futex_op,  but the accompanying operation was neither
              FUTEX_WAIT, FUTEX_WAIT_BITSET, nor FUTEX_WAIT_REQUEUE_PI.

       ENOSYS (FUTEX_LOCK_PI, FUTEX_TRYLOCK_PI, FUTEX_UNLOCK_PI, FUTEX_CMP_REQUEUE_PI, FUTEX_WAIT_REQUEUE_PI)  A  run-time
              check  determined  that  the operation is not available.  The PI-futex operations are not implemented on all
              architectures and are not supported on some CPU variants.

       EPERM  (FUTEX_LOCK_PI, FUTEX_TRYLOCK_PI, FUTEX_CMP_REQUEUE_PI) The caller is not allowed to attach  itself  to  the
              futex  at  uaddr (for FUTEX_CMP_REQUEUE_PI: the futex at uaddr2).  (This may be caused by a state corruption
              in user space.)

       EPERM  (FUTEX_UNLOCK_PI) The caller does not own the lock represented by the futex word.

       ESRCH  (FUTEX_LOCK_PI, FUTEX_TRYLOCK_PI, FUTEX_CMP_REQUEUE_PI) The thread ID in the futex word at  uaddr  does  not
              exist.

       ESRCH  (FUTEX_CMP_REQUEUE_PI) The thread ID in the futex word at uaddr2 does not exist.

       ETIMEDOUT
              The  operation  in  futex_op  employed  the timeout specified in timeout, and the timeout expired before the
              operation completed.

VERSIONS
       Futexes were first made available in a stable kernel release with Linux 2.6.0.

       Initial futex support was merged in Linux 2.5.7 but with different semantics from  what  was  described  above.   A
       four-argument  system call with the semantics described in this page was introduced in Linux 2.5.40.  A fifth argu‐
       ment was added in Linux 2.5.70, and a sixth argument was added in Linux 2.6.7.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       Glibc does not provide a wrapper for this system call; call it using syscall(2).

       Several higher-level programming abstractions are implemented via futexes, including POSIX semaphores  and  various
       POSIX threads synchronization mechanisms (mutexes, condition variables, read-write locks, and barriers).

EXAMPLE
       The program below demonstrates use of futexes in a program where a parent process and a child process use a pair of
       futexes located inside a shared anonymous mapping to synchronize access to a shared resource:  the  terminal.   The
       two  processes  each  write nloops (a command-line argument that defaults to 5 if omitted) messages to the terminal
       and employ a synchronization protocol that ensures that they alternate in writing messages.  Upon running this pro‐
       gram we see output such as the following:

           $ ./futex_demo
           Parent (18534) 0
           Child  (18535) 0
           Parent (18534) 1
           Child  (18535) 1
           Parent (18534) 2
           Child  (18535) 2
           Parent (18534) 3
           Child  (18535) 3
           Parent (18534) 4
           Child  (18535) 4

   Program source

       /* futex_demo.c

          Usage: futex_demo [nloops]
                           (Default: 5)

          Demonstrate the use of futexes in a program where parent and child
          use a pair of futexes located inside a shared anonymous mapping to
          synchronize access to a shared resource: the terminal. The two
          processes each write 'num-loops' messages to the terminal and employ
          a synchronization protocol that ensures that they alternate in
          writing messages.
       */
       #define _GNU_SOURCE
       #include <stdio.h>
       #include <errno.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <sys/wait.h>
       #include <sys/mman.h>
       #include <sys/syscall.h>
       #include <linux/futex.h>
       #include <sys/time.h>

       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       static int *futex1, *futex2, *iaddr;

       static int
       futex(int *uaddr, int futex_op, int val,
             const struct timespec *timeout, int *uaddr2, int val3)
       {
           return syscall(SYS_futex, uaddr, futex_op, val,
                          timeout, uaddr, val3);
       }

       /* Acquire the futex pointed to by 'futexp': wait for its value to
          become 1, and then set the value to 0. */

       static void
       fwait(int *futexp)
       {
           int s;

           /* __sync_bool_compare_and_swap(ptr, oldval, newval) is a gcc
              built-in function.  It atomically performs the equivalent of:

                  if (*ptr == oldval)
                      *ptr = newval;

              It returns true if the test yielded true and *ptr was updated.
              The alternative here would be to employ the equivalent atomic
              machine-language instructions.  For further information, see
              the GCC Manual. */

           while (1) {

               /* Is the futex available? */

               if (__sync_bool_compare_and_swap(futexp, 1, 0))
                   break;      /* Yes */

               /* Futex is not available; wait */

               s = futex(futexp, FUTEX_WAIT, 0, NULL, NULL, 0);
               if (s == -1 && errno != EAGAIN)
                   errExit("futex-FUTEX_WAIT");
           }
       }

       /* Release the futex pointed to by 'futexp': if the futex currently
          has the value 0, set its value to 1 and the wake any futex waiters,
          so that if the peer is blocked in fpost(), it can proceed. */

       static void
       fpost(int *futexp)
       {
           int s;

           /* __sync_bool_compare_and_swap() was described in comments above */

           if (__sync_bool_compare_and_swap(futexp, 0, 1)) {

               s = futex(futexp, FUTEX_WAKE, 1, NULL, NULL, 0);
               if (s  == -1)
                   errExit("futex-FUTEX_WAKE");
           }
       }

       int
       main(int argc, char *argv[])
       {
           pid_t childPid;
           int j, nloops;

           setbuf(stdout, NULL);

           nloops = (argc > 1) ? atoi(argv[1]) : 5;

           /* Create a shared anonymous mapping that will hold the futexes.
              Since the futexes are being shared between processes, we
              subsequently use the "shared" futex operations (i.e., not the
              ones suffixed "_PRIVATE") */

           iaddr = mmap(NULL, sizeof(int) * 2, PROT_READ | PROT_WRITE,
                       MAP_ANONYMOUS | MAP_SHARED, -1, 0);
           if (iaddr == MAP_FAILED)
               errExit("mmap");

           futex1 = &iaddr[0];
           futex2 = &iaddr[1];

           *futex1 = 0;        /* State: unavailable */
           *futex2 = 1;        /* State: available */

           /* Create a child process that inherits the shared anonymous
              mapping */

           childPid = fork();
           if (childPid == -1)
               errExit("fork");

           if (childPid == 0) {        /* Child */
               for (j = 0; j < nloops; j++) {
                   fwait(futex1);
                   printf("Child  (%ld) %d\n", (long) getpid(), j);
                   fpost(futex2);
               }

               exit(EXIT_SUCCESS);
           }

           /* Parent falls through to here */

           for (j = 0; j < nloops; j++) {
               fwait(futex2);
               printf("Parent (%ld) %d\n", (long) getpid(), j);
               fpost(futex1);
           }

           wait(NULL);

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       get_robust_list(2), restart_syscall(2), pthread_mutexattr_getprotocol(3), futex(7), sched(7)

       The following kernel source files:

       * Documentation/pi-futex.txt

       * Documentation/futex-requeue-pi.txt

       * Documentation/locking/rt-mutex.txt

       * Documentation/locking/rt-mutex-design.txt

       * Documentation/robust-futex-ABI.txt

       Franke, H., Russell, R., and Kirwood, M., 2002.  Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux (from
       proceedings of the Ottawa Linux Symposium 2002),
       ⟨http://kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf⟩

       Hart, D., 2009. A futex overview and update, ⟨http://lwn.net/Articles/360699/⟩

       Hart, D. and Guniguntala, D., 2009.  Requeue-PI: Making Glibc Condvars PI-Aware (from proceedings of the 2009 Real-
       Time Linux Workshop), ⟨http://lwn.net/images/conf/rtlws11/papers/proc/p10.pdf⟩

       Drepper, U., 2011. Futexes Are Tricky, ⟨http://www.akkadia.org/drepper/futex.pdf⟩

       Futex example library, futex-*.tar.bz2 at
       ⟨ftp://ftp.kernel.org/pub/linux/kernel/people/rusty/⟩

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                FUTEX(2)
</pre>
<pre zoom>
<span xsmall>2 timer_settime</span>
TIMER_SETTIME(2)                                 Linux Programmer's Manual                                TIMER_SETTIME(2)

NAME
       timer_settime, timer_gettime - arm/disarm and fetch state of POSIX per-process timer

SYNOPSIS
       #include <time.h>

       int timer_settime(timer_t timerid, int flags,
                         const struct itimerspec *new_value,
                         struct itimerspec *old_value);
       int timer_gettime(timer_t timerid, struct itimerspec *curr_value);

       Link with -lrt.

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       timer_settime(), timer_gettime(): _POSIX_C_SOURCE >= 199309L

DESCRIPTION
       timer_settime()  arms  or disarms the timer identified by timerid.  The new_value argument is pointer to an itimer‐
       spec structure that specifies the new initial value and the new interval for the timer.  The  itimerspec  structure
       is defined as follows:

           struct timespec {
               time_t tv_sec;                /* Seconds */
               long   tv_nsec;               /* Nanoseconds */
           };

           struct itimerspec {
               struct timespec it_interval;  /* Timer interval */
               struct timespec it_value;     /* Initial expiration */
           };

       Each of the substructures of the itimerspec structure is a timespec structure that allows a time value to be speci‐
       fied in seconds and nanoseconds.  These time values are measured according to the clock that was specified when the
       timer was created by timer_create(2).

       If  new_value->it_value  specifies  a  nonzero  value (i.e., either subfield is nonzero), then timer_settime() arms
       (starts) the timer, setting it to initially expire at the given time.  (If the timer was already  armed,  then  the
       previous settings are overwritten.)  If new_value->it_value specifies a zero value (i.e., both subfields are zero),
       then the timer is disarmed.

       The new_value->it_interval field specifies the period of the timer, in seconds and nanoseconds.  If this  field  is
       nonzero,  then  each  time  that  an  armed  timer  expires,  the  timer  is  reloaded  from the value specified in
       new_value->it_interval.  If new_value->it_interval specifies a zero value, then the timer expires just once, at the
       time specified by it_value.

       By  default,  the  initial  expiration time specified in new_value->it_value is interpreted relative to the current
       time on the timer's clock at the time of the call.  This can be modified by specifying TIMER_ABSTIME in  flags,  in
       which  case  new_value->it_value is interpreted as an absolute value as measured on the timer's clock; that is, the
       timer will expire when the clock value reaches the value specified by new_value->it_value.  If the specified  abso‐
       lute  time  has already passed, then the timer expires immediately, and the overrun count (see timer_getoverrun(2))
       will be set correctly.

       If the value of the CLOCK_REALTIME clock is adjusted while an absolute timer based on that clock is armed, then the
       expiration  of the timer will be appropriately adjusted.  Adjustments to the CLOCK_REALTIME clock have no effect on
       relative timers based on that clock.

       If old_value is not NULL, then it points to a buffer that is used to return the previous interval of the timer  (in
       old_value->it_interval)  and  the  amount  of  time  until  the  timer  would  previously  have  next  expired  (in
       old_value->it_value).

       timer_gettime() returns the time until next expiration, and the interval, for the timer specified  by  timerid,  in
       the  buffer  pointed  to  by  curr_value.   The  time  remaining  until  the  next  timer expiration is returned in
       curr_value->it_value; this is always a relative value, regardless of whether the TIMER_ABSTIME flag was  used  when
       arming  the  timer.   If  the value returned in curr_value->it_value is zero, then the timer is currently disarmed.
       The timer interval is returned in curr_value->it_interval.  If the value  returned  in  curr_value->it_interval  is
       zero, then this is a "one-shot" timer.

RETURN VALUE
       On  success,  timer_settime() and timer_gettime() return 0.  On error, -1 is returned, and errno is set to indicate
       the error.

ERRORS
       These functions may fail with the following errors:

       EFAULT new_value, old_value, or curr_value is not a valid pointer.

       EINVAL timerid is invalid.

       timer_settime() may fail with the following errors:

       EINVAL new_value.it_value is negative; or new_value.it_value.tv_nsec is negative or greater than 999,999,999.

VERSIONS
       These system calls are available since Linux 2.6.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

EXAMPLE
       See timer_create(2).

SEE ALSO
       timer_create(2), timer_getoverrun(2), time(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        TIMER_SETTIME(2)
</pre>
<pre zoom>
<span xsmall>2 getcwd</span>
GETCWD(3)                                        Linux Programmer's Manual                                       GETCWD(3)

NAME
       getcwd, getwd, get_current_dir_name - get current working directory

SYNOPSIS
       #include <unistd.h>

       char *getcwd(char *buf, size_t size);

       char *getwd(char *buf);

       char *get_current_dir_name(void);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       get_current_dir_name():
              _GNU_SOURCE

       getwd():
           Since glibc 2.12:
               (_XOPEN_SOURCE >= 500) && ! (_POSIX_C_SOURCE >= 200809L)
                   || /* Glibc since 2.19: */ _DEFAULT_SOURCE
                   || /* Glibc versions <= 2.19: */ _BSD_SOURCE
           Before glibc 2.12:
               _BSD_SOURCE || _XOPEN_SOURCE >= 500

DESCRIPTION
       These  functions return a null-terminated string containing an absolute pathname that is the current working direc‐
       tory of the calling process.  The pathname is returned as the function result and via the argument buf, if present.

       If the current directory is not below the root directory of the current process (e.g., because the  process  set  a
       new  filesystem  root  using chroot(2) without changing its current directory into the new root), then, since Linux
       2.6.36, the returned path will be prefixed with the string "(unreachable)".  Such behavior can also be caused by an
       unprivileged  user  by  changing  the current directory into another mount namespace.  When dealing with paths from
       untrusted sources, callers of these functions should consider checking whether the returned path starts with '/' or
       '('  to  avoid  misinterpreting  an  unreachable  path  as  a  relative  path.  This is no longer true under some C
       libraries; see NOTES.

       The getcwd() function copies an absolute pathname of the current working directory to the array pointed to by  buf,
       which is of length size.

       If  the  length  of  the  absolute  pathname of the current working directory, including the terminating null byte,
       exceeds size bytes, NULL is returned, and errno is set to ERANGE; an application should check for this  error,  and
       allocate a larger buffer if necessary.

       As  an extension to the POSIX.1-2001 standard, glibc's getcwd() allocates the buffer dynamically using malloc(3) if
       buf is NULL.  In this case, the allocated buffer has the length size unless size is zero, when buf is allocated  as
       big as necessary.  The caller should free(3) the returned buffer.

       get_current_dir_name()  will  malloc(3)  an  array  big enough to hold the absolute pathname of the current working
       directory.  If the environment variable PWD is set, and its value is correct, then that  value  will  be  returned.
       The caller should free(3) the returned buffer.

       getwd()  does  not  malloc(3) any memory.  The buf argument should be a pointer to an array at least PATH_MAX bytes
       long.  If the length of the absolute pathname of the current working  directory,  including  the  terminating  null
       byte,  exceeds  PATH_MAX  bytes,  NULL  is returned, and errno is set to ENAMETOOLONG.  (Note that on some systems,
       PATH_MAX may not be a compile-time constant; furthermore, its value may depend on the filesystem, see pathconf(3).)
       For portability and security reasons, use of getwd() is deprecated.

RETURN VALUE
       On  success, these functions return a pointer to a string containing the pathname of the current working directory.
       In the case getcwd() and getwd() this is the same value as buf.

       On failure, these functions return NULL, and errno is set to indicate the error.  The contents of the array pointed
       to by buf are undefined on error.

ERRORS
       EACCES Permission to read or search a component of the filename was denied.

       EFAULT buf points to a bad address.

       EINVAL The size argument is zero and buf is not a null pointer.

       EINVAL getwd(): buf is NULL.

       ENAMETOOLONG
              getwd(): The size of the null-terminated absolute pathname string exceeds PATH_MAX bytes.

       ENOENT The current working directory has been unlinked.

       ENOMEM Out of memory.

       ERANGE The  size  argument is less than the length of the absolute pathname of the working directory, including the
              terminating null byte.  You need to allocate a bigger array and try again.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌───────────────────────┬───────────────┬─────────────┐
       │Interface              │ Attribute     │ Value       │
       ├───────────────────────┼───────────────┼─────────────┤
       │getcwd(), getwd()      │ Thread safety │ MT-Safe     │
       ├───────────────────────┼───────────────┼─────────────┤
       │get_current_dir_name() │ Thread safety │ MT-Safe env │
       └───────────────────────┴───────────────┴─────────────┘
CONFORMING TO
       getcwd() conforms to POSIX.1-2001.  Note however that POSIX.1-2001 leaves the behavior of getcwd()  unspecified  if
       buf is NULL.

       getwd()  is  present  in  POSIX.1-2001, but marked LEGACY.  POSIX.1-2008 removes the specification of getwd().  Use
       getcwd() instead.  POSIX.1-2001 does not define any errors for getwd().

       get_current_dir_name() is a GNU extension.

NOTES
       Under Linux,  the  function  getcwd()  is  a  system  call  (since  2.1.92).   On  older  systems  it  would  query
       /proc/self/cwd.   If both system call and proc filesystem are missing, a generic implementation is called.  Only in
       that case can these calls fail under Linux with EACCES.

       Since a Linux 2.6.36 change that added "(unreachable)", the glibc getcwd() has  failed  to  conform  to  POSIX  and
       returned  a  relative  path  when the API contract requires an absolute path.  With glibc 2.27 onwards this is cor‐
       rected; calling getcwd() from such a path will now result in failure with ENOENT.

       These functions are often used to save the location of the current working directory for the purpose  of  returning
       to  it  later.   Opening  the  current directory (".") and calling fchdir(2) to return is usually a faster and more
       reliable alternative when sufficiently many file descriptors are available,  especially  on  platforms  other  than
       Linux.

SEE ALSO
       pwd(1), chdir(2), fchdir(2), open(2), unlink(2), free(3), malloc(3)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                     2018-04-30                                               GETCWD(3)
</pre>
<pre zoom>
<span xsmall>2 modify_ldt</span>
MODIFY_LDT(2)                                    Linux Programmer's Manual                                   MODIFY_LDT(2)

NAME
       modify_ldt - get or set a per-process LDT entry

SYNOPSIS
       #include <sys/types.h>

       int modify_ldt(int func, void *ptr, unsigned long bytecount);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       modify_ldt()  reads  or  writes  the  local  descriptor  table (LDT) for a process.  The LDT is an array of segment
       descriptors that can be referenced by user code.  Linux allows processes to configure a per-process (actually  per-
       mm)  LDT.   For  more  information about the LDT, see the Intel Software Developer's Manual or the AMD Architecture
       Programming Manual.

       When func is 0, modify_ldt() reads the LDT into the memory pointed to by ptr.  The number  of  bytes  read  is  the
       smaller  of  bytecount and the actual size of the LDT, although the kernel may act as though the LDT is padded with
       additional trailing zero bytes.  On success, modify_ldt() will return the number of bytes read.

       When func is 1 or 0x11, modify_ldt() modifies the LDT entry  indicated  by  ptr->entry_number.   ptr  points  to  a
       user_desc structure and bytecount must equal the size of this structure.

       The user_desc structure is defined in <asm/ldt.h> as:

           struct user_desc {
               unsigned int  entry_number;
               unsigned long base_addr;
               unsigned int  limit;
               unsigned int  seg_32bit:1;
               unsigned int  contents:2;
               unsigned int  read_exec_only:1;
               unsigned int  limit_in_pages:1;
               unsigned int  seg_not_present:1;
               unsigned int  useable:1;
           };

       In Linux 2.4 and earlier, this structure was named modify_ldt_ldt_s.

       The  contents  field  is  the  segment type (data, expand-down data, non-conforming code, or conforming code).  The
       other fields match their descriptions in the CPU manual, although  modify_ldt()  cannot  set  the  hardware-defined
       "accessed" bit described in the CPU manual.

       A  user_desc  is  considered "empty" if read_exec_only and seg_not_present are set to 1 and all of the other fields
       are 0.  An LDT entry can be cleared by setting it to an "empty" user_desc or, if func is 1, by  setting  both  base
       and limit to 0.

       A conforming code segment (i.e., one with contents==3) will be rejected if func is 1 or if seg_not_present is 0.

       When func is 2, modify_ldt() will read zeros.  This appears to be a leftover from Linux 2.4.

RETURN VALUE
       On success, modify_ldt() returns either the actual number of bytes read (for reading) or 0 (for writing).  On fail‐
       ure, modify_ldt() returns -1 and sets errno to indicate the error.

ERRORS
       EFAULT ptr points outside the address space.

       EINVAL ptr is 0, or func is 1 and bytecount is not equal to the size of the structure user_desc, or func  is  1  or
              0x11 and the new LDT entry has invalid values.

       ENOSYS func is neither 0, 1, 2, nor 0x11.

CONFORMING TO
       This call is Linux-specific and should not be used in programs intended to be portable.

NOTES
       Glibc does not provide a wrapper for this system call; call it using syscall(2).

       modify_ldt()  should  not  be  used for thread-local storage, as it slows down context switches and only supports a
       limited number of threads.  Threading libraries should use set_thread_area(2) or arch_prctl(2) instead,  except  on
       extremely old kernels that do not support those system calls.

       The  normal  use  for  modify_ldt() is to run legacy 16-bit or segmented 32-bit code.  Not all kernels allow 16-bit
       segments to be installed, however.

       Even on 64-bit kernels, modify_ldt() cannot be used to create a long mode (i.e., 64-bit) code segment.  The undocu‐
       mented field "lm" in user_desc is not useful, and, despite its name, does not result in a long mode segment.

BUGS
       On  64-bit  kernels before Linux 3.19, setting the "lm" bit in user_desc prevents the descriptor from being consid‐
       ered empty.  Keep in mind that the "lm" bit does not exist in the 32-bit headers,  but  these  buggy  kernels  will
       still notice the bit even when set in a 32-bit process.

SEE ALSO
       arch_prctl(2), set_thread_area(2), vm86(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           MODIFY_LDT(2)
</pre>
<pre zoom>
<span xsmall>2 getdents</span>
GETDENTS(2)                                      Linux Programmer's Manual                                     GETDENTS(2)

NAME
       getdents, getdents64 - get directory entries

SYNOPSIS
       int getdents(unsigned int fd, struct linux_dirent *dirp,
                    unsigned int count);
       int getdents64(unsigned int fd, struct linux_dirent64 *dirp,
                    unsigned int count);

       Note: There are no glibc wrappers for these system calls; see NOTES.

DESCRIPTION
       These  are  not the interfaces you are interested in.  Look at readdir(3) for the POSIX-conforming C library inter‐
       face.  This page documents the bare kernel system call interfaces.

   getdents()
       The system call getdents() reads several linux_dirent structures from the directory referred to by  the  open  file
       descriptor fd into the buffer pointed to by dirp.  The argument count specifies the size of that buffer.

       The linux_dirent structure is declared as follows:

           struct linux_dirent {
               unsigned long  d_ino;     /* Inode number */
               unsigned long  d_off;     /* Offset to next linux_dirent */
               unsigned short d_reclen;  /* Length of this linux_dirent */
               char           d_name[];  /* Filename (null-terminated) */
                                 /* length is actually (d_reclen - 2 -
                                    offsetof(struct linux_dirent, d_name)) */
               /*
               char           pad;       // Zero padding byte
               char           d_type;    // File type (only since Linux
                                         // 2.6.4); offset is (d_reclen - 1)
               */
           }

       d_ino  is  an  inode  number.   d_off  is  the  distance  from  the start of the directory to the start of the next
       linux_dirent.  d_reclen is the size of this entire linux_dirent.  d_name is a null-terminated filename.

       d_type is a byte at the end of the structure that indicates the file type.  It contains one of the following values
       (defined in <dirent.h>):

       DT_BLK      This is a block device.

       DT_CHR      This is a character device.

       DT_DIR      This is a directory.

       DT_FIFO     This is a named pipe (FIFO).

       DT_LNK      This is a symbolic link.

       DT_REG      This is a regular file.

       DT_SOCK     This is a UNIX domain socket.

       DT_UNKNOWN  The file type is unknown.

       The  d_type  field is implemented since Linux 2.6.4.  It occupies a space that was previously a zero-filled padding
       byte in the linux_dirent structure.  Thus, on kernels up to and including 2.6.3, attempting to  access  this  field
       always provides the value 0 (DT_UNKNOWN).

       Currently, only some filesystems (among them: Btrfs, ext2, ext3, and ext4) have full support for returning the file
       type in d_type.  All applications must properly handle a return of DT_UNKNOWN.

   getdents64()
       The original Linux getdents() system call did not handle large filesystems and large file  offsets.   Consequently,
       Linux  2.4 added getdents64(), with wider types for the d_ino and d_off fields.  In addition, getdents64() supports
       an explicit d_type field.

       The getdents64() system call is like getdents(), except that its second argument is a pointer to a buffer  contain‐
       ing structures of the following type:

           struct linux_dirent64 {
               ino64_t        d_ino;    /* 64-bit inode number */
               off64_t        d_off;    /* 64-bit offset to next structure */
               unsigned short d_reclen; /* Size of this dirent */
               unsigned char  d_type;   /* File type */
               char           d_name[]; /* Filename (null-terminated) */
           };

RETURN VALUE
       On  success,  the number of bytes read is returned.  On end of directory, 0 is returned.  On error, -1 is returned,
       and errno is set appropriately.

ERRORS
       EBADF  Invalid file descriptor fd.

       EFAULT Argument points outside the calling process's address space.

       EINVAL Result buffer is too small.

       ENOENT No such directory.

       ENOTDIR
              File descriptor does not refer to a directory.

CONFORMING TO
       SVr4.

NOTES
       Glibc does not provide a wrapper for these system calls; call them using syscall(2).  You will need to  define  the
       linux_dirent or linux_dirent64 structure yourself.  However, you probably want to use readdir(3) instead.

       These calls supersede readdir(2).

EXAMPLE
       The  program  below  demonstrates the use of getdents().  The following output shows an example of what we see when
       running this program on an ext2 directory:

           $ ./a.out /testfs/
           --------------- nread=120 ---------------
           inode#    file type  d_reclen  d_off   d_name
                  2  directory    16         12  .
                  2  directory    16         24  ..
                 11  directory    24         44  lost+found
                 12  regular      16         56  a
             228929  directory    16         68  sub
              16353  directory    16         80  sub2
             130817  directory    16       4096  sub3

   Program source

       #define _GNU_SOURCE
       #include <dirent.h>     /* Defines DT_* constants */
       #include <fcntl.h>
       #include <stdio.h>
       #include <unistd.h>
       #include <stdlib.h>
       #include <sys/stat.h>
       #include <sys/syscall.h>

       #define handle_error(msg) \
               do { perror(msg); exit(EXIT_FAILURE); } while (0)

       struct linux_dirent {
           long           d_ino;
           off_t          d_off;
           unsigned short d_reclen;
           char           d_name[];
       };

       #define BUF_SIZE 1024

       int
       main(int argc, char *argv[])
       {
           int fd, nread;
           char buf[BUF_SIZE];
           struct linux_dirent *d;
           int bpos;
           char d_type;

           fd = open(argc > 1 ? argv[1] : ".", O_RDONLY | O_DIRECTORY);
           if (fd == -1)
               handle_error("open");

           for ( ; ; ) {
               nread = syscall(SYS_getdents, fd, buf, BUF_SIZE);
               if (nread == -1)
                   handle_error("getdents");

               if (nread == 0)
                   break;

               printf("--------------- nread=%d ---------------\n", nread);
               printf("inode#    file type  d_reclen  d_off   d_name\n");
               for (bpos = 0; bpos < nread;) {
                   d = (struct linux_dirent *) (buf + bpos);
                   printf("%8ld  ", d->d_ino);
                   d_type = *(buf + bpos + d->d_reclen - 1);
                   printf("%-10s ", (d_type == DT_REG) ?  "regular" :
                                    (d_type == DT_DIR) ?  "directory" :
                                    (d_type == DT_FIFO) ? "FIFO" :
                                    (d_type == DT_SOCK) ? "socket" :
                                    (d_type == DT_LNK) ?  "symlink" :
                                    (d_type == DT_BLK) ?  "block dev" :
                                    (d_type == DT_CHR) ?  "char dev" : "???");
                   printf("%4d %10lld  %s\n", d->d_reclen,
                           (long long) d->d_off, d->d_name);
                   bpos += d->d_reclen;
               }
           }

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       readdir(2), readdir(3), inode(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             GETDENTS(2)
</pre>
<pre zoom>
<span xsmall>2 open_by_handle_at</span>
OPEN_BY_HANDLE_AT(2)                             Linux Programmer's Manual                            OPEN_BY_HANDLE_AT(2)

NAME
       name_to_handle_at, open_by_handle_at - obtain handle for a pathname and open file via a handle

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>

       int name_to_handle_at(int dirfd, const char *pathname,
                             struct file_handle *handle,
                             int *mount_id, int flags);

       int open_by_handle_at(int mount_fd, struct file_handle *handle,
                             int flags);

DESCRIPTION
       The  name_to_handle_at()  and open_by_handle_at() system calls split the functionality of openat(2) into two parts:
       name_to_handle_at() returns an opaque handle that corresponds to a specified file;  open_by_handle_at()  opens  the
       file corresponding to a handle returned by a previous call to name_to_handle_at() and returns an open file descrip‐
       tor.

   name_to_handle_at()
       The name_to_handle_at() system call returns a file handle and a mount ID corresponding to the file specified by the
       dirfd  and pathname arguments.  The file handle is returned via the argument handle, which is a pointer to a struc‐
       ture of the following form:

           struct file_handle {
               unsigned int  handle_bytes;   /* Size of f_handle [in, out] */
               int           handle_type;    /* Handle type [out] */
               unsigned char f_handle[0];    /* File identifier (sized by
                                                caller) [out] */
           };

       It is the caller's responsibility to allocate the structure with a size large enough to hold the handle returned in
       f_handle.   Before  the call, the handle_bytes field should be initialized to contain the allocated size for f_han‐
       dle.  (The constant MAX_HANDLE_SZ, defined in <fcntl.h>, specifies the maximum expected size for a file handle.  It
       is  not  a  guaranteed upper limit as future filesystems may require more space.)  Upon successful return, the han‐
       dle_bytes field is updated to contain the number of bytes actually written to f_handle.

       The caller can discover the required size for the file_handle structure by making  a  call  in  which  handle->han‐
       dle_bytes  is  zero; in this case, the call fails with the error EOVERFLOW and handle->handle_bytes is set to indi‐
       cate the required size; the caller can then use this information to allocate a structure of the correct  size  (see
       EXAMPLE  below).  Some care is needed here as EOVERFLOW can also indicate that no file handle is available for this
       particular name in a filesystem which does normally support file-handle lookup.  This case can be detected when the
       EOVERFLOW error is returned without handle_bytes being increased.

       Other  than  the use of the handle_bytes field, the caller should treat the file_handle structure as an opaque data
       type: the handle_type and f_handle fields are needed only by a subsequent call to open_by_handle_at().

       The flags argument is a bit mask constructed by ORing together zero or more of AT_EMPTY_PATH and AT_SYMLINK_FOLLOW,
       described below.

       Together,  the pathname and dirfd arguments identify the file for which a handle is to be obtained.  There are four
       distinct cases:

       *  If pathname is a nonempty string containing an absolute pathname,  then  a  handle  is  returned  for  the  file
          referred to by that pathname.  In this case, dirfd is ignored.

       *  If  pathname  is a nonempty string containing a relative pathname and dirfd has the special value AT_FDCWD, then
          pathname is interpreted relative to the current working directory of the caller, and a handle  is  returned  for
          the file to which it refers.

       *  If  pathname  is  a nonempty string containing a relative pathname and dirfd is a file descriptor referring to a
          directory, then pathname is interpreted relative to the directory referred to by dirfd, and a handle is returned
          for the file to which it refers.  (See openat(2) for an explanation of why "directory file descriptors" are use‐
          ful.)

       *  If pathname is an empty string and flags specifies the value AT_EMPTY_PATH, then  dirfd  can  be  an  open  file
          descriptor  referring  to  any type of file, or AT_FDCWD, meaning the current working directory, and a handle is
          returned for the file to which it refers.

       The mount_id argument returns an identifier for the filesystem mount that corresponds  to  pathname.   This  corre‐
       sponds  to  the first field in one of the records in /proc/self/mountinfo.  Opening the pathname in the fifth field
       of that record yields a file descriptor for the mount point; that file descriptor can be used in a subsequent  call
       to  open_by_handle_at().   mount_id is returned both for a successful call and for a call that results in the error
       EOVERFLOW.

       By default, name_to_handle_at() does not dereference pathname if it is a symbolic link, and thus returns  a  handle
       for the link itself.  If AT_SYMLINK_FOLLOW is specified in flags, pathname is dereferenced if it is a symbolic link
       (so that the call returns a handle for the file referred to by the link).

       name_to_handle_at() does not trigger a mount when the final component of the path is an automount  point.   When  a
       filesystem  supports  both file handles and automount points, a name_to_handle_at() call on an automount point will
       return with error EOVERFLOW without having increased handle_bytes.  This can happen since Linux 4.13 with NFS  when
       accessing  a  directory  which is on a separate filesystem on the server.  In this case, the automount can be trig‐
       gered by adding a "/" to the end of the path.

   open_by_handle_at()
       The open_by_handle_at() system call opens the file referred to by handle, a file handle returned by a previous call
       to name_to_handle_at().

       The  mount_fd  argument is a file descriptor for any object (file, directory, etc.)  in the mounted filesystem with
       respect to which handle should be interpreted.  The special value AT_FDCWD can be specified,  meaning  the  current
       working directory of the caller.

       The  flags  argument  is  as  for open(2).  If handle refers to a symbolic link, the caller must specify the O_PATH
       flag, and the symbolic link is not dereferenced; the O_NOFOLLOW flag, if specified, is ignored.

       The caller must have the CAP_DAC_READ_SEARCH capability to invoke open_by_handle_at().

RETURN VALUE
       On success, name_to_handle_at() returns 0, and open_by_handle_at() returns a nonnegative file descriptor.

       In the event of an error, both system calls return -1 and set errno to indicate the cause of the error.

ERRORS
       name_to_handle_at() and open_by_handle_at() can fail for the same errors as openat(2).  In addition, they can  fail
       with the errors noted below.

       name_to_handle_at() can fail with the following errors:

       EFAULT pathname, mount_id, or handle points outside your accessible address space.

       EINVAL flags includes an invalid bit value.

       EINVAL handle->handle_bytes is greater than MAX_HANDLE_SZ.

       ENOENT pathname is an empty string, but AT_EMPTY_PATH was not specified in flags.

       ENOTDIR
              The  file descriptor supplied in dirfd does not refer to a directory, and it is not the case that both flags
              includes AT_EMPTY_PATH and pathname is an empty string.

       EOPNOTSUPP
              The filesystem does not support decoding of a pathname to a file handle.

       EOVERFLOW
              The handle->handle_bytes value passed into the call was too small.  When  this  error  occurs,  handle->han‐
              dle_bytes is updated to indicate the required size for the handle.

       open_by_handle_at() can fail with the following errors:

       EBADF  mount_fd is not an open file descriptor.

       EFAULT handle points outside your accessible address space.

       EINVAL handle->handle_bytes is greater than MAX_HANDLE_SZ or is equal to zero.

       ELOOP  handle refers to a symbolic link, but O_PATH was not specified in flags.

       EPERM  The caller does not have the CAP_DAC_READ_SEARCH capability.

       ESTALE The specified handle is not valid.  This error will occur if, for example, the file has been deleted.

VERSIONS
       These system calls first appeared in Linux 2.6.39.  Library support is provided in glibc since version 2.14.

CONFORMING TO
       These system calls are nonstandard Linux extensions.

       FreeBSD has a broadly similar pair of system calls in the form of getfh() and openfh().

NOTES
       A  file handle can be generated in one process using name_to_handle_at() and later used in a different process that
       calls open_by_handle_at().

       Some filesystem don't support the translation of pathnames to file handles, for example, /proc, /sys,  and  various
       network filesystems.

       A file handle may become invalid ("stale") if a file is deleted, or for other filesystem-specific reasons.  Invalid
       handles are notified by an ESTALE error from open_by_handle_at().

       These system calls are designed for use by user-space file servers.  For example, a  user-space  NFS  server  might
       generate  a file handle and pass it to an NFS client.  Later, when the client wants to open the file, it could pass
       the handle back to the server.  This sort of functionality allows a user-space file server to operate in  a  state‐
       less fashion with respect to the files it serves.

       If  pathname  refers  to  a  symbolic  link  and flags does not specify AT_SYMLINK_FOLLOW, then name_to_handle_at()
       returns a handle for the link (rather than the file to which it refers).  The  process  receiving  the  handle  can
       later  perform  operations  on  the  symbolic link by converting the handle to a file descriptor using open_by_han‐
       dle_at() with the O_PATH flag, and then passing the file descriptor as the dirfd argument in system calls  such  as
       readlinkat(2) and fchownat(2).

   Obtaining a persistent filesystem ID
       The mount IDs in /proc/self/mountinfo can be reused as filesystems are unmounted and mounted.  Therefore, the mount
       ID returned by name_to_handle_at() (in *mount_id) should not be treated as a persistent identifier for  the  corre‐
       sponding  mounted  filesystem.  However, an application can use the information in the mountinfo record that corre‐
       sponds to the mount ID to derive a persistent identifier.

       For example, one can use the device name in the fifth field of the mountinfo record to search for the corresponding
       device  UUID via the symbolic links in /dev/disks/by-uuid.  (A more comfortable way of obtaining the UUID is to use
       the libblkid(3) library.)  That process can then be reversed, using the UUID to look up the device name,  and  then
       obtaining the corresponding mount point, in order to produce the mount_fd argument used by open_by_handle_at().

EXAMPLE
       The  two  programs  below  demonstrate  the  use of name_to_handle_at() and open_by_handle_at().  The first program
       (t_name_to_handle_at.c) uses name_to_handle_at() to obtain the file handle and mount ID for the file  specified  in
       its command-line argument; the handle and mount ID are written to standard output.

       The  second program (t_open_by_handle_at.c) reads a mount ID and file handle from standard input.  The program then
       employs open_by_handle_at() to open the file using that handle.  If an optional command-line argument is  supplied,
       then  the  mount_fd  argument  for open_by_handle_at() is obtained by opening the directory named in that argument.
       Otherwise, mount_fd is obtained by scanning /proc/self/mountinfo to find a record whose mount ID matches the  mount
       ID  read  from  standard input, and the mount directory specified in that record is opened.  (These programs do not
       deal with the fact that mount IDs are not persistent.)

       The following shell session demonstrates the use of these two programs:

           $ echo 'Can you please think about it?' > cecilia.txt
           $ ./t_name_to_handle_at cecilia.txt > fh
           $ ./t_open_by_handle_at < fh
           open_by_handle_at: Operation not permitted
           $ sudo ./t_open_by_handle_at < fh      # Need CAP_SYS_ADMIN
           Read 31 bytes
           $ rm cecilia.txt

       Now we delete and (quickly) re-create the file so that it has the same content and  (by  chance)  the  same  inode.
       Nevertheless,  open_by_handle_at()  recognizes  that  the  original  file  referred to by the file handle no longer
       exists.

           $ stat --printf="%i\n" cecilia.txt     # Display inode number
           4072121
           $ rm cecilia.txt
           $ echo 'Can you please think about it?' > cecilia.txt
           $ stat --printf="%i\n" cecilia.txt     # Check inode number
           4072121
           $ sudo ./t_open_by_handle_at < fh
           open_by_handle_at: Stale NFS file handle

   Program source: t_name_to_handle_at.c

       #define _GNU_SOURCE
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <errno.h>
       #include <string.h>

       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       int
       main(int argc, char *argv[])
       {
           struct file_handle *fhp;
           int mount_id, fhsize, flags, dirfd, j;
           char *pathname;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s pathname\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           pathname = argv[1];

           /* Allocate file_handle structure */

           fhsize = sizeof(*fhp);
           fhp = malloc(fhsize);
           if (fhp == NULL)
               errExit("malloc");

           /* Make an initial call to name_to_handle_at() to discover
              the size required for file handle */

           dirfd = AT_FDCWD;           /* For name_to_handle_at() calls */
           flags = 0;                  /* For name_to_handle_at() calls */
           fhp->handle_bytes = 0;
           if (name_to_handle_at(dirfd, pathname, fhp,
                       &mount_id, flags) != -1 || errno != EOVERFLOW) {
               fprintf(stderr, "Unexpected result from name_to_handle_at()\n");
               exit(EXIT_FAILURE);
           }

           /* Reallocate file_handle structure with correct size */

           fhsize = sizeof(struct file_handle) + fhp->handle_bytes;
           fhp = realloc(fhp, fhsize);         /* Copies fhp->handle_bytes */
           if (fhp == NULL)
               errExit("realloc");

           /* Get file handle from pathname supplied on command line */

           if (name_to_handle_at(dirfd, pathname, fhp, &mount_id, flags) == -1)
               errExit("name_to_handle_at");

           /* Write mount ID, file handle size, and file handle to stdout,
              for later reuse by t_open_by_handle_at.c */

           printf("%d\n", mount_id);
           printf("%d %d   ", fhp->handle_bytes, fhp->handle_type);
           for (j = 0; j < fhp->handle_bytes; j++)
               printf(" %02x", fhp->f_handle[j]);
           printf("\n");

           exit(EXIT_SUCCESS);
       }

   Program source: t_open_by_handle_at.c

       #define _GNU_SOURCE
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>
       #include <limits.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <string.h>

       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       /* Scan /proc/self/mountinfo to find the line whose mount ID matches
          'mount_id'. (An easier way to do this is to install and use the
          'libmount' library provided by the 'util-linux' project.)
          Open the corresponding mount path and return the resulting file
          descriptor. */

       static int
       open_mount_path_by_id(int mount_id)
       {
           char *linep;
           size_t lsize;
           char mount_path[PATH_MAX];
           int mi_mount_id, found;
           ssize_t nread;
           FILE *fp;

           fp = fopen("/proc/self/mountinfo", "r");
           if (fp == NULL)
               errExit("fopen");

           found = 0;
           linep = NULL;
           while (!found) {
               nread = getline(&linep, &lsize, fp);
               if (nread == -1)
                   break;

               nread = sscanf(linep, "%d %*d %*s %*s %s",
                              &mi_mount_id, mount_path);
               if (nread != 2) {
                   fprintf(stderr, "Bad sscanf()\n");
                   exit(EXIT_FAILURE);
               }

               if (mi_mount_id == mount_id)
                   found = 1;
           }
           free(linep);

           fclose(fp);

           if (!found) {
               fprintf(stderr, "Could not find mount point\n");
               exit(EXIT_FAILURE);
           }

           return open(mount_path, O_RDONLY);
       }

       int
       main(int argc, char *argv[])
       {
           struct file_handle *fhp;
           int mount_id, fd, mount_fd, handle_bytes, j;
           ssize_t nread;
           char buf[1000];
       #define LINE_SIZE 100
           char line1[LINE_SIZE], line2[LINE_SIZE];
           char *nextp;

           if ((argc > 1 && strcmp(argv[1], "--help") == 0) || argc > 2) {
               fprintf(stderr, "Usage: %s [mount-path]\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           /* Standard input contains mount ID and file handle information:

                Line 1: <mount_id>
                Line 2: <handle_bytes> <handle_type>   <bytes of handle in hex>
           */

           if ((fgets(line1, sizeof(line1), stdin) == NULL) ||
                  (fgets(line2, sizeof(line2), stdin) == NULL)) {
               fprintf(stderr, "Missing mount_id / file handle\n");
               exit(EXIT_FAILURE);
           }

           mount_id = atoi(line1);

           handle_bytes = strtoul(line2, &nextp, 0);

           /* Given handle_bytes, we can now allocate file_handle structure */

           fhp = malloc(sizeof(struct file_handle) + handle_bytes);
           if (fhp == NULL)
               errExit("malloc");

           fhp->handle_bytes = handle_bytes;

           fhp->handle_type = strtoul(nextp, &nextp, 0);

           for (j = 0; j < fhp->handle_bytes; j++)
               fhp->f_handle[j] = strtoul(nextp, &nextp, 16);

           /* Obtain file descriptor for mount point, either by opening
              the pathname specified on the command line, or by scanning
              /proc/self/mounts to find a mount that matches the 'mount_id'
              that we received from stdin. */

           if (argc > 1)
               mount_fd = open(argv[1], O_RDONLY);
           else
               mount_fd = open_mount_path_by_id(mount_id);

           if (mount_fd == -1)
               errExit("opening mount fd");

           /* Open file using handle and mount point */

           fd = open_by_handle_at(mount_fd, fhp, O_RDONLY);
           if (fd == -1)
               errExit("open_by_handle_at");

           /* Try reading a few bytes from the file */

           nread = read(fd, buf, sizeof(buf));
           if (nread == -1)
               errExit("read");

           printf("Read %zd bytes\n", nread);

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       open(2), libblkid(3), blkid(8), findfs(8), mount(8)

       The     libblkid     and     libmount     documentation     in     the     latest     util-linux     release     at
       ⟨https://www.kernel.org/pub/linux/utils/util-linux/⟩

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                    OPEN_BY_HANDLE_AT(2)
</pre>
<pre zoom>
<span xsmall>2 sched_setaffinity</span>
SCHED_SETAFFINITY(2)                             Linux Programmer's Manual                            SCHED_SETAFFINITY(2)

NAME
       sched_setaffinity, sched_getaffinity - set and get a thread's CPU affinity mask

SYNOPSIS
       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <sched.h>

       int sched_setaffinity(pid_t pid, size_t cpusetsize,
                             const cpu_set_t *mask);

       int sched_getaffinity(pid_t pid, size_t cpusetsize,
                             cpu_set_t *mask);

DESCRIPTION
       A  thread's  CPU affinity mask determines the set of CPUs on which it is eligible to run.  On a multiprocessor sys‐
       tem, setting the CPU affinity mask can be used to obtain performance benefits.  For example, by dedicating one  CPU
       to  a  particular  thread  (i.e., setting the affinity mask of that thread to specify a single CPU, and setting the
       affinity mask of all other threads to exclude that CPU), it is possible to ensure maximum execution speed for  that
       thread.  Restricting a thread to run on a single CPU also avoids the performance cost caused by the cache invalida‐
       tion that occurs when a thread ceases to execute on one CPU and then recommences execution on a different CPU.

       A CPU affinity mask is represented by the cpu_set_t structure, a "CPU set", pointed to by mask.  A  set  of  macros
       for manipulating CPU sets is described in CPU_SET(3).

       sched_setaffinity()  sets  the  CPU affinity mask of the thread whose ID is pid to the value specified by mask.  If
       pid is zero, then the calling thread is used.  The argument cpusetsize is the length (in bytes) of the data pointed
       to by mask.  Normally this argument would be specified as sizeof(cpu_set_t).

       If  the  thread specified by pid is not currently running on one of the CPUs specified in mask, then that thread is
       migrated to one of the CPUs specified in mask.

       sched_getaffinity() writes the affinity mask of the thread whose ID is pid into the cpu_set_t structure pointed  to
       by  mask.   The  cpusetsize  argument  specifies the size (in bytes) of mask.  If pid is zero, then the mask of the
       calling thread is returned.

RETURN VALUE
       On success, sched_setaffinity() and sched_getaffinity() return 0.  On error, -1  is  returned,  and  errno  is  set
       appropriately.

ERRORS
       EFAULT A supplied memory address was invalid.

       EINVAL The  affinity bit mask mask contains no processors that are currently physically on the system and permitted
              to the thread according to any restrictions that may be imposed by cpuset cgroups or the "cpuset"  mechanism
              described in cpuset(7).

       EINVAL (sched_getaffinity()  and, in kernels before 2.6.9, sched_setaffinity()) cpusetsize is smaller than the size
              of the affinity mask used by the kernel.

       EPERM  (sched_setaffinity()) The calling thread does not have appropriate privileges.  The caller needs  an  effec‐
              tive user ID equal to the real user ID or effective user ID of the thread identified by pid, or it must pos‐
              sess the CAP_SYS_NICE capability in the user namespace of the thread pid.

       ESRCH  The thread whose ID is pid could not be found.

VERSIONS
       The CPU affinity system calls were introduced in Linux kernel 2.5.8.  The system call wrappers were  introduced  in
       glibc 2.3.  Initially, the glibc interfaces included a cpusetsize argument, typed as unsigned int.  In glibc 2.3.3,
       the cpusetsize argument was removed, but was then restored in glibc 2.3.4, with type size_t.

CONFORMING TO
       These system calls are Linux-specific.

NOTES
       After a call to sched_setaffinity(), the set of CPUs on which the thread will actually run is the  intersection  of
       the  set specified in the mask argument and the set of CPUs actually present on the system.  The system may further
       restrict the set of CPUs on which the thread runs if the "cpuset" mechanism described in cpuset(7) is  being  used.
       These restrictions on the actual set of CPUs on which the thread will run are silently imposed by the kernel.

       There  are  various  ways of determining the number of CPUs available on the system, including: inspecting the con‐
       tents of /proc/cpuinfo; using sysconf(3) to obtain the values of the _SC_NPROCESSORS_CONF and  _SC_NPROCESSORS_ONLN
       parameters; and inspecting the list of CPU directories under /sys/devices/system/cpu/.

       sched(7) has a description of the Linux scheduling scheme.

       The  affinity mask is a per-thread attribute that can be adjusted independently for each of the threads in a thread
       group.  The value returned from a call to gettid(2) can be passed in the argument pid.  Specifying pid  as  0  will
       set  the  attribute  for  the  calling thread, and passing the value returned from a call to getpid(2) will set the
       attribute for the main thread  of  the  thread  group.   (If  you  are  using  the  POSIX  threads  API,  then  use
       pthread_setaffinity_np(3) instead of sched_setaffinity().)

       The  isolcpus  boot option can be used to isolate one or more CPUs at boot time, so that no processes are scheduled
       onto those CPUs.  Following the use of this boot option, the only way to schedule processes onto the isolated  CPUs
       is  via  sched_setaffinity() or the cpuset(7) mechanism.  For further information, see the kernel source file Docu‐
       mentation/admin-guide/kernel-parameters.txt.  As noted in that file, isolcpus is the preferred mechanism of isolat‐
       ing CPUs (versus the alternative of manually setting the CPU affinity of all processes on the system).

       A  child  created  via  fork(2)  inherits its parent's CPU affinity mask.  The affinity mask is preserved across an
       execve(2).

   C library/kernel differences
       This manual page describes the glibc interface for the CPU affinity calls.  The actual  system  call  interface  is
       slightly different, with the mask being typed as unsigned long *, reflecting the fact that the underlying implemen‐
       tation of CPU sets is a simple bit mask.  On success, the raw sched_getaffinity() system call returns the size  (in
       bytes) of the cpumask_t data type that is used internally by the kernel to represent the CPU set bit mask.

   Handling systems with large CPU affinity masks
       The  underlying system calls (which represent CPU masks as bit masks of type unsigned long *) impose no restriction
       on the size of the CPU mask.  However, the cpu_set_t data type used by glibc has a fixed size of 128 bytes, meaning
       that  the maximum CPU number that can be represented is 1023.  If the kernel CPU affinity mask is larger than 1024,
       then calls of the form:

           sched_getaffinity(pid, sizeof(cpu_set_t), &mask);

       fail with the error EINVAL, the error produced by the underlying system call for the case where the mask size spec‐
       ified in cpusetsize is smaller than the size of the affinity mask used by the kernel.  (Depending on the system CPU
       topology, the kernel affinity mask can be substantially larger than the number of active CPUs in the system.)

       When working on systems with large kernel CPU affinity masks, one must dynamically allocate the mask argument  (see
       CPU_ALLOC(3)).   Currently,  the  only  way  to  do  this  is  by  probing  for the size of the required mask using
       sched_getaffinity() calls with increasing mask sizes (until the call does not fail with the error EINVAL).

       Be aware that CPU_ALLOC(3) may allocate a slightly larger CPU set than requested (because CPU sets are  implemented
       as  bit  masks  allocated  in  units  of  sizeof(long)).  Consequently, sched_getaffinity() can set bits beyond the
       requested allocation size, because the kernel sees a few additional bits.  Therefore,  the  caller  should  iterate
       over  the  bits  in  the  returned  set, counting those which are set, and stop upon reaching the value returned by
       CPU_COUNT(3) (rather than iterating over the number of bits requested to be allocated).

EXAMPLE
       The program below creates a child process.  The parent and child then each assign themselves to a specified CPU and
       execute  identical  loops  that  consume some CPU time.  Before terminating, the parent waits for the child to com‐
       plete.  The program takes three command-line arguments: the CPU number for the  parent,  the  CPU  number  for  the
       child, and the number of loop iterations that both processes should perform.

       As the sample runs below demonstrate, the amount of real and CPU time consumed when running the program will depend
       on intra-core caching effects and whether the processes are using the same CPU.

       We first employ lscpu(1) to determine that this (x86) system has two cores, each with two CPUs:

           $ lscpu | grep -i 'core.*:|socket'
           Thread(s) per core:    2
           Core(s) per socket:    2
           Socket(s):             1

       We then time the operation of the example program for three cases: both processes running on  the  same  CPU;  both
       processes  running  on  different  CPUs on the same core; and both processes running on different CPUs on different
       cores.

           $ time -p ./a.out 0 0 100000000
           real 14.75
           user 3.02
           sys 11.73
           $ time -p ./a.out 0 1 100000000
           real 11.52
           user 3.98
           sys 19.06
           $ time -p ./a.out 0 3 100000000
           real 7.89
           user 3.29
           sys 12.07

   Program source

       #define _GNU_SOURCE
       #include <sched.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <sys/wait.h>

       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       int
       main(int argc, char *argv[])
       {
           cpu_set_t set;
           int parentCPU, childCPU;
           int nloops, j;

           if (argc != 4) {
               fprintf(stderr, "Usage: %s parent-cpu child-cpu num-loops\n",
                       argv[0]);
               exit(EXIT_FAILURE);
           }

           parentCPU = atoi(argv[1]);
           childCPU = atoi(argv[2]);
           nloops = atoi(argv[3]);

           CPU_ZERO(&set);

           switch (fork()) {
           case -1:            /* Error */
               errExit("fork");

           case 0:             /* Child */
               CPU_SET(childCPU, &set);

               if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)
                   errExit("sched_setaffinity");

               for (j = 0; j < nloops; j++)
                   getppid();

               exit(EXIT_SUCCESS);

           default:            /* Parent */
               CPU_SET(parentCPU, &set);

               if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)
                   errExit("sched_setaffinity");

               for (j = 0; j < nloops; j++)
                   getppid();

               wait(NULL);     /* Wait for child to terminate */
               exit(EXIT_SUCCESS);
           }
       }

SEE ALSO
       lscpu(1), nproc(1), taskset(1), clone(2), getcpu(2), getpriority(2), gettid(2), nice(2), sched_get_priority_max(2),
       sched_get_priority_min(2), sched_getscheduler(2), sched_setscheduler(2), setpriority(2), CPU_SET(3), get_nprocs(3),
       pthread_setaffinity_np(3), sched_getcpu(3), capabilities(7), cpuset(7), sched(7), numactl(8)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                    SCHED_SETAFFINITY(2)
</pre>
<pre zoom>
<span xsmall>2 rt_sigaction</span>
SIGACTION(2)                                     Linux Programmer's Manual                                    SIGACTION(2)

NAME
       sigaction, rt_sigaction - examine and change a signal action

SYNOPSIS
       #include <signal.h>

       int sigaction(int signum, const struct sigaction *act,
                     struct sigaction *oldact);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       sigaction(): _POSIX_C_SOURCE

       siginfo_t: _POSIX_C_SOURCE >= 199309L

DESCRIPTION
       The  sigaction() system call is used to change the action taken by a process on receipt of a specific signal.  (See
       signal(7) for an overview of signals.)

       signum specifies the signal and can be any valid signal except SIGKILL and SIGSTOP.

       If act is non-NULL, the new action for signal signum is installed from act.  If oldact is  non-NULL,  the  previous
       action is saved in oldact.

       The sigaction structure is defined as something like:

           struct sigaction {
               void     (*sa_handler)(int);
               void     (*sa_sigaction)(int, siginfo_t *, void *);
               sigset_t   sa_mask;
               int        sa_flags;
               void     (*sa_restorer)(void);
           };

       On some architectures a union is involved: do not assign to both sa_handler and sa_sigaction.

       The  sa_restorer  field  is  not intended for application use.  (POSIX does not specify a sa_restorer field.)  Some
       further details of the purpose of this field can be found in sigreturn(2).

       sa_handler specifies the action to be associated with signum and may be SIG_DFL for the default action, SIG_IGN  to
       ignore  this  signal,  or a pointer to a signal handling function.  This function receives the signal number as its
       only argument.

       If SA_SIGINFO is specified in sa_flags, then sa_sigaction (instead of  sa_handler)  specifies  the  signal-handling
       function for signum.  This function receives three arguments, as described below.

       sa_mask  specifies a mask of signals which should be blocked (i.e., added to the signal mask of the thread in which
       the signal handler is invoked) during execution of the signal handler.  In addition, the signal which triggered the
       handler will be blocked, unless the SA_NODEFER flag is used.

       sa_flags  specifies a set of flags which modify the behavior of the signal.  It is formed by the bitwise OR of zero
       or more of the following:

           SA_NOCLDSTOP
                  If signum is SIGCHLD, do not receive notification when child processes stop (i.e., when they receive one
                  of  SIGSTOP,  SIGTSTP,  SIGTTIN, or SIGTTOU) or resume (i.e., they receive SIGCONT) (see wait(2)).  This
                  flag is meaningful only when establishing a handler for SIGCHLD.

           SA_NOCLDWAIT (since Linux 2.6)
                  If signum is SIGCHLD, do not transform children into zombies when they terminate.  See also  waitpid(2).
                  This flag is meaningful only when establishing a handler for SIGCHLD, or when setting that signal's dis‐
                  position to SIG_DFL.

                  If the SA_NOCLDWAIT flag is set when establishing a handler for SIGCHLD, POSIX.1 leaves  it  unspecified
                  whether  a  SIGCHLD  signal is generated when a child process terminates.  On Linux, a SIGCHLD signal is
                  generated in this case; on some other implementations, it is not.

           SA_NODEFER
                  Do not prevent the signal from being received from within its own signal handler.  This flag is meaning‐
                  ful  only  when  establishing  a signal handler.  SA_NOMASK is an obsolete, nonstandard synonym for this
                  flag.

           SA_ONSTACK
                  Call the signal handler on an alternate signal stack provided by sigaltstack(2).  If an alternate  stack
                  is not available, the default stack will be used.  This flag is meaningful only when establishing a sig‐
                  nal handler.

           SA_RESETHAND
                  Restore the signal action to the default upon entry to the signal handler.  This flag is meaningful only
                  when establishing a signal handler.  SA_ONESHOT is an obsolete, nonstandard synonym for this flag.

           SA_RESTART
                  Provide  behavior compatible with BSD signal semantics by making certain system calls restartable across
                  signals.  This flag is meaningful only when establishing a signal handler.  See signal(7) for a  discus‐
                  sion of system call restarting.

           SA_RESTORER
                  Not  intended  for  application  use.  This flag is used by C libraries to indicate that the sa_restorer
                  field contains the address of a "signal trampoline".  See sigreturn(2) for more details.

           SA_SIGINFO (since Linux 2.2)
                  The signal handler takes three arguments, not one.  In this case, sa_sigaction should be set instead  of
                  sa_handler.  This flag is meaningful only when establishing a signal handler.

   The siginfo_t argument to a SA_SIGINFO handler
       When  the  SA_SIGINFO flag is specified in act.sa_flags, the signal handler address is passed via the act.sa_sigac‐
       tion field.  This handler takes three arguments, as follows:

           void
           handler(int sig, siginfo_t *info, void *ucontext)
           {
               ...
           }

       These three arguments are as follows

       sig    The number of the signal that caused invocation of the handler.

       info   A pointer to a siginfo_t, which is a structure containing further information about the signal, as described
              below.

       ucontext
              This  is  a  pointer to a ucontext_t structure, cast to void *.  The structure pointed to by this field con‐
              tains signal context information that was saved on the user-space stack by  the  kernel;  for  details,  see
              sigreturn(2).   Further information about the ucontext_t structure can be found in getcontext(3).  Commonly,
              the handler function doesn't make any use of the third argument.

       The siginfo_t data type is a structure with the following fields:

           siginfo_t {
               int      si_signo;     /* Signal number */
               int      si_errno;     /* An errno value */
               int      si_code;      /* Signal code */
               int      si_trapno;    /* Trap number that caused
                                         hardware-generated signal
                                         (unused on most architectures) */
               pid_t    si_pid;       /* Sending process ID */
               uid_t    si_uid;       /* Real user ID of sending process */
               int      si_status;    /* Exit value or signal */
               clock_t  si_utime;     /* User time consumed */
               clock_t  si_stime;     /* System time consumed */
               sigval_t si_value;     /* Signal value */
               int      si_int;       /* POSIX.1b signal */
               void    *si_ptr;       /* POSIX.1b signal */
               int      si_overrun;   /* Timer overrun count;
                                         POSIX.1b timers */
               int      si_timerid;   /* Timer ID; POSIX.1b timers */
               void    *si_addr;      /* Memory location which caused fault */
               long     si_band;      /* Band event (was int in
                                         glibc 2.3.2 and earlier) */
               int      si_fd;        /* File descriptor */
               short    si_addr_lsb;  /* Least significant bit of address
                                         (since Linux 2.6.32) */
               void    *si_lower;     /* Lower bound when address violation
                                         occurred (since Linux 3.19) */
               void    *si_upper;     /* Upper bound when address violation
                                         occurred (since Linux 3.19) */
               int      si_pkey;      /* Protection key on PTE that caused
                                         fault (since Linux 4.6) */
               void    *si_call_addr; /* Address of system call instruction
                                         (since Linux 3.5) */
               int      si_syscall;   /* Number of attempted system call
                                         (since Linux 3.5) */
               unsigned int si_arch;  /* Architecture of attempted system call
                                         (since Linux 3.5) */
           }

       si_signo, si_errno and si_code are defined for all signals.  (si_errno is generally unused on Linux.)  The rest  of
       the struct may be a union, so that one should read only the fields that are meaningful for the given signal:

       * Signals  sent with kill(2) and sigqueue(3) fill in si_pid and si_uid.  In addition, signals sent with sigqueue(3)
         fill in si_int and si_ptr with the values specified by the  sender  of  the  signal;  see  sigqueue(3)  for  more
         details.

       * Signals  sent by POSIX.1b timers (since Linux 2.6) fill in si_overrun and si_timerid.  The si_timerid field is an
         internal ID used by the kernel to identify the timer; it is not the same as the timer ID returned  by  timer_cre‐
         ate(2).   The  si_overrun field is the timer overrun count; this is the same information as is obtained by a call
         to timer_getoverrun(2).  These fields are nonstandard Linux extensions.

       * Signals sent for message queue notification (see  the  description  of  SIGEV_SIGNAL  in  mq_notify(3))  fill  in
         si_int/si_ptr,  with the sigev_value supplied to mq_notify(3); si_pid, with the process ID of the message sender;
         and si_uid, with the real user ID of the message sender.

       * SIGCHLD fills in si_pid, si_uid, si_status, si_utime, and si_stime, providing information about the  child.   The
         si_pid  field  is  the process ID of the child; si_uid is the child's real user ID.  The si_status field contains
         the exit status of the child (if si_code is CLD_EXITED), or the signal number that caused the process  to  change
         state.  The si_utime and si_stime contain the user and system CPU time used by the child process; these fields do
         not include the times used by waited-for children (unlike getrusage(2) and times(2)).  In kernels up to 2.6,  and
         since 2.6.27, these fields report CPU time in units of sysconf(_SC_CLK_TCK).  In 2.6 kernels before 2.6.27, a bug
         meant that these fields reported time in units of the (configurable) system jiffy (see time(7)).

       * SIGILL, SIGFPE, SIGSEGV, SIGBUS, and SIGTRAP fill in si_addr with the address of the fault.   On  some  architec‐
         tures, these signals also fill in the si_trapno field.

         Some  suberrors  of  SIGBUS, in particular BUS_MCEERR_AO and BUS_MCEERR_AR, also fill in si_addr_lsb.  This field
         indicates the least significant bit of the reported address and therefore the  extent  of  the  corruption.   For
         example,  if a full page was corrupted, si_addr_lsb contains log2(sysconf(_SC_PAGESIZE)).  When SIGTRAP is deliv‐
         ered in response to a ptrace(2) event (PTRACE_EVENT_foo), si_addr is not populated, but  si_pid  and  si_uid  are
         populated  with  the  respective process ID and user ID responsible for delivering the trap.  In the case of sec‐
         comp(2), the tracee will be shown as delivering the  event.   BUS_MCEERR_*  and  si_addr_lsb  are  Linux-specific
         extensions.

         The SEGV_BNDERR suberror of SIGSEGV populates si_lower and si_upper.

         The SEGV_PKUERR suberror of SIGSEGV populates si_pkey.

       * SIGIO/SIGPOLL  (the two names are synonyms on Linux) fills in si_band and si_fd.  The si_band event is a bit mask
         containing the same values as are filled in the revents field by poll(2).  The si_fd  field  indicates  the  file
         descriptor for which the I/O event occurred; for further details, see the description of F_SETSIG in fcntl(2).

       * SIGSYS,  generated  (since  Linux  3.5)  when  a  seccomp filter returns SECCOMP_RET_TRAP, fills in si_call_addr,
         si_syscall, si_arch, si_errno, and other fields as described in seccomp(2).

   The si_code field
       The si_code field inside the siginfo_t argument that is passed to a SA_SIGINFO signal handler is a value (not a bit
       mask) indicating why this signal was sent.  For a ptrace(2) event, si_code will contain SIGTRAP and have the ptrace
       event in the high byte:

           (SIGTRAP | PTRACE_EVENT_foo << 8).

       For a non-ptrace(2) event, the values that can appear in si_code are described in the remainder  of  this  section.
       Since  glibc  2.20,  the definitions of most of these symbols are obtained from <signal.h> by defining feature test
       macros (before including any header file) as follows:

       *  _XOPEN_SOURCE with the value 500 or greater;

       *  _XOPEN_SOURCE and _XOPEN_SOURCE_EXTENDED; or

       *  _POSIX_C_SOURCE with the value 200809L or greater.

       For the TRAP_* constants, the symbol definitions are provided only in the first two cases.  Before glibc  2.20,  no
       feature test macros were required to obtain these symbols.

       For a regular signal, the following list shows the values which can be placed in si_code for any signal, along with
       the reason that the signal was generated.

           SI_USER
                  kill(2).

           SI_KERNEL
                  Sent by the kernel.

           SI_QUEUE
                  sigqueue(3).

           SI_TIMER
                  POSIX timer expired.

           SI_MESGQ (since Linux 2.6.6)
                  POSIX message queue state changed; see mq_notify(3).

           SI_ASYNCIO
                  AIO completed.

           SI_SIGIO
                  Queued SIGIO (only in kernels up to Linux 2.2; from Linux 2.4 onward SIGIO/SIGPOLL fills in  si_code  as
                  described below).

           SI_TKILL (since Linux 2.4.19)
                  tkill(2) or tgkill(2).

       The following values can be placed in si_code for a SIGILL signal:

           ILL_ILLOPC
                  Illegal opcode.

           ILL_ILLOPN
                  Illegal operand.

           ILL_ILLADR
                  Illegal addressing mode.

           ILL_ILLTRP
                  Illegal trap.

           ILL_PRVOPC
                  Privileged opcode.

           ILL_PRVREG
                  Privileged register.

           ILL_COPROC
                  Coprocessor error.

           ILL_BADSTK
                  Internal stack error.

       The following values can be placed in si_code for a SIGFPE signal:

           FPE_INTDIV
                  Integer divide by zero.

           FPE_INTOVF
                  Integer overflow.

           FPE_FLTDIV
                  Floating-point divide by zero.

           FPE_FLTOVF
                  Floating-point overflow.

           FPE_FLTUND
                  Floating-point underflow.

           FPE_FLTRES
                  Floating-point inexact result.

           FPE_FLTINV
                  Floating-point invalid operation.

           FPE_FLTSUB
                  Subscript out of range.

       The following values can be placed in si_code for a SIGSEGV signal:

           SEGV_MAPERR
                  Address not mapped to object.

           SEGV_ACCERR
                  Invalid permissions for mapped object.

           SEGV_BNDERR (since Linux 3.19)
                  Failed address bound checks.

           SEGV_PKUERR (since Linux 4.6)
                  Access  was  denied  by memory protection keys.  See pkeys(7).  The protection key which applied to this
                  access is available via si_pkey.

       The following values can be placed in si_code for a SIGBUS signal:

           BUS_ADRALN
                  Invalid address alignment.

           BUS_ADRERR
                  Nonexistent physical address.

           BUS_OBJERR
                  Object-specific hardware error.

           BUS_MCEERR_AR (since Linux 2.6.32)
                  Hardware memory error consumed on a machine check; action required.

           BUS_MCEERR_AO (since Linux 2.6.32)
                  Hardware memory error detected in process but not consumed; action optional.

       The following values can be placed in si_code for a SIGTRAP signal:

           TRAP_BRKPT
                  Process breakpoint.

           TRAP_TRACE
                  Process trace trap.

           TRAP_BRANCH (since Linux 2.4, IA64 only))
                  Process taken branch trap.

           TRAP_HWBKPT (since Linux 2.4, IA64 only))
                  Hardware breakpoint/watchpoint.

       The following values can be placed in si_code for a SIGCHLD signal:

           CLD_EXITED
                  Child has exited.

           CLD_KILLED
                  Child was killed.

           CLD_DUMPED
                  Child terminated abnormally.

           CLD_TRAPPED
                  Traced child has trapped.

           CLD_STOPPED
                  Child has stopped.

           CLD_CONTINUED (since Linux 2.6.9)
                  Stopped child has continued.

       The following values can be placed in si_code for a SIGIO/SIGPOLL signal:

           POLL_IN
                  Data input available.

           POLL_OUT
                  Output buffers available.

           POLL_MSG
                  Input message available.

           POLL_ERR
                  I/O error.

           POLL_PRI
                  High priority input available.

           POLL_HUP
                  Device disconnected.

       The following value can be placed in si_code for a SIGSYS signal:

           SYS_SECCOMP (since Linux 3.5)
                  Triggered by a seccomp(2) filter rule.

RETURN VALUE
       sigaction() returns 0 on success; on error, -1 is returned, and errno is set to indicate the error.

ERRORS
       EFAULT act or oldact points to memory which is not a valid part of the process address space.

       EINVAL An invalid signal was specified.  This will also be generated if an attempt is made to change the action for
              SIGKILL or SIGSTOP, which cannot be caught or ignored.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

NOTES
       A child created via fork(2) inherits a copy of its parent's signal dispositions.  During an execve(2), the disposi‐
       tions of handled signals are reset to the default; the dispositions of ignored signals are left unchanged.

       According to POSIX, the behavior of a process is undefined after it ignores a SIGFPE,  SIGILL,  or  SIGSEGV  signal
       that  was  not generated by kill(2) or raise(3).  Integer division by zero has undefined result.  On some architec‐
       tures it will generate a SIGFPE signal.  (Also dividing the most negative  integer  by  -1  may  generate  SIGFPE.)
       Ignoring this signal might lead to an endless loop.

       POSIX.1-1990  disallowed setting the action for SIGCHLD to SIG_IGN.  POSIX.1-2001 and later allow this possibility,
       so that ignoring SIGCHLD can be used to prevent the creation of zombies (see wait(2)).  Nevertheless, the  histori‐
       cal BSD and System V behaviors for ignoring SIGCHLD differ, so that the only completely portable method of ensuring
       that terminated children do not become zombies is to catch the SIGCHLD signal and perform a wait(2) or similar.

       POSIX.1-1990 specified only SA_NOCLDSTOP.  POSIX.1-2001 added SA_NOCLDSTOP, SA_NOCLDWAIT,  SA_NODEFER,  SA_ONSTACK,
       SA_RESETHAND,  SA_RESTART, and SA_SIGINFO.  Use of these latter values in sa_flags may be less portable in applica‐
       tions intended for older UNIX implementations.

       The SA_RESETHAND flag is compatible with the SVr4 flag of the same name.

       The SA_NODEFER flag is compatible with the SVr4 flag of the same name under kernels 1.3.9 and newer.  On older ker‐
       nels  the  Linux  implementation allowed the receipt of any signal, not just the one we are installing (effectively
       overriding any sa_mask settings).

       sigaction() can be called with a NULL second argument to query the current signal handler.  It can also be used  to
       check whether a given signal is valid for the current machine by calling it with NULL second and third arguments.

       It  is  not  possible  to block SIGKILL or SIGSTOP (by specifying them in sa_mask).  Attempts to do so are silently
       ignored.

       See sigsetops(3) for details on manipulating signal sets.

       See signal-safety(7) for a list of the async-signal-safe functions that can be safely called inside from  inside  a
       signal handler.

   C library/kernel differences
       The glibc wrapper function for sigaction() gives an error (EINVAL) on attempts to change the disposition of the two
       real-time signals used internally by the NPTL threading implementation.  See nptl(7) for details.

       On architectures where the signal trampoline resides in the C library, the glibc wrapper function  for  sigaction()
       places  the  address  of  the  trampoline  code  in  the act.sa_restorer field and sets the SA_RESTORER flag in the
       act.sa_flags field.  See sigreturn(2).

       The original Linux system call was named sigaction().  However, with the addition of  real-time  signals  in  Linux
       2.2,  the  fixed-size,  32-bit  sigset_t  type supported by that system call was no longer fit for purpose.  Conse‐
       quently, a new system call, rt_sigaction(), was added to support an enlarged sigset_t type.  The  new  system  call
       takes a fourth argument, size_t sigsetsize, which specifies the size in bytes of the signal sets in act.sa_mask and
       oldact.sa_mask.  This argument is currently required to have  the  value  sizeof(sigset_t)  (or  the  error  EINVAL
       results).  The glibc sigaction() wrapper function hides these details from us, transparently calling rt_sigaction()
       when the kernel provides it.

   Undocumented
       Before the introduction of SA_SIGINFO, it was also possible to get some additional information, namely by  using  a
       sa_handler  with  a  second argument of type struct sigcontext.  See the relevant Linux kernel sources for details.
       This use is obsolete now.

BUGS
       In kernels up to and including 2.6.13, specifying SA_NODEFER in sa_flags prevents not  only  the  delivered  signal
       from  being  masked during execution of the handler, but also the signals specified in sa_mask.  This bug was fixed
       in kernel 2.6.14.

EXAMPLE
       See mprotect(2).

SEE ALSO
       kill(1), kill(2), pause(2), restart_syscall(2), seccomp(2) sigaltstack(2), signal(2),  signalfd(2),  sigpending(2),
       sigprocmask(2),  sigreturn(2),  sigsuspend(2),  wait(2),  killpg(3), raise(3), siginterrupt(3), sigqueue(3), sigse‐
       tops(3), sigvec(3), core(5), signal(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            SIGACTION(2)
</pre>
<pre zoom>
<span xsmall>2 stat64</span>
STAT(2)                                          Linux Programmer's Manual                                         STAT(2)

NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       int fstat(int fd, struct stat *statbuf);
       int lstat(const char *pathname, struct stat *statbuf);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
                   int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       lstat():
           /* glibc 2.19 and earlier */ _BSD_SOURCE
               || /* Since glibc 2.20 */ _DEFAULT_SOURCE
               || _XOPEN_SOURCE >= 500
               || /* Since glibc 2.10: */ _POSIX_C_SOURCE >= 200112L

       fstatat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  functions return information about a file, in the buffer pointed to by statbuf.  No permissions are required
       on the file itself, but—in the case of stat(), fstatat(), and lstat()—execute (search) permission  is  required  on
       all of the directories in pathname that lead to the file.

       stat()  and fstatat() retrieve information about the file pointed to by pathname; the differences for fstatat() are
       described below.

       lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information  about  the
       link itself, not the file that it refers to.

       fstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the
       file descriptor fd.

   The stat structure
       All of these system calls return a stat structure, which contains the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

       Note: the order of fields in the stat structure varies somewhat across architectures.  In addition, the  definition
       above  does  not  show the padding bytes that may be present between some fields on various architectures.  Consult
       the glibc and kernel source code if you need to know the details.

       Note: for performance and simplicity reasons, different fields in the stat structure may contain state  information
       from  different  moments  during the execution of the system call.  For example, if st_mode or st_uid is changed by
       another process by calling chmod(2) or chown(2), stat() might return the old st_mode together with the new  st_uid,
       or the old st_uid together with the new st_mode.

       The fields in the stat structure are as follows:

       st_dev This field describes the device on which this file resides.  (The major(3) and minor(3) macros may be useful
              to decompose the device ID in this field.)

       st_ino This field contains the file's inode number.

       st_mode
              This field contains the file type and mode.  See inode(7) for further information.

       st_nlink
              This field contains the number of hard links to the file.

       st_uid This field contains the user ID of the owner of the file.

       st_gid This field contains the ID of the group owner of the file.

       st_rdev
              This field describes the device that this file (inode) represents.

       st_size
              This field gives the size of the file (if it is a regular file or a symbolic link) in bytes.  The size of  a
              symbolic link is the length of the pathname it contains, without a terminating null byte.

       st_blksize
              This field gives the "preferred" block size for efficient filesystem I/O.

       st_blocks
              This  field  indicates  the number of blocks allocated to the file, in 512-byte units.  (This may be smaller
              than st_size/512 when the file has holes.)

       st_atime
              This is the file's last access timestamp.

       st_mtime
              This is the file's last modification timestamp.

       st_ctime
              This is the file's last status change timestamp.

       For further information on the above fields, see inode(7).

   fstatat()
       The fstatat() system call is a more general interface for  accessing  file  information  which  can  still  provide
       exactly the behavior of each of stat(), lstat(), and fstat().

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       stat() and lstat() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like stat() and lstat()).

       If pathname is absolute, then dirfd is ignored.

       flags can either be 0, or include one or more of the following flags ORed:

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2) O_PATH flag).  In this case, dirfd can refer to any type of file, not just a directory, and the
              behavior of fstatat() is similar to that of fstat().  If dirfd is AT_FDCWD, the call operates on the current
              working directory.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.

       AT_NO_AUTOMOUNT (since Linux 2.6.38)
              Don't  automount  the  terminal ("basename") component of pathname if it is a directory that is an automount
              point.  This allows the caller to gather attributes of an automount point (rather than the location it would
              mount).   Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand directory such as used
              for automounter indirect maps.  This flag can be used in tools that scan directories to  prevent  mass-auto‐
              mounting  of a directory of automount points.  The AT_NO_AUTOMOUNT flag has no effect if the mount point has
              already been mounted over.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.   Both
              stat() and lstat() act as though AT_NO_AUTOMOUNT was set.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a  symbolic link, do not dereference it: instead return information about the link itself,
              like lstat().  (By default, fstatat() dereferences symbolic links, like stat().)

       See openat(2) for an explanation of the need for fstatat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Search permission is denied for one of the directories in the path prefix of pathname.  (See also path_reso‐
              lution(7).)

       EBADF  fd is not a valid open file descriptor.

       EFAULT Bad address.

       ELOOP  Too many symbolic links encountered while traversing the path.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A  component  of pathname does not exist, or pathname is an empty string and AT_EMPTY_PATH was not specified
              in flags.

       ENOMEM Out of memory (i.e., kernel memory).

       ENOTDIR
              A component of the path prefix of pathname is not a directory.

       EOVERFLOW
              pathname or fd refers to a file whose size, inode number, or number of  blocks  cannot  be  represented  in,
              respectively,  the  types off_t, ino_t, or blkcnt_t.  This error can occur when, for example, an application
              compiled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 calls stat()  on  a  file  whose  size  exceeds
              (1<<31)-1 bytes.

       The following additional errors can occur for fstatat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fstatat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       stat(), fstat(), lstat(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.

       fstatat(): POSIX.1-2008.

       According  to  POSIX.1-2001, lstat() on a symbolic link need return valid information only in the st_size field and
       the file type of the st_mode field of the stat  structure.   POSIX.1-2008  tightens  the  specification,  requiring
       lstat() to return valid information in all fields except the mode bits in st_mode.

       Use of the st_blocks and st_blksize fields may be less portable.  (They were introduced in BSD.  The interpretation
       differs between systems, and possibly on a single system when NFS mounts are involved.)

NOTES
   Timestamp fields
       Older kernels and older standards did not support nanosecond timestamp fields.  Instead, there were three timestamp
       fields—st_atime, st_mtime, and st_ctime—typed as time_t that recorded timestamps with one-second precision.

       Since  kernel  2.5.48,  the stat structure supports nanosecond resolution for the three file timestamp fields.  The
       nanosecond components of each timestamp are available via names of the form st_atim.tv_nsec,  if  suitable  feature
       test macros are defined.  Nanosecond timestamps were standardized in POSIX.1-2008, and, starting with version 2.12,
       glibc exposes the nanosecond component names if _POSIX_C_SOURCE is defined with the value 200809L  or  greater,  or
       _XOPEN_SOURCE  is  defined  with  the value 700 or greater.  Up to and including glibc 2.19, the definitions of the
       nanoseconds components are also defined if _BSD_SOURCE or _SVID_SOURCE is defined.  If none of  the  aforementioned
       macros are defined, then the nanosecond values are exposed with names of the form st_atimensec.

   C library/kernel differences
       Over  time, increases in the size of the stat structure have led to three successive versions of stat(): sys_stat()
       (slot __NR_oldstat), sys_newstat() (slot __NR_stat), and sys_stat64() (slot __NR_stat64) on 32-bit  platforms  such
       as  i386.   The  first  two  versions were already present in Linux 1.0 (albeit with different names); the last was
       added in Linux 2.4.  Similar remarks apply for fstat() and lstat().

       The kernel-internal versions of the stat structure dealt with by the different versions are, respectively:

       __old_kernel_stat
              The original structure, with rather narrow fields, and no padding.

       stat   Larger st_ino field and padding added to various parts of the structure to allow for future expansion.

       stat64 Even larger st_ino field, larger st_uid and st_gid fields to accommodate the Linux-2.4 expansion of UIDs and
              GIDs  to  32 bits, and various other enlarged fields and further padding in the structure.  (Various padding
              bytes were eventually consumed in Linux 2.6, with the advent of 32-bit device IDs and nanosecond  components
              for the timestamp fields.)

       The  glibc  stat()  wrapper function hides these details from applications, invoking the most recent version of the
       system call provided by the kernel, and repacking the returned information if required for old binaries.

       On modern 64-bit systems, life is simpler: there is a single stat() system call and the kernel deals  with  a  stat
       structure that contains fields of a sufficient size.

       The  underlying  system call employed by the glibc fstatat() wrapper function is actually called fstatat64() or, on
       some architectures, newfstatat().

EXAMPLE
       The following program calls lstat() and displays selected fields in the returned stat structure.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/sysmacros.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           printf("ID of containing device:  [%lx,%lx]\n",
                (long) major(sb.st_dev), (long) minor(sb.st_dev));

           printf("File type:                ");

           switch (sb.st_mode & S_IFMT) {
           case S_IFBLK:  printf("block device\n");            break;
           case S_IFCHR:  printf("character device\n");        break;
           case S_IFDIR:  printf("directory\n");               break;
           case S_IFIFO:  printf("FIFO/pipe\n");               break;
           case S_IFLNK:  printf("symlink\n");                 break;
           case S_IFREG:  printf("regular file\n");            break;
           case S_IFSOCK: printf("socket\n");                  break;
           default:       printf("unknown?\n");                break;
           }

           printf("I-node number:            %ld\n", (long) sb.st_ino);

           printf("Mode:                     %lo (octal)\n",
                   (unsigned long) sb.st_mode);

           printf("Link count:               %ld\n", (long) sb.st_nlink);
           printf("Ownership:                UID=%ld   GID=%ld\n",
                   (long) sb.st_uid, (long) sb.st_gid);

           printf("Preferred I/O block size: %ld bytes\n",
                   (long) sb.st_blksize);
           printf("File size:                %lld bytes\n",
                   (long long) sb.st_size);
           printf("Blocks allocated:         %lld\n",
                   (long long) sb.st_blocks);

           printf("Last status change:       %s", ctime(&sb.st_ctime));
           printf("Last file access:         %s", ctime(&sb.st_atime));
           printf("Last file modification:   %s", ctime(&sb.st_mtime));

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ls(1), stat(1), access(2), chmod(2), chown(2), readlink(2), utime(2), capabilities(7), inode(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 STAT(2)
</pre>
<pre zoom>
<span xsmall>2 inotify_rm_watch</span>
INOTIFY_RM_WATCH(2)                              Linux Programmer's Manual                             INOTIFY_RM_WATCH(2)

NAME
       inotify_rm_watch - remove an existing watch from an inotify instance

SYNOPSIS
       #include <sys/inotify.h>

       int inotify_rm_watch(int fd, int wd);

DESCRIPTION
       inotify_rm_watch()  removes  the watch associated with the watch descriptor wd from the inotify instance associated
       with the file descriptor fd.

       Removing a watch causes an IN_IGNORED event to be generated for this watch descriptor.  (See inotify(7).)

RETURN VALUE
       On success, inotify_rm_watch() returns zero.  On error, -1 is returned and errno is set to indicate  the  cause  of
       the error.

ERRORS
       EBADF  fd is not a valid file descriptor.

       EINVAL The watch descriptor wd is not valid; or fd is not an inotify file descriptor.

VERSIONS
       Inotify was merged into the 2.6.13 Linux kernel.

CONFORMING TO
       This system call is Linux-specific.

SEE ALSO
       inotify_add_watch(2), inotify_init(2), inotify(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                     INOTIFY_RM_WATCH(2)
</pre>
<pre zoom>
<span xsmall>2 ioctl_ficlone</span>
IOCTL-FICLONERANGE(2)                            Linux Programmer's Manual                           IOCTL-FICLONERANGE(2)

NAME
       ioctl_ficlonerange, ioctl_ficlone - share some the data of one file with another file

SYNOPSIS
       #include <sys/ioctl.h>
       #include <linux/fs.h>

       int ioctl(int dest_fd, FICLONERANGE, struct file_clone_range *arg);
       int ioctl(int dest_fd, FICLONE, int src_fd);

DESCRIPTION
       If a filesystem supports files sharing physical storage between multiple files ("reflink"), this ioctl(2) operation
       can be used to make some of the data in the src_fd file appear in the dest_fd file by sharing the underlying  stor‐
       age,  which  is  faster  than  making a separate physical copy of the data.  Both files must reside within the same
       filesystem.  If a file write should occur to a shared region, the filesystem must ensure that  the  changes  remain
       private to the file being written.  This behavior is commonly referred to as "copy on write".

       This  ioctl  reflinks up to src_length bytes from file descriptor src_fd at offset src_offset into the file dest_fd
       at offset dest_offset, provided that both are files.  If src_length is zero, the ioctl reflinks to the end  of  the
       source file.  This information is conveyed in a structure of the following form:

           struct file_clone_range {
               __s64 src_fd;
               __u64 src_offset;
               __u64 src_length;
               __u64 dest_offset;
           };

       Clones  are  atomic  with  regards to concurrent writes, so no locks need to be taken to obtain a consistent cloned
       copy.

       The FICLONE ioctl clones entire files.

RETURN VALUE
       On error, -1 is returned, and errno is set to indicate the error.

ERRORS
       Error codes can be one of, but are not limited to, the following:

       EBADF  src_fd is not open for reading; dest_fd is not open for writing or is open for append-only  writes;  or  the
              filesystem which src_fd resides on does not support reflink.

       EINVAL The  filesystem  does  not  support reflinking the ranges of the given files.  This error can also appear if
              either file descriptor represents a device, FIFO, or socket.  Disk filesystems generally require the  offset
              and  length arguments to be aligned to the fundamental block size.  XFS and Btrfs do not support overlapping
              reflink ranges in the same file.

       EISDIR One of the files is a directory and the filesystem does not support shared regions in directories.

       EOPNOTSUPP
              This can appear if the filesystem does not support reflinking either file  descriptor,  or  if  either  file
              descriptor refers to special inodes.

       EPERM  dest_fd is immutable.

       ETXTBSY
              One of the files is a swap file.  Swap files cannot share storage.

       EXDEV  dest_fd and src_fd are not on the same mounted filesystem.

VERSIONS
       These  ioctl  operations  first  appeared  in  Linux  4.5.   They  were  previously  known  as  BTRFS_IOC_CLONE and
       BTRFS_IOC_CLONE_RANGE, and were private to Btrfs.

CONFORMING TO
       This API is Linux-specific.

NOTES
       Because a copy-on-write operation requires the allocation of new storage, the fallocate(2)  operation  may  unshare
       shared blocks to guarantee that subsequent writes will not fail because of lack of disk space.

SEE ALSO
       ioctl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                   IOCTL-FICLONERANGE(2)
</pre>
<pre zoom>
<span xsmall>2 setfsgid32</span>
SETFSGID(2)                                      Linux Programmer's Manual                                     SETFSGID(2)

NAME
       setfsgid - set group identity used for filesystem checks

SYNOPSIS
       #include <sys/fsuid.h>

       int setfsgid(uid_t fsgid);

DESCRIPTION
       The system call setfsgid() changes the value of the caller's filesystem group ID—the group ID that the Linux kernel
       uses to check for all accesses to the filesystem.  Normally, the value of the filesystem group ID will  shadow  the
       value of the effective group ID.  In fact, whenever the effective group ID is changed, the filesystem group ID will
       also be changed to the new value of the effective group ID.

       Explicit calls to setfsuid(2) and setfsgid() are usually used only by programs such as the Linux  NFS  server  that
       need to change what user and group ID is used for file access without a corresponding change in the real and effec‐
       tive user and group IDs.  A change in the normal user IDs for a program such as the NFS server is a  security  hole
       that can expose it to unwanted signals.  (But see below.)

       setfsgid()  will succeed only if the caller is the superuser or if fsgid matches either the caller's real group ID,
       effective group ID, saved set-group-ID, or current the filesystem user ID.

RETURN VALUE
       On both success and failure, this call returns the previous filesystem group ID of the caller.

VERSIONS
       This system call is present in Linux since version 1.2.

CONFORMING TO
       setfsgid() is Linux-specific and should not be used in programs intended to be portable.

NOTES
       Note that at the time this system call was introduced, a process could send a signal to a  process  with  the  same
       effective  user  ID.   Today signal permission handling is slightly different.  See setfsuid(2) for a discussion of
       why the use of both setfsuid(2) and setfsgid() is nowadays unneeded.

       The original Linux setfsgid() system call supported only 16-bit group IDs.  Subsequently, Linux  2.4  added  setfs‐
       gid32() supporting 32-bit IDs.  The glibc setfsgid() wrapper function transparently deals with the variation across
       kernel versions.

   C library/kernel differences
       In glibc 2.15 and earlier, when the wrapper for this system call determines that the argument can't  be  passed  to
       the  kernel without integer truncation (because the kernel is old and does not support 32-bit group IDs), they will
       return -1 and set errno to EINVAL without attempting the system call.

BUGS
       No error indications of any kind are returned to the caller, and the fact that  both  successful  and  unsuccessful
       calls  return  the  same  value  makes  it  impossible  to directly determine whether the call succeeded or failed.
       Instead, the caller must resort to looking at the return value from a further call such as setfsgid(-1) (which will
       always fail), in order to determine if a preceding call to setfsgid() changed the filesystem group ID.  At the very
       least, EPERM should be returned when the call fails (because the caller lacks the CAP_SETGID capability).

SEE ALSO
       kill(2), setfsuid(2), capabilities(7), credentials(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             SETFSGID(2)
</pre>
<pre zoom>
<span xsmall>2 epoll_create1</span>
EPOLL_CREATE(2)                                  Linux Programmer's Manual                                 EPOLL_CREATE(2)

NAME
       epoll_create, epoll_create1 - open an epoll file descriptor

SYNOPSIS
       #include <sys/epoll.h>

       int epoll_create(int size);
       int epoll_create1(int flags);

DESCRIPTION
       epoll_create()  creates  a  new  epoll(7)  instance.   Since Linux 2.6.8, the size argument is ignored, but must be
       greater than zero; see NOTES below.

       epoll_create() returns a file descriptor referring to the new epoll instance.  This file descriptor is used for all
       the  subsequent  calls to the epoll interface.  When no longer required, the file descriptor returned by epoll_cre‐
       ate() should be closed by using close(2).  When all file descriptors referring  to  an  epoll  instance  have  been
       closed, the kernel destroys the instance and releases the associated resources for reuse.

   epoll_create1()
       If flags is 0, then, other than the fact that the obsolete size argument is dropped, epoll_create1() is the same as
       epoll_create().  The following value can be included in flags to obtain different behavior:

       EPOLL_CLOEXEC
              Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.  See the description  of  the  O_CLOEXEC
              flag in open(2) for reasons why this may be useful.

RETURN VALUE
       On success, these system calls return a nonnegative file descriptor.  On error, -1 is returned, and errno is set to
       indicate the error.

ERRORS
       EINVAL size is not positive.

       EINVAL (epoll_create1()) Invalid value specified in flags.

       EMFILE The per-user limit on the number of epoll instances  imposed  by  /proc/sys/fs/epoll/max_user_instances  was
              encountered.  See epoll(7) for further details.

       EMFILE The per-process limit on the number of open file descriptors has been reached.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENOMEM There was insufficient memory to create the kernel object.

VERSIONS
       epoll_create()  was added to the kernel in version 2.6.  Library support is provided in glibc starting with version
       2.3.2.

       epoll_create1() was added to the kernel in version 2.6.27.  Library support is provided in glibc starting with ver‐
       sion 2.9.

CONFORMING TO
       epoll_create() is Linux-specific.

NOTES
       In  the initial epoll_create() implementation, the size argument informed the kernel of the number of file descrip‐
       tors that the caller expected to add to the epoll instance.  The kernel used this information as  a  hint  for  the
       amount  of  space  to  initially allocate in internal data structures describing events.  (If necessary, the kernel
       would allocate more space if the caller's usage exceeded the hint given in size.)  Nowadays, this hint is no longer
       required  (the kernel dynamically sizes the required data structures without needing the hint), but size must still
       be greater than zero, in order to ensure backward compatibility when new epoll applications are run on  older  ker‐
       nels.

SEE ALSO
       close(2), epoll_ctl(2), epoll_wait(2), epoll(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                         EPOLL_CREATE(2)
</pre>
<pre zoom>
<span xsmall>2 setxattr</span>
SETXATTR(2)                                      Linux Programmer's Manual                                     SETXATTR(2)

NAME
       setxattr, lsetxattr, fsetxattr - set an extended attribute value

SYNOPSIS
       #include <sys/types.h>
       #include <sys/xattr.h>

       int setxattr(const char *path, const char *name,
                     const void *value, size_t size, int flags);
       int lsetxattr(const char *path, const char *name,
                     const void *value, size_t size, int flags);
       int fsetxattr(int fd, const char *name,
                     const void *value, size_t size, int flags);

DESCRIPTION
       Extended  attributes  are name:value pairs associated with inodes (files, directories, symbolic links, etc.).  They
       are extensions to the normal attributes which are associated with all inodes  in  the  system  (i.e.,  the  stat(2)
       data).  A complete overview of extended attributes concepts can be found in xattr(7).

       setxattr()  sets  the  value of the extended attribute identified by name and associated with the given path in the
       filesystem.  The size argument specifies the size (in bytes) of value; a zero-length value is permitted.

       lsetxattr() is identical to setxattr(), except in the case of a symbolic link, where the extended attribute is  set
       on the link itself, not the file that it refers to.

       fsetxattr()  is  identical to setxattr(), only the extended attribute is set on the open file referred to by fd (as
       returned by open(2)) in place of path.

       An extended attribute name is a null-terminated string.  The name includes a namespace prefix; there  may  be  sev‐
       eral,  disjoint  namespaces  associated with an individual inode.  The value of an extended attribute is a chunk of
       arbitrary textual or binary data of specified length.

       By default (i.e., flags is zero), the extended attribute will be created if it does not exist, or the value will be
       replaced  if the attribute already exists.  To modify these semantics, one of the following values can be specified
       in flags:

       XATTR_CREATE
              Perform a pure create, which fails if the named attribute exists already.

       XATTR_REPLACE
              Perform a pure replace operation, which fails if the named attribute does not already exist.

RETURN VALUE
       On success, zero is returned.  On failure, -1 is returned and errno is set appropriately.

ERRORS
       EDQUOT Disk quota limits meant that there is insufficient space remaining to store the extended attribute.

       EEXIST XATTR_CREATE was specified, and the attribute exists already.

       ENOATTR
              XATTR_REPLACE was specified, and the attribute does not exist.  (ENOATTR is defined to be a synonym for ENO‐
              DATA in <attr/xattr.h>.)

       ENOSPC There is insufficient space remaining to store the extended attribute.

       ENOTSUP
              The namespace prefix of name is not valid.

       ENOTSUP
              Extended attributes are not supported by the filesystem, or are disabled,

       EPERM  The file is marked immutable or append-only.  (See ioctl_iflags(2).)

       In addition, the errors documented in stat(2) can also occur.

VERSIONS
       These system calls have been available on Linux since kernel 2.4; glibc support is provided since version 2.3.

CONFORMING TO
       These system calls are Linux-specific.

SEE ALSO
       getfattr(1), setfattr(1), getxattr(2), listxattr(2), open(2), removexattr(2), stat(2), symlink(7), xattr(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-03-13                                             SETXATTR(2)
</pre>
<pre zoom>
<span xsmall>2 clock_settime</span>
CLOCK_GETRES(2)                                  Linux Programmer's Manual                                 CLOCK_GETRES(2)

NAME
       clock_getres, clock_gettime, clock_settime - clock and time functions

SYNOPSIS
       #include <time.h>

       int clock_getres(clockid_t clk_id, struct timespec *res);

       int clock_gettime(clockid_t clk_id, struct timespec *tp);

       int clock_settime(clockid_t clk_id, const struct timespec *tp);

       Link with -lrt (only for glibc versions before 2.17).

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       clock_getres(), clock_gettime(), clock_settime():
              _POSIX_C_SOURCE >= 199309L

DESCRIPTION
       The  function  clock_getres()  finds  the resolution (precision) of the specified clock clk_id, and, if res is non-
       NULL, stores it in the struct timespec pointed to by res.  The resolution of clocks depends on  the  implementation
       and  cannot  be  configured by a particular process.  If the time value pointed to by the argument tp of clock_set‐
       time() is not a multiple of res, then it is truncated to a multiple of res.

       The functions clock_gettime() and clock_settime() retrieve and set the time of the specified clock clk_id.

       The res and tp arguments are timespec structures, as specified in <time.h>:

           struct timespec {
               time_t   tv_sec;        /* seconds */
               long     tv_nsec;       /* nanoseconds */
           };

       The clk_id argument is the identifier of the particular clock on which to act.  A  clock  may  be  system-wide  and
       hence visible for all processes, or per-process if it measures time only within a single process.

       All  implementations support the system-wide real-time clock, which is identified by CLOCK_REALTIME.  Its time rep‐
       resents seconds and nanoseconds since the Epoch.  When its time is changed, timers  for  a  relative  interval  are
       unaffected, but timers for an absolute point in time are affected.

       More  clocks  may  be implemented.  The interpretation of the corresponding time values and the effect on timers is
       unspecified.

       Sufficiently recent versions of glibc and the Linux kernel support the following clocks:

       CLOCK_REALTIME
              System-wide clock that measures real (i.e., wall-clock) time.  Setting this clock requires appropriate priv‐
              ileges.  This clock is affected by discontinuous jumps in the system time (e.g., if the system administrator
              manually changes the clock), and by the incremental adjustments performed by adjtime(3) and NTP.

       CLOCK_REALTIME_COARSE (since Linux 2.6.32; Linux-specific)
              A faster but less precise version of CLOCK_REALTIME.  Use when you need  very  fast,  but  not  fine-grained
              timestamps.   Requires per-architecture support, and probably also architecture support for this flag in the
              vdso(7).

       CLOCK_MONOTONIC
              Clock that cannot be set and represents monotonic time since some unspecified starting point.  This clock is
              not  affected  by discontinuous jumps in the system time (e.g., if the system administrator manually changes
              the clock), but is affected by the incremental adjustments performed by adjtime(3) and NTP.

       CLOCK_MONOTONIC_COARSE (since Linux 2.6.32; Linux-specific)
              A faster but less precise version of CLOCK_MONOTONIC.  Use when you need very  fast,  but  not  fine-grained
              timestamps.   Requires per-architecture support, and probably also architecture support for this flag in the
              vdso(7).

       CLOCK_MONOTONIC_RAW (since Linux 2.6.28; Linux-specific)
              Similar to CLOCK_MONOTONIC, but provides access to a raw hardware-based time that  is  not  subject  to  NTP
              adjustments or the incremental adjustments performed by adjtime(3).

       CLOCK_BOOTTIME (since Linux 2.6.39; Linux-specific)
              Identical  to  CLOCK_MONOTONIC,  except it also includes any time that the system is suspended.  This allows
              applications to get a suspend-aware monotonic clock  without  having  to  deal  with  the  complications  of
              CLOCK_REALTIME, which may have discontinuities if the time is changed using settimeofday(2) or similar.

       CLOCK_PROCESS_CPUTIME_ID (since Linux 2.6.12)
              Per-process CPU-time clock (measures CPU time consumed by all threads in the process).

       CLOCK_THREAD_CPUTIME_ID (since Linux 2.6.12)
              Thread-specific CPU-time clock.

RETURN VALUE
       clock_gettime(),  clock_settime(),  and clock_getres() return 0 for success, or -1 for failure (in which case errno
       is set appropriately).

ERRORS
       EFAULT tp points outside the accessible address space.

       EINVAL The clk_id specified is not supported on this system.

       EPERM  clock_settime() does not have permission to set the clock indicated.

VERSIONS
       These system calls first appeared in Linux 2.6.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌─────────────────────────────────┬───────────────┬─────────┐
       │Interface                        │ Attribute     │ Value   │
       ├─────────────────────────────────┼───────────────┼─────────┤
       │clock_getres(), clock_gettime(), │ Thread safety │ MT-Safe │
       │clock_settime()                  │               │         │
       └─────────────────────────────────┴───────────────┴─────────┘

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SUSv2.

AVAILABILITY
       On  POSIX  systems  on  which these functions are available, the symbol _POSIX_TIMERS is defined in <unistd.h> to a
       value greater than 0.  The symbols  _POSIX_MONOTONIC_CLOCK,  _POSIX_CPUTIME,  _POSIX_THREAD_CPUTIME  indicate  that
       CLOCK_MONOTONIC, CLOCK_PROCESS_CPUTIME_ID, CLOCK_THREAD_CPUTIME_ID are available.  (See also sysconf(3).)

NOTES
       POSIX.1 specifies the following:

              Setting  the  value of the CLOCK_REALTIME clock via clock_settime() shall have no effect on threads that are
              blocked waiting for a relative time service based upon this clock, including the nanosleep()  function;  nor
              on  the expiration of relative timers based upon this clock.  Consequently, these time services shall expire
              when the requested relative interval elapses, independently of the new or old value of the clock.

   C library/kernel differences
       On some architectures, an implementation of clock_gettime() is provided in the vdso(7).

   Historical note for SMP systems
       Before Linux added kernel support for CLOCK_PROCESS_CPUTIME_ID and CLOCK_THREAD_CPUTIME_ID, glibc implemented these
       clocks on many platforms using timer registers from the CPUs (TSC on i386, AR.ITC on Itanium).  These registers may
       differ between CPUs and as a consequence these clocks may return bogus results if a process is migrated to  another
       CPU.

       If  the  CPUs in an SMP system have different clock sources, then there is no way to maintain a correlation between
       the timer registers since each CPU will run at  a  slightly  different  frequency.   If  that  is  the  case,  then
       clock_getcpuclockid(0) will return ENOENT to signify this condition.  The two clocks will then be useful only if it
       can be ensured that a process stays on a certain CPU.

       The processors in an SMP system do not start all at exactly the same time and therefore  the  timer  registers  are
       typically  running  at  an offset.  Some architectures include code that attempts to limit these offsets on bootup.
       However, the code cannot guarantee to accurately tune the offsets.  Glibc contains no provisions to deal with these
       offsets  (unlike  the Linux Kernel).  Typically these offsets are small and therefore the effects may be negligible
       in most cases.

       Since glibc 2.4, the wrapper functions for the system calls described in this page avoid the  abovementioned  prob‐
       lems  by  employing  the  kernel implementation of CLOCK_PROCESS_CPUTIME_ID and CLOCK_THREAD_CPUTIME_ID, on systems
       that provide such an implementation (i.e., Linux 2.6.12 and later).

BUGS
       According to POSIX.1-2001, a process  with  "appropriate  privileges"  may  set  the  CLOCK_PROCESS_CPUTIME_ID  and
       CLOCK_THREAD_CPUTIME_ID  clocks  using  clock_settime().  On Linux, these clocks are not settable (i.e., no process
       has "appropriate privileges").

SEE ALSO
       date(1),  gettimeofday(2),  settimeofday(2),  time(2),  adjtime(3),  clock_getcpuclockid(3),  ctime(3),   ftime(3),
       pthread_getcpuclockid(3), sysconf(3), time(7), vdso(7), hwclock(8)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

                                                        2017-09-15                                         CLOCK_GETRES(2)
</pre>
<pre zoom>
<span xsmall>2 perf_event_open</span>
PERF_EVENT_OPEN(2)                               Linux Programmer's Manual                              PERF_EVENT_OPEN(2)

NAME
       perf_event_open - set up performance monitoring

SYNOPSIS
       #include <linux/perf_event.h>
       #include <linux/hw_breakpoint.h>

       int perf_event_open(struct perf_event_attr *attr,
                           pid_t pid, int cpu, int group_fd,
                           unsigned long flags);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       Given  a  list  of  parameters,  perf_event_open()  returns  a  file descriptor, for use in subsequent system calls
       (read(2), mmap(2), prctl(2), fcntl(2), etc.).

       A call to perf_event_open() creates a file descriptor that allows measuring  performance  information.   Each  file
       descriptor  corresponds  to  one  event  that is measured; these can be grouped together to measure multiple events
       simultaneously.

       Events can be enabled and disabled in two ways: via ioctl(2) and via prctl(2).  When an event is disabled  it  does
       not count or generate overflows but does continue to exist and maintain its count value.

       Events  come in two flavors: counting and sampled.  A counting event is one that is used for counting the aggregate
       number of events that occur.  In general, counting event results are gathered with  a  read(2)  call.   A  sampling
       event periodically writes measurements to a buffer that can then be accessed via mmap(2).

   Arguments
       The pid and cpu arguments allow specifying which process and CPU to monitor:

       pid == 0 and cpu == -1
              This measures the calling process/thread on any CPU.

       pid == 0 and cpu >= 0
              This measures the calling process/thread only when running on the specified CPU.

       pid > 0 and cpu == -1
              This measures the specified process/thread on any CPU.

       pid > 0 and cpu >= 0
              This measures the specified process/thread only when running on the specified CPU.

       pid == -1 and cpu >= 0
              This  measures  all  processes/threads  on  the  specified CPU.  This requires CAP_SYS_ADMIN capability or a
              /proc/sys/kernel/perf_event_paranoid value of less than 1.

       pid == -1 and cpu == -1
              This setting is invalid and will return an error.

       When pid is greater than zero, permission to perform  this  system  call  is  governed  by  a  ptrace  access  mode
       PTRACE_MODE_READ_REALCREDS check; see ptrace(2).

       The  group_fd  argument allows event groups to be created.  An event group has one event which is the group leader.
       The leader is created first, with group_fd = -1.  The rest  of  the  group  members  are  created  with  subsequent
       perf_event_open() calls with group_fd being set to the file descriptor of the group leader.  (A single event on its
       own is created with group_fd = -1 and is considered to be a group with only 1 member.)  An event group is scheduled
       onto the CPU as a unit: it will be put onto the CPU only if all of the events in the group can be put onto the CPU.
       This means that the values of the member events can be meaningfully compared—added, divided (to get ratios), and so
       on—with each other, since they have counted events for the same set of executed instructions.

       The flags argument is formed by ORing together zero or more of the following values:

       PERF_FLAG_FD_CLOEXEC (since Linux 3.14)
              This  flag enables the close-on-exec flag for the created event file descriptor, so that the file descriptor
              is automatically closed on execve(2).  Setting the close-on-exec flags at creation time, rather  than  later
              with  fcntl(2),  avoids  potential  race  conditions  where the calling thread invokes perf_event_open() and
              fcntl(2) at the same time as another thread calls fork(2) then execve(2).

       PERF_FLAG_FD_NO_GROUP
              This flag tells the event to ignore the group_fd parameter except for the purpose of setting up output redi‐
              rection using the PERF_FLAG_FD_OUTPUT flag.

       PERF_FLAG_FD_OUTPUT (broken since Linux 2.6.35)
              This flag re-routes the event's sampled output to instead be included in the mmap buffer of the event speci‐
              fied by group_fd.

       PERF_FLAG_PID_CGROUP (since Linux 2.6.39)
              This flag activates per-container system-wide monitoring.  A container is an abstraction that isolates a set
              of  resources  for  finer-grained control (CPUs, memory, etc.).  In this mode, the event is measured only if
              the thread running on the monitored CPU belongs to the designated container (cgroup).  The cgroup is identi‐
              fied  by passing a file descriptor opened on its directory in the cgroupfs filesystem.  For instance, if the
              cgroup to monitor is called test, then a file descriptor opened on /dev/cgroup/test  (assuming  cgroupfs  is
              mounted  on  /dev/cgroup) must be passed as the pid parameter.  cgroup monitoring is available only for sys‐
              tem-wide events and may therefore require extra permissions.

       The perf_event_attr structure provides detailed configuration information for the event being created.

           struct perf_event_attr {
               __u32 type;                 /* Type of event */
               __u32 size;                 /* Size of attribute structure */
               __u64 config;               /* Type-specific configuration */

               union {
                   __u64 sample_period;    /* Period of sampling */
                   __u64 sample_freq;      /* Frequency of sampling */
               };

               __u64 sample_type;  /* Specifies values included in sample */
               __u64 read_format;  /* Specifies values returned in read */

               __u64 disabled       : 1,   /* off by default */
                     inherit        : 1,   /* children inherit it */
                     pinned         : 1,   /* must always be on PMU */
                     exclusive      : 1,   /* only group on PMU */
                     exclude_user   : 1,   /* don't count user */
                     exclude_kernel : 1,   /* don't count kernel */
                     exclude_hv     : 1,   /* don't count hypervisor */
                     exclude_idle   : 1,   /* don't count when idle */
                     mmap           : 1,   /* include mmap data */
                     comm           : 1,   /* include comm data */
                     freq           : 1,   /* use freq, not period */
                     inherit_stat   : 1,   /* per task counts */
                     enable_on_exec : 1,   /* next exec enables */
                     task           : 1,   /* trace fork/exit */
                     watermark      : 1,   /* wakeup_watermark */
                     precise_ip     : 2,   /* skid constraint */
                     mmap_data      : 1,   /* non-exec mmap data */
                     sample_id_all  : 1,   /* sample_type all events */
                     exclude_host   : 1,   /* don't count in host */
                     exclude_guest  : 1,   /* don't count in guest */
                     exclude_callchain_kernel : 1,
                                           /* exclude kernel callchains */
                     exclude_callchain_user   : 1,
                                           /* exclude user callchains */
                     mmap2          :  1,  /* include mmap with inode data */
                     comm_exec      :  1,  /* flag comm events that are
                                              due to exec */
                     use_clockid    :  1,  /* use clockid for time fields */
                     context_switch :  1,  /* context switch data */

                     __reserved_1   : 37;

               union {
                   __u32 wakeup_events;    /* wakeup every n events */
                   __u32 wakeup_watermark; /* bytes before wakeup */
               };

               __u32     bp_type;          /* breakpoint type */

               union {
                   __u64 bp_addr;          /* breakpoint address */
                   __u64 kprobe_func;      /* for perf_kprobe */
                   __u64 uprobe_path;      /* for perf_uprobe */
                   __u64 config1;          /* extension of config */
               };

               union {
                   __u64 bp_len;           /* breakpoint length */
                   __u64 kprobe_addr;      /* with kprobe_func == NULL */
                   __u64 probe_offset;     /* for perf_[k,u]probe */
                   __u64 config2;          /* extension of config1 */
               };
               __u64 branch_sample_type;   /* enum perf_branch_sample_type */
               __u64 sample_regs_user;     /* user regs to dump on samples */
               __u32 sample_stack_user;    /* size of stack to dump on
                                              samples */
               __s32 clockid;              /* clock to use for time fields */
               __u64 sample_regs_intr;     /* regs to dump on samples */
               __u32 aux_watermark;        /* aux bytes before wakeup */
               __u16 sample_max_stack;     /* max frames in callchain */
               __u16 __reserved_2;         /* align to u64 */

           };

       The fields of the perf_event_attr structure are described in more detail below:

       type   This field specifies the overall event type.  It has one of the following values:

              PERF_TYPE_HARDWARE
                     This indicates one of the "generalized" hardware events provided by the kernel.  See the config field
                     definition for more details.

              PERF_TYPE_SOFTWARE
                     This indicates one of the software-defined events provided by the kernel (even if no hardware support
                     is available).

              PERF_TYPE_TRACEPOINT
                     This indicates a tracepoint provided by the kernel tracepoint infrastructure.

              PERF_TYPE_HW_CACHE
                     This indicates a hardware cache event.  This has a special encoding, described in  the  config  field
                     definition.

              PERF_TYPE_RAW
                     This indicates a "raw" implementation-specific event in the config field.

              PERF_TYPE_BREAKPOINT (since Linux 2.6.33)
                     This  indicates a hardware breakpoint as provided by the CPU.  Breakpoints can be read/write accesses
                     to an address as well as execution of an instruction address.

              dynamic PMU
                     Since Linux 2.6.38, perf_event_open() can support multiple PMUs.  To enable this, a value exported by
                     the kernel can be used in the type field to indicate which PMU to use.  The value to use can be found
                     in   the   sysfs   filesystem:    there    is    a    subdirectory    per    PMU    instance    under
                     /sys/bus/event_source/devices.  In each subdirectory there is a type file whose content is an integer
                     that can be used in the type field.  For  instance,  /sys/bus/event_source/devices/cpu/type  contains
                     the value for the core CPU PMU, which is usually 4.

              kprobe and uprobe (since Linux 4.17)
                     These  two  dynamic  PMUs  create  a  kprobe/uprobe and attach it to the file descriptor generated by
                     perf_event_open.  The kprobe/uprobe will be destroyed on the destruction of the file descriptor.  See
                     fields kprobe_func, uprobe_path, kprobe_addr, and probe_offset for more details.

       size   The  size of the perf_event_attr structure for forward/backward compatibility.  Set this using sizeof(struct
              perf_event_attr) to allow the kernel to see the struct size at the time of compilation.

              The related define PERF_ATTR_SIZE_VER0 is set to 64; this was  the  size  of  the  first  published  struct.
              PERF_ATTR_SIZE_VER1   is   72,   corresponding   to   the   addition   of   breakpoints   in  Linux  2.6.33.
              PERF_ATTR_SIZE_VER2  is  80  corresponding  to   the   addition   of   branch   sampling   in   Linux   3.4.
              PERF_ATTR_SIZE_VER3  is  96 corresponding to the addition of sample_regs_user and sample_stack_user in Linux
              3.7.  PERF_ATTR_SIZE_VER4  is  104  corresponding  to  the  addition  of  sample_regs_intr  in  Linux  3.19.
              PERF_ATTR_SIZE_VER5 is 112 corresponding to the addition of aux_watermark in Linux 4.1.

       config This specifies which event you want, in conjunction with the type field.  The config1 and config2 fields are
              also taken into account in cases where 64 bits is not enough to fully specify the event.   The  encoding  of
              these fields are event dependent.

              There  are  various ways to set the config field that are dependent on the value of the previously described
              type field.  What follows are various possible settings for config separated out by type.

              If type is PERF_TYPE_HARDWARE, we are measuring one of the generalized hardware  CPU  events.   Not  all  of
              these are available on all platforms.  Set config to one of the following:

                   PERF_COUNT_HW_CPU_CYCLES
                          Total cycles.  Be wary of what happens during CPU frequency scaling.

                   PERF_COUNT_HW_INSTRUCTIONS
                          Retired  instructions.   Be careful, these can be affected by various issues, most notably hard‐
                          ware interrupt counts.

                   PERF_COUNT_HW_CACHE_REFERENCES
                          Cache accesses.  Usually this indicates Last Level Cache accesses but this may vary depending on
                          your  CPU.  This may include prefetches and coherency messages; again this depends on the design
                          of your CPU.

                   PERF_COUNT_HW_CACHE_MISSES
                          Cache misses.  Usually this indicates Last Level Cache misses; this is intended to  be  used  in
                          conjunction with the PERF_COUNT_HW_CACHE_REFERENCES event to calculate cache miss rates.

                   PERF_COUNT_HW_BRANCH_INSTRUCTIONS
                          Retired  branch  instructions.   Prior to Linux 2.6.35, this used the wrong event on AMD proces‐
                          sors.

                   PERF_COUNT_HW_BRANCH_MISSES
                          Mispredicted branch instructions.

                   PERF_COUNT_HW_BUS_CYCLES
                          Bus cycles, which can be different from total cycles.

                   PERF_COUNT_HW_STALLED_CYCLES_FRONTEND (since Linux 3.0)
                          Stalled cycles during issue.

                   PERF_COUNT_HW_STALLED_CYCLES_BACKEND (since Linux 3.0)
                          Stalled cycles during retirement.

                   PERF_COUNT_HW_REF_CPU_CYCLES (since Linux 3.3)
                          Total cycles; not affected by CPU frequency scaling.

              If type is PERF_TYPE_SOFTWARE, we are measuring software events provided by the kernel.  Set config  to  one
              of the following:

                   PERF_COUNT_SW_CPU_CLOCK
                          This reports the CPU clock, a high-resolution per-CPU timer.

                   PERF_COUNT_SW_TASK_CLOCK
                          This reports a clock count specific to the task that is running.

                   PERF_COUNT_SW_PAGE_FAULTS
                          This reports the number of page faults.

                   PERF_COUNT_SW_CONTEXT_SWITCHES
                          This counts context switches.  Until Linux 2.6.34, these were all reported as user-space events,
                          after that they are reported as happening in the kernel.

                   PERF_COUNT_SW_CPU_MIGRATIONS
                          This reports the number of times the process has migrated to a new CPU.

                   PERF_COUNT_SW_PAGE_FAULTS_MIN
                          This counts the number of minor page faults.  These did not require disk I/O to handle.

                   PERF_COUNT_SW_PAGE_FAULTS_MAJ
                          This counts the number of major page faults.  These required disk I/O to handle.

                   PERF_COUNT_SW_ALIGNMENT_FAULTS (since Linux 2.6.33)
                          This counts the number of alignment faults.  These happen when unaligned memory accesses happen;
                          the kernel can handle these but it reduces performance.  This happens only on some architectures
                          (never on x86).

                   PERF_COUNT_SW_EMULATION_FAULTS (since Linux 2.6.33)
                          This counts the number of  emulation  faults.   The  kernel  sometimes  traps  on  unimplemented
                          instructions and emulates them for user space.  This can negatively impact performance.

                   PERF_COUNT_SW_DUMMY (since Linux 3.12)
                          This is a placeholder event that counts nothing.  Informational sample record types such as mmap
                          or comm must be associated with an active event.  This dummy event allows gathering such records
                          without requiring a counting event.

              If  type  is PERF_TYPE_TRACEPOINT, then we are measuring kernel tracepoints.  The value to use in config can
              be obtained from under debugfs tracing/events/*/*/id if ftrace is enabled in the kernel.

              If type is PERF_TYPE_HW_CACHE, then we are measuring a hardware CPU cache event.  To calculate the appropri‐
              ate config value use the following equation:

                      (perf_hw_cache_id) | (perf_hw_cache_op_id << 8) |
                      (perf_hw_cache_op_result_id << 16)

                  where perf_hw_cache_id is one of:

                      PERF_COUNT_HW_CACHE_L1D
                             for measuring Level 1 Data Cache

                      PERF_COUNT_HW_CACHE_L1I
                             for measuring Level 1 Instruction Cache

                      PERF_COUNT_HW_CACHE_LL
                             for measuring Last-Level Cache

                      PERF_COUNT_HW_CACHE_DTLB
                             for measuring the Data TLB

                      PERF_COUNT_HW_CACHE_ITLB
                             for measuring the Instruction TLB

                      PERF_COUNT_HW_CACHE_BPU
                             for measuring the branch prediction unit

                      PERF_COUNT_HW_CACHE_NODE (since Linux 3.1)
                             for measuring local memory accesses

                  and perf_hw_cache_op_id is one of:

                      PERF_COUNT_HW_CACHE_OP_READ
                             for read accesses

                      PERF_COUNT_HW_CACHE_OP_WRITE
                             for write accesses

                      PERF_COUNT_HW_CACHE_OP_PREFETCH
                             for prefetch accesses

                  and perf_hw_cache_op_result_id is one of:

                      PERF_COUNT_HW_CACHE_RESULT_ACCESS
                             to measure accesses

                      PERF_COUNT_HW_CACHE_RESULT_MISS
                             to measure misses

              If type is PERF_TYPE_RAW, then a custom "raw" config value is needed.  Most CPUs support events that are not
              covered by the "generalized" events.  These are implementation defined; see your CPU manual (for example the
              Intel  Volume 3B documentation or the AMD BIOS and Kernel Developer Guide).  The libpfm4 library can be used
              to translate from the name in the architectural manuals to the raw hex value  perf_event_open()  expects  in
              this field.

              If type is PERF_TYPE_BREAKPOINT, then leave config set to zero.  Its parameters are set in other places.

              If     type     is     kprobe     or     uprobe,     set     retprobe     (bit     0    of    config,    see
              /sys/bus/event_source/devices/[k,u]probe/format/retprobe) for kretprobe/uretprobe.  See fields  kprobe_func,
              uprobe_path, kprobe_addr, and probe_offset for more details.

       kprobe_func, uprobe_path, kprobe_addr, and probe_offset
              These fields describe the kprobe/uprobe for dynamic PMUs kprobe and uprobe.  For kprobe: use kprobe_func and
              probe_offset, or use kprobe_addr and leave kprobe_func as NULL.  For uprobe: use uprobe_path and  probe_off‐
              set.

       sample_period, sample_freq
              A  "sampling"  event is one that generates an overflow notification every N events, where N is given by sam‐
              ple_period.  A sampling event has sample_period > 0.  When an overflow occurs, requested data is recorded in
              the mmap buffer.  The sample_type field controls what data is recorded on each overflow.

              sample_freq  can  be  used  if you wish to use frequency rather than period.  In this case, you set the freq
              flag.  The kernel will adjust the sampling period to try and achieve the desired rate.  The rate of  adjust‐
              ment is a timer tick.

       sample_type
              The  various  bits  in this field specify which values to include in the sample.  They will be recorded in a
              ring-buffer, which is available to user space using mmap(2).  The order in which the values are saved in the
              sample  are  documented  in  the  MMAP  Layout subsection below; it is not the enum perf_event_sample_format
              order.

              PERF_SAMPLE_IP
                     Records instruction pointer.

              PERF_SAMPLE_TID
                     Records the process and thread IDs.

              PERF_SAMPLE_TIME
                     Records a timestamp.

              PERF_SAMPLE_ADDR
                     Records an address, if applicable.

              PERF_SAMPLE_READ
                     Record counter values for all events in a group, not just the group leader.

              PERF_SAMPLE_CALLCHAIN
                     Records the callchain (stack backtrace).

              PERF_SAMPLE_ID
                     Records a unique ID for the opened event's group leader.

              PERF_SAMPLE_CPU
                     Records CPU number.

              PERF_SAMPLE_PERIOD
                     Records the current sampling period.

              PERF_SAMPLE_STREAM_ID
                     Records a unique ID for the opened event.  Unlike PERF_SAMPLE_ID the actual ID is returned,  not  the
                     group leader.  This ID is the same as the one returned by PERF_FORMAT_ID.

              PERF_SAMPLE_RAW
                     Records additional data, if applicable.  Usually returned by tracepoint events.

              PERF_SAMPLE_BRANCH_STACK (since Linux 3.4)
                     This provides a record of recent branches, as provided by CPU branch sampling hardware (such as Intel
                     Last Branch Record).  Not all hardware supports this feature.

                     See the branch_sample_type field for how to filter which branches are reported.

              PERF_SAMPLE_REGS_USER (since Linux 3.7)
                     Records the current user-level CPU register state (the values in the process before  the  kernel  was
                     called).

              PERF_SAMPLE_STACK_USER (since Linux 3.7)
                     Records the user level stack, allowing stack unwinding.

              PERF_SAMPLE_WEIGHT (since Linux 3.10)
                     Records  a  hardware  provided  weight  value  that expresses how costly the sampled event was.  This
                     allows the hardware to highlight expensive events in a profile.

              PERF_SAMPLE_DATA_SRC (since Linux 3.10)
                     Records the data source: where in the memory hierarchy the data associated with the sampled  instruc‐
                     tion came from.  This is available only if the underlying hardware supports this feature.

              PERF_SAMPLE_IDENTIFIER (since Linux 3.12)
                     Places  the  SAMPLE_ID  value  in a fixed position in the record, either at the beginning (for sample
                     events) or at the end (if a non-sample event).

                     This was necessary because a sample stream may have records from various different event sources with
                     different  sample_type settings.  Parsing the event stream properly was not possible because the for‐
                     mat of the record was needed to find SAMPLE_ID, but the format could not  be  found  without  knowing
                     what event the sample belonged to (causing a circular dependency).

                     The  PERF_SAMPLE_IDENTIFIER  setting makes the event stream always parsable by putting SAMPLE_ID in a
                     fixed location, even though it means having duplicate SAMPLE_ID values in records.

              PERF_SAMPLE_TRANSACTION (since Linux 3.13)
                     Records reasons for transactional memory abort events (for example, from Intel TSX transactional mem‐
                     ory support).

                     The precise_ip setting must be greater than 0 and a transactional memory abort event must be measured
                     or no values will be recorded.  Also note that some perf_event measurements, such  as  sampled  cycle
                     counting, may cause extraneous aborts (by causing an interrupt during a transaction).

              PERF_SAMPLE_REGS_INTR (since Linux 3.19)
                     Records  a  subset  of  the  current  CPU  register  state  as specified by sample_regs_intr.  Unlike
                     PERF_SAMPLE_REGS_USER the register values will return kernel register state if the overflow  happened
                     while kernel code is running.  If the CPU supports hardware sampling of register state (i.e., PEBS on
                     Intel x86) and precise_ip is set higher than zero then the register values returned  are  those  cap‐
                     tured by hardware at the time of the sampled instruction's retirement.

       read_format
              This field specifies the format of the data returned by read(2) on a perf_event_open() file descriptor.

              PERF_FORMAT_TOTAL_TIME_ENABLED
                     Adds  the  64-bit  time_enabled  field.  This can be used to calculate estimated totals if the PMU is
                     overcommitted and multiplexing is happening.

              PERF_FORMAT_TOTAL_TIME_RUNNING
                     Adds the 64-bit time_running field.  This can be used to calculate estimated totals  if  the  PMU  is
                     overcommitted and multiplexing is happening.

              PERF_FORMAT_ID
                     Adds a 64-bit unique value that corresponds to the event group.

              PERF_FORMAT_GROUP
                     Allows all counter values in an event group to be read with one read.

       disabled
              The  disabled  bit specifies whether the counter starts out disabled or enabled.  If disabled, the event can
              later be enabled by ioctl(2), prctl(2), or enable_on_exec.

              When creating an event group, typically the group leader is initialized with disabled set to 1 and any child
              events  are  initialized  with disabled set to 0.  Despite disabled being 0, the child events will not start
              until the group leader is enabled.

       inherit
              The inherit bit specifies that this counter should count events of child tasks as well as  the  task  speci‐
              fied.   This  applies  only to new children, not to any existing children at the time the counter is created
              (nor to any new children of existing children).

              Inherit does not work for some combinations of read_format values, such as PERF_FORMAT_GROUP.

       pinned The pinned bit specifies that the counter should always be on the CPU if at all possible.  It  applies  only
              to  hardware  counters  and  only  to  group leaders.  If a pinned counter cannot be put onto the CPU (e.g.,
              because there are not enough hardware counters or because of a conflict with some  other  event),  then  the
              counter  goes  into  an  'error'  state,  where reads return end-of-file (i.e., read(2) returns 0) until the
              counter is subsequently enabled or disabled.

       exclusive
              The exclusive bit specifies that when this counter's group is on the CPU, it should be the only group  using
              the  CPU's  counters.  In the future this may allow monitoring programs to support PMU features that need to
              run alone so that they do not disrupt other hardware counters.

              Note that many unexpected situations may prevent events with the exclusive bit set from ever running.   This
              includes  any  users running a system-wide measurement as well as any kernel use of the performance counters
              (including the commonly enabled NMI Watchdog Timer interface).

       exclude_user
              If this bit is set, the count excludes events that happen in user space.

       exclude_kernel
              If this bit is set, the count excludes events that happen in kernel space.

       exclude_hv
              If this bit is set, the count excludes events that happen in the hypervisor.  This is mainly for  PMUs  that
              have  built-in  support  for handling this (such as POWER).  Extra support is needed for handling hypervisor
              measurements on most machines.

       exclude_idle
              If set, don't count when the CPU is idle.

       mmap   The mmap bit enables generation of PERF_RECORD_MMAP samples for every mmap(2) call that has  PROT_EXEC  set.
              This  allows  tools  to notice new executable code being mapped into a program (dynamic shared libraries for
              example) so that addresses can be mapped back to the original code.

       comm   The comm bit enables tracking of process command name as modified by the exec(2) and prctl(PR_SET_NAME) sys‐
              tem  calls  as well as writing to /proc/self/comm.  If the comm_exec flag is also successfully set (possible
              since Linux 3.16), then the misc flag PERF_RECORD_MISC_COMM_EXEC can be used to  differentiate  the  exec(2)
              case from the others.

       freq   If this bit is set, then sample_frequency not sample_period is used when setting up the sampling interval.

       inherit_stat
              This  bit  enables saving of event counts on context switch for inherited tasks.  This is meaningful only if
              the inherit field is set.

       enable_on_exec
              If this bit is set, a counter is automatically enabled after a call to exec(2).

       task   If this bit is set, then fork/exit notifications are included in the ring buffer.

       watermark
              If set, have an overflow notification happen when we cross the wakeup_watermark boundary.  Otherwise,  over‐
              flow notifications happen after wakeup_events samples.

       precise_ip (since Linux 2.6.35)
              This  controls  the amount of skid.  Skid is how many instructions execute between an event of interest hap‐
              pening and the kernel being able to stop and record the event.  Smaller skid is better and allows more accu‐
              rate  reporting  of  which  events  correspond to which instructions, but hardware is often limited with how
              small this can be.

              The possible values of this field are the following:

              0  SAMPLE_IP can have arbitrary skid.

              1  SAMPLE_IP must have constant skid.

              2  SAMPLE_IP requested to have 0 skid.

              3  SAMPLE_IP must have 0 skid.  See also the description of PERF_RECORD_MISC_EXACT_IP.

       mmap_data (since Linux 2.6.36)
              This is the counterpart of the mmap field.  This enables generation of PERF_RECORD_MMAP samples for  mmap(2)
              calls that do not have PROT_EXEC set (for example data and SysV shared memory).

       sample_id_all (since Linux 2.6.38)
              If  set,  then  TID, TIME, ID, STREAM_ID, and CPU can additionally be included in non-PERF_RECORD_SAMPLEs if
              the corresponding sample_type is selected.

              If PERF_SAMPLE_IDENTIFIER is specified, then an additional ID value is included as the last  value  to  ease
              parsing the record stream.  This may lead to the id value appearing twice.

              The layout is described by this pseudo-structure:

                  struct sample_id {
                      { u32 pid, tid; }   /* if PERF_SAMPLE_TID set */
                      { u64 time;     }   /* if PERF_SAMPLE_TIME set */
                      { u64 id;       }   /* if PERF_SAMPLE_ID set */
                      { u64 stream_id;}   /* if PERF_SAMPLE_STREAM_ID set  */
                      { u32 cpu, res; }   /* if PERF_SAMPLE_CPU set */
                      { u64 id;       }   /* if PERF_SAMPLE_IDENTIFIER set */
                  };
                  ,in

       exclude_host (since Linux 3.2)
              When  conducting  measurements  that  include  processes running VM instances (i.e., have executed a KVM_RUN
              ioctl(2)), only measure events happening inside a guest instance.   This  is  only  meaningful  outside  the
              guests;  this  setting  does not change counts gathered inside of a guest.  Currently, this functionality is
              x86 only.

       exclude_guest (since Linux 3.2)
              When conducting measurements that include processes running VM instances  (i.e.,  have  executed  a  KVM_RUN
              ioctl(2)),  do  not  measure  events  happening inside guest instances.  This is only meaningful outside the
              guests; this setting does not change counts gathered inside of a guest.  Currently,  this  functionality  is
              x86 only.

       exclude_callchain_kernel (since Linux 3.7)
              Do not include kernel callchains.

       exclude_callchain_user (since Linux 3.7)
              Do not include user callchains.

       mmap2 (since Linux 3.16)
              Generate an extended executable mmap record that contains enough additional information to uniquely identify
              shared mappings.  The mmap flag must also be set for this to work.

       comm_exec (since Linux 3.16)
              This is purely a feature-detection flag, it does not change kernel behavior.  If this flag can  successfully
              be  set,  then, when comm is enabled, the PERF_RECORD_MISC_COMM_EXEC flag will be set in the misc field of a
              comm record header if the rename event being reported was caused by a call to exec(2).  This allows tools to
              distinguish between the various types of process renaming.

       use_clockid (since Linux 4.1)
              This  allows  selecting  which internal Linux clock to use when generating timestamps via the clockid field.
              This can make it easier to correlate perf sample times with timestamps generated by other tools.

       context_switch (since Linux 4.3)
              This enables the generation of PERF_RECORD_SWITCH records when a context switch occurs.  It also enables the
              generation  of PERF_RECORD_SWITCH_CPU_WIDE records when sampling in CPU-wide mode.  This functionality is in
              addition to existing tracepoint and software events for measuring context switches.  The advantage  of  this
              method is that it will give full information even with strict perf_event_paranoid settings.

       wakeup_events, wakeup_watermark
              This union sets how many samples (wakeup_events) or bytes (wakeup_watermark) happen before an overflow noti‐
              fication happens.  Which one is used is selected by the watermark bit flag.

              wakeup_events counts only PERF_RECORD_SAMPLE  record  types.   To  receive  overflow  notification  for  all
              PERF_RECORD types choose watermark and set wakeup_watermark to 1.

              Prior  to  Linux  3.0, setting wakeup_events to 0 resulted in no overflow notifications; more recent kernels
              treat 0 the same as 1.

       bp_type (since Linux 2.6.33)
              This chooses the breakpoint type.  It is one of:

              HW_BREAKPOINT_EMPTY
                     No breakpoint.

              HW_BREAKPOINT_R
                     Count when we read the memory location.

              HW_BREAKPOINT_W
                     Count when we write the memory location.

              HW_BREAKPOINT_RW
                     Count when we read or write the memory location.

              HW_BREAKPOINT_X
                     Count when we execute code at the memory location.

              The values can be combined via a bitwise or, but the combination of HW_BREAKPOINT_R or HW_BREAKPOINT_W  with
              HW_BREAKPOINT_X is not allowed.

       bp_addr (since Linux 2.6.33)
              This  is  the  address  of  the  breakpoint.   For  execution breakpoints, this is the memory address of the
              instruction of interest; for read and write breakpoints, it is the memory address of the memory location  of
              interest.

       config1 (since Linux 2.6.39)
              config1 is used for setting events that need an extra register or otherwise do not fit in the regular config
              field.  Raw OFFCORE_EVENTS on Nehalem/Westmere/SandyBridge use this field on Linux 3.3 and later kernels.

       bp_len (since Linux 2.6.33)
              bp_len is the length of the  breakpoint  being  measured  if  type  is  PERF_TYPE_BREAKPOINT.   Options  are
              HW_BREAKPOINT_LEN_1,  HW_BREAKPOINT_LEN_2,  HW_BREAKPOINT_LEN_4,  and HW_BREAKPOINT_LEN_8.  For an execution
              breakpoint, set this to sizeof(long).

       config2 (since Linux 2.6.39)
              config2 is a further extension of the config1 field.

       branch_sample_type (since Linux 3.4)
              If PERF_SAMPLE_BRANCH_STACK is enabled, then this specifies what branches to include in the branch record.

              The first part of the value is the privilege level, which is a combination  of  one  of  the  values  listed
              below.   If  the  user  does  not  set privilege level explicitly, the kernel will use the event's privilege
              level.  Event and branch privilege levels do not have to match.

              PERF_SAMPLE_BRANCH_USER
                     Branch target is in user space.

              PERF_SAMPLE_BRANCH_KERNEL
                     Branch target is in kernel space.

              PERF_SAMPLE_BRANCH_HV
                     Branch target is in hypervisor.

              PERF_SAMPLE_BRANCH_PLM_ALL
                     A convenience value that is the three preceding values ORed together.

              In addition to the privilege value, at least one or more of the following bits must be set.

              PERF_SAMPLE_BRANCH_ANY
                     Any branch type.

              PERF_SAMPLE_BRANCH_ANY_CALL
                     Any call branch (includes direct calls, indirect calls, and far jumps).

              PERF_SAMPLE_BRANCH_IND_CALL
                     Indirect calls.

              PERF_SAMPLE_BRANCH_CALL (since Linux 4.4)
                     Direct calls.

              PERF_SAMPLE_BRANCH_ANY_RETURN
                     Any return branch.

              PERF_SAMPLE_BRANCH_IND_JUMP (since Linux 4.2)
                     Indirect jumps.

              PERF_SAMPLE_BRANCH_COND (since Linux 3.16)
                     Conditional branches.

              PERF_SAMPLE_BRANCH_ABORT_TX (since Linux 3.11)
                     Transactional memory aborts.

              PERF_SAMPLE_BRANCH_IN_TX (since Linux 3.11)
                     Branch in transactional memory transaction.

              PERF_SAMPLE_BRANCH_NO_TX (since Linux 3.11)
                     Branch not in transactional memory  transaction.   PERF_SAMPLE_BRANCH_CALL_STACK  (since  Linux  4.1)
                     Branch  is  part  of a hardware-generated call stack.  This requires hardware support, currently only
                     found on Intel x86 Haswell or newer.

       sample_regs_user (since Linux 3.7)
              This bit mask defines the set of user CPU registers to dump on samples.  The layout of the register mask  is
              architecture-specific and is described in the kernel header file arch/ARCH/include/uapi/asm/perf_regs.h.

       sample_stack_user (since Linux 3.7)
              This defines the size of the user stack to dump if PERF_SAMPLE_STACK_USER is specified.

       clockid (since Linux 4.1)
              If use_clockid is set, then this field selects which internal Linux timer to use for timestamps.  The avail‐
              able  timers  are  defined  in  linux/time.h,  with  CLOCK_MONOTONIC,  CLOCK_MONOTONIC_RAW,  CLOCK_REALTIME,
              CLOCK_BOOTTIME, and CLOCK_TAI currently supported.

       aux_watermark (since Linux 4.1)
              This specifies how much data is required to trigger a PERF_RECORD_AUX sample.

       sample_max_stack (since Linux 4.8)
              When  sample_type  includes PERF_SAMPLE_CALLCHAIN, this field specifies how many stack frames to report when
              generating the callchain.

   Reading results
       Once a perf_event_open() file descriptor has been opened, the values of the  events  can  be  read  from  the  file
       descriptor.  The values that are there are specified by the read_format field in the attr structure at open time.

       If you attempt to read into a buffer that is not big enough to hold the data, the error ENOSPC results.

       Here is the layout of the data returned by a read:

       * If PERF_FORMAT_GROUP was specified to allow reading all events in a group at once:

             struct read_format {
                 u64 nr;            /* The number of events */
                 u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */
                 u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */
                 struct {
                     u64 value;     /* The value of the event */
                     u64 id;        /* if PERF_FORMAT_ID */
                 } values[nr];
             };

       * If PERF_FORMAT_GROUP was not specified:

             struct read_format {
                 u64 value;         /* The value of the event */
                 u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */
                 u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */
                 u64 id;            /* if PERF_FORMAT_ID */
             };

       The values read are as follows:

       nr     The number of events in this file descriptor.  Available only if PERF_FORMAT_GROUP was specified.

       time_enabled, time_running
              Total  time  the  event  was  enabled  and running.  Normally these values are the same.  If more events are
              started, then available counter slots on the PMU, then multiplexing happens and events run only part of  the
              time.   In  that  case, the time_enabled and time running values can be used to scale an estimated value for
              the count.

       value  An unsigned 64-bit value containing the counter result.

       id     A globally unique value for this particular event; only present if PERF_FORMAT_ID was specified in read_for‐
              mat.

   MMAP layout
       When  using  perf_event_open() in sampled mode, asynchronous events (like counter overflow or PROT_EXEC mmap track‐
       ing) are logged into a ring-buffer.  This ring-buffer is created and accessed through mmap(2).

       The mmap size should be 1+2^n pages, where the first page is a metadata  page  (struct  perf_event_mmap_page)  that
       contains various bits of information such as where the ring-buffer head is.

       Before  kernel 2.6.39, there is a bug that means you must allocate an mmap ring buffer when sampling even if you do
       not plan to access it.

       The structure of the first metadata mmap page is as follows:

           struct perf_event_mmap_page {
               __u32 version;        /* version number of this structure */
               __u32 compat_version; /* lowest version this is compat with */
               __u32 lock;           /* seqlock for synchronization */
               __u32 index;          /* hardware counter identifier */
               __s64 offset;         /* add to hardware counter value */
               __u64 time_enabled;   /* time event active */
               __u64 time_running;   /* time event on CPU */
               union {
                   __u64   capabilities;
                   struct {
                       __u64 cap_usr_time / cap_usr_rdpmc / cap_bit0 : 1,
                             cap_bit0_is_deprecated : 1,
                             cap_user_rdpmc         : 1,
                             cap_user_time          : 1,
                             cap_user_time_zero     : 1,
                   };
               };
               __u16 pmc_width;
               __u16 time_shift;
               __u32 time_mult;
               __u64 time_offset;
               __u64 __reserved[120];   /* Pad to 1 k */
               __u64 data_head;         /* head in the data section */
               __u64 data_tail;         /* user-space written tail */
               __u64 data_offset;       /* where the buffer starts */
               __u64 data_size;         /* data buffer size */
               __u64 aux_head;
               __u64 aux_tail;
               __u64 aux_offset;
               __u64 aux_size;

           }

       The following list describes the fields in the perf_event_mmap_page structure in more detail:

       version
              Version number of this structure.

       compat_version
              The lowest version this is compatible with.

       lock   A seqlock for synchronization.

       index  A unique hardware counter identifier.

       offset When using rdpmc for reads this offset value must be added to the one returned by rdpmc to get  the  current
              total event count.

       time_enabled
              Time the event was active.

       time_running
              Time the event was running.

       cap_usr_time / cap_usr_rdpmc / cap_bit0 (since Linux 3.4)
              There  was  a bug in the definition of cap_usr_time and cap_usr_rdpmc from Linux 3.4 until Linux 3.11.  Both
              bits were defined to point to  the  same  location,  so  it  was  impossible  to  know  if  cap_usr_time  or
              cap_usr_rdpmc were actually set.

              Starting  with  Linux  3.12,  these  are  renamed  to  cap_bit0  and  you  should  use the cap_user_time and
              cap_user_rdpmc fields instead.

       cap_bit0_is_deprecated (since Linux 3.12)
              If set, this bit indicates that the kernel supports the properly separated cap_user_time and  cap_user_rdpmc
              bits.

              If  not-set,  it indicates an older kernel where cap_usr_time and cap_usr_rdpmc map to the same bit and thus
              both features should be used with caution.

       cap_user_rdpmc (since Linux 3.12)
              If the hardware supports user-space read of performance  counters  without  syscall  (this  is  the  "rdpmc"
              instruction on x86), then the following code can be used to do a read:

                  u32 seq, time_mult, time_shift, idx, width;
                  u64 count, enabled, running;
                  u64 cyc, time_offset;

                  do {
                      seq = pc->lock;
                      barrier();
                      enabled = pc->time_enabled;
                      running = pc->time_running;

                      if (pc->cap_usr_time && enabled != running) {
                          cyc = rdtsc();
                          time_offset = pc->time_offset;
                          time_mult   = pc->time_mult;
                          time_shift  = pc->time_shift;
                      }

                      idx = pc->index;
                      count = pc->offset;

                      if (pc->cap_usr_rdpmc && idx) {
                          width = pc->pmc_width;
                          count += rdpmc(idx - 1);
                      }

                      barrier();
                  } while (pc->lock != seq);

       cap_user_time (since Linux 3.12)
              This bit indicates the hardware has a constant, nonstop timestamp counter (TSC on x86).

       cap_user_time_zero (since Linux 3.12)
              Indicates the presence of time_zero which allows mapping timestamp values to the hardware clock.

       pmc_width
              If cap_usr_rdpmc, this field provides the bit-width of the value read using the rdpmc or equivalent instruc‐
              tion.  This can be used to sign extend the result like:

                  pmc <<= 64 - pmc_width;
                  pmc >>= 64 - pmc_width; // signed shift right
                  count += pmc;

       time_shift, time_mult, time_offset

              If cap_usr_time, these fields can be used to compute the time  delta  since  time_enabled  (in  nanoseconds)
              using rdtsc or similar.

                  u64 quot, rem;
                  u64 delta;
                  quot = (cyc >> time_shift);
                  rem = cyc & (((u64)1 << time_shift) - 1);
                  delta = time_offset + quot * time_mult +
                          ((rem * time_mult) >> time_shift);

              Where time_offset, time_mult, time_shift, and cyc are read in the seqcount loop described above.  This delta
              can then be added to enabled and possible running (if idx), improving the scaling:

                  enabled += delta;
                  if (idx)
                      running += delta;
                  quot = count / running;
                  rem  = count % running;
                  count = quot * enabled + (rem * enabled) / running;

       time_zero (since Linux 3.12)

              If cap_usr_time_zero is set, then the hardware clock (the TSC timestamp counter on x86)  can  be  calculated
              from the time_zero, time_mult, and time_shift values:

                  time = timestamp - time_zero;
                  quot = time / time_mult;
                  rem  = time % time_mult;
                  cyc = (quot << time_shift) + (rem << time_shift) / time_mult;

              And vice versa:

                  quot = cyc >> time_shift;
                  rem  = cyc & (((u64)1 << time_shift) - 1);
                  timestamp = time_zero + quot * time_mult +
                      ((rem * time_mult) >> time_shift);

       data_head
              This points to the head of the data section.  The value continuously increases, it does not wrap.  The value
              needs to be manually wrapped by the size of the mmap buffer before accessing the samples.

              On SMP-capable platforms, after reading the data_head value, user space should issue an rmb().

       data_tail
              When the mapping is PROT_WRITE, the data_tail value should be written by user space to reflect the last read
              data.  In this case, the kernel will not overwrite unread data.

       data_offset (since Linux 4.1)
              Contains the offset of the location in the mmap buffer where perf sample data begins.

       data_size (since Linux 4.1)
              Contains the size of the perf sample region within the mmap buffer.

       aux_head, aux_tail, aux_offset, aux_size (since Linux 4.1)
              The  AUX  region  allows mmaping a separate sample buffer for high-bandwidth data streams (separate from the
              main perf sample buffer).  An example of a high-bandwidth stream is instruction tracing support, as is found
              in newer Intel processors.

              To  set  up  an AUX area, first aux_offset needs to be set with an offset greater than data_offset+data_size
              and aux_size needs to be set to the desired buffer size.  The desired offset and size must be page  aligned,
              and  the  size must be a power of two.  These values are then passed to mmap in order to map the AUX buffer.
              Pages in the AUX buffer are included as part of the RLIMIT_MEMLOCK resource limit  (see  setrlimit(2)),  and
              also as part of the perf_event_mlock_kb allowance.

              By  default,  the AUX buffer will be truncated if it will not fit in the available space in the ring buffer.
              If the AUX buffer is mapped as a read only buffer, then it will operate in ring buffer mode where  old  data
              will  be overwritten by new.  In overwrite mode, it might not be possible to infer where the new data began,
              and it is the consumer's job to disable measurement while reading to avoid possible data races.

              The aux_head and aux_tail ring buffer pointers have the same behavior and ordering  rules  as  the  previous
              described data_head and data_tail.

       The following 2^n ring-buffer pages have the layout described below.

       If  perf_event_attr.sample_id_all is set, then all event types will have the sample_type selected fields related to
       where/when (identity) an event took place (TID, TIME, ID, CPU, STREAM_ID) described in PERF_RECORD_SAMPLE below, it
       will  be  stashed just after the perf_event_header and the fields already present for the existing fields, that is,
       at the end of the payload.  This allows a newer perf.data file to be supported by older perf tools,  with  the  new
       optional fields being ignored.

       The mmap values start with a header:

           struct perf_event_header {
               __u32   type;
               __u16   misc;
               __u16   size;
           };

       Below,  we  describe  the  perf_event_header  fields  in more detail.  For ease of reading, the fields with shorter
       descriptions are presented first.

       size   This indicates the size of the record.

       misc   The misc field contains additional information about the sample.

              The CPU mode can be determined from this value by masking with PERF_RECORD_MISC_CPUMODE_MASK and looking for
              one of the following (note these are not bit masks, only one can be set at a time):

              PERF_RECORD_MISC_CPUMODE_UNKNOWN
                     Unknown CPU mode.

              PERF_RECORD_MISC_KERNEL
                     Sample happened in the kernel.

              PERF_RECORD_MISC_USER
                     Sample happened in user code.

              PERF_RECORD_MISC_HYPERVISOR
                     Sample happened in the hypervisor.

              PERF_RECORD_MISC_GUEST_KERNEL (since Linux 2.6.35)
                     Sample happened in the guest kernel.

              PERF_RECORD_MISC_GUEST_USER  (since Linux 2.6.35)
                     Sample happened in guest user code.

              Since the following three statuses are generated by different record types, they alias to the same bit:

              PERF_RECORD_MISC_MMAP_DATA (since Linux 3.10)
                     This is set when the mapping is not executable; otherwise the mapping is executable.

              PERF_RECORD_MISC_COMM_EXEC (since Linux 3.16)
                     This  is  set  for a PERF_RECORD_COMM record on kernels more recent than Linux 3.16 if a process name
                     change was caused by an exec(2) system call.

              PERF_RECORD_MISC_SWITCH_OUT (since Linux 4.3)
                     When a PERF_RECORD_SWITCH or PERF_RECORD_SWITCH_CPU_WIDE record is generated, this bit indicates that
                     the context switch is away from the current process (instead of into the current process).

              In addition, the following bits can be set:

              PERF_RECORD_MISC_EXACT_IP
                     This indicates that the content of PERF_SAMPLE_IP points to the actual instruction that triggered the
                     event.  See also perf_event_attr.precise_ip.

              PERF_RECORD_MISC_EXT_RESERVED (since Linux 2.6.35)
                     This indicates there is extended data available (currently not used).

              PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT
                     This bit is not set by the kernel.  It is reserved for the user-space perf utility to  indicate  that
                     /proc/i[pid]/maps parsing was taking too long and was stopped, and thus the mmap records may be trun‐
                     cated.

       type   The type value is one of the below.  The values in the corresponding record (that follows the header) depend
              on the type selected as shown.

              PERF_RECORD_MMAP
                  The  MMAP  events  record  the PROT_EXEC mappings so that we can correlate user-space IPs to code.  They
                  have the following structure:

                      struct {
                          struct perf_event_header header;
                          u32    pid, tid;
                          u64    addr;
                          u64    len;
                          u64    pgoff;
                          char   filename[];
                      };

                  pid    is the process ID.

                  tid    is the thread ID.

                  addr   is the address of the allocated memory.  len is the length of the allocated memory.  pgoff is the
                         page  offset  of  the allocated memory.  filename is a string describing the backing of the allo‐
                         cated memory.

              PERF_RECORD_LOST
                  This record indicates when events are lost.

                      struct {
                          struct perf_event_header header;
                          u64    id;
                          u64    lost;
                          struct sample_id sample_id;
                      };

                  id     is the unique event ID for the samples that were lost.

                  lost   is the number of events that were lost.

              PERF_RECORD_COMM
                  This record indicates a change in the process name.

                      struct {
                          struct perf_event_header header;
                          u32    pid;
                          u32    tid;
                          char   comm[];
                          struct sample_id sample_id;
                      };

                  pid    is the process ID.

                  tid    is the thread ID.

                  comm   is a string containing the new name of the process.

              PERF_RECORD_EXIT
                  This record indicates a process exit event.

                      struct {
                          struct perf_event_header header;
                          u32    pid, ppid;
                          u32    tid, ptid;
                          u64    time;
                          struct sample_id sample_id;
                      };

              PERF_RECORD_THROTTLE, PERF_RECORD_UNTHROTTLE
                  This record indicates a throttle/unthrottle event.

                      struct {
                          struct perf_event_header header;
                          u64    time;
                          u64    id;
                          u64    stream_id;
                          struct sample_id sample_id;
                      };

              PERF_RECORD_FORK
                  This record indicates a fork event.

                      struct {
                          struct perf_event_header header;
                          u32    pid, ppid;
                          u32    tid, ptid;
                          u64    time;
                          struct sample_id sample_id;
                      };

              PERF_RECORD_READ
                  This record indicates a read event.

                      struct {
                          struct perf_event_header header;
                          u32    pid, tid;
                          struct read_format values;
                          struct sample_id sample_id;
                      };

              PERF_RECORD_SAMPLE
                  This record indicates a sample.

                      struct {
                          struct perf_event_header header;
                          u64    sample_id;   /* if PERF_SAMPLE_IDENTIFIER */
                          u64    ip;          /* if PERF_SAMPLE_IP */
                          u32    pid, tid;    /* if PERF_SAMPLE_TID */
                          u64    time;        /* if PERF_SAMPLE_TIME */
                          u64    addr;        /* if PERF_SAMPLE_ADDR */
                          u64    id;          /* if PERF_SAMPLE_ID */
                          u64    stream_id;   /* if PERF_SAMPLE_STREAM_ID */
                          u32    cpu, res;    /* if PERF_SAMPLE_CPU */
                          u64    period;      /* if PERF_SAMPLE_PERIOD */
                          struct read_format v;
                                              /* if PERF_SAMPLE_READ */
                          u64    nr;          /* if PERF_SAMPLE_CALLCHAIN */
                          u64    ips[nr];     /* if PERF_SAMPLE_CALLCHAIN */
                          u32    size;        /* if PERF_SAMPLE_RAW */
                          char  data[size];   /* if PERF_SAMPLE_RAW */
                          u64    bnr;         /* if PERF_SAMPLE_BRANCH_STACK */
                          struct perf_branch_entry lbr[bnr];
                                              /* if PERF_SAMPLE_BRANCH_STACK */
                          u64    abi;         /* if PERF_SAMPLE_REGS_USER */
                          u64    regs[weight(mask)];
                                              /* if PERF_SAMPLE_REGS_USER */
                          u64    size;        /* if PERF_SAMPLE_STACK_USER */
                          char   data[size];  /* if PERF_SAMPLE_STACK_USER */
                          u64    dyn_size;    /* if PERF_SAMPLE_STACK_USER &&
                                                 size != 0 */
                          u64    weight;      /* if PERF_SAMPLE_WEIGHT */
                          u64    data_src;    /* if PERF_SAMPLE_DATA_SRC */
                          u64    transaction; /* if PERF_SAMPLE_TRANSACTION */
                          u64    abi;         /* if PERF_SAMPLE_REGS_INTR */
                          u64    regs[weight(mask)];
                                              /* if PERF_SAMPLE_REGS_INTR */
                      };

                  sample_id
                      If PERF_SAMPLE_IDENTIFIER is enabled, a 64-bit unique ID is included.  This is a duplication of  the
                      PERF_SAMPLE_ID  id  value,  but included at the beginning of the sample so parsers can easily obtain
                      the value.

                  ip  If PERF_SAMPLE_IP is enabled, then a 64-bit instruction pointer value is included.

                  pid, tid
                      If PERF_SAMPLE_TID is enabled, then a 32-bit process ID and 32-bit thread ID are included.

                  time
                      If PERF_SAMPLE_TIME is enabled,  then  a  64-bit  timestamp  is  included.   This  is  obtained  via
                      local_clock() which is a hardware timestamp if available and the jiffies value if not.

                  addr
                      If PERF_SAMPLE_ADDR is enabled, then a 64-bit address is included.  This is usually the address of a
                      tracepoint, breakpoint, or software event; otherwise the value is 0.

                  id  If PERF_SAMPLE_ID is enabled, a 64-bit unique ID is included.  If the event is a member of an  event
                      group, the group leader ID is returned.  This ID is the same as the one returned by PERF_FORMAT_ID.

                  stream_id
                      If  PERF_SAMPLE_STREAM_ID  is  enabled,  a  64-bit unique ID is included.  Unlike PERF_SAMPLE_ID the
                      actual ID is returned, not the group leader.  This ID is the same as the one returned  by  PERF_FOR‐
                      MAT_ID.

                  cpu, res
                      If  PERF_SAMPLE_CPU is enabled, this is a 32-bit value indicating which CPU was being used, in addi‐
                      tion to a reserved (unused) 32-bit value.

                  period
                      If PERF_SAMPLE_PERIOD is enabled, a 64-bit value indicating the current sampling period is written.

                  v   If PERF_SAMPLE_READ is enabled, a structure of type read_format is included which has values for all
                      events  in  the  event  group.   The  values  included  depend  on  the  read_format  value  used at
                      perf_event_open() time.

                  nr, ips[nr]
                      If PERF_SAMPLE_CALLCHAIN is enabled, then a 64-bit number is included which indicates how many  fol‐
                      lowing 64-bit instruction pointers will follow.  This is the current callchain.

                  size, data[size]
                      If  PERF_SAMPLE_RAW is enabled, then a 32-bit value indicating size is included followed by an array
                      of 8-bit values of length size.  The values are padded with 0 to have 64-bit alignment.

                      This RAW record data is opaque with respect to the ABI.  The ABI  doesn't  make  any  promises  with
                      respect  to  the stability of its content, it may vary depending on event, hardware, and kernel ver‐
                      sion.

                  bnr, lbr[bnr]
                      If PERF_SAMPLE_BRANCH_STACK is enabled, then a 64-bit value indicating  the  number  of  records  is
                      included, followed by bnr perf_branch_entry structures which each include the fields:

                      from   This indicates the source instruction (may not be a branch).

                      to     The branch target.

                      mispred
                             The branch target was mispredicted.

                      predicted
                             The branch target was predicted.

                      in_tx (since Linux 3.11)
                             The branch was in a transactional memory transaction.

                      abort (since Linux 3.11)
                             The branch was in an aborted transactional memory transaction.

                      cycles (since Linux 4.3)
                             This reports the number of cycles elapsed since the previous branch stack update.

                      The entries are from most to least recent, so the first entry has the most recent branch.

                      Support for mispred, predicted, and cycles is optional; if not supported, those values will be 0.

                      The type of branches recorded is specified by the branch_sample_type field.

                  abi, regs[weight(mask)]
                      If PERF_SAMPLE_REGS_USER is enabled, then the user CPU registers are recorded.

                      The   abi   field   is   one  of  PERF_SAMPLE_REGS_ABI_NONE,  PERF_SAMPLE_REGS_ABI_32  or  PERF_SAM‐
                      PLE_REGS_ABI_64.

                      The regs field is an array of the CPU registers that were specified  by  the  sample_regs_user  attr
                      field.  The number of values is the number of bits set in the sample_regs_user bit mask.

                  size, data[size], dyn_size
                      If PERF_SAMPLE_STACK_USER is enabled, then the user stack is recorded.  This can be used to generate
                      stack backtraces.  size is the size requested by the user in sample_stack_user or else  the  maximum
                      record  size.   data  is the stack data (a raw dump of the memory pointed to by the stack pointer at
                      the time of sampling).  dyn_size is the amount of data actually dumped  (can  be  less  than  size).
                      Note that dyn_size is omitted if size is 0.

                  weight
                      If  PERF_SAMPLE_WEIGHT  is  enabled,  then  a 64-bit value provided by the hardware is recorded that
                      indicates how costly the event was.  This allows expensive events to stand out more clearly in  pro‐
                      files.

                  data_src
                      If PERF_SAMPLE_DATA_SRC is enabled, then a 64-bit value is recorded that is made up of the following
                      fields:

                      mem_op
                          Type of opcode, a bitwise combination of:

                          PERF_MEM_OP_NA          Not available
                          PERF_MEM_OP_LOAD        Load instruction
                          PERF_MEM_OP_STORE       Store instruction
                          PERF_MEM_OP_PFETCH      Prefetch
                          PERF_MEM_OP_EXEC        Executable code

                      mem_lvl
                          Memory hierarchy level hit or miss, a bitwise combination of  the  following,  shifted  left  by
                          PERF_MEM_LVL_SHIFT:

                          PERF_MEM_LVL_NA         Not available
                          PERF_MEM_LVL_HIT        Hit
                          PERF_MEM_LVL_MISS       Miss
                          PERF_MEM_LVL_L1         Level 1 cache
                          PERF_MEM_LVL_LFB        Line fill buffer
                          PERF_MEM_LVL_L2         Level 2 cache
                          PERF_MEM_LVL_L3         Level 3 cache
                          PERF_MEM_LVL_LOC_RAM    Local DRAM
                          PERF_MEM_LVL_REM_RAM1   Remote DRAM 1 hop
                          PERF_MEM_LVL_REM_RAM2   Remote DRAM 2 hops
                          PERF_MEM_LVL_REM_CCE1   Remote cache 1 hop
                          PERF_MEM_LVL_REM_CCE2   Remote cache 2 hops
                          PERF_MEM_LVL_IO         I/O memory
                          PERF_MEM_LVL_UNC        Uncached memory

                      mem_snoop
                          Snoop mode, a bitwise combination of the following, shifted left by PERF_MEM_SNOOP_SHIFT:

                          PERF_MEM_SNOOP_NA       Not available
                          PERF_MEM_SNOOP_NONE     No snoop
                          PERF_MEM_SNOOP_HIT      Snoop hit
                          PERF_MEM_SNOOP_MISS     Snoop miss
                          PERF_MEM_SNOOP_HITM     Snoop hit modified

                      mem_lock
                          Lock instruction, a bitwise combination of the following, shifted left by PERF_MEM_LOCK_SHIFT:

                          PERF_MEM_LOCK_NA        Not available
                          PERF_MEM_LOCK_LOCKED    Locked transaction

                      mem_dtlb
                          TLB   access   hit   or   miss,  a  bitwise  combination  of  the  following,  shifted  left  by
                          PERF_MEM_TLB_SHIFT:

                          PERF_MEM_TLB_NA         Not available
                          PERF_MEM_TLB_HIT        Hit
                          PERF_MEM_TLB_MISS       Miss
                          PERF_MEM_TLB_L1         Level 1 TLB
                          PERF_MEM_TLB_L2         Level 2 TLB
                          PERF_MEM_TLB_WK         Hardware walker
                          PERF_MEM_TLB_OS         OS fault handler

                  transaction
                      If the PERF_SAMPLE_TRANSACTION flag is set, then a 64-bit field is recorded describing  the  sources
                      of any transactional memory aborts.

                      The field is a bitwise combination of the following values:

                      PERF_TXN_ELISION
                             Abort from an elision type transaction (Intel-CPU-specific).

                      PERF_TXN_TRANSACTION
                             Abort from a generic transaction.

                      PERF_TXN_SYNC
                             Synchronous abort (related to the reported instruction).

                      PERF_TXN_ASYNC
                             Asynchronous abort (not related to the reported instruction).

                      PERF_TXN_RETRY
                             Retryable abort (retrying the transaction may have succeeded).

                      PERF_TXN_CONFLICT
                             Abort due to memory conflicts with other threads.

                      PERF_TXN_CAPACITY_WRITE
                             Abort due to write capacity overflow.

                      PERF_TXN_CAPACITY_READ
                             Abort due to read capacity overflow.

                      In  addition,  a  user-specified  abort  code  can be obtained from the high 32 bits of the field by
                      shifting right by PERF_TXN_ABORT_SHIFT and masking with the value PERF_TXN_ABORT_MASK.

                  abi, regs[weight(mask)]
                      If PERF_SAMPLE_REGS_INTR is enabled, then the user CPU registers are recorded.

                      The  abi  field  is  one  of  PERF_SAMPLE_REGS_ABI_NONE,   PERF_SAMPLE_REGS_ABI_32,   or   PERF_SAM‐
                      PLE_REGS_ABI_64.

                      The  regs  field  is  an array of the CPU registers that were specified by the sample_regs_intr attr
                      field.  The number of values is the number of bits set in the sample_regs_intr bit mask.

              PERF_RECORD_MMAP2
                  This record includes extended information on mmap(2) calls returning executable mappings.  The format is
                  similar  to that of the PERF_RECORD_MMAP record, but includes extra values that allow uniquely identify‐
                  ing shared mappings.

                      struct {
                          struct perf_event_header header;
                          u32    pid;
                          u32    tid;
                          u64    addr;
                          u64    len;
                          u64    pgoff;
                          u32    maj;
                          u32    min;
                          u64    ino;
                          u64    ino_generation;
                          u32    prot;
                          u32    flags;
                          char   filename[];
                          struct sample_id sample_id;
                      };

                  pid    is the process ID.

                  tid    is the thread ID.

                  addr   is the address of the allocated memory.

                  len    is the length of the allocated memory.

                  pgoff  is the page offset of the allocated memory.

                  maj    is the major ID of the underlying device.

                  min    is the minor ID of the underlying device.

                  ino    is the inode number.

                  ino_generation
                         is the inode generation.

                  prot   is the protection information.

                  flags  is the flags information.

                  filename
                         is a string describing the backing of the allocated memory.

              PERF_RECORD_AUX (since Linux 4.1)

                  This record reports that new data is available in the separate AUX buffer region.

                      struct {
                          struct perf_event_header header;
                          u64    aux_offset;
                          u64    aux_size;
                          u64    flags;
                          struct sample_id sample_id;
                      };

                  aux_offset
                         offset in the AUX mmap region where the new data begins.

                  aux_size
                         size of the data made available.

                  flags  describes the AUX update.

                         PERF_AUX_FLAG_TRUNCATED
                                if set, then the data returned was truncated to fit the available buffer size.

                         PERF_AUX_FLAG_OVERWRITE
                                if set, then the data returned has overwritten previous data.

              PERF_RECORD_ITRACE_START (since Linux 4.1)

                  This record indicates which process has initiated an instruction trace event, allowing tools to properly
                  correlate the instruction addresses in the AUX buffer with the proper executable.

                      struct {
                          struct perf_event_header header;
                          u32    pid;
                          u32    tid;
                      };

                  pid    process ID of the thread starting an instruction trace.

                  tid    thread ID of the thread starting an instruction trace.

              PERF_RECORD_LOST_SAMPLES (since Linux 4.2)

                  When  using hardware sampling (such as Intel PEBS) this record indicates some number of samples that may
                  have been lost.

                      struct {
                          struct perf_event_header header;
                          u64    lost;
                          struct sample_id sample_id;
                      };

                  lost   the number of potentially lost samples.

              PERF_RECORD_SWITCH (since Linux 4.3)

                  This record indicates a context switch has happened.  The PERF_RECORD_MISC_SWITCH_OUT bit  in  the  misc
                  field indicates whether it was a context switch into or away from the current process.

                      struct {
                          struct perf_event_header header;
                          struct sample_id sample_id;
                      };

              PERF_RECORD_SWITCH_CPU_WIDE (since Linux 4.3)

                  As  with PERF_RECORD_SWITCH this record indicates a context switch has happened, but it only occurs when
                  sampling in CPU-wide mode and provides additional information on the  process  being  switched  to/from.
                  The  PERF_RECORD_MISC_SWITCH_OUT bit in the misc field indicates whether it was a context switch into or
                  away from the current process.

                      struct {
                          struct perf_event_header header;
                          u32 next_prev_pid;
                          u32 next_prev_tid;
                          struct sample_id sample_id;
                      };

                  next_prev_pid
                         The process ID of the previous (if switching in) or next (if switching out) process on the CPU.

                  next_prev_tid
                         The thread ID of the previous (if switching in) or next (if switching out) thread on the CPU.

   Overflow handling
       Events can be set to notify when a threshold is crossed, indicating an overflow.  Overflow conditions can  be  cap‐
       tured  by  monitoring  the event file descriptor with poll(2), select(2), or epoll(7).  Alternatively, the overflow
       events can be captured via sa signal handler, by enabling I/O signaling on the file descriptor; see the  discussion
       of the F_SETOWN and F_SETSIG operations in fcntl(2).

       Overflows are generated only by sampling events (sample_period must have a nonzero value).

       There are two ways to generate overflow notifications.

       The  first  is to set a wakeup_events or wakeup_watermark value that will trigger if a certain number of samples or
       bytes have been written to the mmap ring buffer.  In this case, POLL_IN is indicated.

       The other way is by use of the PERF_EVENT_IOC_REFRESH ioctl.  This ioctl adds to a  counter  that  decrements  each
       time the event overflows.  When nonzero, POLL_IN is indicated, but once the counter reaches 0 POLL_HUP is indicated
       and the underlying event is disabled.

       Refreshing an event group leader refreshes all siblings and refreshing with a  parameter  of  0  currently  enables
       infinite refreshes; these behaviors are unsupported and should not be relied on.

       Starting with Linux 3.18, POLL_HUP is indicated if the event being monitored is attached to a different process and
       that process exits.

   rdpmc instruction
       Starting with Linux 3.4 on x86, you can use the rdpmc instruction to get low-latency reads without having to  enter
       the kernel.  Note that using rdpmc is not necessarily faster than other methods for reading event values.

       Support  for  this can be detected with the cap_usr_rdpmc field in the mmap page; documentation on how to calculate
       event values can be found in that section.

       Originally, when rdpmc support was enabled, any process (not just ones with an active perf  event)  could  use  the
       rdpmc  instruction  to  access the counters.  Starting with Linux 4.0, rdpmc support is only allowed if an event is
       currently  enabled  in  a  process's  context.   To  restore   the   old   behavior,   write   the   value   2   to
       /sys/devices/cpu/rdpmc.

   perf_event ioctl calls
       Various ioctls act on perf_event_open() file descriptors:

       PERF_EVENT_IOC_ENABLE
              This enables the individual event or event group specified by the file descriptor argument.

              If the PERF_IOC_FLAG_GROUP bit is set in the ioctl argument, then all events in a group are enabled, even if
              the event specified is not the group leader (but see BUGS).

       PERF_EVENT_IOC_DISABLE
              This disables the individual counter or event group specified by the file descriptor argument.

              Enabling or disabling the leader of a group enables or disables the entire group; that is, while  the  group
              leader is disabled, none of the counters in the group will count.  Enabling or disabling a member of a group
              other than the leader affects only that counter; disabling a non-leader stops that counter from counting but
              doesn't affect any other counter.

              If  the  PERF_IOC_FLAG_GROUP bit is set in the ioctl argument, then all events in a group are disabled, even
              if the event specified is not the group leader (but see BUGS).

       PERF_EVENT_IOC_REFRESH
              Non-inherited overflow counters can use this to enable a counter for a number of overflows specified by  the
              argument,  after which it is disabled.  Subsequent calls of this ioctl add the argument value to the current
              count.  An overflow notification with POLL_IN set will happen on each overflow until the  count  reaches  0;
              when  that happens a notification with POLL_HUP set is sent and the event is disabled.  Using an argument of
              0 is considered undefined behavior.

       PERF_EVENT_IOC_RESET
              Reset the event count specified by the file descriptor argument to zero.  This resets only the counts; there
              is no way to reset the multiplexing time_enabled or time_running values.

              If  the  PERF_IOC_FLAG_GROUP bit is set in the ioctl argument, then all events in a group are reset, even if
              the event specified is not the group leader (but see BUGS).

       PERF_EVENT_IOC_PERIOD
              This updates the overflow period for the event.

              Since Linux 3.7 (on ARM) and Linux 3.14 (all other architectures), the new period takes effect  immediately.
              On older kernels, the new period did not take effect until after the next overflow.

              The argument is a pointer to a 64-bit value containing the desired new period.

              Prior to Linux 2.6.36, this ioctl always failed due to a bug in the kernel.

       PERF_EVENT_IOC_SET_OUTPUT
              This tells the kernel to report event notifications to the specified file descriptor rather than the default
              one.  The file descriptors must all be on the same CPU.

              The argument specifies the desired file descriptor, or -1 if output should be ignored.

       PERF_EVENT_IOC_SET_FILTER (since Linux 2.6.33)
              This adds an ftrace filter to this event.

              The argument is a pointer to the desired ftrace filter.

       PERF_EVENT_IOC_ID (since Linux 3.12)
              This returns the event ID value for the given event file descriptor.

              The argument is a pointer to a 64-bit unsigned integer to hold the result.

       PERF_EVENT_IOC_SET_BPF (since Linux 4.1)
              This allows attaching a Berkeley Packet Filter (BPF) program to an existing kprobe  tracepoint  event.   You
              need CAP_SYS_ADMIN privileges to use this ioctl.

              The argument is a BPF program file descriptor that was created by a previous bpf(2) system call.

   Using prctl(2)
       A   process   can   enable  or  disable  all  the  event  groups  that  are  attached  to  it  using  the  prctl(2)
       PR_TASK_PERF_EVENTS_ENABLE and PR_TASK_PERF_EVENTS_DISABLE operations.  This applies to all counters on the calling
       process, whether created by this process or by another, and does not affect any counters that this process has cre‐
       ated on other processes.  It enables or disables only the group leaders, not any other members in the groups.

   perf_event related configuration files
       Files in /proc/sys/kernel/

           /proc/sys/kernel/perf_event_paranoid
                  The perf_event_paranoid file can be set to restrict access to the performance counters.

                  2   allow only user-space measurements (default since Linux 4.6).
                  1   allow both kernel and user measurements (default before Linux 4.6).
                  0   allow access to CPU-specific data but not raw tracepoint samples.
                  -1  no restrictions.

                  The existence of the perf_event_paranoid file is the official method for determining if  a  kernel  sup‐
                  ports perf_event_open().

           /proc/sys/kernel/perf_event_max_sample_rate
                  This  sets  the  maximum  sample  rate.   Setting this too high can allow users to sample at a rate that
                  impacts overall machine performance and potentially lock up the machine.  The default  value  is  100000
                  (samples per second).

           /proc/sys/kernel/perf_event_max_stack
                  This file sets the maximum depth of stack frame entries reported when generating a call trace.

           /proc/sys/kernel/perf_event_mlock_kb
                  Maximum number of pages an unprivileged user can mlock(2).  The default is 516 (kB).

       Files in /sys/bus/event_source/devices/

           Since  Linux  2.6.34, the kernel supports having multiple PMUs available for monitoring.  Information on how to
           program these PMUs can be found under /sys/bus/event_source/devices/.  Each subdirectory corresponds to a  dif‐
           ferent PMU.

           /sys/bus/event_source/devices/*/type (since Linux 2.6.38)
                  This contains an integer that can be used in the type field of perf_event_attr to indicate that you wish
                  to use this PMU.

           /sys/bus/event_source/devices/cpu/rdpmc (since Linux 3.4)
                  If this file is 1, then direct user-space access to the performance counter registers is allowed via the
                  rdpmc instruction.  This can be disabled by echoing 0 to the file.

                  As of Linux 4.0 the behavior has changed, so that 1 now means only allow access to processes with active
                  perf events, with 2 indicating the old allow-anyone-access behavior.

           /sys/bus/event_source/devices/*/format/ (since Linux 3.4)
                  This subdirectory contains information on the architecture-specific subfields available for  programming
                  the various config fields in the perf_event_attr struct.

                  The  content  of each file is the name of the config field, followed by a colon, followed by a series of
                  integer bit ranges separated by commas.  For  example,  the  file  event  may  contain  the  value  con‐
                  fig1:1,6-10,44  which  indicates  that  event  is  an  attribute  that  occupies  bits 1,6–10, and 44 of
                  perf_event_attr::config1.

           /sys/bus/event_source/devices/*/events/ (since Linux 3.4)
                  This subdirectory contains files with predefined events.  The contents are strings describing the  event
                  settings  expressed in terms of the fields found in the previously mentioned ./format/ directory.  These
                  are not necessarily complete lists of all events supported by a PMU, but  usually  a  subset  of  events
                  deemed useful or interesting.

                  The  content  of each file is a list of attribute names separated by commas.  Each entry has an optional
                  value (either hex or decimal).  If no value is specified, then it is assumed to be  a  single-bit  field
                  with a value of 1.  An example entry may look like this: event=0x2,inv,ldlat=3.

           /sys/bus/event_source/devices/*/uevent
                  This file is the standard kernel device interface for injecting hotplug events.

           /sys/bus/event_source/devices/*/cpumask (since Linux 3.7)
                  The  cpumask  file contains a comma-separated list of integers that indicate a representative CPU number
                  for each socket (package) on the motherboard.  This is needed when  setting  up  uncore  or  northbridge
                  events, as those PMUs present socket-wide events.

RETURN VALUE
       perf_event_open()  returns  the new file descriptor, or -1 if an error occurred (in which case, errno is set appro‐
       priately).

ERRORS
       The errors returned by perf_event_open() can be inconsistent, and may vary across processor architectures and  per‐
       formance monitoring units.

       E2BIG  Returned  if the perf_event_attr size value is too small (smaller than PERF_ATTR_SIZE_VER0), too big (larger
              than the page size), or larger than the kernel supports and the extra bytes are not  zero.   When  E2BIG  is
              returned, the perf_event_attr size field is overwritten by the kernel to be the size of the structure it was
              expecting.

       EACCES Returned when the requested event requires CAP_SYS_ADMIN permissions (or a more permissive perf_event  para‐
              noid  setting).   Some  common  cases where an unprivileged process may encounter this error: attaching to a
              process owned by a different user; monitoring all processes on a given CPU (i.e., specifying the  pid  argu‐
              ment as -1); and not setting exclude_kernel when the paranoid setting requires it.

       EBADF  Returned  if  the group_fd file descriptor is not valid, or, if PERF_FLAG_PID_CGROUP is set, the cgroup file
              descriptor in pid is not valid.

       EBUSY (since Linux 4.1)
              Returned if another event already has exclusive access to the PMU.

       EFAULT Returned if the attr pointer points at an invalid memory address.

       EINVAL Returned if the specified event is invalid.  There are many possible reasons  for  this.   A  not-exhaustive
              list:  sample_freq is higher than the maximum setting; the cpu to monitor does not exist; read_format is out
              of range; sample_type is out of range; the flags value is out of range; exclusive  or  pinned  set  and  the
              event  is  not  a  group  leader; the event config values are out of range or set reserved bits; the generic
              event selected is not supported; or there is not enough room to add the selected event.

       EMFILE Each opened event uses one file descriptor.  If a large number of events are opened, the  per-process  limit
              on the number of open file descriptors will be reached, and no more events can be created.

       ENODEV Returned when the event involves a feature not supported by the current CPU.

       ENOENT Returned if the type setting is not valid.  This error is also returned for some unsupported generic events.

       ENOSPC Prior to Linux 3.3, if there was not enough room for the event, ENOSPC was returned.  In Linux 3.3, this was
              changed to EINVAL.  ENOSPC is still returned if you try to add more breakpoint events than supported by  the
              hardware.

       ENOSYS Returned if PERF_SAMPLE_STACK_USER is set in sample_type and it is not supported by hardware.

       EOPNOTSUPP
              Returned  if  an  event requiring a specific hardware feature is requested but there is no hardware support.
              This includes requesting low-skid events if not supported, branch tracing if it is not  available,  sampling
              if no PMU interrupt is available, and branch stacks for software events.

       EOVERFLOW (since Linux 4.8)
              Returned  if PERF_SAMPLE_CALLCHAIN is requested and sample_max_stack is larger than the maximum specified in
              /proc/sys/kernel/perf_event_max_stack.

       EPERM  Returned on many (but not all) architectures when an unsupported exclude_hv, exclude_idle, exclude_user,  or
              exclude_kernel setting is specified.

              It  can  also happen, as with EACCES, when the requested event requires CAP_SYS_ADMIN permissions (or a more
              permissive perf_event paranoid setting).  This includes setting a breakpoint on a kernel address, and (since
              Linux 3.13) setting a kernel function-trace tracepoint.

       ESRCH  Returned if attempting to attach to a process that does not exist.

VERSION
       perf_event_open()  was  introduced  in  Linux  2.6.31  but was called perf_counter_open().  It was renamed in Linux
       2.6.32.

CONFORMING TO
       This perf_event_open() system call Linux-specific and should not be used in programs intended to be portable.

NOTES
       Glibc does not provide a wrapper for this system call; call it using syscall(2).  See the example below.

       The official way of knowing if perf_event_open() support is enabled is checking  for  the  existence  of  the  file
       /proc/sys/kernel/perf_event_paranoid.

BUGS
       The  F_SETOWN_EX  option to fcntl(2) is needed to properly get overflow signals in threads.  This was introduced in
       Linux 2.6.32.

       Prior to Linux 2.6.33 (at least for x86), the kernel did not check if events could be scheduled together until read
       time.   The  same happens on all known kernels if the NMI watchdog is enabled.  This means to see if a given set of
       events works you have to perf_event_open(), start, then read before you know for sure you can  get  valid  measure‐
       ments.

       Prior to Linux 2.6.34, event constraints were not enforced by the kernel.  In that case, some events would silently
       return "0" if the kernel scheduled them in an improper counter slot.

       Prior to Linux 2.6.34, there was a bug when multiplexing where the wrong results could be returned.

       Kernels from Linux 2.6.35 to Linux 2.6.39 can quickly crash the kernel if "inherit" is enabled and many threads are
       started.

       Prior to Linux 2.6.35, PERF_FORMAT_GROUP did not work with attached processes.

       There is a bug in the kernel code between Linux 2.6.36 and Linux 3.0 that ignores the "watermark" field and acts as
       if a wakeup_event was chosen if the union has a nonzero value in it.

       From Linux 2.6.31 to Linux 3.4, the PERF_IOC_FLAG_GROUP ioctl argument was broken and would repeatedly  operate  on
       the event specified rather than iterating across all sibling events in a group.

       From  Linux  3.4  to  Linux  3.11,  the mmap cap_usr_rdpmc and cap_usr_time bits mapped to the same location.  Code
       should migrate to the new cap_user_rdpmc and cap_user_time fields instead.

       Always double-check your results!  Various generalized events have had wrong values.  For example, retired branches
       measured the wrong thing on AMD machines until Linux 2.6.35.

EXAMPLE
       The following is a short example that measures the total instruction count of a call to printf(3).

       #include <stdlib.h>
       #include <stdio.h>
       #include <unistd.h>
       #include <string.h>
       #include <sys/ioctl.h>
       #include <linux/perf_event.h>
       #include <asm/unistd.h>

       static long
       perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
                       int cpu, int group_fd, unsigned long flags)
       {
           int ret;

           ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,
                          group_fd, flags);
           return ret;
       }

       int
       main(int argc, char **argv)
       {
           struct perf_event_attr pe;
           long long count;
           int fd;

           memset(&pe, 0, sizeof(struct perf_event_attr));
           pe.type = PERF_TYPE_HARDWARE;
           pe.size = sizeof(struct perf_event_attr);
           pe.config = PERF_COUNT_HW_INSTRUCTIONS;
           pe.disabled = 1;
           pe.exclude_kernel = 1;
           pe.exclude_hv = 1;

           fd = perf_event_open(&pe, 0, -1, -1, 0);
           if (fd == -1) {
              fprintf(stderr, "Error opening leader %llx\n", pe.config);
              exit(EXIT_FAILURE);
           }

           ioctl(fd, PERF_EVENT_IOC_RESET, 0);
           ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);

           printf("Measuring instruction count for this printf\n");

           ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);
           read(fd, &count, sizeof(long long));

           printf("Used %lld instructions\n", count);

           close(fd);
       }

SEE ALSO
       perf(1), fcntl(2), mmap(2), open(2), prctl(2), read(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-02-02                                      PERF_EVENT_OPEN(2)
</pre>
<pre zoom>
<span xsmall>2 inw</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 futimesat</span>
FUTIMESAT(2)                                     Linux Programmer's Manual                                    FUTIMESAT(2)

NAME
       futimesat - change timestamps of a file relative to a directory file descriptor

SYNOPSIS
       #include <fcntl.h> /* Definition of AT_* constants */
       #include <sys/time.h>

       int futimesat(int dirfd, const char *pathname,
                     const struct timeval times[2]);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       futimesat(): _GNU_SOURCE

DESCRIPTION
       This system call is obsolete.  Use utimensat(2) instead.

       The  futimesat() system call operates in exactly the same way as utimes(2), except for the differences described in
       this manual page.

       If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by  the
       file  descriptor dirfd (rather than relative to the current working directory of the calling process, as is done by
       utimes(2) for a relative pathname).

       If pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the  cur‐
       rent working directory of the calling process (like utimes(2)).

       If pathname is absolute, then dirfd is ignored.

RETURN VALUE
       On success, futimesat() returns a 0.  On error, -1 is returned and errno is set to indicate the error.

ERRORS
       The same errors that occur for utimes(2) can also occur for futimesat().  The following additional errors can occur
       for futimesat():

       EBADF  dirfd is not a valid file descriptor.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       futimesat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       This system call is nonstandard.  It was implemented from a specification that was proposed for POSIX.1,  but  that
       specification was replaced by the one for utimensat(2).

       A similar system call exists on Solaris.

NOTES
   Glibc notes
       If  pathname  is  NULL,  then  the glibc futimesat() wrapper function updates the times for the file referred to by
       dirfd.

SEE ALSO
       stat(2), utimensat(2), utimes(2), futimes(3), path_resolution(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            FUTIMESAT(2)
</pre>
<pre zoom>
<span xsmall>2 setreuid32</span>
SETREUID(2)                                      Linux Programmer's Manual                                     SETREUID(2)

NAME
       setreuid, setregid - set real and/or effective user or group ID

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int setreuid(uid_t ruid, uid_t euid);
       int setregid(gid_t rgid, gid_t egid);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       setreuid(), setregid():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.19: */ _DEFAULT_SOURCE
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       setreuid() sets real and effective user IDs of the calling process.

       Supplying a value of -1 for either the real or effective user ID forces the system to leave that ID unchanged.

       Unprivileged  processes may only set the effective user ID to the real user ID, the effective user ID, or the saved
       set-user-ID.

       Unprivileged users may only set the real user ID to the real user ID or the effective user ID.

       If the real user ID is set (i.e., ruid is not -1) or the effective user ID is set to a value not equal to the  pre‐
       vious real user ID, the saved set-user-ID will be set to the new effective user ID.

       Completely  analogously, setregid() sets real and effective group ID's of the calling process, and all of the above
       holds with "group" instead of "user".

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

       Note: there are cases where setreuid() can fail even when the caller is UID 0; it is a grave security error to omit
       checking for a failure return from setreuid().

ERRORS
       EAGAIN The call would change the caller's real UID (i.e., ruid does not match the caller's real UID), but there was
              a temporary failure allocating the necessary kernel data structures.

       EAGAIN ruid does not match the caller's real UID and this call would bring the number of processes belonging to the
              real user ID ruid over the caller's RLIMIT_NPROC resource limit.  Since Linux 3.1, this error case no longer
              occurs (but robust applications should check for this error); see the description of EAGAIN in execve(2).

       EINVAL One or more of the target user or group IDs is not valid in this user namespace.

       EPERM  The calling process is not privileged (on Linux, does not have the necessary capability in its  user  names‐
              pace: CAP_SETUID in the case of setreuid(), or CAP_SETGID in the case of setregid()) and a change other than
              (i) swapping the effective user (group) ID with the real user (group) ID, or (ii) setting one to  the  value
              of  the  other  or  (iii) setting the effective user (group) ID to the value of the saved set-user-ID (saved
              set-group-ID) was specified.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD (setreuid() and setregid() first appeared in 4.2BSD).

NOTES
       Setting the effective user (group) ID to the saved set-user-ID (saved set-group-ID) is possible since Linux  1.1.37
       (1.1.38).

       POSIX.1  does  not  specify all of the UID changes that Linux permits for an unprivileged process.  For setreuid(),
       the effective user ID can be made the same as the real user ID or the saved  set-user-ID,  and  it  is  unspecified
       whether  unprivileged  processes  may set the real user ID to the real user ID, the effective user ID, or the saved
       set-user-ID.  For setregid(), the real group ID can be changed to the value of  the  saved  set-group-ID,  and  the
       effective group ID can be changed to the value of the real group ID or the saved set-group-ID.  The precise details
       of what ID changes are permitted vary across implementations.

       POSIX.1 makes no specification about the effect of these calls on the saved set-user-ID and saved set-group-ID.

       The original Linux setreuid() and setregid() system calls supported only 16-bit user and group IDs.   Subsequently,
       Linux  2.4 added setreuid32() and setregid32(), supporting 32-bit IDs.  The glibc setreuid() and setregid() wrapper
       functions transparently deal with the variations across kernel versions.

   C library/kernel differences
       At the kernel level, user IDs and group IDs are a per-thread attribute.  However, POSIX requires that  all  threads
       in  a process share the same credentials.  The NPTL threading implementation handles the POSIX requirements by pro‐
       viding wrapper functions for the various system calls that change process UIDs and GIDs.  These  wrapper  functions
       (including  those  for  setreuid()  and  setregid()) employ a signal-based technique to ensure that when one thread
       changes credentials, all of the other threads in the process also  change  their  credentials.   For  details,  see
       nptl(7).

SEE ALSO
       getgid(2),  getuid(2), seteuid(2), setgid(2), setresuid(2), setuid(2), capabilities(7), credentials(7), user_names‐
       paces(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             SETREUID(2)
</pre>
<pre zoom>
<span xsmall>2 msgget</span>
MSGGET(2)                                        Linux Programmer's Manual                                       MSGGET(2)

NAME
       msgget - get a System V message queue identifier

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgget(key_t key, int msgflg);

DESCRIPTION
       The  msgget()  system call returns the System V message queue identifier associated with the value of the key argu‐
       ment.  It may be used either to obtain the identifier of a previously created message queue (when  msgflg  is  zero
       and key does not have the value IPC_PRIVATE), or to create a new set.

       A new message queue is created if key has the value IPC_PRIVATE or key isn't IPC_PRIVATE, no message queue with the
       given key key exists, and IPC_CREAT is specified in msgflg.

       If msgflg specifies both IPC_CREAT and IPC_EXCL and a message queue already exists for  key,  then  msgget()  fails
       with errno set to EEXIST.  (This is analogous to the effect of the combination O_CREAT | O_EXCL for open(2).)

       Upon  creation,  the  least  significant  bits  of the argument msgflg define the permissions of the message queue.
       These permission bits have the same format and semantics as the permissions specified  for  the  mode  argument  of
       open(2).  (The execute permissions are not used.)

       If  a  new  message queue is created, then its associated data structure msqid_ds (see msgctl(2)) is initialized as
       follows:

              msg_perm.cuid and msg_perm.uid are set to the effective user ID of the calling process.

              msg_perm.cgid and msg_perm.gid are set to the effective group ID of the calling process.

              The least significant 9 bits of msg_perm.mode are set to the least significant 9 bits of msgflg.

              msg_qnum, msg_lspid, msg_lrpid, msg_stime, and msg_rtime are set to 0.

              msg_ctime is set to the current time.

              msg_qbytes is set to the system limit MSGMNB.

       If the message queue already exists the permissions are verified, and a check is made to see if it  is  marked  for
       destruction.

RETURN VALUE
       If  successful,  the  return  value will be the message queue identifier (a nonnegative integer), otherwise -1 with
       errno indicating the error.

ERRORS
       On failure, errno is set to one of the following values:

       EACCES A message queue exists for key, but the calling process does not have permission to access  the  queue,  and
              does not have the CAP_IPC_OWNER capability in the user namespace that governs its IPC namespace.

       EEXIST IPC_CREAT and IPC_EXCL were specified in msgflg, but a message queue already exists for key.

       ENOENT No message queue exists for key and msgflg did not specify IPC_CREAT.

       ENOMEM A message queue has to be created but the system does not have enough memory for the new data structure.

       ENOSPC A  message  queue  has  to be created but the system limit for the maximum number of message queues (MSGMNI)
              would be exceeded.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

NOTES
       The inclusion of <sys/types.h> and <sys/ipc.h> isn't required on Linux or by any version of POSIX.   However,  some
       old  implementations  required  the  inclusion of these header files, and the SVID also documented their inclusion.
       Applications intended to be portable to such old systems may need to include these header files.

       IPC_PRIVATE isn't a flag field but a key_t type.  If this special value is used for key, the  system  call  ignores
       everything but the least significant 9 bits of msgflg and creates a new message queue (on success).

       The following is a system limit on message queue resources affecting a msgget() call:

       MSGMNI System-wide  limit on the number of message queues.  Before Linux 3.19, the default value for this limit was
              calculated using a formula based on available system memory.  Since Linux 3.19, the default value is 32,000.
              On Linux, this limit can be read and modified via /proc/sys/kernel/msgmni.

   Linux notes
       Until version 2.3.20, Linux would return EIDRM for a msgget() on a message queue scheduled for deletion.

BUGS
       The name choice IPC_PRIVATE was perhaps unfortunate, IPC_NEW would more clearly show its function.

SEE ALSO
       msgctl(2), msgrcv(2), msgsnd(2), ftok(3), capabilities(7), mq_overview(7), svipc(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                               MSGGET(2)
</pre>
<pre zoom>
<span xsmall>2 listxattr</span>
LISTXATTR(2)                                     Linux Programmer's Manual                                    LISTXATTR(2)

NAME
       listxattr, llistxattr, flistxattr - list extended attribute names

SYNOPSIS
       #include <sys/types.h>
       #include <sys/xattr.h>

       ssize_t listxattr(const char *path, char *list, size_t size);
       ssize_t llistxattr(const char *path, char *list, size_t size);
       ssize_t flistxattr(int fd, char *list, size_t size);

DESCRIPTION
       Extended  attributes  are name:value pairs associated with inodes (files, directories, symbolic links, etc.).  They
       are extensions to the normal attributes which are associated with all inodes  in  the  system  (i.e.,  the  stat(2)
       data).  A complete overview of extended attributes concepts can be found in xattr(7).

       listxattr()  retrieves  the list of extended attribute names associated with the given path in the filesystem.  The
       retrieved list is placed in list, a caller-allocated buffer whose size (in bytes)  is  specified  in  the  argument
       size.   The list is the set of (null-terminated) names, one after the other.  Names of extended attributes to which
       the calling process does not have access may be omitted from the list.  The length of the attribute  name  list  is
       returned.

       llistxattr()  is  identical  to  listxattr(),  except  in  the  case of a symbolic link, where the list of names of
       extended attributes associated with the link itself is retrieved, not the file that it refers to.

       flistxattr() is identical to listxattr(), only the open file referred to by fd (as returned by open(2)) is interro‐
       gated in place of path.

       A  single  extended attribute name is a null-terminated string.  The name includes a namespace prefix; there may be
       several, disjoint namespaces associated with an individual inode.

       If size is specified as zero, these calls return the current size of the list  of  extended  attribute  names  (and
       leave  list  unchanged).   This can be used to determine the size of the buffer that should be supplied in a subse‐
       quent call.  (But, bear in mind that there is a possibility that the set of extended attributes may change  between
       the two calls, so that it is still necessary to check the return status from the second call.)

   Example
       The list of names is returned as an unordered array of null-terminated character strings (attribute names are sepa‐
       rated by null bytes ('\0')), like this:

           user.name1\0system.name1\0user.name2\0

       Filesystems that implement POSIX ACLs using extended attributes might return a list like this:

           system.posix_acl_access\0system.posix_acl_default\0

RETURN VALUE
       On success, a nonnegative number is returned indicating the size of the extended attribute name list.  On  failure,
       -1 is returned and errno is set appropriately.

ERRORS
       E2BIG  The size of the list of extended attribute names is larger than the maximum size allowed; the list cannot be
              retrieved.  This can happen on filesystems that support an unlimited number of extended attributes per  file
              such as XFS, for example.  See BUGS.

       ENOTSUP
              Extended attributes are not supported by the filesystem, or are disabled.

       ERANGE The size of the list buffer is too small to hold the result.

       In addition, the errors documented in stat(2) can also occur.

VERSIONS
       These system calls have been available on Linux since kernel 2.4; glibc support is provided since version 2.3.

CONFORMING TO
       These system calls are Linux-specific.

BUGS
       As  noted in xattr(7), the VFS imposes a limit of 64 kB on the size of the extended attribute name list returned by
       listxattr(7).  If the total size of attribute names attached to a file exceeds this limit, it is no longer possible
       to retrieve the list of attribute names.

EXAMPLE
       The  following  program demonstrates the usage of listxattr() and getxattr(2).  For the file whose pathname is pro‐
       vided as a command-line argument, it lists all extended file attributes and their values.

       To keep the code simple, the program assumes that attribute keys and values are constant during  the  execution  of
       the  program.  A production program should expect and handle changes during execution of the program.  For example,
       the number of bytes required for attribute keys might increase between the two calls to listxattr().   An  applica‐
       tion could handle this possibility using a loop that retries the call (perhaps up to a predetermined maximum number
       of attempts) with a larger buffer each time it fails with the error ERANGE.  Calls to getxattr(2) could be  handled
       similarly.

       The following output was recorded by first creating a file, setting some extended file attributes, and then listing
       the attributes with the example program.

   Example output
           $ touch /tmp/foo
           $ setfattr -n user.fred -v chocolate /tmp/foo
           $ setfattr -n user.frieda -v bar /tmp/foo
           $ setfattr -n user.empty /tmp/foo
           $ ./listxattr /tmp/foo
           user.fred: chocolate
           user.frieda: bar
           user.empty: <no value>

   Program source (listxattr.c)
       #include <malloc.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>
       #include <sys/types.h>
       #include <sys/xattr.h>

       int
       main(int argc, char *argv[])
       {
           ssize_t buflen, keylen, vallen;
           char *buf, *key, *val;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s path\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           /*
            * Determine the length of the buffer needed.
            */
           buflen = listxattr(argv[1], NULL, 0);
           if (buflen == -1) {
               perror("listxattr");
               exit(EXIT_FAILURE);
           }
           if (buflen == 0) {
               printf("%s has no attributes.\n", argv[1]);
               exit(EXIT_SUCCESS);
           }

           /*
            * Allocate the buffer.
            */
           buf = malloc(buflen);
           if (buf == NULL) {
               perror("malloc");
               exit(EXIT_FAILURE);
           }

           /*
            * Copy the list of attribute keys to the buffer.
            */
           buflen = listxattr(argv[1], buf, buflen);
           if (buflen == -1) {
               perror("listxattr");
               exit(EXIT_FAILURE);
           }

           /*
            * Loop over the list of zero terminated strings with the
            * attribute keys. Use the remaining buffer length to determine
            * the end of the list.
            */
           key = buf;
           while (buflen > 0) {

               /*
                * Output attribute key.
                */
               printf("%s: ", key);

               /*
                * Determine length of the value.
                */
               vallen = getxattr(argv[1], key, NULL, 0);
               if (vallen == -1)
                   perror("getxattr");

               if (vallen > 0) {

                   /*
                    * Allocate value buffer.
                    * One extra byte is needed to append 0x00.
                    */
                   val = malloc(vallen + 1);
                   if (val == NULL) {
                       perror("malloc");
                       exit(EXIT_FAILURE);
                   }

                   /*
                    * Copy value to buffer.
                    */
                   vallen = getxattr(argv[1], key, val, vallen);
                   if (vallen == -1)
                       perror("getxattr");
                   else {
                       /*
                        * Output attribute value.
                        */
                       val[vallen] = 0;
                       printf("%s", val);
                   }

                   free(val);
               } else if (vallen == 0)
                   printf("<no value>");

               printf("\n");

               /*
                * Forward to next attribute key.
                */
               keylen = strlen(key) + 1;
               buflen -= keylen;
               key += keylen;
           }

           free(buf);
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       getfattr(1), setfattr(1), getxattr(2), open(2), removexattr(2), setxattr(2), stat(2), symlink(7), xattr(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            LISTXATTR(2)
</pre>
<pre zoom>
<span xsmall>2 getxattr</span>
GETXATTR(2)                                      Linux Programmer's Manual                                     GETXATTR(2)

NAME
       getxattr, lgetxattr, fgetxattr - retrieve an extended attribute value

SYNOPSIS
       #include <sys/types.h>
       #include <sys/xattr.h>

       ssize_t getxattr(const char *path, const char *name,
                        void *value, size_t size);
       ssize_t lgetxattr(const char *path, const char *name,
                        void *value, size_t size);
       ssize_t fgetxattr(int fd, const char *name,
                        void *value, size_t size);

DESCRIPTION
       Extended  attributes  are name:value pairs associated with inodes (files, directories, symbolic links, etc.).  They
       are extensions to the normal attributes which are associated with all inodes  in  the  system  (i.e.,  the  stat(2)
       data).  A complete overview of extended attributes concepts can be found in xattr(7).

       getxattr()  retrieves  the value of the extended attribute identified by name and associated with the given path in
       the filesystem.  The attribute value is placed in the buffer pointed to by value; size specifies the size  of  that
       buffer.  The return value of the call is the number of bytes placed in value.

       lgetxattr()  is  identical  to getxattr(), except in the case of a symbolic link, where the link itself is interro‐
       gated, not the file that it refers to.

       fgetxattr() is identical to getxattr(), only the open file referred to by fd (as returned by open(2))  is  interro‐
       gated in place of path.

       An  extended  attribute  name is a null-terminated string.  The name includes a namespace prefix; there may be sev‐
       eral, disjoint namespaces associated with an individual inode.  The value of an extended attribute is  a  chunk  of
       arbitrary textual or binary data that was assigned using setxattr(2).

       If  size is specified as zero, these calls return the current size of the named extended attribute (and leave value
       unchanged).  This can be used to determine the size of the buffer that should be supplied  in  a  subsequent  call.
       (But,  bear  in mind that there is a possibility that the attribute value may change between the two calls, so that
       it is still necessary to check the return status from the second call.)

RETURN VALUE
       On success, these calls return a nonnegative value which is the size (in bytes) of the  extended  attribute  value.
       On failure, -1 is returned and errno is set appropriately.

ERRORS
       E2BIG  The  size of the attribute value is larger than the maximum size allowed; the attribute cannot be retrieved.
              This can happen on filesystems that support very large attribute values such as NFSv4, for example.

       ENOATTR
              The named attribute does not exist, or the process has no access to this attribute.  (ENOATTR is defined  to
              be a synonym for ENODATA in <attr/xattr.h>.)

       ENOTSUP
              Extended attributes are not supported by the filesystem, or are disabled.

       ERANGE The size of the value buffer is too small to hold the result.

       In addition, the errors documented in stat(2) can also occur.

VERSIONS
       These system calls have been available on Linux since kernel 2.4; glibc support is provided since version 2.3.

CONFORMING TO
       These system calls are Linux-specific.

EXAMPLE
       See listxattr(2).

SEE ALSO
       getfattr(1), setfattr(1), listxattr(2), open(2), removexattr(2), setxattr(2), stat(2), symlink(7), xattr(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-03-13                                             GETXATTR(2)
</pre>
<pre zoom>
<span xsmall>2 io_submit</span>
IO_SUBMIT(2)                                     Linux Programmer's Manual                                    IO_SUBMIT(2)

NAME
       io_submit - submit asynchronous I/O blocks for processing

SYNOPSIS
       #include <linux/aio_abi.h>          /* Defines needed types */

       int io_submit(aio_context_t ctx_id, long nr, struct iocb **iocbpp);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       The  io_submit()  system  call  queues  nr I/O request blocks for processing in the AIO context ctx_id.  The iocbpp
       argument should be an array of nr AIO control blocks, which will be submitted to context ctx_id.

       The iocb (I/O control block) structure defined in linux/aio_abi.h defines the parameters that control the I/O oper‐
       ation.

           #include <linux/aio_abi.h>

           struct iocb {
               __u64   aio_data;
               __u32   PADDED(aio_key, aio_rw_flags);
               __u16   aio_lio_opcode;
               __s16   aio_reqprio;
               __u32   aio_fildes;
               __u64   aio_buf;
               __u64   aio_nbytes;
               __s64   aio_offset;
               __u64   aio_reserved2;
               __u32   aio_flags;
               __u32   aio_resfd;
           };

       The fields of this structure are as follows:

       aio_data
              This is an internal field used by the kernel.  Do not modify this field after an io_submit(2) call.

       aio_key
              This is an internal field used by the kernel.  Do not modify this field after an io_submit(2) call.

       aio_rw_flags
              This defines the R/W flags passed with structure.  The valid values are:

              RWF_APPEND (since Linux 4.16)
                     Append  data to the end of the file.  See the description of the flag of the same name in pwritev2(2)
                     as well as the description of O_APPEND in open(2).  The aio_offset field is ignored.  The file offset
                     is not changed.

              RWF_DSYNC (since Linux 4.7)
                     Write  operation  complete  according  to  requirement  of  synchronized I/O data integrity.  See the
                     description of the flag of the same name in  pwritev2(2)  as  well  the  description  of  O_DSYNC  in
                     open(2).

              RWF_HIPRI (since Linux 4.6)
                     High priority request, poll if possible

              RWF_NOWAIT (since Linux 4.14)
                     Don't  wait  if  the  I/O will block for operations such as file block allocations, dirty page flush,
                     mutex locks, or a congested block device inside the kernel.  If any of these conditions are met,  the
                     control block is returned immediately with a return value of -EAGAIN in the res field of the io_event
                     structure (see io_getevents(2)).

              RWF_SYNC (since Linux 4.7)
                     Write operation complete according to requirement  of  synchronized  I/O  file  integrity.   See  the
                     description of the flag of the same name in pwritev2(2) as well the description of O_SYNC in open(2).

       aio_lio_opcode
              This  defines  the  type  of I/O to be performed by the iocb structure.  The valid values are defined by the
              enum defined in linux/aio_abi.h:

                  enum {
                      IOCB_CMD_PREAD = 0,
                      IOCB_CMD_PWRITE = 1,
                      IOCB_CMD_FSYNC = 2,
                      IOCB_CMD_FDSYNC = 3,
                      IOCB_CMD_NOOP = 6,
                      IOCB_CMD_PREADV = 7,
                      IOCB_CMD_PWRITEV = 8,
                  };

       aio_reqprio
              This defines the requests priority.

       aio_filedes
              The file descriptor on which the I/O operation is to be performed.

       aio_buf
              This is the buffer used to transfer data for a read or write operation.

       aio_nbytes
              This is the size of the buffer pointed to by aio_buf.

       aio_offset
              This is the file offset at which the I/O operation is to be performed.

       aio_flags
              This is the flag to be passed iocb structure.  The only valid value is IOCB_FLAG_RESFD, which indicates that
              the asynchronous I/O control must signal the file descriptor mentioned in aio_resfd upon completion.

       aio_resfd
              The file descriptor to signal in the event of asynchronous I/O completion.

RETURN VALUE
       On success, io_submit() returns the number of iocbs submitted (which may be less than nr, or 0 if nr is zero).  For
       the failure return, see NOTES.

ERRORS
       EAGAIN Insufficient resources are available to queue any iocbs.

       EBADF  The file descriptor specified in the first iocb is invalid.

       EFAULT One of the data structures points to invalid data.

       EINVAL The AIO context specified by ctx_id is invalid.  nr is less than 0.  The iocb at *iocbpp[0] is not  properly
              initialized, or the operation specified is invalid for the file descriptor in the iocb.

       ENOSYS io_submit() is not implemented on this architecture.

VERSIONS
       The asynchronous I/O system calls first appeared in Linux 2.5.

CONFORMING TO
       io_submit() is Linux-specific and should not be used in programs that are intended to be portable.

NOTES
       Glibc  does  not  provide  a  wrapper  function  for  this system call.  You could invoke it using syscall(2).  But
       instead, you probably want to use the io_submit() wrapper function provided by libaio.

       Note that the libaio wrapper function uses a different type (io_context_t) for the ctx_id argument.  Note also that
       the  libaio  wrapper  does  not follow the usual C library conventions for indicating errors: on error it returns a
       negated error number (the negative of one of the values listed in ERRORS).  If  the  system  call  is  invoked  via
       syscall(2),  then  the  return value follows the usual conventions for indicating an error: -1, with errno set to a
       (positive) value that indicates the error.

SEE ALSO
       io_cancel(2), io_destroy(2), io_getevents(2), io_setup(2), aio(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                            IO_SUBMIT(2)
</pre>
<pre zoom>
<span xsmall>2 io_cancel</span>
IO_CANCEL(2)                                     Linux Programmer's Manual                                    IO_CANCEL(2)

NAME
       io_cancel - cancel an outstanding asynchronous I/O operation

SYNOPSIS
       #include <linux/aio_abi.h>          /* Defines needed types */

       int io_cancel(aio_context_t ctx_id, struct iocb *iocb,
                     struct io_event *result);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       The  io_cancel()  system  call  attempts  to cancel an asynchronous I/O operation previously submitted with io_sub‐
       mit(2).  The iocb argument describes the operation to be canceled and the ctx_id argument is  the  AIO  context  to
       which  the  operation  was submitted.  If the operation is successfully canceled, the event will be copied into the
       memory pointed to by result without being placed into the completion queue.

RETURN VALUE
       On success, io_cancel() returns 0.  For the failure return, see NOTES.

ERRORS
       EAGAIN The iocb specified was not canceled.

       EFAULT One of the data structures points to invalid data.

       EINVAL The AIO context specified by ctx_id is invalid.

       ENOSYS io_cancel() is not implemented on this architecture.

VERSIONS
       The asynchronous I/O system calls first appeared in Linux 2.5.

CONFORMING TO
       io_cancel() is Linux-specific and should not be used in programs that are intended to be portable.

NOTES
       Glibc does not provide a wrapper function for this system  call.   You  could  invoke  it  using  syscall(2).   But
       instead, you probably want to use the io_cancel() wrapper function provided by libaio.

       Note that the libaio wrapper function uses a different type (io_context_t) for the ctx_id argument.  Note also that
       the libaio wrapper does not follow the usual C library conventions for indicating errors: on  error  it  returns  a
       negated  error  number  (the  negative  of  one of the values listed in ERRORS).  If the system call is invoked via
       syscall(2), then the return value follows the usual conventions for indicating an error: -1, with errno  set  to  a
       (positive) value that indicates the error.

SEE ALSO
       io_destroy(2), io_getevents(2), io_setup(2), io_submit(2), aio(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            IO_CANCEL(2)
</pre>
<pre zoom>
<span xsmall>2 lremovexattr</span>
REMOVEXATTR(2)                                   Linux Programmer's Manual                                  REMOVEXATTR(2)

NAME
       removexattr, lremovexattr, fremovexattr - remove an extended attribute

SYNOPSIS
       #include <sys/types.h>
       #include <sys/xattr.h>

       int removexattr(const char *path, const char *name);
       int lremovexattr(const char *path, const char *name);
       int fremovexattr(int fd, const char *name);

DESCRIPTION
       Extended  attributes  are name:value pairs associated with inodes (files, directories, symbolic links, etc.).  They
       are extensions to the normal attributes which are associated with all inodes  in  the  system  (i.e.,  the  stat(2)
       data).  A complete overview of extended attributes concepts can be found in xattr(7).

       removexattr()  removes the extended attribute identified by name and associated with the given path in the filesys‐
       tem.

       lremovexattr() is identical to removexattr(), except in the case of a symbolic link, where the  extended  attribute
       is removed from the link itself, not the file that it refers to.

       fremovexattr() is identical to removexattr(), only the extended attribute is removed from the open file referred to
       by fd (as returned by open(2)) in place of path.

       An extended attribute name is a null-terminated string.  The name includes a namespace prefix; there  may  be  sev‐
       eral, disjoint namespaces associated with an individual inode.

RETURN VALUE
       On success, zero is returned.  On failure, -1 is returned and errno is set appropriately.

ERRORS
       ENOATTR
              The named attribute does not exist.  (ENOATTR is defined to be a synonym for ENODATA in <attr/xattr.h>.)

       ENOTSUP
              Extended attributes are not supported by the filesystem, or are disabled.

       In addition, the errors documented in stat(2) can also occur.

VERSIONS
       These system calls have been available on Linux since kernel 2.4; glibc support is provided since version 2.3.

CONFORMING TO
       These system calls are Linux-specific.

SEE ALSO
       getfattr(1), setfattr(1), getxattr(2), listxattr(2), open(2), setxattr(2), stat(2), symlink(7), xattr(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2015-05-07                                          REMOVEXATTR(2)
</pre>
<pre zoom>
<span xsmall>2 execveat</span>
EXECVEAT(2)                                      Linux Programmer's Manual                                     EXECVEAT(2)

NAME
       execveat - execute program relative to a directory file descriptor

SYNOPSIS
       #include <unistd.h>

       int execveat(int dirfd, const char *pathname,
                    char *const argv[], char *const envp[],
                    int flags);

DESCRIPTION
       The  execveat() system call executes the program referred to by the combination of dirfd and pathname.  It operates
       in exactly the same way as execve(2), except for the differences described in this manual page.

       If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by  the
       file  descriptor dirfd (rather than relative to the current working directory of the calling process, as is done by
       execve(2) for a relative pathname).

       If pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the  cur‐
       rent working directory of the calling process (like execve(2)).

       If pathname is absolute, then dirfd is ignored.

       If  pathname  is  an empty string and the AT_EMPTY_PATH flag is specified, then the file descriptor dirfd specifies
       the file to be executed (i.e., dirfd refers to an executable file, rather than a directory).

       The flags argument is a bit mask that can include zero or more of the following flags:

       AT_EMPTY_PATH
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the open(2) O_PATH flag).

       AT_SYMLINK_NOFOLLOW
              If  the  file  identified  by dirfd and a non-NULL pathname is a symbolic link, then the call fails with the
              error ELOOP.

RETURN VALUE
       On success, execveat() does not return.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       The same errors that occur for execve(2) can also occur for execveat().  The following additional errors can  occur
       for execveat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ELOOP  flags  includes  AT_SYMLINK_NOFOLLOW  and the file identified by dirfd and a non-NULL pathname is a symbolic
              link.

       ENOENT The program identified by dirfd and pathname requires the use of an interpreter program (such  as  a  script
              starting  with "#!"), but the file descriptor dirfd was opened with the O_CLOEXEC flag, with the result that
              the program file is inaccessible to the launched interpreter.  See BUGS.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       execveat() was added to Linux in kernel 3.19.  GNU C library support is pending.

CONFORMING TO
       The execveat() system call is Linux-specific.

NOTES
       In addition to the reasons explained in openat(2), the execveat() system call is also needed to allow fexecve(3) to
       be implemented on systems that do not have the /proc filesystem mounted.

       When  asked  to execute a script file, the argv[0] that is passed to the script interpreter is a string of the form
       /dev/fd/N or /dev/fd/N/P, where N is the number of the file descriptor passed via the dirfd argument.  A string  of
       the first form occurs when AT_EMPTY_PATH is employed.  A string of the second form occurs when the script is speci‐
       fied via both dirfd and pathname; in this case, P is the value given in pathname.

       For the same reasons described in fexecve(3), the natural idiom when using execveat() is to set  the  close-on-exec
       flag on dirfd.  (But see BUGS.)

BUGS
       The ENOENT error described above means that it is not possible to set the close-on-exec flag on the file descriptor
       given to a call of the form:

           execveat(fd, "", argv, envp, AT_EMPTY_PATH);

       However, the inability to set the close-on-exec flag means that a file descriptor referring  to  the  script  leaks
       through  to  the  script  itself.   As  well as wasting a file descriptor, this leakage can lead to file-descriptor
       exhaustion in scenarios where scripts recursively employ execveat().

SEE ALSO
       execve(2), openat(2), fexecve(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             EXECVEAT(2)
</pre>
<pre zoom>
<span xsmall>2 pread</span>
PREAD(2)                                         Linux Programmer's Manual                                        PREAD(2)

NAME
       pread, pwrite - read from or write to a file descriptor at a given offset

SYNOPSIS
       #include <unistd.h>

       ssize_t pread(int fd, void *buf, size_t count, off_t offset);

       ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pread(), pwrite():
           _XOPEN_SOURCE >= 500
           || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L

DESCRIPTION
       pread() reads up to count bytes from file descriptor fd at offset offset (from the start of the file) into the buf‐
       fer starting at buf.  The file offset is not changed.

       pwrite() writes up to count bytes from the buffer starting at buf to the file descriptor fd at offset offset.   The
       file offset is not changed.

       The file referenced by fd must be capable of seeking.

RETURN VALUE
       On  success, pread() returns the number of bytes read (a return of zero indicates end of file) and pwrite() returns
       the number of bytes written.

       Note that is not an error for a successful call to transfer fewer bytes than requested (see read(2) and write(2)).

       On error, -1 is returned and errno is set to indicate the cause of the error.

ERRORS
       pread() can fail and set errno to any error specified for read(2) or lseek(2).  pwrite() can fail and set errno  to
       any error specified for write(2) or lseek(2).

VERSIONS
       The  pread()  and  pwrite() system calls were added to Linux in version 2.1.60; the entries in the i386 system call
       table were added in 2.1.69.  C library support (including emulation using lseek(2) on  older  kernels  without  the
       system calls) was added in glibc 2.1.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       The  pread()  and  pwrite()  system calls are especially useful in multithreaded applications.  They allow multiple
       threads to perform I/O on the same file descriptor without being affected by changes to the file  offset  by  other
       threads.

   C library/kernel differences
       On  Linux,  the  underlying  system calls were renamed in kernel 2.6: pread() became pread64(), and pwrite() became
       pwrite64().  The system call numbers remained the same.  The glibc pread() and pwrite() wrapper functions transpar‐
       ently deal with the change.

       On  some  32-bit  architectures,  the calling signature for these system calls differ, for the reasons described in
       syscall(2).

BUGS
       POSIX requires that opening a file with the O_APPEND flag should have no effect on the location at  which  pwrite()
       writes  data.   However, on Linux, if a file is opened with O_APPEND, pwrite() appends data to the end of the file,
       regardless of the value of offset.

SEE ALSO
       lseek(2), read(2), readv(2), write(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                PREAD(2)
</pre>
<pre zoom>
<span xsmall>2 getppid</span>
GETPID(2)                                        Linux Programmer's Manual                                       GETPID(2)

NAME
       getpid, getppid - get process identification

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       pid_t getpid(void);
       pid_t getppid(void);

DESCRIPTION
       getpid() returns the process ID (PID) of the calling process.  (This is often used by routines that generate unique
       temporary filenames.)

       getppid() returns the process ID of the parent of the calling process.  This will be either the ID of  the  process
       that  created this process using fork(), or, if that process has already terminated, the ID of the process to which
       this  process  has  been  reparented  (either  init(1)  or  a  "subreaper"  process  defined   via   the   prctl(2)
       PR_SET_CHILD_SUBREAPER operation).

ERRORS
       These functions are always successful.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD, SVr4.

NOTES
       If the caller's parent is in a different PID namespace (see pid_namespaces(7)), getppid() returns 0.

       From  a kernel perspective, the PID (which is shared by all of the threads in a multithreaded process) is sometimes
       also known as the thread group ID (TGID).  This contrasts with the kernel thread ID (TID), which is unique for each
       thread.  For further details, see gettid(2) and the discussion of the CLONE_THREAD flag in clone(2).

   C library/kernel differences
       From  glibc  version  2.3.4  up to and including version 2.24, the glibc wrapper function for getpid() cached PIDs,
       with the goal of avoiding additional system calls when a process calls getpid() repeatedly.  Normally this  caching
       was  invisible,  but  its  correct  operation relied on support in the wrapper functions for fork(2), vfork(2), and
       clone(2): if an application bypassed the glibc wrappers for these system calls by using syscall(2), then a call  to
       getpid()  in the child would return the wrong value (to be precise: it would return the PID of the parent process).
       In addition, there were cases where getpid() could return the wrong value even when invoking clone(2) via the glibc
       wrapper  function.   (For a discussion of one such case, see BUGS in clone(2).)  Furthermore, the complexity of the
       caching code had been the source of a few bugs within glibc over the years.

       Because of the aforementioned problems, since glibc version 2.25, the PID  cache  is  removed:  calls  to  getpid()
       always invoke the actual system call, rather than returning a cached value.

SEE ALSO
       clone(2),  fork(2),  gettid(2),  kill(2),  exec(3),  mkstemp(3), tempnam(3), tmpfile(3), tmpnam(3), credentials(7),
       pid_namespaces(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-11-26                                               GETPID(2)
</pre>
<pre zoom>
<span xsmall>2 pread64</span>
PREAD(2)                                         Linux Programmer's Manual                                        PREAD(2)

NAME
       pread, pwrite - read from or write to a file descriptor at a given offset

SYNOPSIS
       #include <unistd.h>

       ssize_t pread(int fd, void *buf, size_t count, off_t offset);

       ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pread(), pwrite():
           _XOPEN_SOURCE >= 500
           || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L

DESCRIPTION
       pread() reads up to count bytes from file descriptor fd at offset offset (from the start of the file) into the buf‐
       fer starting at buf.  The file offset is not changed.

       pwrite() writes up to count bytes from the buffer starting at buf to the file descriptor fd at offset offset.   The
       file offset is not changed.

       The file referenced by fd must be capable of seeking.

RETURN VALUE
       On  success, pread() returns the number of bytes read (a return of zero indicates end of file) and pwrite() returns
       the number of bytes written.

       Note that is not an error for a successful call to transfer fewer bytes than requested (see read(2) and write(2)).

       On error, -1 is returned and errno is set to indicate the cause of the error.

ERRORS
       pread() can fail and set errno to any error specified for read(2) or lseek(2).  pwrite() can fail and set errno  to
       any error specified for write(2) or lseek(2).

VERSIONS
       The  pread()  and  pwrite() system calls were added to Linux in version 2.1.60; the entries in the i386 system call
       table were added in 2.1.69.  C library support (including emulation using lseek(2) on  older  kernels  without  the
       system calls) was added in glibc 2.1.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       The  pread()  and  pwrite()  system calls are especially useful in multithreaded applications.  They allow multiple
       threads to perform I/O on the same file descriptor without being affected by changes to the file  offset  by  other
       threads.

   C library/kernel differences
       On  Linux,  the  underlying  system calls were renamed in kernel 2.6: pread() became pread64(), and pwrite() became
       pwrite64().  The system call numbers remained the same.  The glibc pread() and pwrite() wrapper functions transpar‐
       ently deal with the change.

       On  some  32-bit  architectures,  the calling signature for these system calls differ, for the reasons described in
       syscall(2).

BUGS
       POSIX requires that opening a file with the O_APPEND flag should have no effect on the location at  which  pwrite()
       writes  data.   However, on Linux, if a file is opened with O_APPEND, pwrite() appends data to the end of the file,
       regardless of the value of offset.

SEE ALSO
       lseek(2), read(2), readv(2), write(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                PREAD(2)
</pre>
<pre zoom>
<span xsmall>2 statfs</span>
STATFS(2)                                        Linux Programmer's Manual                                       STATFS(2)

NAME
       statfs, fstatfs - get filesystem statistics

SYNOPSIS
       #include <sys/vfs.h>    /* or <sys/statfs.h> */

       int statfs(const char *path, struct statfs *buf);
       int fstatfs(int fd, struct statfs *buf);

DESCRIPTION
       The  statfs()  system call returns information about a mounted filesystem.  path is the pathname of any file within
       the mounted filesystem.  buf is a pointer to a statfs structure defined approximately as follows:

           struct statfs {
               __fsword_t f_type;    /* Type of filesystem (see below) */
               __fsword_t f_bsize;   /* Optimal transfer block size */
               fsblkcnt_t f_blocks;  /* Total data blocks in filesystem */
               fsblkcnt_t f_bfree;   /* Free blocks in filesystem */
               fsblkcnt_t f_bavail;  /* Free blocks available to
                                        unprivileged user */
               fsfilcnt_t f_files;   /* Total file nodes in filesystem */
               fsfilcnt_t f_ffree;   /* Free file nodes in filesystem */
               fsid_t     f_fsid;    /* Filesystem ID */
               __fsword_t f_namelen; /* Maximum length of filenames */
               __fsword_t f_frsize;  /* Fragment size (since Linux 2.6) */
               __fsword_t f_flags;   /* Mount flags of filesystem
                                        (since Linux 2.6.36) */
               __fsword_t f_spare[xxx];
                               /* Padding bytes reserved for future use */
           };

       The following filesystem types may appear in f_type:

           ADFS_SUPER_MAGIC      0xadf5
           AFFS_SUPER_MAGIC      0xadff
           AFS_SUPER_MAGIC       0x5346414f
           ANON_INODE_FS_MAGIC   0x09041934 /* Anonymous inode FS (for
                                               pseudofiles that have no name;
                                               e.g., epoll, signalfd, bpf) */
           AUTOFS_SUPER_MAGIC    0x0187
           BDEVFS_MAGIC          0x62646576
           BEFS_SUPER_MAGIC      0x42465331
           BFS_MAGIC             0x1badface
           BINFMTFS_MAGIC        0x42494e4d
           BPF_FS_MAGIC          0xcafe4a11
           BTRFS_SUPER_MAGIC     0x9123683e
           BTRFS_TEST_MAGIC      0x73727279
           CGROUP_SUPER_MAGIC    0x27e0eb   /* Cgroup pseudo FS */
           CGROUP2_SUPER_MAGIC   0x63677270 /* Cgroup v2 pseudo FS */
           CIFS_MAGIC_NUMBER     0xff534d42
           CODA_SUPER_MAGIC      0x73757245
           COH_SUPER_MAGIC       0x012ff7b7
           CRAMFS_MAGIC          0x28cd3d45
           DEBUGFS_MAGIC         0x64626720
           DEVFS_SUPER_MAGIC     0x1373     /* Linux 2.6.17 and earlier */
           DEVPTS_SUPER_MAGIC    0x1cd1
           ECRYPTFS_SUPER_MAGIC  0xf15f
           EFIVARFS_MAGIC        0xde5e81e4
           EFS_SUPER_MAGIC       0x00414a53
           EXT_SUPER_MAGIC       0x137d     /* Linux 2.0 and earlier */
           EXT2_OLD_SUPER_MAGIC  0xef51
           EXT2_SUPER_MAGIC      0xef53
           EXT3_SUPER_MAGIC      0xef53
           EXT4_SUPER_MAGIC      0xef53
           F2FS_SUPER_MAGIC      0xf2f52010
           FUSE_SUPER_MAGIC      0x65735546
           FUTEXFS_SUPER_MAGIC   0xbad1dea  /* Unused */
           HFS_SUPER_MAGIC       0x4244
           HOSTFS_SUPER_MAGIC    0x00c0ffee
           HPFS_SUPER_MAGIC      0xf995e849
           HUGETLBFS_MAGIC       0x958458f6
           ISOFS_SUPER_MAGIC     0x9660
           JFFS2_SUPER_MAGIC     0x72b6
           JFS_SUPER_MAGIC       0x3153464a
           MINIX_SUPER_MAGIC     0x137f     /* original minix FS */
           MINIX_SUPER_MAGIC2    0x138f     /* 30 char minix FS */
           MINIX2_SUPER_MAGIC    0x2468     /* minix V2 FS */
           MINIX2_SUPER_MAGIC2   0x2478     /* minix V2 FS, 30 char names */
           MINIX3_SUPER_MAGIC    0x4d5a     /* minix V3 FS, 60 char names */
           MQUEUE_MAGIC          0x19800202 /* POSIX message queue FS */
           MSDOS_SUPER_MAGIC     0x4d44
           MTD_INODE_FS_MAGIC    0x11307854
           NCP_SUPER_MAGIC       0x564c
           NFS_SUPER_MAGIC       0x6969
           NILFS_SUPER_MAGIC     0x3434
           NSFS_MAGIC            0x6e736673
           NTFS_SB_MAGIC         0x5346544e
           OCFS2_SUPER_MAGIC     0x7461636f
           OPENPROM_SUPER_MAGIC  0x9fa1
           OVERLAYFS_SUPER_MAGIC 0x794c7630
           PIPEFS_MAGIC          0x50495045
           PROC_SUPER_MAGIC      0x9fa0     /* /proc FS */
           PSTOREFS_MAGIC        0x6165676c
           QNX4_SUPER_MAGIC      0x002f
           QNX6_SUPER_MAGIC      0x68191122
           RAMFS_MAGIC           0x858458f6
           REISERFS_SUPER_MAGIC  0x52654973
           ROMFS_MAGIC           0x7275
           SECURITYFS_MAGIC      0x73636673
           SELINUX_MAGIC         0xf97cff8c
           SMACK_MAGIC           0x43415d53
           SMB_SUPER_MAGIC       0x517b
           SOCKFS_MAGIC          0x534f434b
           SQUASHFS_MAGIC        0x73717368
           SYSFS_MAGIC           0x62656572
           SYSV2_SUPER_MAGIC     0x012ff7b6
           SYSV4_SUPER_MAGIC     0x012ff7b5
           TMPFS_MAGIC           0x01021994
           TRACEFS_MAGIC         0x74726163
           UDF_SUPER_MAGIC       0x15013346
           UFS_MAGIC             0x00011954
           USBDEVICE_SUPER_MAGIC 0x9fa2
           V9FS_MAGIC            0x01021997
           VXFS_SUPER_MAGIC      0xa501fcf5
           XENFS_SUPER_MAGIC     0xabba1974
           XENIX_SUPER_MAGIC     0x012ff7b4
           XFS_SUPER_MAGIC       0x58465342
           _XIAFS_SUPER_MAGIC    0x012fd16d /* Linux 2.0 and earlier */

       Most of these MAGIC constants are defined in /usr/include/linux/magic.h, and some are hardcoded in kernel sources.

       The f_flags field is a bit mask indicating mount options for the filesystem.  It contains zero or more of the  fol‐
       lowing bits:

       ST_MANDLOCK
              Mandatory locking is permitted on the filesystem (see fcntl(2)).

       ST_NOATIME
              Do not update access times; see mount(2).

       ST_NODEV
              Disallow access to device special files on this filesystem.

       ST_NODIRATIME
              Do not update directory access times; see mount(2).

       ST_NOEXEC
              Execution of programs is disallowed on this filesystem.

       ST_NOSUID
              The set-user-ID and set-group-ID bits are ignored by exec(3) for executable files on this filesystem

       ST_RDONLY
              This filesystem is mounted read-only.

       ST_RELATIME
              Update atime relative to mtime/ctime; see mount(2).

       ST_SYNCHRONOUS
              Writes are synched to the filesystem immediately (see the description of O_SYNC in open(2)).

       Nobody knows what f_fsid is supposed to contain (but see below).

       Fields that are undefined for a particular filesystem are set to 0.

       fstatfs() returns the same information about an open file referenced by descriptor fd.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES (statfs())  Search  permission is denied for a component of the path prefix of path.  (See also path_resolu‐
              tion(7).)

       EBADF  (fstatfs()) fd is not a valid open file descriptor.

       EFAULT buf or path points to an invalid address.

       EINTR  The call was interrupted by a signal; see signal(7).

       EIO    An I/O error occurred while reading from the filesystem.

       ELOOP  (statfs()) Too many symbolic links were encountered in translating path.

       ENAMETOOLONG
              (statfs()) path is too long.

       ENOENT (statfs()) The file referred to by path does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOSYS The filesystem does not support this call.

       ENOTDIR
              (statfs()) A component of the path prefix of path is not a directory.

       EOVERFLOW
              Some values were too large to be represented in the returned struct.

CONFORMING TO
       Linux-specific.  The Linux statfs() was inspired by the 4.4BSD one (but they do not use the same structure).

NOTES
       The __fsword_t type used for various fields in the statfs structure  definition  is  a  glibc  internal  type,  not
       intended  for  public use.  This leaves the programmer in a bit of a conundrum when trying to copy or compare these
       fields to local variables in a program.  Using unsigned int for such variables suffices on most systems.

       The original Linux statfs() and fstatfs() system calls were not designed with extremely large file sizes  in  mind.
       Subsequently,  Linux  2.6  added new statfs64() and fstatfs64() system calls that employ a new structure, statfs64.
       The new structure contains the same fields as the original statfs structure, but the sizes of  various  fields  are
       increased,  to accommodate large file sizes.  The glibc statfs() and fstatfs() wrapper functions transparently deal
       with the kernel differences.

       Some systems have only <sys/vfs.h>, other systems also have <sys/statfs.h>, where the former includes  the  latter.
       So it seems including the former is the best choice.

       LSB has deprecated the library calls statfs() and fstatfs() and tells us to use statvfs(2) and fstatvfs(2) instead.

   The f_fsid field
       Solaris,  Irix  and  POSIX have a system call statvfs(2) that returns a struct statvfs (defined in <sys/statvfs.h>)
       containing an unsigned long f_fsid.  Linux, SunOS, HP-UX, 4.4BSD have a system call statfs() that returns a  struct
       statfs (defined in <sys/vfs.h>) containing a fsid_t f_fsid, where fsid_t is defined as struct { int val[2]; }.  The
       same holds for FreeBSD, except that it uses the include file <sys/mount.h>.

       The general idea is that f_fsid contains some random stuff such that the pair (f_fsid,ino)  uniquely  determines  a
       file.   Some  operating  systems  use  (a  variation  on) the device number, or the device number combined with the
       filesystem type.  Several operating systems restrict giving out the f_fsid field to the superuser only (and zero it
       for unprivileged users), because this field is used in the filehandle of the filesystem when NFS-exported, and giv‐
       ing it out is a security concern.

       Under some operating systems, the fsid can be used as the second argument to the sysfs(2) system call.

BUGS
       From Linux 2.6.38 up to and including Linux 3.1, fstatfs() failed with the error ENOSYS for file  descriptors  cre‐
       ated by pipe(2).

SEE ALSO
       stat(2), statvfs(3), path_resolution(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               STATFS(2)
</pre>
<pre zoom>
<span xsmall>2 signalfd</span>
SIGNALFD(2)                                      Linux Programmer's Manual                                     SIGNALFD(2)

NAME
       signalfd - create a file descriptor for accepting signals

SYNOPSIS
       #include <sys/signalfd.h>

       int signalfd(int fd, const sigset_t *mask, int flags);

DESCRIPTION
       signalfd()  creates  a file descriptor that can be used to accept signals targeted at the caller.  This provides an
       alternative to the use of a signal handler or sigwaitinfo(2), and has the advantage that the file descriptor may be
       monitored by select(2), poll(2), and epoll(7).

       The  mask  argument  specifies  the  set of signals that the caller wishes to accept via the file descriptor.  This
       argument is a signal set whose contents can be initialized using the macros described in  sigsetops(3).   Normally,
       the  set  of  signals to be received via the file descriptor should be blocked using sigprocmask(2), to prevent the
       signals being handled according to their default dispositions.  It is not possible to receive  SIGKILL  or  SIGSTOP
       signals via a signalfd file descriptor; these signals are silently ignored if specified in mask.

       If  the  fd  argument is -1, then the call creates a new file descriptor and associates the signal set specified in
       mask with that file descriptor.  If fd is not -1, then it must specify a valid existing signalfd  file  descriptor,
       and mask is used to replace the signal set associated with that file descriptor.

       Starting with Linux 2.6.27, the following values may be bitwise ORed in flags to change the behavior of signalfd():

       SFD_NONBLOCK  Set  the  O_NONBLOCK  file status flag on the new open file description.  Using this flag saves extra
                     calls to fcntl(2) to achieve the same result.

       SFD_CLOEXEC   Set the close-on-exec (FD_CLOEXEC) flag on the new file  descriptor.   See  the  description  of  the
                     O_CLOEXEC flag in open(2) for reasons why this may be useful.

       In Linux up to version 2.6.26, the flags argument is unused, and must be specified as zero.

       signalfd() returns a file descriptor that supports the following operations:

       read(2)
              If  one  or  more  of  the signals specified in mask is pending for the process, then the buffer supplied to
              read(2) is used to return one or more signalfd_siginfo structures (see below)  that  describe  the  signals.
              The read(2) returns information for as many signals as are pending and will fit in the supplied buffer.  The
              buffer must be at least sizeof(struct signalfd_siginfo) bytes.  The return value of the read(2) is the total
              number of bytes read.

              As  a  consequence  of  the  read(2),  the  signals are consumed, so that they are no longer pending for the
              process (i.e., will not be caught by signal handlers, and cannot be accepted using sigwaitinfo(2)).

              If none of the signals in mask is pending for the process, then the read(2) either blocks until one  of  the
              signals in mask is generated for the process, or fails with the error EAGAIN if the file descriptor has been
              made nonblocking.

       poll(2), select(2) (and similar)
              The file descriptor is readable (the select(2) readfds argument; the poll(2) POLLIN flag) if one or more  of
              the signals in mask is pending for the process.

              The  signalfd  file  descriptor  also  supports  the  other  file-descriptor  multiplexing APIs: pselect(2),
              ppoll(2), and epoll(7).

       close(2)
              When the file descriptor is no longer required it should be closed.  When all  file  descriptors  associated
              with the same signalfd object have been closed, the resources for object are freed by the kernel.

   The signalfd_siginfo structure
       The format of the signalfd_siginfo structure(s) returned by read(2)s from a signalfd file descriptor is as follows:

           struct signalfd_siginfo {
               uint32_t ssi_signo;    /* Signal number */
               int32_t  ssi_errno;    /* Error number (unused) */
               int32_t  ssi_code;     /* Signal code */
               uint32_t ssi_pid;      /* PID of sender */
               uint32_t ssi_uid;      /* Real UID of sender */
               int32_t  ssi_fd;       /* File descriptor (SIGIO) */
               uint32_t ssi_tid;      /* Kernel timer ID (POSIX timers)
               uint32_t ssi_band;     /* Band event (SIGIO) */
               uint32_t ssi_overrun;  /* POSIX timer overrun count */
               uint32_t ssi_trapno;   /* Trap number that caused signal */
               int32_t  ssi_status;   /* Exit status or signal (SIGCHLD) */
               int32_t  ssi_int;      /* Integer sent by sigqueue(3) */
               uint64_t ssi_ptr;      /* Pointer sent by sigqueue(3) */
               uint64_t ssi_utime;    /* User CPU time consumed (SIGCHLD) */
               uint64_t ssi_stime;    /* System CPU time consumed
                                         (SIGCHLD) */
               uint64_t ssi_addr;     /* Address that generated signal
                                         (for hardware-generated signals) */
               uint16_t ssi_addr_lsb; /* Least significant bit of address
                                         (SIGBUS; since Linux 2.6.37)
               uint8_t  pad[X];       /* Pad size to 128 bytes (allow for
                                         additional fields in the future) */
           };

       Each  of  the  fields  in this structure is analogous to the similarly named field in the siginfo_t structure.  The
       siginfo_t structure is described in sigaction(2).  Not all fields in the returned signalfd_siginfo  structure  will
       be  valid  for a specific signal; the set of valid fields can be determined from the value returned in the ssi_code
       field.  This field is the analog of the siginfo_t si_code field; see sigaction(2) for details.

   fork(2) semantics
       After a fork(2), the child inherits a copy of the signalfd file descriptor.  A read(2) from the file descriptor  in
       the child will return information about signals queued to the child.

   Semantics of file descriptor passing
       As with other file descriptors, signalfd file descriptors can be passed to another process via a UNIX domain socket
       (see unix(7)).  In the receiving process, a read(2) from the received file descriptor will return information about
       signals queued to that process.

   execve(2) semantics
       Just  like  any  other  file descriptor, a signalfd file descriptor remains open across an execve(2), unless it has
       been marked for close-on-exec (see fcntl(2)).  Any signals that were available for  reading  before  the  execve(2)
       remain  available to the newly loaded program.  (This is analogous to traditional signal semantics, where a blocked
       signal that is pending remains pending across an execve(2).)

   Thread semantics
       The semantics of signalfd file descriptors in a multithreaded program mirror the standard  semantics  for  signals.
       In  other words, when a thread reads from a signalfd file descriptor, it will read the signals that are directed to
       the thread itself and the signals that are directed to the process (i.e., the entire thread group).  (A thread will
       not be able to read signals that are directed to other threads in the process.)

RETURN VALUE
       On  success, signalfd() returns a signalfd file descriptor; this is either a new file descriptor (if fd was -1), or
       fd if fd was a valid signalfd file descriptor.  On error, -1 is returned and errno is set to indicate the error.

ERRORS
       EBADF  The fd file descriptor is not a valid file descriptor.

       EINVAL fd is not a valid signalfd file descriptor.

       EINVAL flags is invalid; or, in Linux 2.6.26 or earlier, flags is nonzero.

       EMFILE The per-process limit on the number of open file descriptors has been reached.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENODEV Could not mount (internal) anonymous inode device.

       ENOMEM There was insufficient memory to create a new signalfd file descriptor.

VERSIONS
       signalfd() is available on Linux since kernel 2.6.22.  Working support is provided in glibc since version 2.8.  The
       signalfd4() system call (see NOTES) is available on Linux since kernel 2.6.27.

CONFORMING TO
       signalfd() and signalfd4() are Linux-specific.

NOTES
       A  process  can  create  multiple signalfd file descriptors.  This makes it possible to accept different signals on
       different file descriptors.  (This may be useful if monitoring the file descriptors using  select(2),  poll(2),  or
       epoll(7): the arrival of different signals will make different file descriptors ready.)  If a signal appears in the
       mask of more than one of the file descriptors, then occurrences of that signal can be read (once) from any  one  of
       the file descriptors.

       Attempts to include SIGKILL and SIGSTOP in mask are silently ignored.

       The  signal  mask  employed  by  a  signalfd file descriptor can be viewed via the entry for the corresponding file
       descriptor in the process's /proc/[pid]/fdinfo directory.  See proc(5) for further details.

   Limitations
       The signalfd mechanism can't be used to receive signals that are synchronously generated, such as the SIGSEGV  sig‐
       nal  that  results  from  accessing  an invalid memory address or the SIGFPE signal that results from an arithmetic
       error.  Such signals can be caught only via signal handler.

       As described above, in normal usage one blocks the signals that will be accepted via  signalfd().   If  spawning  a
       child  process  to execute a helper program (that does not need the signalfd file descriptor), then, after the call
       to fork(2), you will normally want to unblock those signals before calling execve(2), so that  the  helper  program
       can see any signals that it expects to see.  Be aware, however, that this won't be possible in the case of a helper
       program spawned behind the scenes by any library function that the program may call.  In such cases, one must  fall
       back  to  using  a  traditional signal handler that writes to a file descriptor monitored by select(2), poll(2), or
       epoll(7),

   C library/kernel differences
       The underlying Linux system call requires an additional argument, size_t sizemask, which specifies the size of  the
       mask  argument.   The  glibc  signalfd()  wrapper  function  does  not include this argument, since it provides the
       required value for the underlying system call.

       There are two underlying Linux system calls: signalfd() and the more recent signalfd4().  The  former  system  call
       does not implement a flags argument.  The latter system call implements the flags values described above.  Starting
       with glibc 2.9, the signalfd() wrapper function will use signalfd4() where it is available.

BUGS
       In kernels before 2.6.25, the ssi_ptr and ssi_int fields are not filled in with the data accompanying a signal sent
       by sigqueue(3).

EXAMPLE
       The  program  below  accepts the signals SIGINT and SIGQUIT via a signalfd file descriptor.  The program terminates
       after accepting a SIGQUIT signal.  The following shell session demonstrates the use of the program:

           $ ./signalfd_demo
           ^C                   # Control-C generates SIGINT
           Got SIGINT
           ^C
           Got SIGINT
           ^\                    # Control-\ generates SIGQUIT
           Got SIGQUIT
           $

   Program source

       #include <sys/signalfd.h>
       #include <signal.h>
       #include <unistd.h>
       #include <stdlib.h>
       #include <stdio.h>

       #define handle_error(msg) \
           do { perror(msg); exit(EXIT_FAILURE); } while (0)

       int
       main(int argc, char *argv[])
       {
           sigset_t mask;
           int sfd;
           struct signalfd_siginfo fdsi;
           ssize_t s;

           sigemptyset(&mask);
           sigaddset(&mask, SIGINT);
           sigaddset(&mask, SIGQUIT);

           /* Block signals so that they aren't handled
              according to their default dispositions */

           if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)
               handle_error("sigprocmask");

           sfd = signalfd(-1, &mask, 0);
           if (sfd == -1)
               handle_error("signalfd");

           for (;;) {
               s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));
               if (s != sizeof(struct signalfd_siginfo))
                   handle_error("read");

               if (fdsi.ssi_signo == SIGINT) {
                   printf("Got SIGINT\n");
               } else if (fdsi.ssi_signo == SIGQUIT) {
                   printf("Got SIGQUIT\n");
                   exit(EXIT_SUCCESS);
               } else {
                   printf("Read unexpected signal\n");
               }
           }
       }

SEE ALSO
       eventfd(2), poll(2), read(2), select(2), sigaction(2), sigprocmask(2),  sigwaitinfo(2),  timerfd_create(2),  sigse‐
       tops(3), sigwait(3), epoll(7), signal(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-05-03                                             SIGNALFD(2)
</pre>
<pre zoom>
<span xsmall>2 removexattr</span>
REMOVEXATTR(2)                                   Linux Programmer's Manual                                  REMOVEXATTR(2)

NAME
       removexattr, lremovexattr, fremovexattr - remove an extended attribute

SYNOPSIS
       #include <sys/types.h>
       #include <sys/xattr.h>

       int removexattr(const char *path, const char *name);
       int lremovexattr(const char *path, const char *name);
       int fremovexattr(int fd, const char *name);

DESCRIPTION
       Extended  attributes  are name:value pairs associated with inodes (files, directories, symbolic links, etc.).  They
       are extensions to the normal attributes which are associated with all inodes  in  the  system  (i.e.,  the  stat(2)
       data).  A complete overview of extended attributes concepts can be found in xattr(7).

       removexattr()  removes the extended attribute identified by name and associated with the given path in the filesys‐
       tem.

       lremovexattr() is identical to removexattr(), except in the case of a symbolic link, where the  extended  attribute
       is removed from the link itself, not the file that it refers to.

       fremovexattr() is identical to removexattr(), only the extended attribute is removed from the open file referred to
       by fd (as returned by open(2)) in place of path.

       An extended attribute name is a null-terminated string.  The name includes a namespace prefix; there  may  be  sev‐
       eral, disjoint namespaces associated with an individual inode.

RETURN VALUE
       On success, zero is returned.  On failure, -1 is returned and errno is set appropriately.

ERRORS
       ENOATTR
              The named attribute does not exist.  (ENOATTR is defined to be a synonym for ENODATA in <attr/xattr.h>.)

       ENOTSUP
              Extended attributes are not supported by the filesystem, or are disabled.

       In addition, the errors documented in stat(2) can also occur.

VERSIONS
       These system calls have been available on Linux since kernel 2.4; glibc support is provided since version 2.3.

CONFORMING TO
       These system calls are Linux-specific.

SEE ALSO
       getfattr(1), setfattr(1), getxattr(2), listxattr(2), open(2), setxattr(2), stat(2), symlink(7), xattr(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2015-05-07                                          REMOVEXATTR(2)
</pre>
<pre zoom>
<span xsmall>2 ioprio_get</span>
IOPRIO_SET(2)                                    Linux Programmer's Manual                                   IOPRIO_SET(2)

NAME
       ioprio_get, ioprio_set - get/set I/O scheduling class and priority

SYNOPSIS
       int ioprio_get(int which, int who);
       int ioprio_set(int which, int who, int ioprio);

       Note: There are no glibc wrappers for these system calls; see NOTES.

DESCRIPTION
       The  ioprio_get()  and  ioprio_set() system calls respectively get and set the I/O scheduling class and priority of
       one or more threads.

       The which and who arguments identify the thread(s) on which the system calls operate.  The  which  argument  deter‐
       mines how who is interpreted, and has one of the following values:

       IOPRIO_WHO_PROCESS
              who  is  a process ID or thread ID identifying a single process or thread.  If who is 0, then operate on the
              calling thread.

       IOPRIO_WHO_PGRP
              who is a process group ID identifying all the members of a process group.  If who is 0, then operate on  the
              process group of which the caller is a member.

       IOPRIO_WHO_USER
              who is a user ID identifying all of the processes that have a matching real UID.

       If  which  is  specified as IOPRIO_WHO_PGRP or IOPRIO_WHO_USER when calling ioprio_get(), and more than one process
       matches who, then the returned priority will be the highest one found among all of  the  matching  processes.   One
       priority  is  said  to  be higher than another one if it belongs to a higher priority class (IOPRIO_CLASS_RT is the
       highest priority class; IOPRIO_CLASS_IDLE is the lowest) or if it belongs to the same priority class as  the  other
       process but has a higher priority level (a lower priority number means a higher priority level).

       The  ioprio  argument given to ioprio_set() is a bit mask that specifies both the scheduling class and the priority
       to be assigned to the target process(es).  The following macros are used for assembling and dissecting ioprio  val‐
       ues:

       IOPRIO_PRIO_VALUE(class, data)
              Given a scheduling class and priority (data), this macro combines the two values to produce an ioprio value,
              which is returned as the result of the macro.

       IOPRIO_PRIO_CLASS(mask)
              Given mask (an ioprio value), this macro returns its I/O  class  component,  that  is,  one  of  the  values
              IOPRIO_CLASS_RT, IOPRIO_CLASS_BE, or IOPRIO_CLASS_IDLE.

       IOPRIO_PRIO_DATA(mask)
              Given mask (an ioprio value), this macro returns its priority (data) component.

       See the NOTES section for more information on scheduling classes and priorities, as well as the meaning of specify‐
       ing ioprio as 0.

       I/O priorities are supported for reads and for synchronous (O_DIRECT, O_SYNC) writes.  I/O priorities are not  sup‐
       ported  for asynchronous writes because they are issued outside the context of the program dirtying the memory, and
       thus program-specific priorities do not apply.

RETURN VALUE
       On success, ioprio_get() returns the ioprio value of the process with highest I/O priority of any of the  processes
       that  match  the  criteria  specified in which and who.  On error, -1 is returned, and errno is set to indicate the
       error.

       On success, ioprio_set() returns 0.  On error, -1 is returned, and errno is set to indicate the error.

ERRORS
       EINVAL Invalid value for which or ioprio.  Refer to the NOTES section for available scheduler classes and  priority
              levels for ioprio.

       EPERM  The  calling  process does not have the privilege needed to assign this ioprio to the specified process(es).
              See the NOTES section for more information on required privileges for ioprio_set().

       ESRCH  No process(es) could be found that matched the specification in which and who.

VERSIONS
       These system calls have been available on Linux since kernel 2.6.13.

CONFORMING TO
       These system calls are Linux-specific.

NOTES
       Glibc does not provide a wrapper for these system calls; call them using syscall(2).

       Two or more processes or threads can share an I/O context.  This will be the case when clone(2) was called with the
       CLONE_IO  flag.   However, by default, the distinct threads of a process will not share the same I/O context.  This
       means that if you want to change the I/O priority of all threads in a process, you may need to call ioprio_set() on
       each of the threads.  The thread ID that you would need for this operation is the one that is returned by gettid(2)
       or clone(2).

       These system calls have an effect only when used in conjunction with an I/O scheduler that supports I/O priorities.
       As at kernel 2.6.17 the only such scheduler is the Completely Fair Queuing (CFQ) I/O scheduler.

       If  no  I/O  scheduler  has  been set for a thread, then by default the I/O priority will follow the CPU nice value
       (setpriority(2)).  In Linux kernels before version 2.6.24, once an I/O priority had been  set  using  ioprio_set(),
       there  was  no way to reset the I/O scheduling behavior to the default.  Since Linux 2.6.24, specifying ioprio as 0
       can be used to reset to the default I/O scheduling behavior.

   Selecting an I/O scheduler
       I/O schedulers are selected on a per-device basis via the special file /sys/block/<device>/queue/scheduler.

       One can view the current I/O scheduler via the /sys filesystem.  For example, the following command displays a list
       of all schedulers currently loaded in the kernel:

           $ cat /sys/block/sda/queue/scheduler
           noop anticipatory deadline [cfq]

       The  scheduler  surrounded  by  brackets  is  the one actually in use for the device (sda in the example).  Setting
       another scheduler is done by writing the name of the new scheduler to this file.  For example, the  following  com‐
       mand will set the scheduler for the sda device to cfq:

           $ su
           Password:
           # echo cfq > /sys/block/sda/queue/scheduler

   The Completely Fair Queuing (CFQ) I/O scheduler
       Since version 3 (also known as CFQ Time Sliced), CFQ implements I/O nice levels similar to those of CPU scheduling.
       These nice levels are grouped into three scheduling classes, each one containing one or more priority levels:

       IOPRIO_CLASS_RT (1)
              This is the real-time I/O class.  This scheduling class is given higher priority than any other class:  pro‐
              cesses from this class are given first access to the disk every time.  Thus, this I/O class needs to be used
              with some care: one I/O real-time process can starve the entire system.  Within the real-time  class,  there
              are  8  levels of class data (priority) that determine exactly how much time this process needs the disk for
              on each service.  The highest real-time priority level is 0; the lowest is 7.  In  the  future,  this  might
              change to be more directly mappable to performance, by passing in a desired data rate instead.

       IOPRIO_CLASS_BE (2)
              This  is  the  best-effort scheduling class, which is the default for any process that hasn't set a specific
              I/O priority.  The class data (priority) determines how much I/O bandwidth  the  process  will  get.   Best-
              effort priority levels are analogous to CPU nice values (see getpriority(2)).  The priority level determines
              a priority relative to other processes in the best-effort scheduling class.  Priority levels  range  from  0
              (highest) to 7 (lowest).

       IOPRIO_CLASS_IDLE (3)
              This is the idle scheduling class.  Processes running at this level get I/O time only when no one else needs
              the disk.  The idle class has no class data.  Attention is required when assigning this priority class to  a
              process, since it may become starved if higher priority processes are constantly accessing the disk.

       Refer to the kernel source file Documentation/block/ioprio.txt for more information on the CFQ I/O Scheduler and an
       example program.

   Required permissions to set I/O priorities
       Permission to change a process's priority is granted or denied based on two criteria:

       Process ownership
              An unprivileged process may set the I/O priority only for a process whose  real  UID  matches  the  real  or
              effective UID of the calling process.  A process which has the CAP_SYS_NICE capability can change the prior‐
              ity of any process.

       What is the desired priority
              Attempts to set very high priorities (IOPRIO_CLASS_RT) require the CAP_SYS_ADMIN  capability.   Kernel  ver‐
              sions  up  to  2.6.24  also required CAP_SYS_ADMIN to set a very low priority (IOPRIO_CLASS_IDLE), but since
              Linux 2.6.25, this is no longer required.

       A call to ioprio_set() must follow both rules, or the call will fail with the error EPERM.

BUGS
       Glibc does not yet provide a suitable header file defining the function prototypes and  macros  described  on  this
       page.  Suitable definitions can be found in linux/ioprio.h.

SEE ALSO
       ionice(1), getpriority(2), open(2), capabilities(7), cgroups(7)

       Documentation/block/ioprio.txt in the Linux kernel source tree

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           IOPRIO_SET(2)
</pre>
<pre zoom>
<span xsmall>2 mbind</span>
MBIND(2)                                         Linux Programmer's Manual                                        MBIND(2)

NAME
       mbind - set memory policy for a memory range

SYNOPSIS
       #include <numaif.h>

       long mbind(void *addr, unsigned long len, int mode,
                  const unsigned long *nodemask, unsigned long maxnode,
                  unsigned flags);

       Link with -lnuma.

DESCRIPTION
       mbind()  sets  the NUMA memory policy, which consists of a policy mode and zero or more nodes, for the memory range
       starting with addr and continuing for len bytes.  The memory policy defines from which node memory is allocated.

       If the memory range specified by the addr and len arguments includes an "anonymous"  region  of  memory—that  is  a
       region of memory created using the mmap(2) system call with the MAP_ANONYMOUS—or a memory-mapped file, mapped using
       the mmap(2) system call with the MAP_PRIVATE flag, pages will be allocated only according to the  specified  policy
       when  the application writes (stores) to the page.  For anonymous regions, an initial read access will use a shared
       page in the kernel containing all zeros.  For a file mapped with MAP_PRIVATE, an initial read access will  allocate
       pages  according  to  the  memory  policy  of the thread that causes the page to be allocated.  This may not be the
       thread that called mbind().

       The specified policy will be ignored for any MAP_SHARED mappings in the specified memory range.  Rather  the  pages
       will  be  allocated according to the memory policy of the thread that caused the page to be allocated.  Again, this
       may not be the thread that called mbind().

       If the specified memory range includes a shared memory region created using the shmget(2) system call and  attached
       using the shmat(2) system call, pages allocated for the anonymous or shared memory region will be allocated accord‐
       ing to the policy specified, regardless of which process attached to the shared memory segment causes  the  alloca‐
       tion.   If,  however,  the shared memory region was created with the SHM_HUGETLB flag, the huge pages will be allo‐
       cated according to the policy specified only if the page allocation is caused by the process that calls mbind() for
       that region.

       By default, mbind() has an effect only for new allocations; if the pages inside the range have been already touched
       before setting the policy, then the policy has  no  effect.   This  default  behavior  may  be  overridden  by  the
       MPOL_MF_MOVE and MPOL_MF_MOVE_ALL flags described below.

       The  mode  argument  must  specify  one  of MPOL_DEFAULT, MPOL_BIND, MPOL_INTERLEAVE, MPOL_PREFERRED, or MPOL_LOCAL
       (which are described in detail below).  All policy modes except MPOL_DEFAULT require the caller to specify the node
       or nodes to which the mode applies, via the nodemask argument.

       The mode argument may also include an optional mode flag.  The supported mode flags are:

       MPOL_F_STATIC_NODES (since Linux-2.6.26)
              A nonempty nodemask specifies physical node IDs.  Linux does not remap the nodemask when the thread moves to
              a different cpuset context, nor when the set of  nodes  allowed  by  the  thread's  current  cpuset  context
              changes.

       MPOL_F_RELATIVE_NODES (since Linux-2.6.26)
              A nonempty nodemask specifies node IDs that are relative to the set of node IDs allowed by the thread's cur‐
              rent cpuset.

       nodemask points to a bit mask of nodes containing up to maxnode bits.  The bit mask size is  rounded  to  the  next
       multiple  of sizeof(unsigned long), but the kernel will use bits only up to maxnode.  A NULL value of nodemask or a
       maxnode value of zero specifies the empty set of nodes.  If the value of maxnode is zero, the nodemask argument  is
       ignored.   Where a nodemask is required, it must contain at least one node that is on-line, allowed by the thread's
       current cpuset context (unless the MPOL_F_STATIC_NODES mode flag is specified), and contains memory.

       The mode argument must include one of the following values:

       MPOL_DEFAULT
              This mode requests that any nondefault policy be removed, restoring default behavior.   When  applied  to  a
              range  of  memory  via  mbind(),  this  means  to use the thread memory policy, which may have been set with
              set_mempolicy(2).  If the mode of the thread memory policy is also  MPOL_DEFAULT,  the  system-wide  default
              policy  will  be  used.  The system-wide default policy allocates pages on the node of the CPU that triggers
              the allocation.  For MPOL_DEFAULT, the nodemask and maxnode arguments must  be  specify  the  empty  set  of
              nodes.

       MPOL_BIND
              This mode specifies a strict policy that restricts memory allocation to the nodes specified in nodemask.  If
              nodemask specifies more than one node, page allocations will come from the node with sufficient free  memory
              that is closest to the node where the allocation takes place.  Pages will not be allocated from any node not
              specified in the IR nodemask .  (Before Linux 2.6.26, page allocations came from the node  with  the  lowest
              numeric  node  ID first, until that node contained no free memory.  Allocations then came from the node with
              the next highest node ID specified in nodemask and so forth, until none of  the  specified  nodes  contained
              free memory.)

       MPOL_INTERLEAVE
              This  mode  specifies  that  page  allocations be interleaved across the set of nodes specified in nodemask.
              This optimizes for bandwidth instead of latency by spreading out pages and memory accesses  to  those  pages
              across multiple nodes.  To be effective the memory area should be fairly large, at least 1 MB or bigger with
              a fairly uniform access pattern.  Accesses to a single page of the area will still be limited to the  memory
              bandwidth of a single node.

       MPOL_PREFERRED
              This  mode  sets  the  preferred  node for allocation.  The kernel will try to allocate pages from this node
              first and fall back to other nodes if the preferred nodes is low on free memory.  If nodemask specifies more
              than  one  node  ID, the first node in the mask will be selected as the preferred node.  If the nodemask and
              maxnode arguments specify the empty set, then the memory is allocated on the node of the CPU that  triggered
              the allocation.

       MPOL_LOCAL (since Linux 3.8)
              This  mode  specifies  "local allocation"; the memory is allocated on the node of the CPU that triggered the
              allocation (the "local node").  The nodemask and maxnode arguments must  specify  the  empty  set.   If  the
              "local  node"  is  low  on free memory, the kernel will try to allocate memory from other nodes.  The kernel
              will allocate memory from the "local node" whenever memory for this node is available.  If the "local  node"
              is  not  allowed  by  the thread's current cpuset context, the kernel will try to allocate memory from other
              nodes.  The kernel will allocate memory from the "local node" whenever it becomes allowed  by  the  thread's
              current  cpuset context.  By contrast, MPOL_DEFAULT reverts to the memory policy of the thread (which may be
              set via set_mempolicy(2)); that policy may be something other than "local allocation".

       If MPOL_MF_STRICT is passed in flags and mode is not MPOL_DEFAULT, then the call fails with the error  EIO  if  the
       existing pages in the memory range don't follow the policy.

       If  MPOL_MF_MOVE  is  specified in flags, then the kernel will attempt to move all the existing pages in the memory
       range so that they follow the policy.  Pages  that  are  shared  with  other  processes  will  not  be  moved.   If
       MPOL_MF_STRICT is also specified, then the call fails with the error EIO if some pages could not be moved.

       If MPOL_MF_MOVE_ALL is passed in flags, then the kernel will attempt to move all existing pages in the memory range
       regardless of whether other processes use the pages.  The calling thread must be privileged (CAP_SYS_NICE)  to  use
       this  flag.  If MPOL_MF_STRICT is also specified, then the call fails with the error EIO if some pages could not be
       moved.

RETURN VALUE
       On success, mbind() returns 0; on error, -1 is returned and errno is set to indicate the error.

ERRORS
       EFAULT Part or all of the memory range specified by nodemask and maxnode points  outside  your  accessible  address
              space.  Or, there was an unmapped hole in the specified memory range specified by addr and len.

       EINVAL An  invalid value was specified for flags or mode; or addr + len was less than addr; or addr is not a multi‐
              ple of the system page size.  Or, mode is MPOL_DEFAULT and nodemask specified a nonempty  set;  or  mode  is
              MPOL_BIND  or MPOL_INTERLEAVE and nodemask is empty.  Or, maxnode exceeds a kernel-imposed limit.  Or, node‐
              mask specifies one or more node IDs that are greater than the maximum supported node ID.  Or,  none  of  the
              node  IDs  specified  by nodemask are on-line and allowed by the thread's current cpuset context, or none of
              the specified  nodes  contain  memory.   Or,  the  mode  argument  specified  both  MPOL_F_STATIC_NODES  and
              MPOL_F_RELATIVE_NODES.

       EIO    MPOL_MF_STRICT  was specified and an existing page was already on a node that does not follow the policy; or
              MPOL_MF_MOVE or MPOL_MF_MOVE_ALL was specified and the kernel was unable to move all existing pages  in  the
              range.

       ENOMEM Insufficient kernel memory was available.

       EPERM  The  flags  argument included the MPOL_MF_MOVE_ALL flag and the caller does not have the CAP_SYS_NICE privi‐
              lege.

VERSIONS
       The mbind() system call was added to the Linux kernel in version 2.6.7.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       For information on library support, see numa(7).

       NUMA policy is not supported on a memory-mapped file range that was mapped with the MAP_SHARED flag.

       The MPOL_DEFAULT mode can have different effects for mbind() and set_mempolicy(2).  When MPOL_DEFAULT is  specified
       for  set_mempolicy(2),  the  thread's memory policy reverts to the system default policy or local allocation.  When
       MPOL_DEFAULT is specified for a range of memory using mbind(), any pages subsequently allocated for that range will
       use  the thread's memory policy, as set by set_mempolicy(2).  This effectively removes the explicit policy from the
       specified range, "falling back" to a possibly nondefault policy.  To select explicit "local allocation" for a  mem‐
       ory  range,  specify  a mode of MPOL_LOCAL or MPOL_PREFERRED with an empty set of nodes.  This method will work for
       set_mempolicy(2), as well.

       Support for huge page policy was added with 2.6.16.  For interleave policy to be effective on  huge  page  mappings
       the policied memory needs to be tens of megabytes or larger.

       MPOL_MF_STRICT is ignored on huge page mappings.

       MPOL_MF_MOVE and MPOL_MF_MOVE_ALL are available only on Linux 2.6.16 and later.

SEE ALSO
       get_mempolicy(2),   getcpu(2),   mmap(2),  set_mempolicy(2),  shmat(2),  shmget(2),  numa(3),  cpuset(7),  numa(7),
       numactl(8)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                MBIND(2)
</pre>
<pre zoom>
<span xsmall>2 fanotify_init</span>
FANOTIFY_INIT(2)                                 Linux Programmer's Manual                                FANOTIFY_INIT(2)

NAME
       fanotify_init - create and initialize fanotify group

SYNOPSIS
       #include <fcntl.h>
       #include <sys/fanotify.h>

       int fanotify_init(unsigned int flags, unsigned int event_f_flags);

DESCRIPTION
       For an overview of the fanotify API, see fanotify(7).

       fanotify_init()  initializes a new fanotify group and returns a file descriptor for the event queue associated with
       the group.

       The file descriptor is used in calls to fanotify_mark(2) to specify the files, directories, and  mounts  for  which
       fanotify  events shall be created.  These events are received by reading from the file descriptor.  Some events are
       only informative, indicating that a file has been accessed.  Other events can be used to determine whether  another
       application  is  permitted  to  access  a file or directory.  Permission to access filesystem objects is granted by
       writing to the file descriptor.

       Multiple programs may be using the fanotify interface at the same time to monitor the same files.

       In the current implementation, the number of fanotify groups per user is limited to  128.   This  limit  cannot  be
       overridden.

       Calling fanotify_init() requires the CAP_SYS_ADMIN capability.  This constraint might be relaxed in future versions
       of the API.  Therefore, certain additional capability checks have been implemented as indicated below.

       The flags argument contains a multi-bit field defining the notification class of the listening application and fur‐
       ther single bit fields specifying the behavior of the file descriptor.

       If  multiple  listeners  for  permission  events exist, the notification class is used to establish the sequence in
       which the listeners receive the events.

       Only one of the following notification classes may be specified in flags:

       FAN_CLASS_PRE_CONTENT
              This value allows the receipt of events notifying that a file has been accessed and  events  for  permission
              decisions  if  a  file may be accessed.  It is intended for event listeners that need to access files before
              they contain their final data.  This notification class might be used by hierarchical storage managers,  for
              example.

       FAN_CLASS_CONTENT
              This  value  allows  the receipt of events notifying that a file has been accessed and events for permission
              decisions if a file may be accessed.  It is intended for event listeners that need to access files when they
              already  contain  their final content.  This notification class might be used by malware detection programs,
              for example.

       FAN_CLASS_NOTIF
              This is the default value.  It does not need to be specified.  This value only allows the receipt of  events
              notifying that a file has been accessed.  Permission decisions before the file is accessed are not possible.

       Listeners   with   different   notification  classes  will  receive  events  in  the  order  FAN_CLASS_PRE_CONTENT,
       FAN_CLASS_CONTENT, FAN_CLASS_NOTIF.  The order of notification for listeners in  the  same  notification  class  is
       undefined.

       The following bits can additionally be set in flags:

       FAN_CLOEXEC
              Set  the  close-on-exec  flag (FD_CLOEXEC) on the new file descriptor.  See the description of the O_CLOEXEC
              flag in open(2).

       FAN_NONBLOCK
              Enable the nonblocking flag (O_NONBLOCK) for the file descriptor.  Reading from the file descriptor will not
              block.  Instead, if no data is available, read(2) fails with the error EAGAIN.

       FAN_UNLIMITED_QUEUE
              Remove  the limit of 16384 events for the event queue.  Use of this flag requires the CAP_SYS_ADMIN capabil‐
              ity.

       FAN_UNLIMITED_MARKS
              Remove the limit of 8192 marks.  Use of this flag requires the CAP_SYS_ADMIN capability.

       The event_f_flags argument defines the file status flags that will be set on the open file  descriptions  that  are
       created  for  fanotify  events.   For  details  of these flags, see the description of the flags values in open(2).
       event_f_flags includes a multi-bit field for the access mode.  This field can take the following values:

       O_RDONLY
              This value allows only read access.

       O_WRONLY
              This value allows only write access.

       O_RDWR This value allows read and write access.

       Additional bits can be set in event_f_flags.  The most useful values are:

       O_LARGEFILE
              Enable support for files exceeding 2 GB.  Failing to set this flag will result in an  EOVERFLOW  error  when
              trying to open a large file which is monitored by an fanotify group on a 32-bit system.

       O_CLOEXEC (since Linux 3.18)
              Enable the close-on-exec flag for the file descriptor.  See the description of the O_CLOEXEC flag in open(2)
              for reasons why this may be useful.

       The following are also allowable: O_APPEND, O_DSYNC, O_NOATIME, O_NONBLOCK, and O_SYNC.  Specifying any other  flag
       in event_f_flags yields the error EINVAL (but see BUGS).

RETURN VALUE
       On  success, fanotify_init() returns a new file descriptor.  On error, -1 is returned, and errno is set to indicate
       the error.

ERRORS
       EINVAL An invalid value was passed in flags or event_f_flags.  FAN_ALL_INIT_FLAGS defines all  allowable  bits  for
              flags.

       EMFILE The number of fanotify groups for this user exceeds 128.

       EMFILE The per-process limit on the number of open file descriptors has been reached.

       ENOMEM The allocation of memory for the notification group failed.

       ENOSYS This  kernel  does not implement fanotify_init().  The fanotify API is available only if the kernel was con‐
              figured with CONFIG_FANOTIFY.

       EPERM  The operation is not permitted because the caller lacks the CAP_SYS_ADMIN capability.

VERSIONS
       fanotify_init() was introduced in version 2.6.36 of the Linux kernel and enabled in version 2.6.37.

CONFORMING TO
       This system call is Linux-specific.

BUGS
       The following bug was present in Linux kernels before version 3.18:

       *  The O_CLOEXEC is ignored when passed in event_f_flags.

       The following bug was present in Linux kernels before version 3.14:

       *  The event_f_flags argument is not checked for invalid flags.  Flags that are intended  only  for  internal  use,
          such as FMODE_EXEC, can be set, and will consequently be set for the file descriptors returned when reading from
          the fanotify file descriptor.

SEE ALSO
       fanotify_mark(2), fanotify(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        FANOTIFY_INIT(2)
</pre>
<pre zoom>
<span xsmall>2 arm_fadvise</span>
POSIX_FADVISE(2)                                 Linux Programmer's Manual                                POSIX_FADVISE(2)

NAME
       posix_fadvise - predeclare an access pattern for file data

SYNOPSIS
       #include <fcntl.h>

       int posix_fadvise(int fd, off_t offset, off_t len, int advice);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       posix_fadvise():
           _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       Programs  can use posix_fadvise() to announce an intention to access file data in a specific pattern in the future,
       thus allowing the kernel to perform appropriate optimizations.

       The advice applies to a (not necessarily existent) region starting at offset and extending for len bytes (or  until
       the  end  of the file if len is 0) within the file referred to by fd.  The advice is not binding; it merely consti‐
       tutes an expectation on behalf of the application.

       Permissible values for advice include:

       POSIX_FADV_NORMAL
              Indicates that the application has no advice to give about its access pattern for the specified data.  If no
              advice is given for an open file, this is the default assumption.

       POSIX_FADV_SEQUENTIAL
              The  application  expects  to  access the specified data sequentially (with lower offsets read before higher
              ones).

       POSIX_FADV_RANDOM
              The specified data will be accessed in random order.

       POSIX_FADV_NOREUSE
              The specified data will be accessed only once.

              In kernels before 2.6.18, POSIX_FADV_NOREUSE had the same semantics as POSIX_FADV_WILLNEED.  This was proba‐
              bly a bug; since kernel 2.6.18, this flag is a no-op.

       POSIX_FADV_WILLNEED
              The specified data will be accessed in the near future.

              POSIX_FADV_WILLNEED initiates a nonblocking read of the specified region into the page cache.  The amount of
              data read may be decreased by the kernel depending on virtual memory load.  (A few megabytes will usually be
              fully satisfied, and more is rarely useful.)

       POSIX_FADV_DONTNEED
              The specified data will not be accessed in the near future.

              POSIX_FADV_DONTNEED attempts to free cached pages associated with the specified region.  This is useful, for
              example, while streaming large files.  A program may periodically request the kernel  to  free  cached  data
              that has already been used, so that more useful cached pages are not discarded instead.

              Requests  to  discard  partial  pages  are  ignored.   It is preferable to preserve needed data than discard
              unneeded data.  If the application requires that data be considered for discarding, then offset and len must
              be page-aligned.

              The  implementation  may  attempt to write back dirty pages in the specified region, but this is not guaran‐
              teed.  Any unwritten dirty pages will not be freed.  If the application wishes to ensure  that  dirty  pages
              will be released, it should call fsync(2) or fdatasync(2) first.

RETURN VALUE
       On success, zero is returned.  On error, an error number is returned.

ERRORS
       EBADF  The fd argument was not a valid file descriptor.

       EINVAL An invalid value was specified for advice.

       ESPIPE The specified file descriptor refers to a pipe or FIFO.  (ESPIPE is the error specified by POSIX, but before
              kernel version 2.6.16, Linux returned EINVAL in this case.)

VERSIONS
       Kernel support first appeared in Linux 2.5.60; the underlying system call is called fadvise64().   Library  support
       has been provided since glibc version 2.2, via the wrapper function posix_fadvise().

       Since  Linux  3.18,  support  for  the  underlying  system  call  is optional, depending on the setting of the CON‐
       FIG_ADVISE_SYSCALLS configuration option.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.  Note that the  type  of  the  len  argument  was  changed  from  size_t  to  off_t  in
       POSIX.1-2003 TC1.

NOTES
       Under   Linux,  POSIX_FADV_NORMAL  sets  the  readahead  window  to  the  default  size  for  the  backing  device;
       POSIX_FADV_SEQUENTIAL doubles this size, and POSIX_FADV_RANDOM disables file  readahead  entirely.   These  changes
       affect  the  entire  file,  not  just  the specified region (but other open file handles to the same file are unaf‐
       fected).

       The contents of the kernel buffer cache can be cleared via  the  /proc/sys/vm/drop_caches  interface  described  in
       proc(5).

       One  can  obtain a snapshot of which pages of a file are resident in the buffer cache by opening a file, mapping it
       with mmap(2), and then applying mincore(2) to the mapping.

   C library/kernel differences
       The name of the wrapper function in the C library is posix_fadvise().  The underlying system call  is  called  fad‐
       vise64() (or, on some architectures, fadvise64_64()).

   Architecture-specific variants
       Some  architectures require 64-bit arguments to be aligned in a suitable pair of registers (see syscall(2) for fur‐
       ther detail).  On such architectures, the call signature of posix_fadvise() shown in the  SYNOPSIS  would  force  a
       register to be wasted as padding between the fd and offset arguments.  Therefore, these architectures define a ver‐
       sion of the system call that orders the arguments suitably, but is otherwise exactly the same as posix_fadvise().

       For example, since Linux 2.6.14, ARM has the following system call:

           long arm_fadvise64_64(int fd, int advice,
                                 loff_t offset, loff_t len);

       These architecture-specific details are generally hidden from applications by  the  glibc  posix_fadvise()  wrapper
       function, which invokes the appropriate architecture-specific system call.

BUGS
       In  kernels  before  2.6.6,  if len was specified as 0, then this was interpreted literally as "zero bytes", rather
       than as meaning "all bytes through to the end of the file".

SEE ALSO
       fincore(1), mincore(2), readahead(2), sync_file_range(2), posix_fallocate(3), posix_madvise(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        POSIX_FADVISE(2)
</pre>
<pre zoom>
<span xsmall>2 sbrk</span>
BRK(2)                                           Linux Programmer's Manual                                          BRK(2)

NAME
       brk, sbrk - change data segment size

SYNOPSIS
       #include <unistd.h>

       int brk(void *addr);

       void *sbrk(intptr_t increment);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       brk(), sbrk():
           Since glibc 2.19:
               _DEFAULT_SOURCE ||
                   (_XOPEN_SOURCE >= 500) &&
                   ! (_POSIX_C_SOURCE >= 200112L)
           From glibc 2.12 to 2.19:
               _BSD_SOURCE || _SVID_SOURCE ||
                   (_XOPEN_SOURCE >= 500) &&
                   ! (_POSIX_C_SOURCE >= 200112L)
           Before glibc 2.12:
               _BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE >= 500

DESCRIPTION
       brk()  and  sbrk()  change  the  location of the program break, which defines the end of the process's data segment
       (i.e., the program break is the first location after the end of the uninitialized data  segment).   Increasing  the
       program break has the effect of allocating memory to the process; decreasing the break deallocates memory.

       brk()  sets  the  end of the data segment to the value specified by addr, when that value is reasonable, the system
       has enough memory, and the process does not exceed its maximum data size (see setrlimit(2)).

       sbrk() increments the program's data space by increment bytes.  Calling sbrk() with an increment of 0 can  be  used
       to find the current location of the program break.

RETURN VALUE
       On success, brk() returns zero.  On error, -1 is returned, and errno is set to ENOMEM.

       On  success,  sbrk() returns the previous program break.  (If the break was increased, then this value is a pointer
       to the start of the newly allocated memory).  On error, (void *) -1 is returned, and errno is set to ENOMEM.

CONFORMING TO
       4.3BSD; SUSv1, marked LEGACY in SUSv2, removed in POSIX.1-2001.

NOTES
       Avoid using brk() and sbrk(): the malloc(3) memory allocation package is the portable and comfortable way of  allo‐
       cating memory.

       Various systems use various types for the argument of sbrk().  Common are int, ssize_t, ptrdiff_t, intptr_t.

   C library/kernel differences
       The  return  value  described  above for brk() is the behavior provided by the glibc wrapper function for the Linux
       brk() system call.  (On most other implementations, the return value from brk() is the same; this return value  was
       also  specified  in  SUSv2.)   However,  the actual Linux system call returns the new program break on success.  On
       failure, the system call returns the current break.  The glibc  wrapper  function  does  some  work  (i.e.,  checks
       whether the new break is less than addr) to provide the 0 and -1 return values described above.

       On Linux, sbrk() is implemented as a library function that uses the brk() system call, and does some internal book‐
       keeping so that it can return the old break value.

SEE ALSO
       execve(2), getrlimit(2), end(3), malloc(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2016-03-15                                                  BRK(2)
</pre>
<pre zoom>
<span xsmall>2 __clone2</span>
CLONE(2)                                         Linux Programmer's Manual                                        CLONE(2)

NAME
       clone, __clone2 - create a child process

SYNOPSIS
       /* Prototype for the glibc wrapper function */

       #define _GNU_SOURCE
       #include <sched.h>

       int clone(int (*fn)(void *), void *child_stack,
                 int flags, void *arg, ...
                 /* pid_t *ptid, void *newtls, pid_t *ctid */ );

       /* For the prototype of the raw system call, see NOTES */

DESCRIPTION
       clone() creates a new process, in a manner similar to fork(2).

       This  page  describes  both the glibc clone() wrapper function and the underlying system call on which it is based.
       The main text describes the wrapper function; the differences for the raw system call are described toward the  end
       of this page.

       Unlike  fork(2), clone() allows the child process to share parts of its execution context with the calling process,
       such as the virtual address space, the table of file descriptors, and the table of signal handlers.  (Note that  on
       this  manual  page,  "calling  process"  normally  corresponds  to  "parent  process".   But see the description of
       CLONE_PARENT below.)

       One use of clone() is to implement threads: multiple flows of control in a  program  that  run  concurrently  in  a
       shared address space.

       When  the  child  process is created with clone(), it commences execution by calling the function pointed to by the
       argument fn.  (This differs from fork(2), where execution continues in the child from  the  point  of  the  fork(2)
       call.)  The arg argument is passed as the argument of the function fn.

       When the fn(arg) function returns, the child process terminates.  The integer returned by fn is the exit status for
       the child process.  The child process may also terminate explicitly by calling exit(2) or after receiving  a  fatal
       signal.

       The  child_stack argument specifies the location of the stack used by the child process.  Since the child and call‐
       ing process may share memory, it is not possible for the child process to execute in the same stack as the  calling
       process.   The  calling  process  must therefore set up memory space for the child stack and pass a pointer to this
       space to clone().  Stacks grow downward on all processors  that  run  Linux  (except  the  HP  PA  processors),  so
       child_stack usually points to the topmost address of the memory space set up for the child stack.

       The  low  byte  of  flags contains the number of the termination signal sent to the parent when the child dies.  If
       this signal is specified as anything other than SIGCHLD, then  the  parent  process  must  specify  the  __WALL  or
       __WCLONE  options  when  waiting for the child with wait(2).  If no signal is specified, then the parent process is
       not signaled when the child terminates.

       flags may also be bitwise-ORed with zero or more of the following constants, in order to  specify  what  is  shared
       between the calling process and the child process:

       CLONE_CHILD_CLEARTID (since Linux 2.5.49)
              Clear  (zero) the child thread ID at the location ctid in child memory when the child exits, and do a wakeup
              on the futex at that address.  The address involved may be changed by the  set_tid_address(2)  system  call.
              This is used by threading libraries.

       CLONE_CHILD_SETTID (since Linux 2.5.49)
              Store  the child thread ID at the location ctid in the child's memory.  The store operation completes before
              clone() returns control to user space.

       CLONE_FILES (since Linux 2.0)
              If CLONE_FILES is set, the calling process and the child process share the same file descriptor table.   Any
              file  descriptor  created by the calling process or by the child process is also valid in the other process.
              Similarly, if one of the processes closes a file descriptor, or changes  its  associated  flags  (using  the
              fcntl(2) F_SETFD operation), the other process is also affected.  If a process sharing a file descriptor ta‐
              ble calls execve(2), its file descriptor table is duplicated (unshared).

              If CLONE_FILES is not set, the child process inherits a copy of all file descriptors opened in  the  calling
              process  at  the time of clone().  Subsequent operations that open or close file descriptors, or change file
              descriptor flags, performed by either the calling process or the child  process  do  not  affect  the  other
              process.   Note,  however,  that  the  duplicated  file descriptors in the child refer to the same open file
              descriptions as the corresponding file descriptors in the calling process, and thus share file  offsets  and
              file status flags (see open(2)).

       CLONE_FS (since Linux 2.0)
              If  CLONE_FS  is set, the caller and the child process share the same filesystem information.  This includes
              the root of the filesystem, the current working directory, and the umask.  Any call to chroot(2),  chdir(2),
              or umask(2) performed by the calling process or the child process also affects the other process.

              If  CLONE_FS  is  not  set,  the  child process works on a copy of the filesystem information of the calling
              process at the time of the clone() call.  Calls to chroot(2), chdir(2), or umask(2) performed later  by  one
              of the processes do not affect the other process.

       CLONE_IO (since Linux 2.6.25)
              If  CLONE_IO  is  set, then the new process shares an I/O context with the calling process.  If this flag is
              not set, then (as with fork(2)) the new process has its own I/O context.

              The I/O context is the I/O scope of the disk scheduler (i.e., what the I/O scheduler uses to model  schedul‐
              ing of a process's I/O).  If processes share the same I/O context, they are treated as one by the I/O sched‐
              uler.  As a consequence, they get to share disk time.  For some I/O schedulers, if two  processes  share  an
              I/O  context,  they  will  be  allowed to interleave their disk access.  If several threads are doing I/O on
              behalf of the same process (aio_read(3), for instance), they should employ CLONE_IO to get better  I/O  per‐
              formance.

              If the kernel is not configured with the CONFIG_BLOCK option, this flag is a no-op.

       CLONE_NEWCGROUP (since Linux 4.6)
              Create  the  process in a new cgroup namespace.  If this flag is not set, then (as with fork(2)) the process
              is created in the same cgroup namespaces as the calling process.  This flag is intended for the  implementa‐
              tion of containers.

              For further information on cgroup namespaces, see cgroup_namespaces(7).

              Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWCGROUP.

       CLONE_NEWIPC (since Linux 2.6.19)
              If  CLONE_NEWIPC  is set, then create the process in a new IPC namespace.  If this flag is not set, then (as
              with fork(2)), the process is created in the same IPC namespace  as  the  calling  process.   This  flag  is
              intended for the implementation of containers.

              An  IPC  namespace provides an isolated view of System V IPC objects (see svipc(7)) and (since Linux 2.6.30)
              POSIX message queues (see mq_overview(7)).  The common characteristic of these IPC mechanisms  is  that  IPC
              objects are identified by mechanisms other than filesystem pathnames.

              Objects  created  in an IPC namespace are visible to all other processes that are members of that namespace,
              but are not visible to processes in other IPC namespaces.

              When an IPC namespace is destroyed (i.e., when the last process that is a member  of  the  namespace  termi‐
              nates), all IPC objects in the namespace are automatically destroyed.

              Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWIPC.  This flag can't be specified in conjunc‐
              tion with CLONE_SYSVSEM.

              For further information on IPC namespaces, see namespaces(7).

       CLONE_NEWNET (since Linux 2.6.24)
              (The implementation of this flag was completed only by about kernel version 2.6.29.)

              If CLONE_NEWNET is set, then create the process in a new network namespace.  If this flag is not  set,  then
              (as with fork(2)) the process is created in the same network namespace as the calling process.  This flag is
              intended for the implementation of containers.

              A network namespace provides an isolated view of the networking stack (network device interfaces,  IPv4  and
              IPv6  protocol  stacks, IP routing tables, firewall rules, the /proc/net and /sys/class/net directory trees,
              sockets, etc.).  A physical network device can live in exactly one network  namespace.   A  virtual  network
              (veth(4))  device  pair  provides a pipe-like abstraction that can be used to create tunnels between network
              namespaces, and can be used to create a bridge to a physical network device in another namespace.

              When a network namespace is freed (i.e., when the last process in the namespace  terminates),  its  physical
              network  devices  are  moved  back to the initial network namespace (not to the parent of the process).  For
              further information on network namespaces, see namespaces(7).

              Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWNET.

       CLONE_NEWNS (since Linux 2.4.19)
              If CLONE_NEWNS is set, the cloned child is started in a new mount namespace, initialized with a copy of  the
              namespace of the parent.  If CLONE_NEWNS is not set, the child lives in the same mount namespace as the par‐
              ent.

              Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWNS.  It  is  not  permitted  to  specify  both
              CLONE_NEWNS and CLONE_FS in the same clone() call.

              For further information on mount namespaces, see namespaces(7) and mount_namespaces(7).

       CLONE_NEWPID (since Linux 2.6.24)
              If  CLONE_NEWPID  is set, then create the process in a new PID namespace.  If this flag is not set, then (as
              with fork(2)) the process is created in the same PID  namespace  as  the  calling  process.   This  flag  is
              intended for the implementation of containers.

              For further information on PID namespaces, see namespaces(7) and pid_namespaces(7).

              Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWPID.  This flag can't be specified in conjunc‐
              tion with CLONE_THREAD or CLONE_PARENT.

       CLONE_NEWUSER
              (This flag first became meaningful for clone() in Linux 2.6.23, the current clone() semantics were merged in
              Linux 3.5, and the final pieces to make the user namespaces completely usable were merged in Linux 3.8.)

              If CLONE_NEWUSER is set, then create the process in a new user namespace.  If this flag is not set, then (as
              with fork(2)) the process is created in the same user namespace as the calling process.

              Before Linux 3.8, use of CLONE_NEWUSER required that the  caller  have  three  capabilities:  CAP_SYS_ADMIN,
              CAP_SETUID, and CAP_SETGID.  Starting with Linux 3.8, no privileges are needed to create a user namespace.

              This  flag  can't  be  specified  in  conjunction  with CLONE_THREAD or CLONE_PARENT.  For security reasons,
              CLONE_NEWUSER cannot be specified in conjunction with CLONE_FS.

              For further information on user namespaces, see namespaces(7) and user_namespaces(7).

       CLONE_NEWUTS (since Linux 2.6.19)
              If CLONE_NEWUTS is set, then create the process in a new UTS namespace, whose identifiers are initialized by
              duplicating  the  identifiers  from the UTS namespace of the calling process.  If this flag is not set, then
              (as with fork(2)) the process is created in the same UTS namespace as the calling  process.   This  flag  is
              intended for the implementation of containers.

              A  UTS  namespace is the set of identifiers returned by uname(2); among these, the domain name and the host‐
              name can be modified by setdomainname(2) and sethostname(2), respectively.  Changes made to the  identifiers
              in  a  UTS  namespace  are visible to all other processes in the same namespace, but are not visible to pro‐
              cesses in other UTS namespaces.

              Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWUTS.

              For further information on UTS namespaces, see namespaces(7).

       CLONE_PARENT (since Linux 2.3.12)
              If CLONE_PARENT is set, then the parent of the new child (as returned by getppid(2)) will  be  the  same  as
              that of the calling process.

              If CLONE_PARENT is not set, then (as with fork(2)) the child's parent is the calling process.

              Note  that it is the parent process, as returned by getppid(2), which is signaled when the child terminates,
              so that if CLONE_PARENT is set, then the parent of the calling process,  rather  than  the  calling  process
              itself, will be signaled.

       CLONE_PARENT_SETTID (since Linux 2.5.49)
              Store  the child thread ID at the location ptid in the parent's memory.  (In Linux 2.5.32-2.5.48 there was a
              flag CLONE_SETTID that did this.)  The store operation completes before  clone()  returns  control  to  user
              space.

       CLONE_PID (Linux 2.0 to 2.5.15)
              If  CLONE_PID is set, the child process is created with the same process ID as the calling process.  This is
              good for hacking the system, but otherwise of not much use.  From Linux 2.3.21 onward, this  flag  could  be
              specified  only by the system boot process (PID 0).  The flag disappeared completely from the kernel sources
              in Linux 2.5.16.  Since then, the kernel silently ignores this bit if it is specified in flags.

       CLONE_PTRACE (since Linux 2.2)
              If CLONE_PTRACE is specified, and the calling process is being  traced,  then  trace  the  child  also  (see
              ptrace(2)).

       CLONE_SETTLS (since Linux 2.5.32)
              The TLS (Thread Local Storage) descriptor is set to newtls.

              The  interpretation  of newtls and the resulting effect is architecture dependent.  On x86, newtls is inter‐
              preted as a struct user_desc * (see set_thread_area(2)).  On x86-64 it is the new value to be  set  for  the
              %fs  base  register  (see the ARCH_SET_FS argument to arch_prctl(2)).  On architectures with a dedicated TLS
              register, it is the new value of that register.

       CLONE_SIGHAND (since Linux 2.0)
              If CLONE_SIGHAND is set, the calling process and the child process share the same table of signal  handlers.
              If  the calling process or child process calls sigaction(2) to change the behavior associated with a signal,
              the behavior is changed in the other process as well.  However, the  calling  process  and  child  processes
              still  have distinct signal masks and sets of pending signals.  So, one of them may block or unblock signals
              using sigprocmask(2) without affecting the other process.

              If CLONE_SIGHAND is not set, the child process inherits a copy of the signal handlers of the calling process
              at the time clone() is called.  Calls to sigaction(2) performed later by one of the processes have no effect
              on the other process.

              Since Linux 2.6.0-test6, flags must also include CLONE_VM if CLONE_SIGHAND is specified

       CLONE_STOPPED (since Linux 2.6.0-test2)
              If CLONE_STOPPED is set, then the child is initially stopped (as though it was sent a SIGSTOP  signal),  and
              must be resumed by sending it a SIGCONT signal.

              This  flag was deprecated from Linux 2.6.25 onward, and was removed altogether in Linux 2.6.38.  Since then,
              the kernel silently ignores it without error.  Starting with Linux 4.6, the same  bit  was  reused  for  the
              CLONE_NEWCGROUP flag.

       CLONE_SYSVSEM (since Linux 2.5.10)
              If  CLONE_SYSVSEM  is  set, then the child and the calling process share a single list of System V semaphore
              adjustment (semadj) values (see semop(2)).  In this case, the shared list accumulates semadj  values  across
              all  processes  sharing the list, and semaphore adjustments are performed only when the last process that is
              sharing the list terminates (or ceases sharing the list using unshare(2)).  If this flag is  not  set,  then
              the child has a separate semadj list that is initially empty.

       CLONE_THREAD (since Linux 2.4.0-test8)
              If  CLONE_THREAD  is  set, the child is placed in the same thread group as the calling process.  To make the
              remainder of the discussion of CLONE_THREAD more readable, the term "thread" is used to refer  to  the  pro‐
              cesses within a thread group.

              Thread groups were a feature added in Linux 2.4 to support the POSIX threads notion of a set of threads that
              share a single PID.  Internally, this shared PID is the so-called thread group  identifier  (TGID)  for  the
              thread group.  Since Linux 2.4, calls to getpid(2) return the TGID of the caller.

              The  threads  within  a  group  can  be distinguished by their (system-wide) unique thread IDs (TID).  A new
              thread's TID is available as the function result returned to the caller of clone(), and a thread can  obtain
              its own TID using gettid(2).

              When a call is made to clone() without specifying CLONE_THREAD, then the resulting thread is placed in a new
              thread group whose TGID is the same as the thread's TID.  This thread is the leader of the new thread group.

              A new thread created with CLONE_THREAD has the same parent process as the  caller  of  clone()  (i.e.,  like
              CLONE_PARENT),  so  that calls to getppid(2) return the same value for all of the threads in a thread group.
              When a CLONE_THREAD thread terminates, the thread that created it using clone() is not sent  a  SIGCHLD  (or
              other  termination)  signal;  nor can the status of such a thread be obtained using wait(2).  (The thread is
              said to be detached.)

              After all of the threads in a thread group terminate the parent process  of  the  thread  group  is  sent  a
              SIGCHLD (or other termination) signal.

              If  any of the threads in a thread group performs an execve(2), then all threads other than the thread group
              leader are terminated, and the new program is executed in the thread group leader.

              If one of the threads in a thread group creates a child using fork(2), then any  thread  in  the  group  can
              wait(2) for that child.

              Since Linux 2.5.35, flags must also include CLONE_SIGHAND if CLONE_THREAD is specified (and note that, since
              Linux 2.6.0-test6, CLONE_SIGHAND also requires CLONE_VM to be included).

              Signals may be sent to a thread group as a whole (i.e., a TGID) using  kill(2),  or  to  a  specific  thread
              (i.e., TID) using tgkill(2).

              Signal  dispositions  and actions are process-wide: if an unhandled signal is delivered to a thread, then it
              will affect (terminate, stop, continue, be ignored in) all members of the thread group.

              Each thread has its own signal mask, as set by sigprocmask(2), but signals can be pending  either:  for  the
              whole process (i.e., deliverable to any member of the thread group), when sent with kill(2); or for an indi‐
              vidual thread, when sent with tgkill(2).  A call to sigpending(2) returns a signal set that is the union  of
              the signals pending for the whole process and the signals that are pending for the calling thread.

              If  kill(2) is used to send a signal to a thread group, and the thread group has installed a handler for the
              signal, then the handler will be invoked in exactly one, arbitrarily selected member  of  the  thread  group
              that has not blocked the signal.  If multiple threads in a group are waiting to accept the same signal using
              sigwaitinfo(2), the kernel will arbitrarily select one of these threads  to  receive  a  signal  sent  using
              kill(2).

       CLONE_UNTRACED (since Linux 2.5.46)
              If CLONE_UNTRACED is specified, then a tracing process cannot force CLONE_PTRACE on this child process.

       CLONE_VFORK (since Linux 2.2)
              If  CLONE_VFORK  is set, the execution of the calling process is suspended until the child releases its vir‐
              tual memory resources via a call to execve(2) or _exit(2) (as with vfork(2)).

              If CLONE_VFORK is not set, then both the calling process and the child are schedulable after the  call,  and
              an application should not rely on execution occurring in any particular order.

       CLONE_VM (since Linux 2.0)
              If  CLONE_VM is set, the calling process and the child process run in the same memory space.  In particular,
              memory writes performed by the calling process or by the  child  process  are  also  visible  in  the  other
              process.   Moreover,  any  memory  mapping  or unmapping performed with mmap(2) or munmap(2) by the child or
              calling process also affects the other process.

              If CLONE_VM is not set, the child process runs in a separate copy of the memory space of the calling process
              at  the time of clone().  Memory writes or file mappings/unmappings performed by one of the processes do not
              affect the other, as with fork(2).

NOTES
       Note that the glibc clone() wrapper function makes some changes in the memory pointed to  by  child_stack  (changes
       required  to set the stack up correctly for the child) before invoking the clone() system call.  So, in cases where
       clone() is used to recursively create children, do not use the buffer employed for the parent's stack as the  stack
       of the child.

   C library/kernel differences
       The  raw  clone() system call corresponds more closely to fork(2) in that execution in the child continues from the
       point of the call.  As such, the fn and arg arguments of the clone() wrapper function are omitted.

       Another difference for the raw clone() system call is that the child_stack argument may be NULL, in which case  the
       child  uses a duplicate of the parent's stack.  (Copy-on-write semantics ensure that the child gets separate copies
       of stack pages when either process modifies the stack.)  In this case, for correct operation, the  CLONE_VM  option
       should not be specified.  (If the child shares the parent's memory because of the use of the CLONE_VM flag, then no
       copy-on-write duplication occurs and chaos is likely to result.)

       The order of the arguments also differs in the raw system call, and there are variations in  the  arguments  across
       architectures, as detailed in the following paragraphs.

       The raw system call interface on x86-64 and some other architectures (including sh, tile, and alpha) is:

           long clone(unsigned long flags, void *child_stack,
                      int *ptid, int *ctid,
                      unsigned long newtls);

       On  x86-32,  and  several other common architectures (including score, ARM, ARM 64, PA-RISC, arc, Power PC, xtensa,
       and MIPS), the order of the last two arguments is reversed:

           long clone(unsigned long flags, void *child_stack,
                     int *ptid, unsigned long newtls,
                     int *ctid);

       On the cris and s390 architectures, the order of the first two arguments is reversed:

           long clone(void *child_stack, unsigned long flags,
                      int *ptid, int *ctid,
                      unsigned long newtls);

       On the microblaze architecture, an additional argument is supplied:

           long clone(unsigned long flags, void *child_stack,
                      int stack_size,         /* Size of stack */
                      int *ptid, int *ctid,
                      unsigned long newtls);

   blackfin, m68k, and sparc
       The argument-passing conventions on blackfin, m68k, and sparc are  different  from  the  descriptions  above.   For
       details, see the kernel (and glibc) source.

   ia64
       On ia64, a different interface is used:

       int __clone2(int (*fn)(void *),
                    void *child_stack_base, size_t stack_size,
                    int flags, void *arg, ...
                 /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ );

       The  prototype  shown above is for the glibc wrapper function; the raw system call interface has no fn or arg argu‐
       ment, and changes the order of the arguments so that flags is the first argument, and tls is the last argument.

       __clone2() operates in the same way as clone(), except that child_stack_base points to the lowest  address  of  the
       child's stack area, and stack_size specifies the size of the stack pointed to by child_stack_base.

   Linux 2.4 and earlier
       In Linux 2.4 and earlier, clone() does not take arguments ptid, tls, and ctid.

RETURN VALUE
       On  success, the thread ID of the child process is returned in the caller's thread of execution.  On failure, -1 is
       returned in the caller's context, no child process will be created, and errno will be set appropriately.

ERRORS
       EAGAIN Too many processes are already running; see fork(2).

       EINVAL CLONE_SIGHAND was specified, but CLONE_VM was not.  (Since Linux 2.6.0-test6.)

       EINVAL CLONE_THREAD was specified, but CLONE_SIGHAND was not.  (Since Linux 2.5.35.)

       EINVAL Both CLONE_FS and CLONE_NEWNS were specified in flags.

       EINVAL (since Linux 3.9)
              Both CLONE_NEWUSER and CLONE_FS were specified in flags.

       EINVAL Both CLONE_NEWIPC and CLONE_SYSVSEM were specified in flags.

       EINVAL One (or both) of CLONE_NEWPID or CLONE_NEWUSER and one (or both) of CLONE_THREAD or CLONE_PARENT were speci‐
              fied in flags.

       EINVAL Returned by the glibc clone() wrapper function when fn or child_stack is specified as NULL.

       EINVAL CLONE_NEWIPC  was  specified  in  flags,  but the kernel was not configured with the CONFIG_SYSVIPC and CON‐
              FIG_IPC_NS options.

       EINVAL CLONE_NEWNET was specified in flags, but the kernel was not configured with the CONFIG_NET_NS option.

       EINVAL CLONE_NEWPID was specified in flags, but the kernel was not configured with the CONFIG_PID_NS option.

       EINVAL CLONE_NEWUTS was specified in flags, but the kernel was not configured with the CONFIG_UTS option.

       EINVAL child_stack is not aligned to  a  suitable  boundary  for  this  architecture.   For  example,  on  aarch64,
              child_stack must be a multiple of 16.

       ENOMEM Cannot  allocate sufficient memory to allocate a task structure for the child, or to copy those parts of the
              caller's context that need to be copied.

       ENOSPC (since Linux 3.7)
              CLONE_NEWPID was specified in flags, but the limit on the nesting depth of PID namespaces  would  have  been
              exceeded; see pid_namespaces(7).

       ENOSPC (since Linux 4.9; beforehand EUSERS)
              CLONE_NEWUSER was specified in flags, and the call would cause the limit on the number of nested user names‐
              paces to be exceeded.  See user_namespaces(7).

              From Linux 3.11 to Linux 4.8, the error diagnosed in this case was EUSERS.

       ENOSPC (since Linux 4.9)
              One of the values in flags specified the creation of a new user namespace, but doing so  would  have  caused
              the  limit  defined  by  the  corresponding file in /proc/sys/user to be exceeded.  For further details, see
              namespaces(7).

       EPERM  CLONE_NEWCGROUP, CLONE_NEWIPC, CLONE_NEWNET, CLONE_NEWNS, CLONE_NEWPID, or CLONE_NEWUTS was specified by  an
              unprivileged process (process without CAP_SYS_ADMIN).

       EPERM  CLONE_PID was specified by a process other than process 0.  (This error occurs only on Linux 2.5.15 and ear‐
              lier.)

       EPERM  CLONE_NEWUSER was specified in flags, but either the effective user ID or the  effective  group  ID  of  the
              caller does not have a mapping in the parent namespace (see user_namespaces(7)).

       EPERM (since Linux 3.9)
              CLONE_NEWUSER  was  specified  in  flags  and the caller is in a chroot environment (i.e., the caller's root
              directory does not match the root directory of the mount namespace in which it resides).

       ERESTARTNOINTR (since Linux 2.6.17)
              System call was interrupted by a signal and will be restarted.  (This can be seen only during a trace.)

       EUSERS (Linux 3.11 to Linux 4.8)
              CLONE_NEWUSER was specified in flags, and the limit on  the  number  of  nested  user  namespaces  would  be
              exceeded.  See the discussion of the ENOSPC error above.

CONFORMING TO
       clone() is Linux-specific and should not be used in programs intended to be portable.

NOTES
       The kcmp(2) system call can be used to test whether two processes share various resources such as a file descriptor
       table, System V semaphore undo operations, or a virtual address space.

       Handlers registered using pthread_atfork(3) are not executed during a call to clone().

       In the Linux 2.4.x series, CLONE_THREAD generally does not make the parent of the new thread the same as the parent
       of  the calling process.  However, for kernel versions 2.4.7 to 2.4.18 the CLONE_THREAD flag implied the CLONE_PAR‐
       ENT flag (as in Linux 2.6.0 and later).

       For a while there was CLONE_DETACHED (introduced in 2.5.32): parent wants no child-exit signal.   In  Linux  2.6.2,
       the need to give this flag together with CLONE_THREAD disappeared.  This flag is still defined, but has no effect.

       On i386, clone() should not be called through vsyscall, but directly through int $0x80.

BUGS
       GNU  C  library  versions  2.3.4 up to and including 2.24 contained a wrapper function for getpid(2) that performed
       caching of PIDs.  This caching relied on support in the glibc wrapper for clone(), but limitations in the implemen‐
       tation  meant that the cache was not up to date in some circumstances.  In particular, if a signal was delivered to
       the child immediately after the clone() call, then a call to getpid(2) in a handler for the signal could return the
       PID of the calling process ("the parent"), if the clone wrapper had not yet had a chance to update the PID cache in
       the child.  (This discussion ignores the case where the child was created using CLONE_THREAD, when getpid(2) should
       return  the  same  value in the child and in the process that called clone(), since the caller and the child are in
       the same thread group.  The stale-cache problem also does not occur if the flags argument includes  CLONE_VM.)   To
       get the truth, it was sometimes necessary to use code such as the following:

           #include <syscall.h>

           pid_t mypid;

           mypid = syscall(SYS_getpid);

       Because  of  the  stale-cache  problem,  as  well as other problems noted in getpid(2), the PID caching feature was
       removed in glibc 2.25.

EXAMPLE
       The following program demonstrates the use of clone() to create a child process that executes  in  a  separate  UTS
       namespace.   The  child  changes  the hostname in its UTS namespace.  Both parent and child then display the system
       hostname, making it possible to see that the hostname differs in the UTS namespaces of the parent and  child.   For
       an example of the use of this program, see setns(2).

   Program source
       #define _GNU_SOURCE
       #include <sys/wait.h>
       #include <sys/utsname.h>
       #include <sched.h>
       #include <string.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>

       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       static int              /* Start function for cloned child */
       childFunc(void *arg)
       {
           struct utsname uts;

           /* Change hostname in UTS namespace of child */

           if (sethostname(arg, strlen(arg)) == -1)
               errExit("sethostname");

           /* Retrieve and display hostname */

           if (uname(&uts) == -1)
               errExit("uname");
           printf("uts.nodename in child:  %s\n", uts.nodename);

           /* Keep the namespace open for a while, by sleeping.
              This allows some experimentation--for example, another
              process might join the namespace. */

           sleep(200);

           return 0;           /* Child terminates now */
       }

       #define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */

       int
       main(int argc, char *argv[])
       {
           char *stack;                    /* Start of stack buffer */
           char *stackTop;                 /* End of stack buffer */
           pid_t pid;
           struct utsname uts;

           if (argc < 2) {
               fprintf(stderr, "Usage: %s <child-hostname>\n", argv[0]);
               exit(EXIT_SUCCESS);
           }

           /* Allocate stack for child */

           stack = malloc(STACK_SIZE);
           if (stack == NULL)
               errExit("malloc");
           stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */

           /* Create child that has its own UTS namespace;
              child commences execution in childFunc() */

           pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);
           if (pid == -1)
               errExit("clone");
           printf("clone() returned %ld\n", (long) pid);

           /* Parent falls through to here */

           sleep(1);           /* Give child time to change its hostname */

           /* Display hostname in parent's UTS namespace. This will be
              different from hostname in child's UTS namespace. */

           if (uname(&uts) == -1)
               errExit("uname");
           printf("uts.nodename in parent: %s\n", uts.nodename);

           if (waitpid(pid, NULL, 0) == -1)    /* Wait for child */
               errExit("waitpid");
           printf("child has terminated\n");

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       fork(2),  futex(2),  getpid(2),  gettid(2),  kcmp(2),  set_thread_area(2),  set_tid_address(2), setns(2), tkill(2),
       unshare(2), wait(2), capabilities(7), namespaces(7), pthreads(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                CLONE(2)
</pre>
<pre zoom>
<span xsmall>2 sched_getparam</span>
SCHED_SETPARAM(2)                                Linux Programmer's Manual                               SCHED_SETPARAM(2)

NAME
       sched_setparam, sched_getparam - set and get scheduling parameters

SYNOPSIS
       #include <sched.h>

       int sched_setparam(pid_t pid, const struct sched_param *param);

       int sched_getparam(pid_t pid, struct sched_param *param);

       struct sched_param {
           ...
           int sched_priority;
           ...
       };

DESCRIPTION
       sched_setparam() sets the scheduling parameters associated with the scheduling policy for the process identified by
       pid.  If pid is zero, then the parameters of the calling process are set.  The interpretation of the argument param
       depends  on the scheduling policy of the process identified by pid.  See sched(7) for a description of the schedul‐
       ing policies supported under Linux.

       sched_getparam() retrieves the scheduling parameters for the process identified by pid.  If pid is zero,  then  the
       parameters of the calling process are retrieved.

       sched_setparam() checks the validity of param for the scheduling policy of the thread.  The value param->sched_pri‐
       ority must lie within the range given by sched_get_priority_min(2) and sched_get_priority_max(2).

       For a discussion of the privileges and resource limits related to scheduling priority and policy, see sched(7).

       POSIX systems on which sched_setparam() and sched_getparam() are  available  define  _POSIX_PRIORITY_SCHEDULING  in
       <unistd.h>.

RETURN VALUE
       On  success,  sched_setparam() and sched_getparam() return 0.  On error, -1 is returned, and errno is set appropri‐
       ately.

ERRORS
       EINVAL Invalid arguments: param is NULL or pid is negative

       EINVAL (sched_setparam()) The argument param does not make sense for the current scheduling policy.

       EPERM  (sched_setparam()) The calling process does not have  appropriate  privileges  (Linux:  does  not  have  the
              CAP_SYS_NICE capability).

       ESRCH  The process whose ID is pid could not be found.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       Scheduling parameters are in fact per-thread attributes on Linux; see sched(7).

SEE ALSO
       getpriority(2), nice(2), sched_get_priority_max(2), sched_get_priority_min(2), sched_getaffinity(2),
       sched_getscheduler(2), sched_setaffinity(2), sched_setattr(2), sched_setscheduler(2), setpriority(2),
       capabilities(7), sched(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                       SCHED_SETPARAM(2)
</pre>
<pre zoom>
<span xsmall>2 waitpid</span>
WAIT(2)                                          Linux Programmer's Manual                                         WAIT(2)

NAME
       wait, waitpid, waitid - wait for process to change state

SYNOPSIS
       #include <sys/types.h>
       #include <sys/wait.h>

       pid_t wait(int *wstatus);

       pid_t waitpid(pid_t pid, int *wstatus, int options);

       int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
                       /* This is the glibc and POSIX interface; see
                          NOTES for information on the raw system call. */

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       waitid():
           Since glibc 2.26: _XOPEN_SOURCE >= 500 ||
               _POSIX_C_SOURCE >= 200809L
           Glibc 2.25 and earlier:
               _XOPEN_SOURCE
                   || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
                   || /* Glibc versions <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       All of these system calls are used to wait for state changes in a child of the calling process, and obtain informa‐
       tion about the child whose state has changed.  A state change is considered to be: the child terminated; the  child
       was  stopped  by  a  signal; or the child was resumed by a signal.  In the case of a terminated child, performing a
       wait allows the system to release the resources associated with the child; if a wait is  not  performed,  then  the
       terminated child remains in a "zombie" state (see NOTES below).

       If  a  child  has already changed state, then these calls return immediately.  Otherwise, they block until either a
       child changes state or a signal handler interrupts the call (assuming  that  system  calls  are  not  automatically
       restarted  using  the  SA_RESTART  flag  of  sigaction(2)).  In the remainder of this page, a child whose state has
       changed and which has not yet been waited upon by one of these system calls is termed waitable.

   wait() and waitpid()
       The wait() system call suspends execution of the calling thread until one of its  children  terminates.   The  call
       wait(&wstatus) is equivalent to:

           waitpid(-1, &wstatus, 0);

       The  waitpid()  system  call  suspends  execution of the calling thread until a child specified by pid argument has
       changed state.  By default, waitpid() waits only for terminated children, but this behavior is modifiable  via  the
       options argument, as described below.

       The value of pid can be:

       < -1   meaning wait for any child process whose process group ID is equal to the absolute value of pid.

       -1     meaning wait for any child process.

       0      meaning wait for any child process whose process group ID is equal to that of the calling process.

       > 0    meaning wait for the child whose process ID is equal to the value of pid.

       The value of options is an OR of zero or more of the following constants:

       WNOHANG     return immediately if no child has exited.

       WUNTRACED   also  return  if  a child has stopped (but not traced via ptrace(2)).  Status for traced children which
                   have stopped is provided even if this option is not specified.

       WCONTINUED (since Linux 2.6.10)
                   also return if a stopped child has been resumed by delivery of SIGCONT.

       (For Linux-only options, see below.)

       If wstatus is not NULL, wait() and waitpid() store status information in the int to which it points.  This  integer
       can  be  inspected with the following macros (which take the integer itself as an argument, not a pointer to it, as
       is done in wait() and waitpid()!):

       WIFEXITED(wstatus)
              returns true if the child terminated normally, that is, by calling exit(3) or _exit(2), or by returning from
              main().

       WEXITSTATUS(wstatus)
              returns  the exit status of the child.  This consists of the least significant 8 bits of the status argument
              that the child specified in a call to exit(3) or _exit(2) or as the  argument  for  a  return  statement  in
              main().  This macro should be employed only if WIFEXITED returned true.

       WIFSIGNALED(wstatus)
              returns true if the child process was terminated by a signal.

       WTERMSIG(wstatus)
              returns  the number of the signal that caused the child process to terminate.  This macro should be employed
              only if WIFSIGNALED returned true.

       WCOREDUMP(wstatus)
              returns true if the child produced a core dump.  This macro should be employed only if WIFSIGNALED  returned
              true.

              This  macro  is  not specified in POSIX.1-2001 and is not available on some UNIX implementations (e.g., AIX,
              SunOS).  Therefore, enclose its use inside #ifdef WCOREDUMP ... #endif.

       WIFSTOPPED(wstatus)
              returns true if the child process was stopped by delivery of a signal; this is possible only if the call was
              done using WUNTRACED or when the child is being traced (see ptrace(2)).

       WSTOPSIG(wstatus)
              returns the number of the signal which caused the child to stop.  This macro should be employed only if WIF‐
              STOPPED returned true.

       WIFCONTINUED(wstatus)
              (since Linux 2.6.10) returns true if the child process was resumed by delivery of SIGCONT.

   waitid()
       The waitid() system call (available since Linux 2.6.9) provides more precise control over which child state changes
       to wait for.

       The idtype and id arguments select the child(ren) to wait for, as follows:

       idtype == P_PID
              Wait for the child whose process ID matches id.

       idtype == P_PGID
              Wait for any child whose process group ID matches id.

       idtype == P_ALL
              Wait for any child; id is ignored.

       The child state changes to wait for are specified by ORing one or more of the following flags in options:

       WEXITED     Wait for children that have terminated.

       WSTOPPED    Wait for children that have been stopped by delivery of a signal.

       WCONTINUED  Wait for (previously stopped) children that have been resumed by delivery of SIGCONT.

       The following flags may additionally be ORed in options:

       WNOHANG     As for waitpid().

       WNOWAIT     Leave  the  child in a waitable state; a later wait call can be used to again retrieve the child status
                   information.

       Upon successful return, waitid() fills in the following fields of the siginfo_t structure pointed to by infop:

       si_pid      The process ID of the child.

       si_uid      The real user ID of the child.  (This field is not set on most other implementations.)

       si_signo    Always set to SIGCHLD.

       si_status   Either the exit status of the child, as given to _exit(2) (or exit(3)), or the signal that  caused  the
                   child  to  terminate,  stop,  or continue.  The si_code field can be used to determine how to interpret
                   this field.

       si_code     Set to one of: CLD_EXITED (child called _exit(2)); CLD_KILLED  (child  killed  by  signal);  CLD_DUMPED
                   (child  killed  by signal, and dumped core); CLD_STOPPED (child stopped by signal); CLD_TRAPPED (traced
                   child has trapped); or CLD_CONTINUED (child continued by SIGCONT).

       If WNOHANG was specified in options and there were no children in a waitable state, then waitid() returns 0 immedi‐
       ately  and  the  state of the siginfo_t structure pointed to by infop depends on the implementation.  To (portably)
       distinguish this case from that where a child was in a waitable state, zero out the si_pid field  before  the  call
       and check for a nonzero value in this field after the call returns.

       POSIX.1-2008  Technical  Corrigendum  1  (2013)  adds the requirement that when WNOHANG is specified in options and
       there were no children in a waitable state, then waitid() should zero out the si_pid and  si_signo  fields  of  the
       structure.  On Linux and other implementations that adhere to this requirement, it is not necessary to zero out the
       si_pid field before calling waitid().  However, not all implementations follow the POSIX.1  specification  on  this
       point.

RETURN VALUE
       wait(): on success, returns the process ID of the terminated child; on error, -1 is returned.

       waitpid():  on  success,  returns the process ID of the child whose state has changed; if WNOHANG was specified and
       one or more child(ren) specified by pid exist, but have not yet changed state, then 0 is returned.  On error, -1 is
       returned.

       waitid(): returns 0 on success or if WNOHANG was specified and no child(ren) specified by id has yet changed state;
       on error, -1 is returned.

       Each of these calls sets errno to an appropriate value in the case of an error.

ERRORS
       ECHILD (for wait()) The calling process does not have any unwaited-for children.

       ECHILD (for waitpid() or waitid()) The process specified by pid (waitpid()) or idtype and id  (waitid())  does  not
              exist  or  is  not  a  child of the calling process.  (This can happen for one's own child if the action for
              SIGCHLD is set to SIG_IGN.  See also the Linux Notes section about threads.)

       EINTR  WNOHANG was not set and an unblocked signal or a SIGCHLD was caught; see signal(7).

       EINVAL The options argument was invalid.

CONFORMING TO
       SVr4, 4.3BSD, POSIX.1-2001.

NOTES
       A child that terminates, but has not been waited for becomes a "zombie".  The kernel maintains  a  minimal  set  of
       information  about  the  zombie process (PID, termination status, resource usage information) in order to allow the
       parent to later perform a wait to obtain information about the child.  As long as a zombie is not removed from  the
       system via a wait, it will consume a slot in the kernel process table, and if this table fills, it will not be pos‐
       sible to create further processes.  If a parent process terminates, then its "zombie" children (if any) are adopted
       by  init(1),  (or  by  the nearest "subreaper" process as defined through the use of the prctl(2) PR_SET_CHILD_SUB‐
       REAPER operation); init(1) automatically performs a wait to remove the zombies.

       POSIX.1-2001 specifies that if the disposition of SIGCHLD is set to SIG_IGN or the SA_NOCLDWAIT  flag  is  set  for
       SIGCHLD  (see  sigaction(2)),  then children that terminate do not become zombies and a call to wait() or waitpid()
       will block until all children have terminated, and then fail with errno set to ECHILD.  (The original  POSIX  stan‐
       dard left the behavior of setting SIGCHLD to SIG_IGN unspecified.  Note that even though the default disposition of
       SIGCHLD is "ignore", explicitly setting the disposition to SIG_IGN results in different treatment of zombie process
       children.)

       Linux  2.6 conforms to the POSIX requirements.  However, Linux 2.4 (and earlier) does not: if a wait() or waitpid()
       call is made while SIGCHLD is being ignored, the call behaves just as though SIGCHLD were not being  ignored,  that
       is, the call blocks until the next child terminates and then returns the process ID and status of that child.

   Linux notes
       In  the  Linux  kernel, a kernel-scheduled thread is not a distinct construct from a process.  Instead, a thread is
       simply a process that is created using the Linux-unique clone(2) system call; other routines such as  the  portable
       pthread_create(3)  call  are  implemented  using clone(2).  Before Linux 2.4, a thread was just a special case of a
       process, and as a consequence one thread could not wait on the children of another thread,  even  when  the  latter
       belongs  to the same thread group.  However, POSIX prescribes such functionality, and since Linux 2.4 a thread can,
       and by default will, wait on children of other threads in the same thread group.

       The following Linux-specific options are for use with children created using clone(2); they can also,  since  Linux
       4.7, be used with waitid():

       __WCLONE
              Wait  for  "clone" children only.  If omitted, then wait for "non-clone" children only.  (A "clone" child is
              one which delivers no signal, or a signal other than SIGCHLD to its parent upon termination.)   This  option
              is ignored if __WALL is also specified.

       __WALL (since Linux 2.4)
              Wait for all children, regardless of type ("clone" or "non-clone").

       __WNOTHREAD (since Linux 2.4)
              Do not wait for children of other threads in the same thread group.  This was the default before Linux 2.4.

       Since Linux 4.7, the __WALL flag is automatically implied if the child is being ptraced.

   C library/kernel differences
       wait() is actually a library function that (in glibc) is implemented as a call to wait4(2).

       On  some  architectures,  there is no waitpid() system call; instead, this interface is implemented via a C library
       wrapper function that calls wait4(2).

       The raw waitid() system call takes a fifth argument, of type struct rusage *.  If this argument is  non-NULL,  then
       it  is used to return resource usage information about the child, in the same manner as wait4(2).  See getrusage(2)
       for details.

BUGS
       According to POSIX.1-2008, an application calling waitid() must ensure that infop points to a  siginfo_t  structure
       (i.e.,  that  it is a non-null pointer).  On Linux, if infop is NULL, waitid() succeeds, and returns the process ID
       of the waited-for child.  Applications should avoid relying on this inconsistent, nonstandard, and unnecessary fea‐
       ture.

EXAMPLE
       The  following  program demonstrates the use of fork(2) and waitpid().  The program creates a child process.  If no
       command-line argument is supplied to the program, then the child suspends its execution using  pause(2),  to  allow
       the  user  to  send  signals to the child.  Otherwise, if a command-line argument is supplied, then the child exits
       immediately, using the integer supplied on the command line as the exit status.  The parent process executes a loop
       that monitors the child using waitpid(), and uses the W*() macros described above to analyze the wait status value.

       The following shell session demonstrates the use of the program:

           $ ./a.out &
           Child PID is 32360
           [1] 32359
           $ kill -STOP 32360
           stopped by signal 19
           $ kill -CONT 32360
           continued
           $ kill -TERM 32360
           killed by signal 15
           [1]+  Done                    ./a.out
           $

   Program source

       #include <sys/wait.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <stdio.h>

       int
       main(int argc, char *argv[])
       {
           pid_t cpid, w;
           int wstatus;

           cpid = fork();
           if (cpid == -1) {
               perror("fork");
               exit(EXIT_FAILURE);
           }

           if (cpid == 0) {            /* Code executed by child */
               printf("Child PID is %ld\n", (long) getpid());
               if (argc == 1)
                   pause();                    /* Wait for signals */
               _exit(atoi(argv[1]));

           } else {                    /* Code executed by parent */
               do {
                   w = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);
                   if (w == -1) {
                       perror("waitpid");
                       exit(EXIT_FAILURE);
                   }

                   if (WIFEXITED(wstatus)) {
                       printf("exited, status=%d\n", WEXITSTATUS(wstatus));
                   } else if (WIFSIGNALED(wstatus)) {
                       printf("killed by signal %d\n", WTERMSIG(wstatus));
                   } else if (WIFSTOPPED(wstatus)) {
                       printf("stopped by signal %d\n", WSTOPSIG(wstatus));
                   } else if (WIFCONTINUED(wstatus)) {
                       printf("continued\n");
                   }
               } while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));
               exit(EXIT_SUCCESS);
           }
       }

SEE ALSO
       _exit(2),  clone(2),  fork(2),  kill(2),  ptrace(2),  sigaction(2), signal(2), wait4(2), pthread_create(3), creden‐
       tials(7), signal(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                                 WAIT(2)
</pre>
<pre zoom>
<span xsmall>2 fdatasync</span>
FSYNC(2)                                         Linux Programmer's Manual                                        FSYNC(2)

NAME
       fsync, fdatasync - synchronize a file's in-core state with storage device

SYNOPSIS
       #include <unistd.h>

       int fsync(int fd);

       int fdatasync(int fd);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       fsync():
           Glibc 2.16 and later:
               No feature test macros need be defined
           Glibc up to and including 2.15:
               _BSD_SOURCE || _XOPEN_SOURCE
                   || /* since glibc 2.8: */ _POSIX_C_SOURCE >= 200112L
       fdatasync():
           _POSIX_C_SOURCE >= 199309L || _XOPEN_SOURCE >= 500

DESCRIPTION
       fsync()  transfers  ("flushes")  all  modified  in-core  data  of  (i.e., modified buffer cache pages for) the file
       referred to by the file descriptor fd to the disk device (or other permanent storage device) so  that  all  changed
       information  can be retrieved even if the system crashes or is rebooted.  This includes writing through or flushing
       a disk cache if present.  The call blocks until the device reports that the transfer has completed.

       As well as flushing the file data, fsync() also flushes the metadata information  associated  with  the  file  (see
       inode(7)).

       Calling  fsync()  does  not necessarily ensure that the entry in the directory containing the file has also reached
       disk.  For that an explicit fsync() on a file descriptor for the directory is also needed.

       fdatasync() is similar to fsync(), but does not flush modified metadata unless that metadata is needed in order  to
       allow  a  subsequent data retrieval to be correctly handled.  For example, changes to st_atime or st_mtime (respec‐
       tively, time of last access and time of last modification; see inode(7)) do not require flushing because  they  are
       not  necessary  for  a  subsequent data read to be handled correctly.  On the other hand, a change to the file size
       (st_size, as made by say ftruncate(2)), would require a metadata flush.

       The aim of fdatasync() is to reduce disk activity for applications that do not require all metadata to be  synchro‐
       nized with the disk.

RETURN VALUE
       On success, these system calls return zero.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EBADF  fd is not a valid open file descriptor.

       EIO    An error occurred during synchronization.  This error may relate to data written to some other file descrip‐
              tor on the same file.  Since Linux 4.13, errors from write-back will be reported  to  all  file  descriptors
              that  might  have written the data which triggered the error.  Some filesystems (e.g., NFS) keep close track
              of which data came through which file descriptor, and give more precise reporting.  Other filesystems (e.g.,
              most  local  filesystems)  will  report  errors to all file descriptors that where open on the file when the
              error was recorded.

       ENOSPC Disk space was exhausted while synchronizing.

       EROFS, EINVAL
              fd is bound to a special file (e.g., a pipe, FIFO, or socket) which does not support synchronization.

       ENOSPC, EDQUOT
              fd is bound to a file on NFS or another filesystem which does not allocate space at the time of  a  write(2)
              system call, and some previous write failed due to insufficient storage space.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD.

AVAILABILITY
       On  POSIX  systems  on  which  fdatasync() is available, _POSIX_SYNCHRONIZED_IO is defined in <unistd.h> to a value
       greater than 0.  (See also sysconf(3).)

NOTES
       On some UNIX systems (but not Linux), fd must be a writable file descriptor.

       In Linux 2.2 and earlier, fdatasync() is equivalent to fsync(), and so has no performance advantage.

       The fsync() implementations in older kernels and lesser used filesystems does not know how to  flush  disk  caches.
       In these cases disk caches need to be disabled using hdparm(8) or sdparm(8) to guarantee safe operation.

SEE ALSO
       sync(1),  bdflush(2),  open(2),  posix_fadvise(2),  pwritev(2),  sync(2), sync_file_range(2), fflush(3), fileno(3),
       hdparm(8), mount(8)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                FSYNC(2)
</pre>
<pre zoom>
<span xsmall>2 llistxattr</span>
LISTXATTR(2)                                     Linux Programmer's Manual                                    LISTXATTR(2)

NAME
       listxattr, llistxattr, flistxattr - list extended attribute names

SYNOPSIS
       #include <sys/types.h>
       #include <sys/xattr.h>

       ssize_t listxattr(const char *path, char *list, size_t size);
       ssize_t llistxattr(const char *path, char *list, size_t size);
       ssize_t flistxattr(int fd, char *list, size_t size);

DESCRIPTION
       Extended  attributes  are name:value pairs associated with inodes (files, directories, symbolic links, etc.).  They
       are extensions to the normal attributes which are associated with all inodes  in  the  system  (i.e.,  the  stat(2)
       data).  A complete overview of extended attributes concepts can be found in xattr(7).

       listxattr()  retrieves  the list of extended attribute names associated with the given path in the filesystem.  The
       retrieved list is placed in list, a caller-allocated buffer whose size (in bytes)  is  specified  in  the  argument
       size.   The list is the set of (null-terminated) names, one after the other.  Names of extended attributes to which
       the calling process does not have access may be omitted from the list.  The length of the attribute  name  list  is
       returned.

       llistxattr()  is  identical  to  listxattr(),  except  in  the  case of a symbolic link, where the list of names of
       extended attributes associated with the link itself is retrieved, not the file that it refers to.

       flistxattr() is identical to listxattr(), only the open file referred to by fd (as returned by open(2)) is interro‐
       gated in place of path.

       A  single  extended attribute name is a null-terminated string.  The name includes a namespace prefix; there may be
       several, disjoint namespaces associated with an individual inode.

       If size is specified as zero, these calls return the current size of the list  of  extended  attribute  names  (and
       leave  list  unchanged).   This can be used to determine the size of the buffer that should be supplied in a subse‐
       quent call.  (But, bear in mind that there is a possibility that the set of extended attributes may change  between
       the two calls, so that it is still necessary to check the return status from the second call.)

   Example
       The list of names is returned as an unordered array of null-terminated character strings (attribute names are sepa‐
       rated by null bytes ('\0')), like this:

           user.name1\0system.name1\0user.name2\0

       Filesystems that implement POSIX ACLs using extended attributes might return a list like this:

           system.posix_acl_access\0system.posix_acl_default\0

RETURN VALUE
       On success, a nonnegative number is returned indicating the size of the extended attribute name list.  On  failure,
       -1 is returned and errno is set appropriately.

ERRORS
       E2BIG  The size of the list of extended attribute names is larger than the maximum size allowed; the list cannot be
              retrieved.  This can happen on filesystems that support an unlimited number of extended attributes per  file
              such as XFS, for example.  See BUGS.

       ENOTSUP
              Extended attributes are not supported by the filesystem, or are disabled.

       ERANGE The size of the list buffer is too small to hold the result.

       In addition, the errors documented in stat(2) can also occur.

VERSIONS
       These system calls have been available on Linux since kernel 2.4; glibc support is provided since version 2.3.

CONFORMING TO
       These system calls are Linux-specific.

BUGS
       As  noted in xattr(7), the VFS imposes a limit of 64 kB on the size of the extended attribute name list returned by
       listxattr(7).  If the total size of attribute names attached to a file exceeds this limit, it is no longer possible
       to retrieve the list of attribute names.

EXAMPLE
       The  following  program demonstrates the usage of listxattr() and getxattr(2).  For the file whose pathname is pro‐
       vided as a command-line argument, it lists all extended file attributes and their values.

       To keep the code simple, the program assumes that attribute keys and values are constant during  the  execution  of
       the  program.  A production program should expect and handle changes during execution of the program.  For example,
       the number of bytes required for attribute keys might increase between the two calls to listxattr().   An  applica‐
       tion could handle this possibility using a loop that retries the call (perhaps up to a predetermined maximum number
       of attempts) with a larger buffer each time it fails with the error ERANGE.  Calls to getxattr(2) could be  handled
       similarly.

       The following output was recorded by first creating a file, setting some extended file attributes, and then listing
       the attributes with the example program.

   Example output
           $ touch /tmp/foo
           $ setfattr -n user.fred -v chocolate /tmp/foo
           $ setfattr -n user.frieda -v bar /tmp/foo
           $ setfattr -n user.empty /tmp/foo
           $ ./listxattr /tmp/foo
           user.fred: chocolate
           user.frieda: bar
           user.empty: <no value>

   Program source (listxattr.c)
       #include <malloc.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>
       #include <sys/types.h>
       #include <sys/xattr.h>

       int
       main(int argc, char *argv[])
       {
           ssize_t buflen, keylen, vallen;
           char *buf, *key, *val;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s path\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           /*
            * Determine the length of the buffer needed.
            */
           buflen = listxattr(argv[1], NULL, 0);
           if (buflen == -1) {
               perror("listxattr");
               exit(EXIT_FAILURE);
           }
           if (buflen == 0) {
               printf("%s has no attributes.\n", argv[1]);
               exit(EXIT_SUCCESS);
           }

           /*
            * Allocate the buffer.
            */
           buf = malloc(buflen);
           if (buf == NULL) {
               perror("malloc");
               exit(EXIT_FAILURE);
           }

           /*
            * Copy the list of attribute keys to the buffer.
            */
           buflen = listxattr(argv[1], buf, buflen);
           if (buflen == -1) {
               perror("listxattr");
               exit(EXIT_FAILURE);
           }

           /*
            * Loop over the list of zero terminated strings with the
            * attribute keys. Use the remaining buffer length to determine
            * the end of the list.
            */
           key = buf;
           while (buflen > 0) {

               /*
                * Output attribute key.
                */
               printf("%s: ", key);

               /*
                * Determine length of the value.
                */
               vallen = getxattr(argv[1], key, NULL, 0);
               if (vallen == -1)
                   perror("getxattr");

               if (vallen > 0) {

                   /*
                    * Allocate value buffer.
                    * One extra byte is needed to append 0x00.
                    */
                   val = malloc(vallen + 1);
                   if (val == NULL) {
                       perror("malloc");
                       exit(EXIT_FAILURE);
                   }

                   /*
                    * Copy value to buffer.
                    */
                   vallen = getxattr(argv[1], key, val, vallen);
                   if (vallen == -1)
                       perror("getxattr");
                   else {
                       /*
                        * Output attribute value.
                        */
                       val[vallen] = 0;
                       printf("%s", val);
                   }

                   free(val);
               } else if (vallen == 0)
                   printf("<no value>");

               printf("\n");

               /*
                * Forward to next attribute key.
                */
               keylen = strlen(key) + 1;
               buflen -= keylen;
               key += keylen;
           }

           free(buf);
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       getfattr(1), setfattr(1), getxattr(2), open(2), removexattr(2), setxattr(2), stat(2), symlink(7), xattr(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            LISTXATTR(2)
</pre>
<pre zoom>
<span xsmall>2 pselect</span>
SELECT(2)                                        Linux Programmer's Manual                                       SELECT(2)

NAME
       select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O multiplexing

SYNOPSIS
       /* According to POSIX.1-2001, POSIX.1-2008 */
       #include <sys/select.h>

       /* According to earlier standards */
       #include <sys/time.h>
       #include <sys/types.h>
       #include <unistd.h>

       int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);

       void FD_CLR(int fd, fd_set *set);
       int  FD_ISSET(int fd, fd_set *set);
       void FD_SET(int fd, fd_set *set);
       void FD_ZERO(fd_set *set);

       #include <sys/select.h>

       int pselect(int nfds, fd_set *readfds, fd_set *writefds,
                   fd_set *exceptfds, const struct timespec *timeout,
                   const sigset_t *sigmask);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pselect(): _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       select()  and pselect() allow a program to monitor multiple file descriptors, waiting until one or more of the file
       descriptors become "ready" for some class of I/O operation (e.g., input possible).  A file descriptor is considered
       ready if it is possible to perform a corresponding I/O operation (e.g., read(2) without blocking, or a sufficiently
       small write(2)).

       select() can monitor only file descriptors numbers that are less than FD_SETSIZE; poll(2) does not have this  limi‐
       tation.  See BUGS.

       The operation of select() and pselect() is identical, other than these three differences:

       (i)    select()  uses  a  timeout  that is a struct timeval (with seconds and microseconds), while pselect() uses a
              struct timespec (with seconds and nanoseconds).

       (ii)   select() may update the timeout argument to indicate how much time was left.  pselect() does not change this
              argument.

       (iii)  select() has no sigmask argument, and behaves as pselect() called with NULL sigmask.

       Three  independent sets of file descriptors are watched.  The file descriptors listed in readfds will be watched to
       see if characters become available for reading (more precisely, to see if a read will not block; in  particular,  a
       file descriptor is also ready on end-of-file).  The file descriptors in writefds will be watched to see if space is
       available for write (though a large write may still block).  The file descriptors in exceptfds will be watched  for
       exceptional conditions.  (For examples of some exceptional conditions, see the discussion of POLLPRI in poll(2).)

       On  exit, each of the file descriptor sets is modified in place to indicate which file descriptors actually changed
       status.  (Thus, if using select() within a loop, the sets must be reinitialized before each call.)

       Each of the three file descriptor sets may be specified as NULL if no file descriptors are to be  watched  for  the
       corresponding class of events.

       Four  macros  are provided to manipulate the sets.  FD_ZERO() clears a set.  FD_SET() and FD_CLR() respectively add
       and remove a given file descriptor from a set.  FD_ISSET() tests to see if a file descriptor is part  of  the  set;
       this is useful after select() returns.

       nfds  should  be  set to the highest-numbered file descriptor in any of the three sets, plus 1.  The indicated file
       descriptors in each set are checked, up to this limit (but see BUGS).

       The timeout argument specifies the interval that select() should block waiting for  a  file  descriptor  to  become
       ready.  The call will block until either:

       *  a file descriptor becomes ready;

       *  the call is interrupted by a signal handler; or

       *  the timeout expires.

       Note  that  the  timeout  interval will be rounded up to the system clock granularity, and kernel scheduling delays
       mean that the blocking interval may overrun by a small amount.  If both fields of the timeval structure  are  zero,
       then  select()  returns  immediately.  (This is useful for polling.)  If timeout is NULL (no timeout), select() can
       block indefinitely.

       sigmask is a pointer to a signal mask (see sigprocmask(2)); if it is not NULL, then pselect()  first  replaces  the
       current signal mask by the one pointed to by sigmask, then does the "select" function, and then restores the origi‐
       nal signal mask.

       Other than the difference in the precision of the timeout argument, the following pselect() call:

           ready = pselect(nfds, &readfds, &writefds, &exceptfds,
                           timeout, &sigmask);

       is equivalent to atomically executing the following calls:

           sigset_t origmask;

           pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);
           ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);
           pthread_sigmask(SIG_SETMASK, &origmask, NULL);

       The reason that pselect() is needed is that if one wants to wait for either a signal or for a  file  descriptor  to
       become  ready, then an atomic test is needed to prevent race conditions.  (Suppose the signal handler sets a global
       flag and returns.  Then a test of this global flag followed by a call of select() could hang  indefinitely  if  the
       signal arrived just after the test but just before the call.  By contrast, pselect() allows one to first block sig‐
       nals, handle the signals that have come in, then call pselect() with the desired sigmask, avoiding the race.)

   The timeout
       The time structures involved are defined in <sys/time.h> and look like

           struct timeval {
               long    tv_sec;         /* seconds */
               long    tv_usec;        /* microseconds */
           };

       and

           struct timespec {
               long    tv_sec;         /* seconds */
               long    tv_nsec;        /* nanoseconds */
           };

       (However, see below on the POSIX.1 versions.)

       Some code calls select() with all three sets empty, nfds zero, and a non-NULL timeout as a fairly portable  way  to
       sleep with subsecond precision.

       On  Linux,  select() modifies timeout to reflect the amount of time not slept; most other implementations do not do
       this.  (POSIX.1 permits either behavior.)  This causes problems both when Linux code which reads timeout is  ported
       to other operating systems, and when code is ported to Linux that reuses a struct timeval for multiple select()s in
       a loop without reinitializing it.  Consider timeout to be undefined after select() returns.

RETURN VALUE
       On success, select() and pselect() return the number of file descriptors contained in the three returned descriptor
       sets  (that  is,  the  total  number of bits that are set in readfds, writefds, exceptfds) which may be zero if the
       timeout expires before anything interesting happens.  On error, -1 is returned, and errno is set  to  indicate  the
       error; the file descriptor sets are unmodified, and timeout becomes undefined.

ERRORS
       EBADF  An  invalid  file  descriptor  was  given  in  one of the sets.  (Perhaps a file descriptor that was already
              closed, or one on which an error has occurred.)  However, see BUGS.

       EINTR  A signal was caught; see signal(7).

       EINVAL nfds is negative or exceeds the RLIMIT_NOFILE resource limit (see getrlimit(2)).

       EINVAL The value contained within timeout is invalid.

       ENOMEM Unable to allocate memory for internal tables.

VERSIONS
       pselect() was added to Linux in kernel 2.6.16.  Prior to this, pselect() was emulated in glibc (but see BUGS).

CONFORMING TO
       select() conforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD (select() first appeared in 4.2BSD).  Generally  porta‐
       ble to/from non-BSD systems supporting clones of the BSD socket layer (including System V variants).  However, note
       that the System V variant typically sets the timeout variable before exit, but the BSD variant does not.

       pselect() is defined in POSIX.1g, and in POSIX.1-2001 and POSIX.1-2008.

NOTES
       An fd_set is a fixed size buffer.  Executing FD_CLR() or FD_SET() with a value of fd that is negative or  is  equal
       to  or  larger  than  FD_SETSIZE will result in undefined behavior.  Moreover, POSIX requires fd to be a valid file
       descriptor.

       On some other UNIX systems, select() can fail with the error EAGAIN if the system fails to allocate kernel-internal
       resources, rather than ENOMEM as Linux does.  POSIX specifies this error for poll(2), but not for select().  Porta‐
       ble programs may wish to check for EAGAIN and loop, just as with EINTR.

       On systems that lack pselect(), reliable (and more portable) signal trapping can be achieved  using  the  self-pipe
       trick.  In this technique, a signal handler writes a byte to a pipe whose other end is monitored by select() in the
       main program.  (To avoid possibly blocking when writing to a pipe that may be full or reading from a pipe that  may
       be empty, nonblocking I/O is used when reading from and writing to the pipe.)

       Concerning  the  types involved, the classical situation is that the two fields of a timeval structure are typed as
       long (as shown above), and the structure is defined in <sys/time.h>.  The POSIX.1 situation is

           struct timeval {
               time_t         tv_sec;     /* seconds */
               suseconds_t    tv_usec;    /* microseconds */
           };

       where the structure is defined in <sys/select.h>  and  the  data  types  time_t  and  suseconds_t  are  defined  in
       <sys/types.h>.

       Concerning prototypes, the classical situation is that one should include <time.h> for select().  The POSIX.1 situ‐
       ation is that one should include <sys/select.h> for select() and pselect().

       Under glibc 2.0, <sys/select.h> gives the wrong prototype for pselect().  Under glibc 2.1 to 2.2.1, it  gives  pse‐
       lect() when _GNU_SOURCE is defined.  Since glibc 2.2.2, the requirements are as shown in the SYNOPSIS.

   Correspondence between select() and poll() notifications
       Within  the  Linux kernel source, we find the following definitions which show the correspondence between the read‐
       able, writable, and exceptional condition notifications of select() and the event notifications provided by poll(2)
       (and epoll(7)):

           #define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP |
                               POLLERR)
                              /* Ready for reading */
           #define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)
                              /* Ready for writing */
           #define POLLEX_SET (POLLPRI)
                              /* Exceptional condition */

   Multithreaded applications
       If  a  file descriptor being monitored by select() is closed in another thread, the result is unspecified.  On some
       UNIX systems, select() unblocks and returns, with an indication that the file descriptor is ready (a subsequent I/O
       operation  will  likely  fail  with an error, unless another the file descriptor reopened between the time select()
       returned and the I/O operations was performed).  On Linux (and some other systems), closing the file descriptor  in
       another thread has no effect on select().  In summary, any application that relies on a particular behavior in this
       scenario must be considered buggy.

   C library/kernel differences
       The Linux kernel allows file descriptor sets of arbitrary size, determining the length of the sets  to  be  checked
       from the value of nfds.  However, in the glibc implementation, the fd_set type is fixed in size.  See also BUGS.

       The  pselect() interface described in this page is implemented by glibc.  The underlying Linux system call is named
       pselect6().  This system call has somewhat different behavior from the glibc wrapper function.

       The Linux pselect6() system call modifies its timeout argument.  However, the glibc  wrapper  function  hides  this
       behavior  by  using  a  local variable for the timeout argument that is passed to the system call.  Thus, the glibc
       pselect() function does not modify its timeout argument; this is the behavior required by POSIX.1-2001.

       The final argument of the pselect6() system call is not a sigset_t * pointer, but is instead  a  structure  of  the
       form:

           struct {
               const kernel_sigset_t *ss;   /* Pointer to signal set */
               size_t ss_len;               /* Size (in bytes) of object
                                               pointed to by 'ss' */
           };

       This  allows  the  system call to obtain both a pointer to the signal set and its size, while allowing for the fact
       that most architectures support a maximum of 6 arguments to a system call.  See sigprocmask(2) for a discussion  of
       the difference between the kernel and libc notion of the signal set.

BUGS
       POSIX  allows  an  implementation to define an upper limit, advertised via the constant FD_SETSIZE, on the range of
       file descriptors that can be specified in a file descriptor set.  The Linux kernel imposes no fixed limit, but  the
       glibc implementation makes fd_set a fixed-size type, with FD_SETSIZE defined as 1024, and the FD_*() macros operat‐
       ing according to that limit.  To monitor file descriptors greater than 1023, use poll(2) instead.

       According to POSIX, select() should check all specified file descriptors in the three file descriptor sets,  up  to
       the  limit  nfds-1.   However, the current implementation ignores any file descriptor in these sets that is greater
       than the maximum file descriptor number that the process currently has open.  According to  POSIX,  any  such  file
       descriptor that is specified in one of the sets should result in the error EBADF.

       Glibc 2.0 provided a version of pselect() that did not take a sigmask argument.

       Starting  with  version 2.1, glibc provided an emulation of pselect() that was implemented using sigprocmask(2) and
       select().  This implementation remained vulnerable to the very race condition that pselect() was designed  to  pre‐
       vent.  Modern versions of glibc use the (race-free) pselect() system call on kernels where it is provided.

       Under  Linux,  select() may report a socket file descriptor as "ready for reading", while nevertheless a subsequent
       read blocks.  This could for example happen when data has arrived but upon examination has wrong  checksum  and  is
       discarded.   There  may be other circumstances in which a file descriptor is spuriously reported as ready.  Thus it
       may be safer to use O_NONBLOCK on sockets that should not block.

       On Linux, select() also modifies timeout if the call is interrupted by a signal  handler  (i.e.,  the  EINTR  error
       return).   This  is not permitted by POSIX.1.  The Linux pselect() system call has the same behavior, but the glibc
       wrapper hides this behavior by internally copying the timeout to a local variable and passing that variable to  the
       system call.

EXAMPLE
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/time.h>
       #include <sys/types.h>
       #include <unistd.h>

       int
       main(void)
       {
           fd_set rfds;
           struct timeval tv;
           int retval;

           /* Watch stdin (fd 0) to see when it has input. */

           FD_ZERO(&rfds);
           FD_SET(0, &rfds);

           /* Wait up to five seconds. */

           tv.tv_sec = 5;
           tv.tv_usec = 0;

           retval = select(1, &rfds, NULL, NULL, &tv);
           /* Don't rely on the value of tv now! */

           if (retval == -1)
               perror("select()");
           else if (retval)
               printf("Data is available now.\n");
               /* FD_ISSET(0, &rfds) will be true. */
           else
               printf("No data within five seconds.\n");

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       accept(2),  connect(2), poll(2), read(2), recv(2), restart_syscall(2), send(2), sigprocmask(2), write(2), epoll(7),
       time(7)

       For a tutorial with discussion and examples, see select_tut(2).

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SELECT(2)
</pre>
<pre zoom>
<span xsmall>2 pselect6</span>
SELECT(2)                                        Linux Programmer's Manual                                       SELECT(2)

NAME
       select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O multiplexing

SYNOPSIS
       /* According to POSIX.1-2001, POSIX.1-2008 */
       #include <sys/select.h>

       /* According to earlier standards */
       #include <sys/time.h>
       #include <sys/types.h>
       #include <unistd.h>

       int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);

       void FD_CLR(int fd, fd_set *set);
       int  FD_ISSET(int fd, fd_set *set);
       void FD_SET(int fd, fd_set *set);
       void FD_ZERO(fd_set *set);

       #include <sys/select.h>

       int pselect(int nfds, fd_set *readfds, fd_set *writefds,
                   fd_set *exceptfds, const struct timespec *timeout,
                   const sigset_t *sigmask);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pselect(): _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       select()  and pselect() allow a program to monitor multiple file descriptors, waiting until one or more of the file
       descriptors become "ready" for some class of I/O operation (e.g., input possible).  A file descriptor is considered
       ready if it is possible to perform a corresponding I/O operation (e.g., read(2) without blocking, or a sufficiently
       small write(2)).

       select() can monitor only file descriptors numbers that are less than FD_SETSIZE; poll(2) does not have this  limi‐
       tation.  See BUGS.

       The operation of select() and pselect() is identical, other than these three differences:

       (i)    select()  uses  a  timeout  that is a struct timeval (with seconds and microseconds), while pselect() uses a
              struct timespec (with seconds and nanoseconds).

       (ii)   select() may update the timeout argument to indicate how much time was left.  pselect() does not change this
              argument.

       (iii)  select() has no sigmask argument, and behaves as pselect() called with NULL sigmask.

       Three  independent sets of file descriptors are watched.  The file descriptors listed in readfds will be watched to
       see if characters become available for reading (more precisely, to see if a read will not block; in  particular,  a
       file descriptor is also ready on end-of-file).  The file descriptors in writefds will be watched to see if space is
       available for write (though a large write may still block).  The file descriptors in exceptfds will be watched  for
       exceptional conditions.  (For examples of some exceptional conditions, see the discussion of POLLPRI in poll(2).)

       On  exit, each of the file descriptor sets is modified in place to indicate which file descriptors actually changed
       status.  (Thus, if using select() within a loop, the sets must be reinitialized before each call.)

       Each of the three file descriptor sets may be specified as NULL if no file descriptors are to be  watched  for  the
       corresponding class of events.

       Four  macros  are provided to manipulate the sets.  FD_ZERO() clears a set.  FD_SET() and FD_CLR() respectively add
       and remove a given file descriptor from a set.  FD_ISSET() tests to see if a file descriptor is part  of  the  set;
       this is useful after select() returns.

       nfds  should  be  set to the highest-numbered file descriptor in any of the three sets, plus 1.  The indicated file
       descriptors in each set are checked, up to this limit (but see BUGS).

       The timeout argument specifies the interval that select() should block waiting for  a  file  descriptor  to  become
       ready.  The call will block until either:

       *  a file descriptor becomes ready;

       *  the call is interrupted by a signal handler; or

       *  the timeout expires.

       Note  that  the  timeout  interval will be rounded up to the system clock granularity, and kernel scheduling delays
       mean that the blocking interval may overrun by a small amount.  If both fields of the timeval structure  are  zero,
       then  select()  returns  immediately.  (This is useful for polling.)  If timeout is NULL (no timeout), select() can
       block indefinitely.

       sigmask is a pointer to a signal mask (see sigprocmask(2)); if it is not NULL, then pselect()  first  replaces  the
       current signal mask by the one pointed to by sigmask, then does the "select" function, and then restores the origi‐
       nal signal mask.

       Other than the difference in the precision of the timeout argument, the following pselect() call:

           ready = pselect(nfds, &readfds, &writefds, &exceptfds,
                           timeout, &sigmask);

       is equivalent to atomically executing the following calls:

           sigset_t origmask;

           pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);
           ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);
           pthread_sigmask(SIG_SETMASK, &origmask, NULL);

       The reason that pselect() is needed is that if one wants to wait for either a signal or for a  file  descriptor  to
       become  ready, then an atomic test is needed to prevent race conditions.  (Suppose the signal handler sets a global
       flag and returns.  Then a test of this global flag followed by a call of select() could hang  indefinitely  if  the
       signal arrived just after the test but just before the call.  By contrast, pselect() allows one to first block sig‐
       nals, handle the signals that have come in, then call pselect() with the desired sigmask, avoiding the race.)

   The timeout
       The time structures involved are defined in <sys/time.h> and look like

           struct timeval {
               long    tv_sec;         /* seconds */
               long    tv_usec;        /* microseconds */
           };

       and

           struct timespec {
               long    tv_sec;         /* seconds */
               long    tv_nsec;        /* nanoseconds */
           };

       (However, see below on the POSIX.1 versions.)

       Some code calls select() with all three sets empty, nfds zero, and a non-NULL timeout as a fairly portable  way  to
       sleep with subsecond precision.

       On  Linux,  select() modifies timeout to reflect the amount of time not slept; most other implementations do not do
       this.  (POSIX.1 permits either behavior.)  This causes problems both when Linux code which reads timeout is  ported
       to other operating systems, and when code is ported to Linux that reuses a struct timeval for multiple select()s in
       a loop without reinitializing it.  Consider timeout to be undefined after select() returns.

RETURN VALUE
       On success, select() and pselect() return the number of file descriptors contained in the three returned descriptor
       sets  (that  is,  the  total  number of bits that are set in readfds, writefds, exceptfds) which may be zero if the
       timeout expires before anything interesting happens.  On error, -1 is returned, and errno is set  to  indicate  the
       error; the file descriptor sets are unmodified, and timeout becomes undefined.

ERRORS
       EBADF  An  invalid  file  descriptor  was  given  in  one of the sets.  (Perhaps a file descriptor that was already
              closed, or one on which an error has occurred.)  However, see BUGS.

       EINTR  A signal was caught; see signal(7).

       EINVAL nfds is negative or exceeds the RLIMIT_NOFILE resource limit (see getrlimit(2)).

       EINVAL The value contained within timeout is invalid.

       ENOMEM Unable to allocate memory for internal tables.

VERSIONS
       pselect() was added to Linux in kernel 2.6.16.  Prior to this, pselect() was emulated in glibc (but see BUGS).

CONFORMING TO
       select() conforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD (select() first appeared in 4.2BSD).  Generally  porta‐
       ble to/from non-BSD systems supporting clones of the BSD socket layer (including System V variants).  However, note
       that the System V variant typically sets the timeout variable before exit, but the BSD variant does not.

       pselect() is defined in POSIX.1g, and in POSIX.1-2001 and POSIX.1-2008.

NOTES
       An fd_set is a fixed size buffer.  Executing FD_CLR() or FD_SET() with a value of fd that is negative or  is  equal
       to  or  larger  than  FD_SETSIZE will result in undefined behavior.  Moreover, POSIX requires fd to be a valid file
       descriptor.

       On some other UNIX systems, select() can fail with the error EAGAIN if the system fails to allocate kernel-internal
       resources, rather than ENOMEM as Linux does.  POSIX specifies this error for poll(2), but not for select().  Porta‐
       ble programs may wish to check for EAGAIN and loop, just as with EINTR.

       On systems that lack pselect(), reliable (and more portable) signal trapping can be achieved  using  the  self-pipe
       trick.  In this technique, a signal handler writes a byte to a pipe whose other end is monitored by select() in the
       main program.  (To avoid possibly blocking when writing to a pipe that may be full or reading from a pipe that  may
       be empty, nonblocking I/O is used when reading from and writing to the pipe.)

       Concerning  the  types involved, the classical situation is that the two fields of a timeval structure are typed as
       long (as shown above), and the structure is defined in <sys/time.h>.  The POSIX.1 situation is

           struct timeval {
               time_t         tv_sec;     /* seconds */
               suseconds_t    tv_usec;    /* microseconds */
           };

       where the structure is defined in <sys/select.h>  and  the  data  types  time_t  and  suseconds_t  are  defined  in
       <sys/types.h>.

       Concerning prototypes, the classical situation is that one should include <time.h> for select().  The POSIX.1 situ‐
       ation is that one should include <sys/select.h> for select() and pselect().

       Under glibc 2.0, <sys/select.h> gives the wrong prototype for pselect().  Under glibc 2.1 to 2.2.1, it  gives  pse‐
       lect() when _GNU_SOURCE is defined.  Since glibc 2.2.2, the requirements are as shown in the SYNOPSIS.

   Correspondence between select() and poll() notifications
       Within  the  Linux kernel source, we find the following definitions which show the correspondence between the read‐
       able, writable, and exceptional condition notifications of select() and the event notifications provided by poll(2)
       (and epoll(7)):

           #define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP |
                               POLLERR)
                              /* Ready for reading */
           #define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)
                              /* Ready for writing */
           #define POLLEX_SET (POLLPRI)
                              /* Exceptional condition */

   Multithreaded applications
       If  a  file descriptor being monitored by select() is closed in another thread, the result is unspecified.  On some
       UNIX systems, select() unblocks and returns, with an indication that the file descriptor is ready (a subsequent I/O
       operation  will  likely  fail  with an error, unless another the file descriptor reopened between the time select()
       returned and the I/O operations was performed).  On Linux (and some other systems), closing the file descriptor  in
       another thread has no effect on select().  In summary, any application that relies on a particular behavior in this
       scenario must be considered buggy.

   C library/kernel differences
       The Linux kernel allows file descriptor sets of arbitrary size, determining the length of the sets  to  be  checked
       from the value of nfds.  However, in the glibc implementation, the fd_set type is fixed in size.  See also BUGS.

       The  pselect() interface described in this page is implemented by glibc.  The underlying Linux system call is named
       pselect6().  This system call has somewhat different behavior from the glibc wrapper function.

       The Linux pselect6() system call modifies its timeout argument.  However, the glibc  wrapper  function  hides  this
       behavior  by  using  a  local variable for the timeout argument that is passed to the system call.  Thus, the glibc
       pselect() function does not modify its timeout argument; this is the behavior required by POSIX.1-2001.

       The final argument of the pselect6() system call is not a sigset_t * pointer, but is instead  a  structure  of  the
       form:

           struct {
               const kernel_sigset_t *ss;   /* Pointer to signal set */
               size_t ss_len;               /* Size (in bytes) of object
                                               pointed to by 'ss' */
           };

       This  allows  the  system call to obtain both a pointer to the signal set and its size, while allowing for the fact
       that most architectures support a maximum of 6 arguments to a system call.  See sigprocmask(2) for a discussion  of
       the difference between the kernel and libc notion of the signal set.

BUGS
       POSIX  allows  an  implementation to define an upper limit, advertised via the constant FD_SETSIZE, on the range of
       file descriptors that can be specified in a file descriptor set.  The Linux kernel imposes no fixed limit, but  the
       glibc implementation makes fd_set a fixed-size type, with FD_SETSIZE defined as 1024, and the FD_*() macros operat‐
       ing according to that limit.  To monitor file descriptors greater than 1023, use poll(2) instead.

       According to POSIX, select() should check all specified file descriptors in the three file descriptor sets,  up  to
       the  limit  nfds-1.   However, the current implementation ignores any file descriptor in these sets that is greater
       than the maximum file descriptor number that the process currently has open.  According to  POSIX,  any  such  file
       descriptor that is specified in one of the sets should result in the error EBADF.

       Glibc 2.0 provided a version of pselect() that did not take a sigmask argument.

       Starting  with  version 2.1, glibc provided an emulation of pselect() that was implemented using sigprocmask(2) and
       select().  This implementation remained vulnerable to the very race condition that pselect() was designed  to  pre‐
       vent.  Modern versions of glibc use the (race-free) pselect() system call on kernels where it is provided.

       Under  Linux,  select() may report a socket file descriptor as "ready for reading", while nevertheless a subsequent
       read blocks.  This could for example happen when data has arrived but upon examination has wrong  checksum  and  is
       discarded.   There  may be other circumstances in which a file descriptor is spuriously reported as ready.  Thus it
       may be safer to use O_NONBLOCK on sockets that should not block.

       On Linux, select() also modifies timeout if the call is interrupted by a signal  handler  (i.e.,  the  EINTR  error
       return).   This  is not permitted by POSIX.1.  The Linux pselect() system call has the same behavior, but the glibc
       wrapper hides this behavior by internally copying the timeout to a local variable and passing that variable to  the
       system call.

EXAMPLE
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/time.h>
       #include <sys/types.h>
       #include <unistd.h>

       int
       main(void)
       {
           fd_set rfds;
           struct timeval tv;
           int retval;

           /* Watch stdin (fd 0) to see when it has input. */

           FD_ZERO(&rfds);
           FD_SET(0, &rfds);

           /* Wait up to five seconds. */

           tv.tv_sec = 5;
           tv.tv_usec = 0;

           retval = select(1, &rfds, NULL, NULL, &tv);
           /* Don't rely on the value of tv now! */

           if (retval == -1)
               perror("select()");
           else if (retval)
               printf("Data is available now.\n");
               /* FD_ISSET(0, &rfds) will be true. */
           else
               printf("No data within five seconds.\n");

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       accept(2),  connect(2), poll(2), read(2), recv(2), restart_syscall(2), send(2), sigprocmask(2), write(2), epoll(7),
       time(7)

       For a tutorial with discussion and examples, see select_tut(2).

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SELECT(2)
</pre>
<pre zoom>
<span xsmall>2 afs_syscall</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 fchmodat</span>
CHMOD(2)                                         Linux Programmer's Manual                                        CHMOD(2)

NAME
       chmod, fchmod, fchmodat - change permissions of a file

SYNOPSIS
       #include <sys/stat.h>

       int chmod(const char *pathname, mode_t mode);
       int fchmod(int fd, mode_t mode);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       fchmod():
           Since glibc 2.24:
               _POSIX_C_SOURCE >= 199309L
           Glibc 2.19 to 2.23
               _POSIX_C_SOURCE
           Glibc 2.16 to 2.19:
               _BSD_SOURCE || _POSIX_C_SOURCE
           Glibc 2.12 to 2.16:
               _BSD_SOURCE || _XOPEN_SOURCE >= 500 ||
                   _POSIX_C_SOURCE >= 200809L
           Glibc 2.11 and earlier:
               _BSD_SOURCE || _XOPEN_SOURCE >= 500

       fchmodat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       The  chmod()  and  fchmod()  system calls change a files mode bits.  (The file mode consists of the file permission
       bits plus the set-user-ID, set-group-ID, and sticky bits.)  These system calls differ only in how the file is spec‐
       ified:

       * chmod()  changes  the mode of the file specified whose pathname is given in pathname, which is dereferenced if it
         is a symbolic link.

       * fchmod() changes the mode of the file referred to by the open file descriptor fd.

       The new file mode is specified in mode, which is a bit mask created by ORing together zero or more of  the  follow‐
       ing:

       S_ISUID  (04000)  set-user-ID (set process effective user ID on execve(2))

       S_ISGID  (02000)  set-group-ID  (set  process  effective  group ID on execve(2); mandatory locking, as described in
                         fcntl(2); take a new file's group from parent directory, as described in chown(2) and mkdir(2))

       S_ISVTX  (01000)  sticky bit (restricted deletion flag, as described in unlink(2))

       S_IRUSR  (00400)  read by owner

       S_IWUSR  (00200)  write by owner

       S_IXUSR  (00100)  execute/search by owner ("search" applies for directories, and  means  that  entries  within  the
                         directory can be accessed)

       S_IRGRP  (00040)  read by group

       S_IWGRP  (00020)  write by group

       S_IXGRP  (00010)  execute/search by group

       S_IROTH  (00004)  read by others

       S_IWOTH  (00002)  write by others

       S_IXOTH  (00001)  execute/search by others

       The  effective  UID  of  the  calling  process  must match the owner of the file, or the process must be privileged
       (Linux: it must have the CAP_FOWNER capability).

       If the calling process is not privileged (Linux: does not have the CAP_FSETID capability), and  the  group  of  the
       file  does  not  match the effective group ID of the process or one of its supplementary group IDs, the S_ISGID bit
       will be turned off, but this will not cause an error to be returned.

       As a security measure, depending on the filesystem, the set-user-ID and set-group-ID execution bits may  be  turned
       off  if a file is written.  (On Linux, this occurs if the writing process does not have the CAP_FSETID capability.)
       On some filesystems, only the superuser can set the sticky bit, which may have a special meaning.  For  the  sticky
       bit, and for set-user-ID and set-group-ID bits on directories, see inode(7).

       On  NFS  filesystems, restricting the permissions will immediately influence already open files, because the access
       control is done on the server, but open files are maintained by  the  client.   Widening  the  permissions  may  be
       delayed for other clients if attribute caching is enabled on them.

   fchmodat()
       The fchmodat() system call operates in exactly the same way as chmod(), except for the differences described here.

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       chmod() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like chmod()).

       If pathname is absolute, then dirfd is ignored.

       flags can either be 0, or include the following flag:

       AT_SYMLINK_NOFOLLOW
              If pathname is a symbolic link, do not dereference it: instead operate on the link itself.  This flag is not
              currently implemented.

       See openat(2) for an explanation of the need for fchmodat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       Depending on the filesystem, errors other than those listed below can be returned.

       The more general errors for chmod() are listed below:

       EACCES Search permission is denied on a component of the path prefix.  (See also path_resolution(7).)

       EFAULT pathname points outside your accessible address space.

       EIO    An I/O error occurred.

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ENAMETOOLONG
              pathname is too long.

       ENOENT The file does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of the path prefix is not a directory.

       EPERM  The  effective  UID  does not match the owner of the file, and the process is not privileged (Linux: it does
              not have the CAP_FOWNER capability).

       EPERM  The file is marked immutable or append-only.  (See ioctl_iflags(2).)

       EROFS  The named file resides on a read-only filesystem.

       The general errors for fchmod() are listed below:

       EBADF  The file descriptor fd is not valid.

       EIO    See above.

       EPERM  See above.

       EROFS  See above.

       The same errors that occur for chmod() can also occur for fchmodat().  The following additional  errors  can  occur
       for fchmodat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

       ENOTSUP
              flags specified AT_SYMLINK_NOFOLLOW, which is not supported.

VERSIONS
       fchmodat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       chmod(), fchmod(): 4.4BSD, SVr4, POSIX.1-2001i, POSIX.1-2008.

       fchmodat(): POSIX.1-2008.

NOTES
   C library/kernel differences
       The  GNU  C  library  fchmodat()  wrapper function implements the POSIX-specified interface described in this page.
       This interface differs from the underlying Linux system call, which does not have a flags argument.

   Glibc notes
       On older kernels where fchmodat() is unavailable, the glibc wrapper function falls back  to  the  use  of  chmod().
       When  pathname is a relative pathname, glibc constructs a pathname based on the symbolic link in /proc/self/fd that
       corresponds to the dirfd argument.

SEE ALSO
       chmod(1), chown(2), execve(2), open(2), stat(2), inode(7), path_resolution(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                CHMOD(2)
</pre>
<pre zoom>
<span xsmall>2 symlink</span>
SYMLINK(2)                                       Linux Programmer's Manual                                      SYMLINK(2)

NAME
       symlink, symlinkat - make a new name for a file

SYNOPSIS
       #include <unistd.h>

       int symlink(const char *target, const char *linkpath);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <unistd.h>

       int symlinkat(const char *target, int newdirfd, const char *linkpath);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       symlink():
           _XOPEN_SOURCE >= 500 || _POSIX_C_SOURCE >= 200112L
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

       symlinkat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       symlink() creates a symbolic link named linkpath which contains the string target.

       Symbolic  links are interpreted at run time as if the contents of the link had been substituted into the path being
       followed to find a file or directory.

       Symbolic links may contain ..  path components, which (if used at the start of the link) refer to the parent direc‐
       tories of that in which the link resides.

       A  symbolic link (also known as a soft link) may point to an existing file or to a nonexistent one; the latter case
       is known as a dangling link.

       The permissions of a symbolic link are irrelevant; the ownership is ignored when following the link, but is checked
       when removal or renaming of the link is requested and the link is in a directory with the sticky bit (S_ISVTX) set.

       If linkpath exists, it will not be overwritten.

   symlinkat()
       The  symlinkat()  system  call  operates in exactly the same way as symlink(), except for the differences described
       here.

       If the pathname given in linkpath is relative, then it is interpreted relative to the directory referred to by  the
       file  descriptor newdirfd (rather than relative to the current working directory of the calling process, as is done
       by symlink() for a relative pathname).

       If linkpath is relative and newdirfd is the special value AT_FDCWD, then linkpath is interpreted  relative  to  the
       current working directory of the calling process (like symlink()).

       If linkpath is absolute, then newdirfd is ignored.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Write access to the directory containing linkpath is denied, or one of the directories in the path prefix of
              linkpath did not allow search permission.  (See also path_resolution(7).)

       EDQUOT The user's quota of resources on the filesystem has been exhausted.  The resources could be inodes  or  disk
              blocks, depending on the filesystem implementation.

       EEXIST linkpath already exists.

       EFAULT target or linkpath points outside your accessible address space.

       EIO    An I/O error occurred.

       ELOOP  Too many symbolic links were encountered in resolving linkpath.

       ENAMETOOLONG
              target or linkpath was too long.

       ENOENT A directory component in linkpath does not exist or is a dangling symbolic link, or target or linkpath is an
              empty string.

       ENOMEM Insufficient kernel memory was available.

       ENOSPC The device containing the file has no room for the new directory entry.

       ENOTDIR
              A component used as a directory in linkpath is not, in fact, a directory.

       EPERM  The filesystem containing linkpath does not support the creation of symbolic links.

       EROFS  linkpath is on a read-only filesystem.

       The following additional errors can occur for symlinkat():

       EBADF  newdirfd is not a valid file descriptor.

       ENOENT linkpath is a relative pathname and newdirfd refers to a directory that has been deleted.

       ENOTDIR
              linkpath is relative and newdirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       symlinkat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       symlink(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       symlinkat(): POSIX.1-2008.

NOTES
       No checking of target is done.

       Deleting the name referred to by a symbolic link will actually delete the file  (unless  it  also  has  other  hard
       links).  If this behavior is not desired, use link(2).

   Glibc notes
       On  older  kernels where symlinkat() is unavailable, the glibc wrapper function falls back to the use of symlink().
       When linkpath is a relative pathname, glibc constructs a pathname based on the symbolic link in /proc/self/fd  that
       corresponds to the newdirfd argument.

SEE ALSO
       ln(1), namei(1), lchown(2), link(2), lstat(2), open(2), readlink(2), rename(2), unlink(2), path_resolution(7), sym‐
       link(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              SYMLINK(2)
</pre>
<pre zoom>
<span xsmall>2 getsockname</span>
GETSOCKNAME(2)                                   Linux Programmer's Manual                                  GETSOCKNAME(2)

NAME
       getsockname - get socket name

SYNOPSIS
       #include <sys/socket.h>

       int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

DESCRIPTION
       getsockname()  returns  the  current address to which the socket sockfd is bound, in the buffer pointed to by addr.
       The addrlen argument should be initialized to indicate the amount of space (in  bytes)  pointed  to  by  addr.   On
       return it contains the actual size of the socket address.

       The  returned  address  is truncated if the buffer provided is too small; in this case, addrlen will return a value
       greater than was supplied to the call.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EBADF  The argument sockfd is not a valid file descriptor.

       EFAULT The addr argument points to memory not in a valid part of the process address space.

       EINVAL addrlen is invalid (e.g., is negative).

       ENOBUFS
              Insufficient resources were available in the system to perform the operation.

       ENOTSOCK
              The file descriptor sockfd does not refer to a socket.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (getsockname() first appeared in 4.2BSD).

NOTES
       For background on the socklen_t type, see accept(2).

SEE ALSO
       bind(2), socket(2), getifaddrs(3), ip(7), socket(7), unix(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                          GETSOCKNAME(2)
</pre>
<pre zoom>
<span xsmall>2 msync</span>
MSYNC(2)                                         Linux Programmer's Manual                                        MSYNC(2)

NAME
       msync - synchronize a file with a memory map

SYNOPSIS
       #include <sys/mman.h>

       int msync(void *addr, size_t length, int flags);

DESCRIPTION
       msync()  flushes  changes  made to the in-core copy of a file that was mapped into memory using mmap(2) back to the
       filesystem.  Without use of this call, there is no guarantee that changes are  written  back  before  munmap(2)  is
       called.   To  be more precise, the part of the file that corresponds to the memory area starting at addr and having
       length length is updated.

       The flags argument should specify exactly one of MS_ASYNC and MS_SYNC, and may additionally include the  MS_INVALI‐
       DATE bit.  These bits have the following meanings:

       MS_ASYNC
              Specifies that an update be scheduled, but the call returns immediately.

       MS_SYNC
              Requests an update and waits for it to complete.

       MS_INVALIDATE
              Asks  to  invalidate other mappings of the same file (so that they can be updated with the fresh values just
              written).

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EBUSY  MS_INVALIDATE was specified in flags, and a memory lock exists for the specified address range.

       EINVAL addr is not a multiple of PAGESIZE; or any bit other than MS_ASYNC |  MS_INVALIDATE  |  MS_SYNC  is  set  in
              flags; or both MS_SYNC and MS_ASYNC are set in flags.

       ENOMEM The indicated memory (or part of it) was not mapped.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

       This  call  was  introduced  in  Linux  1.3.21,  and then used EFAULT instead of ENOMEM.  In Linux 2.4.19, this was
       changed to the POSIX value ENOMEM.

AVAILABILITY
       On POSIX systems on which msync() is available, both _POSIX_MAPPED_FILES and _POSIX_SYNCHRONIZED_IO are defined  in
       <unistd.h> to a value greater than 0.  (See also sysconf(3).)

NOTES
       According  to  POSIX,  either  MS_SYNC or MS_ASYNC must be specified in flags, and indeed failure to include one of
       these flags will cause msync() to fail on some systems.  However, Linux permits a call to  msync()  that  specifies
       neither  of  these  flags,  with  semantics  that  are (currently) equivalent to specifying MS_ASYNC.  (Since Linux
       2.6.19, MS_ASYNC is in fact a no-op, since the kernel properly tracks dirty pages and flushes them  to  storage  as
       necessary.)   Notwithstanding the Linux behavior, portable, future-proof applications should ensure that they spec‐
       ify either MS_SYNC or MS_ASYNC in flags.

SEE ALSO
       mmap(2)

       B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128–129 and 389–391.

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                MSYNC(2)
</pre>
<pre zoom>
<span xsmall>2 rename</span>
RENAME(2)                                        Linux Programmer's Manual                                       RENAME(2)

NAME
       rename, renameat, renameat2 - change the name or location of a file

SYNOPSIS
       #include <stdio.h>

       int rename(const char *oldpath, const char *newpath);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <stdio.h>

       int renameat(int olddirfd, const char *oldpath,
                    int newdirfd, const char *newpath);

       int renameat2(int olddirfd, const char *oldpath,
                     int newdirfd, const char *newpath, unsigned int flags);

       Note: There is no glibc wrapper for renameat2(); see NOTES.

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       renameat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       rename()  renames  a file, moving it between directories if required.  Any other hard links to the file (as created
       using link(2)) are unaffected.  Open file descriptors for oldpath are also unaffected.

       Various restrictions determine whether or not the rename operation succeeds: see ERRORS below.

       If newpath already exists, it will be atomically replaced, so that there is  no  point  at  which  another  process
       attempting  to access newpath will find it missing.  However, there will probably be a window in which both oldpath
       and newpath refer to the file being renamed.

       If oldpath and newpath are existing hard links referring to the same file, then rename() does nothing, and  returns
       a success status.

       If  newpath  exists but the operation fails for some reason, rename() guarantees to leave an instance of newpath in
       place.

       oldpath can specify a directory.  In this case, newpath must either not exist, or it must specify an  empty  direc‐
       tory.

       If  oldpath  refers to a symbolic link, the link is renamed; if newpath refers to a symbolic link, the link will be
       overwritten.

   renameat()
       The renameat() system call operates in exactly the same way as rename(), except for the differences described here.

       If the pathname given in oldpath is relative, then it is interpreted relative to the directory referred to  by  the
       file  descriptor olddirfd (rather than relative to the current working directory of the calling process, as is done
       by rename() for a relative pathname).

       If oldpath is relative and olddirfd is the special value AT_FDCWD, then oldpath is interpreted relative to the cur‐
       rent working directory of the calling process (like rename()).

       If oldpath is absolute, then olddirfd is ignored.

       The  interpretation  of  newpath  is as for oldpath, except that a relative pathname is interpreted relative to the
       directory referred to by the file descriptor newdirfd.

       See openat(2) for an explanation of the need for renameat().

   renameat2()
       renameat2() has an additional flags argument.  A renameat2() call with a  zero  flags  argument  is  equivalent  to
       renameat().

       The flags argument is a bit mask consisting of zero or more of the following flags:

       RENAME_EXCHANGE
              Atomically exchange oldpath and newpath.  Both pathnames must exist but may be of different types (e.g., one
              could be a non-empty directory and the other a symbolic link).

       RENAME_NOREPLACE
              Don't overwrite newpath of the rename.  Return an error if newpath already exists.

              RENAME_NOREPLACE can't be employed together with RENAME_EXCHANGE.

       RENAME_WHITEOUT (since Linux 3.18)
              This operation makes sense only for overlay/union filesystem implementations.

              Specifying RENAME_WHITEOUT creates a "whiteout" object at the source of the rename at the same time as  per‐
              forming  the  rename.   The whole operation is atomic, so that if the rename succeeds then the whiteout will
              also have been created.

              A "whiteout" is an object that has special meaning in union/overlay filesystem constructs.   In  these  con‐
              structs,  multiple  layers  exist  and only the top one is ever modified.  A whiteout on an upper layer will
              effectively hide a matching file in the lower layer, making it appear as if the file didn't exist.

              When a file that exists on the lower layer is renamed, the file is first copied up (if not  already  on  the
              upper layer) and then renamed on the upper, read-write layer.  At the same time, the source file needs to be
              "whiteouted" (so that the version of the source file in the lower layer is rendered invisible).   The  whole
              operation needs to be done atomically.

              When not part of a union/overlay, the whiteout appears as a character device with a {0,0} device number.

              RENAME_WHITEOUT requires the same privileges as creating a device node (i.e., the CAP_MKNOD capability).

              RENAME_WHITEOUT can't be employed together with RENAME_EXCHANGE.

              RENAME_WHITEOUT  requires  support  from the underlying filesystem.  Among the filesystems that provide that
              support are shmem (since Linux 3.18), ext4 (since Linux 3.18), and XFS (since Linux 4.1).

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Write permission is denied for the directory containing oldpath or newpath, or, search permission is  denied
              for  one of the directories in the path prefix of oldpath or newpath, or oldpath is a directory and does not
              allow write permission (needed to update the ..  entry).  (See also path_resolution(7).)

       EBUSY  The rename fails because oldpath or newpath is a directory that is in use by some process (perhaps  as  cur‐
              rent working directory, or as root directory, or because it was open for reading) or is in use by the system
              (for example as mount point), while the system considers this an error.  (Note that there is no  requirement
              to  return  EBUSY  in  such  cases—there  is nothing wrong with doing the rename anyway—but it is allowed to
              return EBUSY if the system cannot otherwise handle such situations.)

       EDQUOT The user's quota of disk blocks on the filesystem has been exhausted.

       EFAULT oldpath or newpath points outside your accessible address space.

       EINVAL The new pathname contained a path prefix of the old, or, more generally, an  attempt  was  made  to  make  a
              directory a subdirectory of itself.

       EISDIR newpath is an existing directory, but oldpath is not a directory.

       ELOOP  Too many symbolic links were encountered in resolving oldpath or newpath.

       EMLINK oldpath  already  has  the maximum number of links to it, or it was a directory and the directory containing
              newpath has the maximum number of links.

       ENAMETOOLONG
              oldpath or newpath was too long.

       ENOENT The link named by oldpath does not exist; or, a directory component in newpath does not exist;  or,  oldpath
              or newpath is an empty string.

       ENOMEM Insufficient kernel memory was available.

       ENOSPC The device containing the file has no room for the new directory entry.

       ENOTDIR
              A component used as a directory in oldpath or newpath is not, in fact, a directory.  Or, oldpath is a direc‐
              tory, and newpath exists but is not a directory.

       ENOTEMPTY or EEXIST
              newpath is a nonempty directory, that is, contains entries other than "." and "..".

       EPERM or EACCES
              The directory containing oldpath has the sticky bit (S_ISVTX) set and the process's  effective  user  ID  is
              neither  the  user  ID of the file to be deleted nor that of the directory containing it, and the process is
              not privileged (Linux: does not have the CAP_FOWNER capability); or newpath is  an  existing  file  and  the
              directory containing it has the sticky bit set and the process's effective user ID is neither the user ID of
              the file to be replaced nor that of the directory containing it, and the process is not  privileged  (Linux:
              does not have the CAP_FOWNER capability); or the filesystem containing pathname does not support renaming of
              the type requested.

       EROFS  The file is on a read-only filesystem.

       EXDEV  oldpath and newpath are not on the same mounted filesystem.  (Linux permits a filesystem to  be  mounted  at
              multiple  points,  but  rename() does not work across different mount points, even if the same filesystem is
              mounted on both.)

       The following additional errors can occur for renameat() and renameat2():

       EBADF  olddirfd or newdirfd is not a valid file descriptor.

       ENOTDIR
              oldpath is relative and olddirfd is a file descriptor referring to a file other than a directory; or similar
              for newpath and newdirfd

       The following additional errors can occur for renameat2():

       EEXIST flags contains RENAME_NOREPLACE and newpath already exists.

       EINVAL An invalid flag was specified in flags.

       EINVAL Both RENAME_NOREPLACE and RENAME_EXCHANGE were specified in flags.

       EINVAL Both RENAME_WHITEOUT and RENAME_EXCHANGE were specified in flags.

       EINVAL The filesystem does not support one of the flags in flags.

       ENOENT flags contains RENAME_EXCHANGE and newpath does not exist.

       EPERM  RENAME_WHITEOUT was specified in flags, but the caller does not have the CAP_MKNOD capability.

VERSIONS
       renameat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

       renameat2() was added to Linux in kernel 3.15.

CONFORMING TO
       rename(): 4.3BSD, C89, C99, POSIX.1-2001, POSIX.1-2008.

       renameat(): POSIX.1-2008.

       renameat2() is Linux-specific.

NOTES
       Glibc does not provide a wrapper for the renameat2() system call; call it using syscall(2).

   Glibc notes
       On  older  kernels  where  renameat() is unavailable, the glibc wrapper function falls back to the use of rename().
       When oldpath and newpath are relative pathnames,  glibc  constructs  pathnames  based  on  the  symbolic  links  in
       /proc/self/fd that correspond to the olddirfd and newdirfd arguments.

BUGS
       On  NFS filesystems, you can not assume that if the operation failed, the file was not renamed.  If the server does
       the rename operation and then crashes, the retransmitted RPC which will be processed when the server  is  up  again
       causes a failure.  The application is expected to deal with this.  See link(2) for a similar problem.

SEE ALSO
       mv(1), chmod(2), link(2), symlink(2), unlink(2), path_resolution(7), symlink(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               RENAME(2)
</pre>
<pre zoom>
<span xsmall>2 lock</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 recv</span>
RECV(2)                                          Linux Programmer's Manual                                         RECV(2)

NAME
       recv, recvfrom, recvmsg - receive a message from a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       ssize_t recv(int sockfd, void *buf, size_t len, int flags);

       ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);

       ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);

DESCRIPTION
       The  recv(),  recvfrom(),  and  recvmsg()  calls  are  used to receive messages from a socket.  They may be used to
       receive data on both connectionless and connection-oriented sockets.  This page first describes common features  of
       all three system calls, and then describes the differences between the calls.

       The  only  difference  between  recv() and read(2) is the presence of flags.  With a zero flags argument, recv() is
       generally equivalent to read(2) (but see NOTES).  Also, the following call

           recv(sockfd, buf, len, flags);

       is equivalent to

           recvfrom(sockfd, buf, len, flags, NULL, NULL);

       All three calls return the length of the message on successful completion.  If a message is too long to fit in  the
       supplied buffer, excess bytes may be discarded depending on the type of socket the message is received from.

       If  no  messages  are available at the socket, the receive calls wait for a message to arrive, unless the socket is
       nonblocking (see fcntl(2)), in which case the value -1 is returned and the external variable errno is set to EAGAIN
       or  EWOULDBLOCK.   The  receive  calls  normally return any data available, up to the requested amount, rather than
       waiting for receipt of the full amount requested.

       An application can use select(2), poll(2), or epoll(7) to determine when more data arrives on a socket.

   The flags argument
       The flags argument is formed by ORing one or more of the following values:

       MSG_CMSG_CLOEXEC (recvmsg() only; since Linux 2.6.23)
              Set the close-on-exec flag for the file descriptor received via a UNIX  domain  file  descriptor  using  the
              SCM_RIGHTS operation (described in unix(7)).  This flag is useful for the same reasons as the O_CLOEXEC flag
              of open(2).

       MSG_DONTWAIT (since Linux 2.2)
              Enables nonblocking operation; if the operation would block, the call fails with the error EAGAIN or EWOULD‐
              BLOCK.   This provides similar behavior to setting the O_NONBLOCK flag (via the fcntl(2) F_SETFL operation),
              but differs in that MSG_DONTWAIT is a per-call option, whereas O_NONBLOCK is a  setting  on  the  open  file
              description  (see  open(2)),  which will affect all threads in the calling process and as well as other pro‐
              cesses that hold file descriptors referring to the same open file description.

       MSG_ERRQUEUE (since Linux 2.2)
              This flag specifies that queued errors should be received from the socket error queue.  The error is  passed
              in an ancillary message with a type dependent on the protocol (for IPv4 IP_RECVERR).  The user should supply
              a buffer of sufficient size.  See cmsg(3) and ip(7) for more  information.   The  payload  of  the  original
              packet  that  caused  the error is passed as normal data via msg_iovec.  The original destination address of
              the datagram that caused the error is supplied via msg_name.

              The error is supplied in a sock_extended_err structure:

                  #define SO_EE_ORIGIN_NONE    0
                  #define SO_EE_ORIGIN_LOCAL   1
                  #define SO_EE_ORIGIN_ICMP    2
                  #define SO_EE_ORIGIN_ICMP6   3

                  struct sock_extended_err
                  {
                      uint32_t ee_errno;   /* error number */
                      uint8_t  ee_origin;  /* where the error originated */
                      uint8_t  ee_type;    /* type */
                      uint8_t  ee_code;    /* code */
                      uint8_t  ee_pad;     /* padding */
                      uint32_t ee_info;    /* additional information */
                      uint32_t ee_data;    /* other data */
                      /* More data may follow */
                  };

                  struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);

              ee_errno contains the errno number of the queued error.  ee_origin is the origin code  of  where  the  error
              originated.   The  other  fields are protocol-specific.  The macro SOCK_EE_OFFENDER returns a pointer to the
              address of the network object where the error originated from given a pointer to the ancillary message.   If
              this  address  is not known, the sa_family member of the sockaddr contains AF_UNSPEC and the other fields of
              the sockaddr are undefined.  The payload of the packet that caused the error is passed as normal data.

              For local errors, no address is passed (this can be checked with the cmsg_len member of the  cmsghdr).   For
              error  receives,  the  MSG_ERRQUEUE  flag is set in the msghdr.  After an error has been passed, the pending
              socket error is regenerated based on the next queued error and will be passed on the next socket operation.

       MSG_OOB
              This flag requests receipt of out-of-band data that would not be received in the normal data  stream.   Some
              protocols  place expedited data at the head of the normal data queue, and thus this flag cannot be used with
              such protocols.

       MSG_PEEK
              This flag causes the receive operation to return data from the beginning of the receive queue without remov‐
              ing that data from the queue.  Thus, a subsequent receive call will return the same data.

       MSG_TRUNC (since Linux 2.2)
              For  raw  (AF_PACKET),  Internet datagram (since Linux 2.4.27/2.6.8), netlink (since Linux 2.6.22), and UNIX
              datagram (since Linux 3.4) sockets: return the real length of the packet  or  datagram,  even  when  it  was
              longer than the passed buffer.

              For use with Internet stream sockets, see tcp(7).

       MSG_WAITALL (since Linux 2.2)
              This  flag  requests  that  the  operation block until the full request is satisfied.  However, the call may
              still return less data than requested if a signal is caught, an error or disconnect occurs, or the next data
              to be received is of a different type than that returned.  This flag has no effect for datagram sockets.

   recvfrom()
       recvfrom() places the received message into the buffer buf.  The caller must specify the size of the buffer in len.

       If  src_addr  is  not  NULL,  and  the  underlying protocol provides the source address of the message, that source
       address is placed in the buffer pointed to by src_addr.  In this case, addrlen is a value-result argument.   Before
       the  call,  it  should  be initialized to the size of the buffer associated with src_addr.  Upon return, addrlen is
       updated to contain the actual size of the source address.  The returned address is truncated if the buffer provided
       is too small; in this case, addrlen will return a value greater than was supplied to the call.

       If the caller is not interested in the source address, src_addr and addrlen should be specified as NULL.

   recv()
       The recv() call is normally used only on a connected socket (see connect(2)).  It is equivalent to the call:

           recvfrom(fd, buf, len, flags, NULL, 0);

   recvmsg()
       The  recvmsg()  call uses a msghdr structure to minimize the number of directly supplied arguments.  This structure
       is defined as follows in <sys/socket.h>:

           struct iovec {                    /* Scatter/gather array items */
               void  *iov_base;              /* Starting address */
               size_t iov_len;               /* Number of bytes to transfer */
           };

           struct msghdr {
               void         *msg_name;       /* optional address */
               socklen_t     msg_namelen;    /* size of address */
               struct iovec *msg_iov;        /* scatter/gather array */
               size_t        msg_iovlen;     /* # elements in msg_iov */
               void         *msg_control;    /* ancillary data, see below */
               size_t        msg_controllen; /* ancillary data buffer len */
               int           msg_flags;      /* flags on received message */
           };

       The msg_name field points to a caller-allocated buffer that is used to return the source address if the  socket  is
       unconnected.   The  caller  should  set msg_namelen to the size of this buffer before this call; upon return from a
       successful call, msg_namelen will contain the length of the returned address.  If the application does not need  to
       know the source address, msg_name can be specified as NULL.

       The fields msg_iov and msg_iovlen describe scatter-gather locations, as discussed in readv(2).

       The  field msg_control, which has length msg_controllen, points to a buffer for other protocol control-related mes‐
       sages or miscellaneous ancillary data.  When recvmsg() is called, msg_controllen should contain the length  of  the
       available  buffer in msg_control; upon return from a successful call it will contain the length of the control mes‐
       sage sequence.

       The messages are of the form:

           struct cmsghdr {
               size_t cmsg_len;    /* Data byte count, including header
                                      (type is socklen_t in POSIX) */
               int    cmsg_level;  /* Originating protocol */
               int    cmsg_type;   /* Protocol-specific type */
           /* followed by
               unsigned char cmsg_data[]; */
           };

       Ancillary data should be accessed only by the macros defined in cmsg(3).

       As an example, Linux uses this ancillary data mechanism to pass extended errors, IP options,  or  file  descriptors
       over UNIX domain sockets.

       The msg_flags field in the msghdr is set on return of recvmsg().  It can contain several flags:

       MSG_EOR
              indicates end-of-record; the data returned completed a record (generally used with sockets of type SOCK_SEQ‐
              PACKET).

       MSG_TRUNC
              indicates that the trailing portion of a datagram was discarded because the datagram  was  larger  than  the
              buffer supplied.

       MSG_CTRUNC
              indicates that some control data were discarded due to lack of space in the buffer for ancillary data.

       MSG_OOB
              is returned to indicate that expedited or out-of-band data were received.

       MSG_ERRQUEUE
              indicates that no data was received but an extended error from the socket error queue.

RETURN VALUE
       These  calls  return  the number of bytes received, or -1 if an error occurred.  In the event of an error, errno is
       set to indicate the error.

       When a stream socket peer has performed an orderly shutdown, the return value will be 0 (the  traditional  "end-of-
       file" return).

       Datagram  sockets in various domains (e.g., the UNIX and Internet domains) permit zero-length datagrams.  When such
       a datagram is received, the return value is 0.

       The value 0 may also be returned if the requested number of bytes to receive from a stream socket was 0.

ERRORS
       These are some standard errors generated by the socket layer.  Additional errors may be generated and returned from
       the underlying protocol modules; see their manual pages.

       EAGAIN or EWOULDBLOCK
              The  socket  is  marked nonblocking and the receive operation would block, or a receive timeout had been set
              and the timeout expired before data was received.  POSIX.1 allows either error to be returned for this case,
              and does not require these constants to have the same value, so a portable application should check for both
              possibilities.

       EBADF  The argument sockfd is an invalid file descriptor.

       ECONNREFUSED
              A remote host refused to allow the network connection (typically because it is  not  running  the  requested
              service).

       EFAULT The receive buffer pointer(s) point outside the process's address space.

       EINTR  The receive was interrupted by delivery of a signal before any data were available; see signal(7).

       EINVAL Invalid argument passed.

       ENOMEM Could not allocate memory for recvmsg().

       ENOTCONN
              The  socket is associated with a connection-oriented protocol and has not been connected (see connect(2) and
              accept(2)).

       ENOTSOCK
              The file descriptor sockfd does not refer to a socket.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.4BSD (these interfaces first appeared in 4.2BSD).

       POSIX.1 describes only the MSG_OOB, MSG_PEEK, and MSG_WAITALL flags.

NOTES
       If a zero-length datagram is pending, read(2) and recv() with a flags argument of zero provide different  behavior.
       In this circumstance, read(2) has no effect (the datagram remains pending), while recv() consumes the pending data‐
       gram.

       The socklen_t type was invented by POSIX.  See also accept(2).

       According to POSIX.1, the msg_controllen field of the msghdr structure should be typed as socklen_t, but glibc cur‐
       rently types it as size_t.

       See  recvmmsg(2)  for information about a Linux-specific system call that can be used to receive multiple datagrams
       in a single call.

EXAMPLE
       An example of the use of recvfrom() is shown in getaddrinfo(3).

SEE ALSO
       fcntl(2), getsockopt(2), read(2), recvmmsg(2), select(2), shutdown(2), socket(2),  cmsg(3),  sockatmark(3),  ip(7),
       ipv6(7), socket(7), tcp(7), udp(7), unix(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 RECV(2)
</pre>
<pre zoom>
<span xsmall>2 getpid</span>
GETPID(2)                                        Linux Programmer's Manual                                       GETPID(2)

NAME
       getpid, getppid - get process identification

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       pid_t getpid(void);
       pid_t getppid(void);

DESCRIPTION
       getpid() returns the process ID (PID) of the calling process.  (This is often used by routines that generate unique
       temporary filenames.)

       getppid() returns the process ID of the parent of the calling process.  This will be either the ID of  the  process
       that  created this process using fork(), or, if that process has already terminated, the ID of the process to which
       this  process  has  been  reparented  (either  init(1)  or  a  "subreaper"  process  defined   via   the   prctl(2)
       PR_SET_CHILD_SUBREAPER operation).

ERRORS
       These functions are always successful.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD, SVr4.

NOTES
       If the caller's parent is in a different PID namespace (see pid_namespaces(7)), getppid() returns 0.

       From  a kernel perspective, the PID (which is shared by all of the threads in a multithreaded process) is sometimes
       also known as the thread group ID (TGID).  This contrasts with the kernel thread ID (TID), which is unique for each
       thread.  For further details, see gettid(2) and the discussion of the CLONE_THREAD flag in clone(2).

   C library/kernel differences
       From  glibc  version  2.3.4  up to and including version 2.24, the glibc wrapper function for getpid() cached PIDs,
       with the goal of avoiding additional system calls when a process calls getpid() repeatedly.  Normally this  caching
       was  invisible,  but  its  correct  operation relied on support in the wrapper functions for fork(2), vfork(2), and
       clone(2): if an application bypassed the glibc wrappers for these system calls by using syscall(2), then a call  to
       getpid()  in the child would return the wrong value (to be precise: it would return the PID of the parent process).
       In addition, there were cases where getpid() could return the wrong value even when invoking clone(2) via the glibc
       wrapper  function.   (For a discussion of one such case, see BUGS in clone(2).)  Furthermore, the complexity of the
       caching code had been the source of a few bugs within glibc over the years.

       Because of the aforementioned problems, since glibc version 2.25, the PID  cache  is  removed:  calls  to  getpid()
       always invoke the actual system call, rather than returning a cached value.

SEE ALSO
       clone(2),  fork(2),  gettid(2),  kill(2),  exec(3),  mkstemp(3), tempnam(3), tmpfile(3), tmpnam(3), credentials(7),
       pid_namespaces(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-11-26                                               GETPID(2)
</pre>
<pre zoom>
<span xsmall>2 setuid32</span>
SETUID(2)                                        Linux Programmer's Manual                                       SETUID(2)

NAME
       setuid - set user identity

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int setuid(uid_t uid);

DESCRIPTION
       setuid()  sets the effective user ID of the calling process.  If the calling process is privileged (more precisely:
       if the process has the CAP_SETUID capability in its user namespace), the real UID and saved  set-user-ID  are  also
       set.

       Under  Linux, setuid() is implemented like the POSIX version with the _POSIX_SAVED_IDS feature.  This allows a set-
       user-ID (other than root) program to drop all of its user privileges, do some un-privileged work, and then reengage
       the original effective user ID in a secure manner.

       If  the  user is root or the program is set-user-ID-root, special care must be taken: setuid() checks the effective
       user ID of the caller and if it is the superuser, all process-related user ID's are set to  uid.   After  this  has
       occurred, it is impossible for the program to regain root privileges.

       Thus,  a  set-user-ID-root  program wishing to temporarily drop root privileges, assume the identity of an unprivi‐
       leged user, and then regain  root  privileges  afterward  cannot  use  setuid().   You  can  accomplish  this  with
       seteuid(2).

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

       Note:  there  are cases where setuid() can fail even when the caller is UID 0; it is a grave security error to omit
       checking for a failure return from setuid().

ERRORS
       EAGAIN The call would change the caller's real UID (i.e., uid does not match the caller's real UID), but there  was
              a temporary failure allocating the necessary kernel data structures.

       EAGAIN uid  does not match the real user ID of the caller and this call would bring the number of processes belong‐
              ing to the real user ID uid over the caller's RLIMIT_NPROC resource limit.  Since Linux 3.1, this error case
              no  longer  occurs  (but  robust applications should check for this error); see the description of EAGAIN in
              execve(2).

       EINVAL The user ID specified in uid is not valid in this user namespace.

       EPERM  The user is not privileged (Linux: does not have the CAP_SETUID capability) and uid does not match the  real
              UID or saved set-user-ID of the calling process.

CONFORMING TO
       POSIX.1-2001,  POSIX.1-2008,  SVr4.   Not quite compatible with the 4.4BSD call, which sets all of the real, saved,
       and effective user IDs.

NOTES
       Linux has the concept of the filesystem user ID, normally equal to the effective user ID.  The setuid()  call  also
       sets the filesystem user ID of the calling process.  See setfsuid(2).

       If uid is different from the old effective UID, the process will be forbidden from leaving core dumps.

       The  original  Linux setuid() system call supported only 16-bit user IDs.  Subsequently, Linux 2.4 added setuid32()
       supporting 32-bit IDs.  The glibc setuid() wrapper function transparently deals with the  variation  across  kernel
       versions.

   C library/kernel differences
       At  the  kernel level, user IDs and group IDs are a per-thread attribute.  However, POSIX requires that all threads
       in a process share the same credentials.  The NPTL threading implementation handles the POSIX requirements by  pro‐
       viding  wrapper  functions for the various system calls that change process UIDs and GIDs.  These wrapper functions
       (including the one for setuid()) employ a signal-based technique to ensure that when  one  thread  changes  creden‐
       tials, all of the other threads in the process also change their credentials.  For details, see nptl(7).

SEE ALSO
       getuid(2), seteuid(2), setfsuid(2), setreuid(2), capabilities(7), credentials(7), user_namespaces(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SETUID(2)
</pre>
<pre zoom>
<span xsmall>2 mlockall</span>
MLOCK(2)                                         Linux Programmer's Manual                                        MLOCK(2)

NAME
       mlock, mlock2, munlock, mlockall, munlockall - lock and unlock memory

SYNOPSIS
       #include <sys/mman.h>

       int mlock(const void *addr, size_t len);
       int mlock2(const void *addr, size_t len, int flags);
       int munlock(const void *addr, size_t len);

       int mlockall(int flags);
       int munlockall(void);

DESCRIPTION
       mlock(),  mlock2(),  and  mlockall() lock part or all of the calling process's virtual address space into RAM, pre‐
       venting that memory from being paged to the swap area.

       munlock() and munlockall() perform the converse operation, unlocking part or all of the calling  process's  virtual
       address  space, so that pages in the specified virtual address range may once more to be swapped out if required by
       the kernel memory manager.

       Memory locking and unlocking are performed in units of whole pages.

   mlock(), mlock2(), and munlock()
       mlock() locks pages in the address range starting at addr and continuing for len bytes.  All pages that  contain  a
       part  of  the  specified address range are guaranteed to be resident in RAM when the call returns successfully; the
       pages are guaranteed to stay in RAM until later unlocked.

       mlock2() also locks pages in the specified range starting at addr and continuing for len bytes.  However, the state
       of  the  pages  contained  in  that range after the call returns successfully will depend on the value in the flags
       argument.

       The flags argument can be either 0 or the following constant:

       MLOCK_ONFAULT
              Lock pages that are currently resident and mark the entire range so that  the  remaining  nonresident  pages
              locked when they are populated by a page fault.

       If flags is 0, mlock2() behaves exactly the same as mlock().

       munlock()  unlocks  pages in the address range starting at addr and continuing for len bytes.  After this call, all
       pages that contain a part of the specified memory range can be moved to external swap space again by the kernel.

   mlockall() and munlockall()
       mlockall() locks all pages mapped into the address space of the calling process.  This includes the  pages  of  the
       code, data and stack segment, as well as shared libraries, user space kernel data, shared memory, and memory-mapped
       files.  All mapped pages are guaranteed to be resident in RAM when the call returns  successfully;  the  pages  are
       guaranteed to stay in RAM until later unlocked.

       The flags argument is constructed as the bitwise OR of one or more of the following constants:

       MCL_CURRENT Lock all pages which are currently mapped into the address space of the process.

       MCL_FUTURE  Lock  all  pages  which  will become mapped into the address space of the process in the future.  These
                   could be, for instance, new pages required by a growing heap and stack as  well  as  new  memory-mapped
                   files or shared memory regions.

       MCL_ONFAULT (since Linux 4.4)
                   Used  together  with  MCL_CURRENT,  MCL_FUTURE, or both.  Mark all current (with MCL_CURRENT) or future
                   (with MCL_FUTURE) mappings to lock pages when they are faulted in.  When  used  with  MCL_CURRENT,  all
                   present  pages  are  locked,  but  mlockall()  will  not  fault  in  non-present pages.  When used with
                   MCL_FUTURE, all future mappings will be marked to lock pages when they are faulted in,  but  they  will
                   not  be  populated  by  the  lock  when  the  mapping is created.  MCL_ONFAULT must be used with either
                   MCL_CURRENT or MCL_FUTURE or both.

       If MCL_FUTURE has been specified, then a later system call (e.g., mmap(2), sbrk(2),  malloc(3)),  may  fail  if  it
       would  cause  the  number  of locked bytes to exceed the permitted maximum (see below).  In the same circumstances,
       stack growth may likewise fail: the kernel will deny stack expansion and deliver a SIGSEGV signal to the process.

       munlockall() unlocks all pages mapped into the address space of the calling process.

RETURN VALUE
       On success, these system calls return 0.  On error, -1 is returned, errno is set appropriately, and no changes  are
       made to any locks in the address space of the process.

ERRORS
       ENOMEM (Linux  2.6.9 and later) the caller had a nonzero RLIMIT_MEMLOCK soft resource limit, but tried to lock more
              memory than the limit permitted.  This limit is not enforced if the process is privileged (CAP_IPC_LOCK).

       ENOMEM (Linux 2.4 and earlier) the calling process tried to lock more than half of RAM.

       EPERM  The caller is not privileged, but needs privilege (CAP_IPC_LOCK) to perform the requested operation.

       For mlock(), mlock2(), and munlock():

       EAGAIN Some or all of the specified address range could not be locked.

       EINVAL The result of the addition addr+len was less than addr (e.g., the addition may have  resulted  in  an  over‐
              flow).

       EINVAL (Not on Linux) addr was not a multiple of the page size.

       ENOMEM Some of the specified address range does not correspond to mapped pages in the address space of the process.

       ENOMEM Locking  or  unlocking a region would result in the total number of mappings with distinct attributes (e.g.,
              locked versus unlocked) exceeding the allowed maximum.  (For example, unlocking a range in the middle  of  a
              currently  locked  mapping  would  result in three mappings: two locked mappings at each end and an unlocked
              mapping in the middle.)

       For mlock2():

       EINVAL Unknown flags were specified.

       For mlockall():

       EINVAL Unknown flags were specified or MCL_ONFAULT was specified without either MCL_FUTURE or MCL_CURRENT.

       For munlockall():

       EPERM  (Linux 2.6.8 and earlier) The caller was not privileged (CAP_IPC_LOCK).

VERSIONS
       mlock2() is available since Linux 4.4; glibc support was added in version 2.27.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

       mlock2 () is Linux specific.

AVAILABILITY
       On POSIX systems on which mlock() and munlock() are available, _POSIX_MEMLOCK_RANGE is defined  in  <unistd.h>  and
       the number of bytes in a page can be determined from the constant PAGESIZE (if defined) in <limits.h> or by calling
       sysconf(_SC_PAGESIZE).

       On POSIX systems on which mlockall() and munlockall() are available, _POSIX_MEMLOCK is defined in <unistd.h>  to  a
       value greater than 0.  (See also sysconf(3).)

NOTES
       Memory locking has two main applications: real-time algorithms and high-security data processing.  Real-time appli‐
       cations require deterministic timing, and, like scheduling, paging is one major cause of unexpected program  execu‐
       tion  delays.  Real-time applications will usually also switch to a real-time scheduler with sched_setscheduler(2).
       Cryptographic security software often handles critical bytes like passwords or secret keys as data structures.   As
       a  result  of  paging,  these secrets could be transferred onto a persistent swap store medium, where they might be
       accessible to the enemy long after the security software has erased the secrets in RAM  and  terminated.   (But  be
       aware  that  the  suspend  mode on laptops and some desktop computers will save a copy of the system's RAM to disk,
       regardless of memory locks.)

       Real-time processes that are using mlockall() to prevent delays on page faults should reserve enough  locked  stack
       pages  before  entering the time-critical section, so that no page fault can be caused by function calls.  This can
       be achieved by calling a function that allocates a sufficiently large automatic variable (an array) and  writes  to
       the  memory  occupied by this array in order to touch these stack pages.  This way, enough pages will be mapped for
       the stack and can be locked into RAM.  The dummy writes ensure that not even copy-on-write page faults can occur in
       the critical section.

       Memory  locks  are  not inherited by a child created via fork(2) and are automatically removed (unlocked) during an
       execve(2) or when the process terminates.  The mlockall() MCL_FUTURE and MCL_FUTURE | MCL_ONFAULT settings are  not
       inherited by a child created via fork(2) and are cleared during an execve(2).

       Note  that fork(2) will prepare the address space for a copy-on-write operation.  The consequence is that any write
       access that follows will cause a page fault that in turn may cause high latencies for a real-time process.   There‐
       fore,  it  is  crucial  not to invoke fork(2) after an mlockall() or mlock() operation—not even from a thread which
       runs at a low priority within a process which also has a thread running at elevated priority.

       The memory lock on an address range is automatically removed if the address range is unmapped via munmap(2).

       Memory locks do not stack, that is, pages which have been locked several times by calls to  mlock(),  mlock2(),  or
       mlockall()  will  be  unlocked by a single call to munlock() for the corresponding range or by munlockall().  Pages
       which are mapped to several locations or by several processes stay locked into RAM as long as they  are  locked  at
       least at one location or by at least one process.

       If a call to mlockall() which uses the MCL_FUTURE flag is followed by another call that does not specify this flag,
       the changes made by the MCL_FUTURE call will be lost.

       The mlock2() MLOCK_ONFAULT flag and the mlockall() MCL_ONFAULT flag allow efficient memory locking for applications
       that  deal  with  large  mappings where only a (small) portion of pages in the mapping are touched.  In such cases,
       locking all of the pages in a mapping would incur a significant penalty for memory locking.

   Linux notes
       Under Linux, mlock(), mlock2(), and munlock() automatically round addr down to the nearest page boundary.  However,
       the  POSIX.1  specification of mlock() and munlock() allows an implementation to require that addr is page aligned,
       so portable applications should ensure this.

       The VmLck field of the Linux-specific /proc/[pid]/status file shows how many kilobytes of memory the  process  with
       ID PID has locked using mlock(), mlock2(), mlockall(), and mmap(2) MAP_LOCKED.

   Limits and permissions
       In Linux 2.6.8 and earlier, a process must be privileged (CAP_IPC_LOCK) in order to lock memory and the RLIMIT_MEM‐
       LOCK soft resource limit defines a limit on how much memory the process may lock.

       Since Linux 2.6.9, no limits are placed on the amount of  memory  that  a  privileged  process  can  lock  and  the
       RLIMIT_MEMLOCK soft resource limit instead defines a limit on how much memory an unprivileged process may lock.

BUGS
       In Linux 4.8 and earlier, a bug in the kernel's accounting of locked memory for unprivileged processes (i.e., with‐
       out CAP_IPC_LOCK) meant that if the region specified by addr and len overlapped an existing lock, then the  already
       locked  bytes in the overlapping region were counted twice when checking against the limit.  Such double accounting
       could incorrectly calculate a "total locked memory" value for the process that exceeded the  RLIMIT_MEMLOCK  limit,
       with the result that mlock() and mlock2() would fail on requests that should have succeeded.  This bug was fixed in
       Linux 4.9

       In the 2.4 series Linux kernels up to and including 2.4.17, a bug caused  the  mlockall()  MCL_FUTURE  flag  to  be
       inherited across a fork(2).  This was rectified in kernel 2.4.18.

       Since  kernel  2.6.9,  if  a  privileged  process  calls mlockall(MCL_FUTURE) and later drops privileges (loses the
       CAP_IPC_LOCK capability by, for example, setting its effective UID to a  nonzero  value),  then  subsequent  memory
       allocations (e.g., mmap(2), brk(2)) will fail if the RLIMIT_MEMLOCK resource limit is encountered.

SEE ALSO
       mincore(2), mmap(2), setrlimit(2), shmctl(2), sysconf(3), proc(5), capabilities(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-02-02                                                MLOCK(2)
</pre>
<pre zoom>
<span xsmall>2 umask</span>
UMASK(2)                                         Linux Programmer's Manual                                        UMASK(2)

NAME
       umask - set file mode creation mask

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>

       mode_t umask(mode_t mask);

DESCRIPTION
       umask()  sets  the calling process's file mode creation mask (umask) to mask & 0777 (i.e., only the file permission
       bits of mask are used), and returns the previous value of the mask.

       The umask is used by open(2), mkdir(2), and other system calls that create files to modify the  permissions  placed
       on  newly  created files or directories.  Specifically, permissions in the umask are turned off from the mode argu‐
       ment to open(2) and mkdir(2).

       Alternatively, if the parent directory has a default ACL (see acl(5)), the umask is ignored,  the  default  ACL  is
       inherited,  the permission bits are set based on the inherited ACL, and permission bits absent in the mode argument
       are turned off.  For example, the following default ACL is equivalent to a umask of 022:

           u::rwx,g::r-x,o::r-x

       Combining the effect of this default ACL with a mode argument of 0666 (rw-rw-rw-), the resulting  file  permissions
       would be 0644 (rw-r--r--).

       The constants that should be used to specify mask are described in inode(7).

       The typical default value for the process umask is S_IWGRP | S_IWOTH (octal 022).  In the usual case where the mode
       argument to open(2) is specified as:

           S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH

       (octal 0666) when creating a new file, the permissions on the resulting file will be:

           S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH

       (because 0666 & ~022 = 0644; i.e., rw-r--r--).

RETURN VALUE
       This system call always succeeds and the previous value of the mask is returned.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

NOTES
       A child process created via fork(2) inherits its parent's umask.  The umask is left unchanged by execve(2).

       It is impossible to use umask() to fetch a process's umask without at the same time changing it.  A second call  to
       umask()  would then be needed to restore the umask.  The nonatomicity of these two steps provides the potential for
       races in multithreaded programs.

       Since Linux 4.7, the umask of any process can be viewed via the Umask field of /proc/[pid]/status.  Inspecting this
       field in /proc/self/status allows a process to retrieve its umask without at the same time changing it.

       The  umask  setting  also  affects  the  permissions  assigned  to  POSIX  IPC  objects  (mq_open(3),  sem_open(3),
       shm_open(3)), FIFOs (mkfifo(3)), and UNIX domain sockets (unix(7)) created by the  process.   The  umask  does  not
       affect  the  permissions  assigned  to  System V  IPC  objects  created by the process (using msgget(2), semget(2),
       shmget(2)).

SEE ALSO
       chmod(2), mkdir(2), open(2), stat(2), acl(5)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                UMASK(2)
</pre>
<pre zoom>
<span xsmall>2 rt_sigpending</span>
SIGPENDING(2)                                    Linux Programmer's Manual                                   SIGPENDING(2)

NAME
       sigpending, rt_sigpending - examine pending signals

SYNOPSIS
       #include <signal.h>

       int sigpending(sigset_t *set);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       sigpending(): _POSIX_C_SOURCE

DESCRIPTION
       sigpending()  returns  the  set  of  signals that are pending for delivery to the calling thread (i.e., the signals
       which have been raised while blocked).  The mask of pending signals is returned in set.

RETURN VALUE
       sigpending() returns 0 on success and -1 on error.  In the event of an error, errno is set to indicate the cause.

ERRORS
       EFAULT set points to memory which is not a valid part of the process address space.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       See sigsetops(3) for details on manipulating signal sets.

       If a signal is both blocked and has a disposition of "ignored", it is not added to the mask of pending signals when
       generated.

       The  set of signals that is pending for a thread is the union of the set of signals that is pending for that thread
       and the set of signals that is pending for the process as a whole; see signal(7).

       A child created via fork(2) initially has an empty pending signal set; the pending signal set is  preserved  across
       an execve(2).

   C library/kernel differences
       The  original  Linux  system call was named sigpending().  However, with the addition of real-time signals in Linux
       2.2, the fixed-size, 32-bit sigset_t argument supported by that system call was no longer fit for purpose.   Conse‐
       quently,  a  new system call, rt_sigpending(), was added to support an enlarged sigset_t type.  The new system call
       takes a second argument, size_t sigsetsize, which specifies the size in bytes of the signal set in set.  The  glibc
       sigpending()  wrapper  function  hides these details from us, transparently calling rt_sigpending() when the kernel
       provides it.

BUGS
       In versions of glibc up to and including 2.2.1, there is a bug in the wrapper function for sigpending() which means
       that information about pending real-time signals is not correctly returned.

SEE ALSO
       kill(2), sigaction(2), signal(2), sigprocmask(2), sigsuspend(2), sigsetops(3), signal(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           SIGPENDING(2)
</pre>
<pre zoom>
<span xsmall>2 process_vm_writev</span>
PROCESS_VM_READV(2)                              Linux Programmer's Manual                             PROCESS_VM_READV(2)

NAME
       process_vm_readv, process_vm_writev - transfer data between process address spaces

SYNOPSIS
       #include <sys/uio.h>

       ssize_t process_vm_readv(pid_t pid,
                                const struct iovec *local_iov,
                                unsigned long liovcnt,
                                const struct iovec *remote_iov,
                                unsigned long riovcnt,
                                unsigned long flags);

       ssize_t process_vm_writev(pid_t pid,
                                 const struct iovec *local_iov,
                                 unsigned long liovcnt,
                                 const struct iovec *remote_iov,
                                 unsigned long riovcnt,
                                 unsigned long flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       process_vm_readv(), process_vm_writev():
           _GNU_SOURCE

DESCRIPTION
       These  system  calls  transfer  data between the address space of the calling process ("the local process") and the
       process identified by pid ("the remote process").  The data moves directly between the address spaces  of  the  two
       processes, without passing through kernel space.

       The  process_vm_readv()  system  call  transfers data from the remote process to the local process.  The data to be
       transferred is identified by remote_iov and riovcnt: remote_iov is a pointer to an array describing address  ranges
       in  the  process  pid,  and riovcnt specifies the number of elements in remote_iov.  The data is transferred to the
       locations specified by local_iov and liovcnt: local_iov is a pointer to an array describing address ranges  in  the
       calling process, and liovcnt specifies the number of elements in local_iov.

       The  process_vm_writev() system call is the converse of process_vm_readv()—it transfers data from the local process
       to the remote process.  Other than the direction of the transfer, the arguments liovcnt,  local_iov,  riovcnt,  and
       remote_iov have the same meaning as for process_vm_readv().

       The local_iov and remote_iov arguments point to an array of iovec structures, defined in <sys/uio.h> as:

           struct iovec {
               void  *iov_base;    /* Starting address */
               size_t iov_len;     /* Number of bytes to transfer */
           };

       Buffers are processed in array order.  This means that process_vm_readv() completely fills local_iov[0] before pro‐
       ceeding to local_iov[1], and so on.  Likewise, remote_iov[0] is completely read before proceeding to remote_iov[1],
       and so on.

       Similarly,  process_vm_writev()  writes  out the entire contents of local_iov[0] before proceeding to local_iov[1],
       and it completely fills remote_iov[0] before proceeding to remote_iov[1].

       The lengths of remote_iov[i].iov_len and local_iov[i].iov_len do not have to be the same.  Thus, it is possible  to
       split a single local buffer into multiple remote buffers, or vice versa.

       The flags argument is currently unused and must be set to 0.

       The  values  specified in the liovcnt and riovcnt arguments must be less than or equal to IOV_MAX (defined in <lim‐
       its.h> or accessible via the call sysconf(_SC_IOV_MAX)).

       The count arguments and local_iov are checked before doing any transfers.  If the counts are too big, or  local_iov
       is  invalid, or the addresses refer to regions that are inaccessible to the local process, none of the vectors will
       be processed and an error will be returned immediately.

       Note, however, that these system calls do not check the memory regions in the  remote  process  until  just  before
       doing  the  read/write.   Consequently, a partial read/write (see RETURN VALUE) may result if one of the remote_iov
       elements points to an invalid memory region in the remote process.   No  further  reads/writes  will  be  attempted
       beyond  that  point.   Keep this in mind when attempting to read data of unknown length (such as C strings that are
       null-terminated) from a remote process, by avoiding spanning memory pages (typically  4 KiB)  in  a  single  remote
       iovec element.  (Instead, split the remote read into two remote_iov elements and have them merge back into a single
       write local_iov entry.  The first read entry goes up to the page boundary, while the second starts on the next page
       boundary.)

       Permission  to  read  from or write to another process is governed by a ptrace access mode PTRACE_MODE_ATTACH_REAL‐
       CREDS check; see ptrace(2).

RETURN VALUE
       On success, process_vm_readv() returns the number of bytes read and process_vm_writev() returns the number of bytes
       written.  This return value may be less than the total number of requested bytes, if a partial read/write occurred.
       (Partial transfers apply at the granularity of iovec elements.  These system calls won't perform a partial transfer
       that  splits  a  single  iovec  element.)   The caller should check the return value to determine whether a partial
       read/write occurred.

       On error, -1 is returned and errno is set appropriately.

ERRORS
       EFAULT The memory described by local_iov is outside the caller's accessible address space.

       EFAULT The memory described by remote_iov is outside the accessible address space of the process pid.

       EINVAL The sum of the iov_len values of either local_iov or remote_iov overflows a ssize_t value.

       EINVAL flags is not 0.

       EINVAL liovcnt or riovcnt is too large.

       ENOMEM Could not allocate memory for internal copies of the iovec structures.

       EPERM  The caller does not have permission to access the address space of the process pid.

       ESRCH  No process with ID pid exists.

VERSIONS
       These system calls were added in Linux 3.2.  Support is provided in glibc since version 2.15.

CONFORMING TO
       These system calls are nonstandard Linux extensions.

NOTES
       The data transfers performed by process_vm_readv() and process_vm_writev() are not guaranteed to be atomic  in  any
       way.

       These  system calls were designed to permit fast message passing by allowing messages to be exchanged with a single
       copy operation (rather than the double copy that would be required  when  using,  for  example,  shared  memory  or
       pipes).

EXAMPLE
       The  following  code  sample  demonstrates the use of process_vm_readv().  It reads 20 bytes at the address 0x10000
       from the process with PID 10 and writes the first 10 bytes into buf1 and the second 10 bytes into buf2.

       #include <sys/uio.h>

       int
       main(void)
       {
           struct iovec local[2];
           struct iovec remote[1];
           char buf1[10];
           char buf2[10];
           ssize_t nread;
           pid_t pid = 10;             /* PID of remote process */

           local[0].iov_base = buf1;
           local[0].iov_len = 10;
           local[1].iov_base = buf2;
           local[1].iov_len = 10;
           remote[0].iov_base = (void *) 0x10000;
           remote[0].iov_len = 20;

           nread = process_vm_readv(pid, local, 2, remote, 1, 0);
           if (nread != 20)
               return 1;
           else
               return 0;
       }

SEE ALSO
       readv(2), writev(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                     PROCESS_VM_READV(2)
</pre>
<pre zoom>
<span xsmall>2 exit_group</span>
EXIT_GROUP(2)                                    Linux Programmer's Manual                                   EXIT_GROUP(2)

NAME
       exit_group - exit all threads in a process

SYNOPSIS
       #include <linux/unistd.h>

       void exit_group(int status);

DESCRIPTION
       This  system  call is equivalent to _exit(2) except that it terminates not only the calling thread, but all threads
       in the calling process's thread group.

RETURN VALUE
       This system call does not return.

VERSIONS
       This call is present since Linux 2.5.35.

CONFORMING TO
       This call is Linux-specific.

NOTES
       Since glibc 2.3, this is the system call invoked when the _exit(2) wrapper function is called.

SEE ALSO
       exit(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2008-11-27                                           EXIT_GROUP(2)
</pre>
<pre zoom>
<span xsmall>2 gtty</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 mq_timedsend</span>
MQ_SEND(3)                                       Linux Programmer's Manual                                      MQ_SEND(3)

NAME
       mq_send, mq_timedsend - send a message to a message queue

SYNOPSIS
       #include <mqueue.h>

       int mq_send(mqd_t mqdes, const char *msg_ptr,
                     size_t msg_len, unsigned int msg_prio);

       #include <time.h>
       #include <mqueue.h>

       int mq_timedsend(mqd_t mqdes, const char *msg_ptr,
                     size_t msg_len, unsigned int msg_prio,
                     const struct timespec *abs_timeout);

       Link with -lrt.

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       mq_timedsend():
           _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       mq_send()  adds  the message pointed to by msg_ptr to the message queue referred to by the message queue descriptor
       mqdes.  The msg_len argument specifies the length of the message pointed to by msg_ptr; this length  must  be  less
       than or equal to the queue's mq_msgsize attribute.  Zero-length messages are allowed.

       The msg_prio argument is a nonnegative integer that specifies the priority of this message.  Messages are placed on
       the queue in decreasing order of priority, with newer messages of the same priority being placed after  older  mes‐
       sages with the same priority.  See mq_overview(7) for details on the range for the message priority.

       If  the  message  queue  is  already  full  (i.e., the number of messages on the queue equals the queue's mq_maxmsg
       attribute), then, by default, mq_send() blocks until sufficient space becomes available to allow the message to  be
       queued,  or  until  the call is interrupted by a signal handler.  If the O_NONBLOCK flag is enabled for the message
       queue description, then the call instead fails immediately with the error EAGAIN.

       mq_timedsend() behaves just like mq_send(), except that if the queue is full and the O_NONBLOCK flag is not enabled
       for  the  message  queue description, then abs_timeout points to a structure which specifies how long the call will
       block.  This value is an absolute timeout in seconds and nanoseconds since the  Epoch,  1970-01-01  00:00:00  +0000
       (UTC), specified in the following structure:

           struct timespec {
               time_t tv_sec;        /* seconds */
               long   tv_nsec;       /* nanoseconds */
           };

       If  the  message queue is full, and the timeout has already expired by the time of the call, mq_timedsend() returns
       immediately.

RETURN VALUE
       On success, mq_send() and mq_timedsend() return zero; on error, -1 is returned, with  errno  set  to  indicate  the
       error.

ERRORS
       EAGAIN The queue was full, and the O_NONBLOCK flag was set for the message queue description referred to by mqdes.

       EBADF  The descriptor specified in mqdes was invalid or not opened for writing.

       EINTR  The call was interrupted by a signal handler; see signal(7).

       EINVAL The  call  would  have  blocked,  and  abs_timeout was invalid, either because tv_sec was less than zero, or
              because tv_nsec was less than zero or greater than 1000 million.

       EMSGSIZE
              msg_len was greater than the mq_msgsize attribute of the message queue.

       ETIMEDOUT
              The call timed out before a message could be transferred.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌──────────────────────────┬───────────────┬─────────┐
       │Interface                 │ Attribute     │ Value   │
       ├──────────────────────────┼───────────────┼─────────┤
       │mq_send(), mq_timedsend() │ Thread safety │ MT-Safe │
       └──────────────────────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       On Linux, mq_timedsend() is a system call, and mq_send() is a library function layered on top of that system call.

SEE ALSO
       mq_close(3), mq_getattr(3), mq_notify(3), mq_open(3), mq_receive(3), mq_unlink(3), mq_overview(7), time(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              MQ_SEND(3)
</pre>
<pre zoom>
<span xsmall>2 quotactl</span>
QUOTACTL(2)                                      Linux Programmer's Manual                                     QUOTACTL(2)

NAME
       quotactl - manipulate disk quotas

SYNOPSIS
       #include <sys/quota.h>
       #include <xfs/xqm.h> /* for XFS quotas */

       int quotactl(int cmd, const char *special, int id, caddr_t addr);

DESCRIPTION
       The quota system can be used to set per-user, per-group, and per-project limits on the amount of disk space used on
       a filesystem.  For each user and/or group, a soft limit and a hard limit can be set for each filesystem.  The  hard
       limit can't be exceeded.  The soft limit can be exceeded, but warnings will ensue.  Moreover, the user can't exceed
       the soft limit for more than grace period duration (one week by default) at a time;  after  this,  the  soft  limit
       counts as a hard limit.

       The  quotactl()  call  manipulates  disk quotas.  The cmd argument indicates a command to be applied to the user or
       group ID specified in id.  To initialize the cmd argument, use the QCMD(subcmd, type) macro.   The  type  value  is
       either  USRQUOTA,  for  user quotas, GRPQUOTA, for group quotas, or (since Linux 4.1) PRJQUOTA, for project quotas.
       The subcmd value is described below.

       The special argument is a pointer to a null-terminated string containing the pathname of the (mounted)  block  spe‐
       cial device for the filesystem being manipulated.

       The  addr  argument is the address of an optional, command-specific, data structure that is copied in or out of the
       system.  The interpretation of addr is given with each command below.

       The subcmd value is one of the following:

       Q_QUOTAON
               Turn on quotas for a filesystem.  The id argument is the identification number of the quota  format  to  be
               used.  Currently, there are three supported quota formats:

               QFMT_VFS_OLD The original quota format.

               QFMT_VFS_V0  The standard VFS v0 quota format, which can handle 32-bit UIDs and GIDs and quota limits up to
                            2^42 bytes and 2^32 inodes.

               QFMT_VFS_V1  A quota format that can handle 32-bit UIDs and GIDs and quota limits of 2^64  bytes  and  2^64
                            inodes.

               The  addr  argument  points  to the pathname of a file containing the quotas for the filesystem.  The quota
               file must exist; it is normally created with the quotacheck(8) program.  This operation requires  privilege
               (CAP_SYS_ADMIN).

       Q_QUOTAOFF
               Turn  off  quotas for a filesystem.  The addr and id arguments are ignored.  This operation requires privi‐
               lege (CAP_SYS_ADMIN).

       Q_GETQUOTA
               Get disk quota limits and current usage for user or group id.  The addr argument is a pointer  to  a  dqblk
               structure defined in <sys/quota.h> as follows:

                   /* uint64_t is an unsigned 64-bit integer;
                      uint32_t is an unsigned 32-bit integer */

                   struct dqblk {      /* Definition since Linux 2.4.22 */
                       uint64_t dqb_bhardlimit;  /* Absolute limit on disk
                                                    quota blocks alloc */
                       uint64_t dqb_bsoftlimit;  /* Preferred limit on
                                                    disk quota blocks */
                       uint64_t dqb_curspace;    /* Current occupied space
                                                    (in bytes) */
                       uint64_t dqb_ihardlimit;  /* Maximum number of
                                                    allocated inodes */
                       uint64_t dqb_isoftlimit;  /* Preferred inode limit */
                       uint64_t dqb_curinodes;   /* Current number of
                                                    allocated inodes */
                       uint64_t dqb_btime;       /* Time limit for excessive
                                                    disk use */
                       uint64_t dqb_itime;       /* Time limit for excessive
                                                    files */
                       uint32_t dqb_valid;       /* Bit mask of QIF_*
                                                    constants */
                   };

                   /* Flags in dqb_valid that indicate which fields in
                      dqblk structure are valid. */

                   #define QIF_BLIMITS   1
                   #define QIF_SPACE     2
                   #define QIF_ILIMITS   4
                   #define QIF_INODES    8
                   #define QIF_BTIME     16
                   #define QIF_ITIME     32
                   #define QIF_LIMITS    (QIF_BLIMITS | QIF_ILIMITS)
                   #define QIF_USAGE     (QIF_SPACE | QIF_INODES)
                   #define QIF_TIMES     (QIF_BTIME | QIF_ITIME)
                   #define QIF_ALL       (QIF_LIMITS | QIF_USAGE | QIF_TIMES)

               The  dqb_valid  field  is  a  bit  mask that is set to indicate the entries in the dqblk structure that are
               valid.  Currently, the kernel fills in all entries of the dqblk structure and marks them as  valid  in  the
               dqb_valid  field.  Unprivileged users may retrieve only their own quotas; a privileged user (CAP_SYS_ADMIN)
               can retrieve the quotas of any user.

       Q_GETNEXTQUOTA (since Linux 4.6)
               This operation is the same as Q_GETQUOTA, but it returns quota information for the next ID greater than  or
               equal to id that has a quota set.

               The  addr  argument is a pointer to a nextdqblk structure whose fields are as for the dqblk, except for the
               addition of a dqb_id field that is used to return the ID for which quota information is being returned:

                   struct nextdqblk {
                       uint64_t dqb_bhardlimit;
                       uint64_t dqb_bsoftlimit;
                       uint64_t dqb_curspace;
                       uint64_t dqb_ihardlimit;
                       uint64_t dqb_isoftlimit;
                       uint64_t dqb_curinodes;
                       uint64_t dqb_btime;
                       uint64_t dqb_itime;
                       uint32_t dqb_valid;
                       uint32_t dqb_id;
                   };

       Q_SETQUOTA
               Set quota information for user or group id, using the information supplied in the dqblk  structure  pointed
               to  by addr.  The dqb_valid field of the dqblk structure indicates which entries in the structure have been
               set by the caller.  This operation supersedes the Q_SETQLIM and Q_SETUSE operations in the  previous  quota
               interfaces.  This operation requires privilege (CAP_SYS_ADMIN).

       Q_GETINFO (since Linux 2.4.22)
               Get  information  (like  grace  times)  about quotafile.  The addr argument should be a pointer to a dqinfo
               structure.  This structure is defined in <sys/quota.h> as follows:

                   /* uint64_t is an unsigned 64-bit integer;
                      uint32_t is an unsigned 32-bit integer */

                   struct dqinfo {         /* Defined since kernel 2.4.22 */
                       uint64_t dqi_bgrace;  /* Time before block soft limit
                                                becomes hard limit */
                       uint64_t dqi_igrace;  /* Time before inode soft limit
                                                becomes hard limit */
                       uint32_t dqi_flags;   /* Flags for quotafile
                                                (DQF_*) */
                       uint32_t dqi_valid;
                   };

                   /* Bits for dqi_flags */

                   /* Quota format QFMT_VFS_OLD */

                   #define DQF_ROOT_SQUASH (1 << 0) /* Root squash enabled */
                                 /* Before Linux v4.0, this had been defined
                                    privately as V1_DQF_RSQUASH */

                   /* Quota format QFMT_VFS_V0 / QFMT_VFS_V1 */

                   #define DQF_SYS_FILE    (1 << 16)   /* Quota stored in
                                                          a system file */

                   /* Flags in dqi_valid that indicate which fields in
                      dqinfo structure are valid. */

                   #define IIF_BGRACE  1
                   #define IIF_IGRACE  2
                   #define IIF_FLAGS   4
                   #define IIF_ALL     (IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)

               The dqi_valid field in the dqinfo structure indicates the entries in the structure that  are  valid.   Cur‐
               rently,  the  kernel  fills  in  all  entries  of  the  dqinfo structure and marks them all as valid in the
               dqi_valid field.  The id argument is ignored.

       Q_SETINFO (since Linux 2.4.22)
               Set information about quotafile.  The addr argument should  be  a  pointer  to  a  dqinfo  structure.   The
               dqi_valid  field  of  the dqinfo structure indicates the entries in the structure that have been set by the
               caller.  This operation supersedes the Q_SETGRACE and Q_SETFLAGS operations in the  previous  quota  inter‐
               faces.  The id argument is ignored.  This operation requires privilege (CAP_SYS_ADMIN).

       Q_GETFMT (since Linux 2.4.22)
               Get  quota format used on the specified filesystem.  The addr argument should be a pointer to a 4-byte buf‐
               fer where the format number will be stored.

       Q_SYNC  Update the on-disk copy of quota usages for a filesystem.  If special is NULL, then  all  filesystems  with
               active quotas are sync'ed.  The addr and id arguments are ignored.

       Q_GETSTATS (supported up to Linux 2.4.21)
               Get  statistics  and  other  generic  information about the quota subsystem.  The addr argument should be a
               pointer to a dqstats structure in which data should be stored.  This structure is defined in <sys/quota.h>.
               The special and id arguments are ignored.

               This  operation is obsolete and was removed in Linux 2.4.22.  Files in /proc/sys/fs/quota/ carry the infor‐
               mation instead.

       For XFS filesystems making use of the XFS Quota Manager (XQM), the above commands are bypassed  and  the  following
       commands are used:

       Q_XQUOTAON
               Turn on quotas for an XFS filesystem.  XFS provides the ability to turn on/off quota limit enforcement with
               quota accounting.  Therefore, XFS expects addr to be a pointer to an unsigned int that contains a  combina‐
               tion of the following flags (defined in <xfs/xqm.h>):

                   #define XFS_QUOTA_UDQ_ACCT (1<<0) /* User quota
                                                        accounting */
                   #define XFS_QUOTA_UDQ_ENFD (1<<1) /* User quota limits
                                                        enforcement */
                   #define XFS_QUOTA_GDQ_ACCT (1<<2) /* Group quota
                                                        accounting */
                   #define XFS_QUOTA_GDQ_ENFD (1<<3) /* Group quota limits
                                                        enforcement */
                   #define XFS_QUOTA_PDQ_ACCT (1<<4) /* Project quota
                                                        accounting */
                   #define XFS_QUOTA_PDQ_ENFD (1<<5) /* Project quota limits
                                                        enforcement */

               This operation requires privilege (CAP_SYS_ADMIN).  The id argument is ignored.

       Q_XQUOTAOFF
               Turn  off quotas for an XFS filesystem.  As with Q_QUOTAON, XFS filesystems expect a pointer to an unsigned
               int that specifies whether quota accounting and/or limit enforcement need to be turned off (using the  same
               flags  as  for Q_XQUOTAON subcommand).  This operation requires privilege (CAP_SYS_ADMIN).  The id argument
               is ignored.

       Q_XGETQUOTA
               Get disk quota limits and current usage for user id.  The addr argument is a pointer  to  an  fs_disk_quota
               structure, which is defined in <xfs/xqm.h> as follows:

                   /* All the blk units are in BBs (Basic Blocks) of
                      512 bytes. */

                   #define FS_DQUOT_VERSION  1  /* fs_disk_quota.d_version */

                   #define XFS_USER_QUOTA    (1<<0)  /* User quota type */
                   #define XFS_PROJ_QUOTA    (1<<1)  /* Project quota type */
                   #define XFS_GROUP_QUOTA   (1<<2)  /* Group quota type */

                   struct fs_disk_quota {
                       int8_t   d_version;   /* Version of this structure */
                       int8_t   d_flags;     /* XFS_{USER,PROJ,GROUP}_QUOTA */
                       uint16_t d_fieldmask; /* Field specifier */
                       uint32_t d_id;        /* User, project, or group ID */
                       uint64_t d_blk_hardlimit; /* Absolute limit on
                                                    disk blocks */
                       uint64_t d_blk_softlimit; /* Preferred limit on
                                                    disk blocks */
                       uint64_t d_ino_hardlimit; /* Maximum # allocated
                                                    inodes */
                       uint64_t d_ino_softlimit; /* Preferred inode limit */
                       uint64_t d_bcount;    /* # disk blocks owned by
                                                the user */
                       uint64_t d_icount;    /* # inodes owned by the user */
                       int32_t  d_itimer;    /* Zero if within inode limits */
                                             /* If not, we refuse service */
                       int32_t  d_btimer;    /* Similar to above; for
                                                disk blocks */
                       uint16_t d_iwarns;    /* # warnings issued with
                                                respect to # of inodes */
                       uint16_t d_bwarns;    /* # warnings issued with
                                                respect to disk blocks */
                       int32_t  d_padding2;  /* Padding - for future use */
                       uint64_t d_rtb_hardlimit; /* Absolute limit on realtime
                                                    (RT) disk blocks */
                       uint64_t d_rtb_softlimit; /* Preferred limit on RT
                                                    disk blocks */
                       uint64_t d_rtbcount;  /* # realtime blocks owned */
                       int32_t  d_rtbtimer;  /* Similar to above; for RT
                                                disk blocks */
                       uint16_t d_rtbwarns;  /* # warnings issued with
                                                respect to RT disk blocks */
                       int16_t  d_padding3;  /* Padding - for future use */
                       char     d_padding4[8];   /* Yet more padding */
                   };

               Unprivileged  users  may retrieve only their own quotas; a privileged user (CAP_SYS_ADMIN) may retrieve the
               quotas of any user.

       Q_XGETNEXTQUOTA (since Linux 4.6)
               This operation is the same as Q_XGETQUOTA, but it returns (in the fs_disk_quota structure pointed by  addr)
               quota  information  for  the  next  ID  greater  than or equal to id that has a quota set.  Note that since
               fs_disk_quota already has q_id field, no separate structure type is needed (in contrast with Q_GETQUOTA and
               Q_GETNEXTQUOTA commands)

       Q_XSETQLIM
               Set  disk  quota  limits  for user id.  The addr argument is a pointer to an fs_disk_quota structure.  This
               operation requires privilege (CAP_SYS_ADMIN).

       Q_XGETQSTAT
               Returns XFS filesystem-specific quota information in the fs_quota_stat structure pointed by addr.  This  is
               useful  for finding out how much space is used to store quota information, and also to get the quota on/off
               status of a given local XFS filesystem.  The fs_quota_stat structure itself is defined as follows:

                   #define FS_QSTAT_VERSION 1  /* fs_quota_stat.qs_version */

                   struct fs_qfilestat {
                       uint64_t qfs_ino;       /* Inode number */
                       uint64_t qfs_nblks;     /* Number of BBs
                                                  512-byte-blocks */
                       uint32_t qfs_nextents;  /* Number of extents */
                   };

                   struct fs_quota_stat {
                       int8_t   qs_version; /* Version number for
                                               future changes */
                       uint16_t qs_flags; /* XFS_QUOTA_{U,P,G}DQ_{ACCT,ENFD} */
                       int8_t   qs_pad;   /* Unused */
                       struct fs_qfilestat qs_uquota;  /* User quota storage
                                                          information */
                       struct fs_qfilestat qs_gquota;  /* Group quota storage
                                                          information */
                       uint32_t qs_incoredqs;   /* Number of dquots in core */
                       int32_t  qs_btimelimit;  /* Limit for blocks timer */
                       int32_t  qs_itimelimit;  /* Limit for inodes timer */
                       int32_t  qs_rtbtimelimit;/* Limit for RT
                                                   blocks timer */
                       uint16_t qs_bwarnlimit;  /* Limit for # of warnings */
                       uint16_t qs_iwarnlimit;  /* Limit for # of warnings */
                   };

               The id argument is ignored.

       Q_XGETQSTATV
               Returns XFS filesystem-specific quota information in the fs_quota_statv pointed to by addr.   This  version
               of  the  command uses a structure with proper versioning support, along with appropriate layout (all fields
               are naturally aligned) and padding to avoiding special compat handling; it also provides the ability to get
               statistics regarding the project quota file.  The fs_quota_statv structure itself is defined as follows:

                   #define FS_QSTATV_VERSION1 1 /* fs_quota_statv.qs_version */

                   struct fs_qfilestatv {
                       uint64_t qfs_ino;       /* Inode number */
                       uint64_t qfs_nblks;     /* Number of BBs
                                                  512-byte-blocks */
                       uint32_t qfs_nextents;  /* Number of extents */
                       uint32_t qfs_pad;       /* Pad for 8-byte alignment */
                   };

                   struct fs_quota_statv {
                       int8_t   qs_version;    /* Version for future
                                                  changes */
                       uint8_t  qs_pad1;       /* Pad for 16-bit alignment */
                       uint16_t qs_flags;      /* XFS_QUOTA_.* flags */
                       uint32_t qs_incoredqs;  /* Number of dquots incore */
                       struct fs_qfilestatv qs_uquota;  /* User quota
                                                           information */
                       struct fs_qfilestatv qs_gquota;  /* Group quota
                                                           information */
                       struct fs_qfilestatv qs_pquota;  /* Project quota
                                                           information */
                       int32_t  qs_btimelimit;   /* Limit for blocks timer */
                       int32_t  qs_itimelimit;   /* Limit for inodes timer */
                       int32_t  qs_rtbtimelimit; /* Limit for RT blocks
                                                    timer */
                       uint16_t qs_bwarnlimit;   /* Limit for # of warnings */
                       uint16_t qs_iwarnlimit;   /* Limit for # of warnings */
                       uint64_t qs_pad2[8];      /* For future proofing */
                   };

               The  qs_version  field of the structure should be filled with the version of the structure supported by the
               callee (for now, only FS_QSTAT_VERSION1 is supported).  The kernel will fill the  structure  in  accordance
               with version provided.  The id argument is ignored.

       Q_XQUOTARM
               Free  the  disk  space taken by disk quotas. The addr argument should be a pointer to an unsigned int value
               containing flags (the same as in d_flags field of fs_disk_quota structure) which  identify  what  types  of
               quota  should be removed (note that the quota type passed in the cmd argument is ignored, but should remain
               valid in order to pass preliminary quotactl syscall handler checks).

               Quotas must have already been turned off.  The id argument is ignored.

       Q_XQUOTASYNC (since Linux 2.6.15; no-op since Linux 3.4)
               This command was an XFS quota equivalent to Q_SYNC, but it is no-op since  Linux  3.4,  as  sync(1)  writes
               quota  information to disk now (in addition to the other filesystem metadata that it writes out).  The spe‐
               cial, id and addr arguments are ignored.

RETURN VALUE
       On success, quotactl() returns 0; on error -1 is returned, and errno is set to indicate the error.

ERRORS
       EACCES cmd is Q_QUOTAON, and the quota file pointed to by addr exists, but is not a regular file or is not  on  the
              filesystem pointed to by special.

       EBUSY  cmd is Q_QUOTAON, but another Q_QUOTAON had already been performed.

       EFAULT addr or special is invalid.

       EINVAL cmd or type is invalid.

       EINVAL cmd is Q_QUOTAON, but the specified quota file is corrupted.

       ENOENT The file specified by special or addr does not exist.

       ENOSYS The kernel has not been compiled with the CONFIG_QUOTA option.

       ENOTBLK
              special is not a block device.

       EPERM  The caller lacked the required privilege (CAP_SYS_ADMIN) for the specified operation.

       ERANGE cmd is Q_SETQUOTA, but the specified limits are out of the range allowed by the quota format.

       ESRCH  No disk quota is found for the indicated user.  Quotas have not been turned on for this filesystem.

       ESRCH  cmd is Q_QUOTAON, but the specified quota format was not found.

       ESRCH  cmd  is Q_GETNEXTQUOTA or Q_XGETNEXTQUOTA, but there is no ID greater than or equal to id that has an active
              quota.

NOTES
       Instead of <xfs/xqm.h> one can use <linux/dqblk_xfs.h>, taking into account that there are several naming  discrep‐
       ancies:

       ·  Quota  enabling  flags  (of  format  XFS_QUOTA_[UGP]DQ_{ACCT,ENFD})  are  defined  without  a  leading  "X",  as
          FS_QUOTA_[UGP]DQ_{ACCT,ENFD}.

       ·  The   same   is   true   for   XFS_{USER,GROUP,PROJ}_QUOTA   quota   type   flags,   which   are   defined    as
          FS_{USER,GROUP,PROJ}_QUOTA.

       ·  The  dqblk_xfs.h  header  file  defines  its  own XQM_USRQUOTA, XQM_GRPQUOTA, and XQM_PRJQUOTA constants for the
          available quota types, but their values are the same as for constants without the XQM_ prefix.

SEE ALSO
       quota(1), getrlimit(2), quotacheck(8), quotaon(8)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             QUOTACTL(2)
</pre>
<pre zoom>
<span xsmall>2 mmap2</span>
MMAP2(2)                                         Linux Programmer's Manual                                        MMAP2(2)

NAME
       mmap2 - map files or devices into memory

SYNOPSIS
       #include <sys/mman.h>

       void *mmap2(void *addr, size_t length, int prot,
                    int flags, int fd, off_t pgoffset);

DESCRIPTION
       This  is  probably  not the system call that you are interested in; instead, see mmap(2), which describes the glibc
       wrapper function that invokes this system call.

       The mmap2() system call provides the same interface as mmap(2), except that the final argument specifies the offset
       into  the  file in 4096-byte units (instead of bytes, as is done by mmap(2)).  This enables applications that use a
       32-bit off_t to map large files (up to 2^44 bytes).

RETURN VALUE
       On success, mmap2() returns a pointer to the mapped area.  On error, -1 is returned and errno is set appropriately.

ERRORS
       EFAULT Problem with getting the data from user space.

       EINVAL (Various platforms where the page size is not 4096 bytes.)  offset * 4096 is not a multiple  of  the  system
              page size.

       mmap2() can also return any of the errors described in mmap(2).

VERSIONS
       mmap2() is available since Linux 2.3.31.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       On  architectures  where  this  system  call is present, the glibc mmap() wrapper function invokes this system call
       rather than the mmap(2) system call.

       This system call does not exist on x86-64.

       On ia64, the unit for offset is actually the system page size, rather than 4096 bytes.

SEE ALSO
       getpagesize(2), mmap(2), mremap(2), msync(2), shm_open(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                MMAP2(2)
</pre>
<pre zoom>
<span xsmall>2 nice</span>
NICE(2)                                          Linux Programmer's Manual                                         NICE(2)

NAME
       nice - change process priority

SYNOPSIS
       #include <unistd.h>

       int nice(int inc);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       nice(): _XOPEN_SOURCE
           || /* Since glibc 2.19: */ _DEFAULT_SOURCE
           || /* Glibc versions <= 2.19: */ _BSD_SOURCE || _SVID_SOURCE

DESCRIPTION
       nice() adds inc to the nice value for the calling thread.  (A higher nice value means a low priority.)

       The range of the nice value is +19 (low priority) to -20 (high priority).  Attempts to set a nice value outside the
       range are clamped to the range.

       Traditionally, only a privileged process could lower the nice value (i.e., set a higher priority).  However,  since
       Linux  2.6.12,  an  unprivileged  process  can  decrease  the  nice  value  of a target process that has a suitable
       RLIMIT_NICE soft limit; see getrlimit(2) for details.

RETURN VALUE
       On success, the new nice value is returned (but see NOTES below).  On error, -1  is  returned,  and  errno  is  set
       appropriately.

       A  successful  call  can  legitimately  return  -1.   To detect an error, set errno to 0 before the call, and check
       whether it is nonzero after nice() returns -1.

ERRORS
       EPERM  The calling process attempted to increase its priority by supplying a  negative  inc  but  has  insufficient
              privileges.   Under  Linux,  the  CAP_SYS_NICE  capability  is  required.   (But  see  the discussion of the
              RLIMIT_NICE resource limit in setrlimit(2).)

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  However, the raw system call and  (g)libc  (earlier  than  glibc  2.2.4)
       return value is nonstandard, see below.

NOTES
       For further details on the nice value, see sched(7).

       Note:  the  addition  of the "autogroup" feature in Linux 2.6.38 means that the nice value no longer has its tradi‐
       tional effect in many circumstances.  For details, see sched(7).

   C library/kernel differences
       POSIX.1 specifies that nice() should return the new nice value.  However, the raw Linux system call  returns  0  on
       success.  Likewise, the nice() wrapper function provided in glibc 2.2.3 and earlier returns 0 on success.

       Since glibc 2.2.4, the nice() wrapper function provided by glibc provides conformance to POSIX.1 by calling getpri‐
       ority(2) to obtain the new nice value, which is then returned to the caller.

SEE ALSO
       nice(1), renice(1), fork(2), getpriority(2), getrlimit(2), setpriority(2), capabilities(7), sched(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 NICE(2)
</pre>
<pre zoom>
<span xsmall>2 ioctl_tty</span>
IOCTL_TTY(2)                                     Linux Programmer's Manual                                    IOCTL_TTY(2)

NAME
       ioctl_tty - ioctls for terminals and serial lines

SYNOPSIS
       #include <termios.h>

       int ioctl(int fd, int cmd, ...);

DESCRIPTION
       The  ioctl(2)  call  for  terminals and serial ports accepts many possible command arguments.  Most require a third
       argument, of varying type, here called argp or arg.

       Use of ioctl makes for nonportable programs.  Use the POSIX interface described in termios(3) whenever possible.

   Get and set terminal attributes
       TCGETS    struct termios *argp
              Equivalent to tcgetattr(fd, argp).
              Get the current serial port settings.

       TCSETS    const struct termios *argp
              Equivalent to tcsetattr(fd, TCSANOW, argp).
              Set the current serial port settings.

       TCSETSW   const struct termios *argp
              Equivalent to tcsetattr(fd, TCSADRAIN, argp).
              Allow the output buffer to drain, and set the current serial port settings.

       TCSETSF   const struct termios *argp
              Equivalent to tcsetattr(fd, TCSAFLUSH, argp).
              Allow the output buffer to drain, discard pending input, and set the current serial port settings.

       The following four ioctls are just like TCGETS, TCSETS, TCSETSW, TCSETSF, except that they take a  struct  termio *
       instead of a struct termios *.

              TCGETA    struct termio *argp

              TCSETA    const struct termio *argp

              TCSETAW   const struct termio *argp

              TCSETAF   const struct termio *argp

   Locking the termios structure
       The  termios  structure  of a terminal can be locked.  The lock is itself a termios structure, with nonzero bits or
       fields indicating a locked value.

       TIOCGLCKTRMIOS struct termios *argp
              Gets the locking status of the termios structure of the terminal.

       TIOCSLCKTRMIOS const struct termios *argp
              Sets the locking status of the termios structure of the terminal.  Only a  process  with  the  CAP_SYS_ADMIN
              capability can do this.

   Get and set window size
       Window  sizes are kept in the kernel, but not used by the kernel (except in the case of virtual consoles, where the
       kernel will update the window size when the size of the virtual console changes, for  example,  by  loading  a  new
       font).

       The following constants and structure are defined in <sys/ioctl.h>.

       TIOCGWINSZ     struct winsize *argp
              Get window size.

       TIOCSWINSZ     const struct winsize *argp
              Set window size.

       The struct used by these ioctls is defined as

           struct winsize {
               unsigned short ws_row;
               unsigned short ws_col;
               unsigned short ws_xpixel;   /* unused */
               unsigned short ws_ypixel;   /* unused */
           };

       When the window size changes, a SIGWINCH signal is sent to the foreground process group.

   Sending a break
       TCSBRK    int arg
              Equivalent to tcsendbreak(fd, arg).
              If the terminal is using asynchronous serial data transmission, and arg is zero, then send a break (a stream
              of zero bits) for between 0.25 and 0.5 seconds.  If the terminal  is  not  using  asynchronous  serial  data
              transmission,  then  either  a  break  is sent, or the function returns without doing anything.  When arg is
              nonzero, nobody knows what will happen.

              (SVr4, UnixWare, Solaris, Linux treat tcsendbreak(fd,arg) with nonzero arg like tcdrain(fd).   SunOS  treats
              arg as a multiplier, and sends a stream of bits arg times as long as done for zero arg.  DG/UX and AIX treat
              arg (when nonzero) as a time interval measured in milliseconds.  HP-UX ignores arg.)

       TCSBRKP   int arg
              So-called "POSIX version" of TCSBRK.  It treats nonzero arg as a timeinterval measured in  deciseconds,  and
              does nothing when the driver does not support breaks.

       TIOCSBRK  void
              Turn break on, that is, start sending zero bits.

       TIOCCBRK  void
              Turn break off, that is, stop sending zero bits.

   Software flow control
       TCXONC    int arg
              Equivalent to tcflow(fd, arg).
              See tcflow(3) for the argument values TCOOFF, TCOON, TCIOFF, TCION.

   Buffer count and flushing
       FIONREAD  int *argp
              Get the number of bytes in the input buffer.

       TIOCINQ   int *argp
              Same as FIONREAD.

       TIOCOUTQ  int *argp
              Get the number of bytes in the output buffer.

       TCFLSH    int arg
              Equivalent to tcflush(fd, arg).
              See tcflush(3) for the argument values TCIFLUSH, TCOFLUSH, TCIOFLUSH.

   Faking input
       TIOCSTI   const char *argp
              Insert the given byte in the input queue.

   Redirecting console output
       TIOCCONS  void
              Redirect  output  that  would  have  gone to /dev/console or /dev/tty0 to the given terminal.  If that was a
              pseudoterminal master, send it to the slave.  In Linux before version 2.6.10, anybody can do this as long as
              the  output  was  not redirected yet; since version 2.6.10, only a process with the CAP_SYS_ADMIN capability
              may do this.  If output was redirected already EBUSY is returned, but redirection can be  stopped  by  using
              this ioctl with fd pointing at /dev/console or /dev/tty0.

   Controlling terminal
       TIOCSCTTY int arg
              Make the given terminal the controlling terminal of the calling process.  The calling process must be a ses‐
              sion leader and not have a controlling terminal already.  For this case, arg should be specified as zero.

              If this terminal is already the controlling terminal of a different session group, then the ioctl fails with
              EPERM,  unless  the  caller has the CAP_SYS_ADMIN capability and arg equals 1, in which case the terminal is
              stolen, and all processes that had it as controlling terminal lose it.

       TIOCNOTTY void
              If the given terminal was the controlling terminal of the calling process, give up this  controlling  termi‐
              nal.   If  the  process was session leader, then send SIGHUP and SIGCONT to the foreground process group and
              all processes in the current session lose their controlling terminal.

   Process group and session ID
       TIOCGPGRP pid_t *argp
              When successful, equivalent to *argp = tcgetpgrp(fd).
              Get the process group ID of the foreground process group on this terminal.

       TIOCSPGRP const pid_t *argp
              Equivalent to tcsetpgrp(fd, *argp).
              Set the foreground process group ID of this terminal.

       TIOCGSID  pid_t *argp
              Get the session ID of the given terminal.  This fails with the error ENOTTY if the terminal is not a  master
              pseudoterminal and not our controlling terminal.  Strange.

   Exclusive mode
       TIOCEXCL  void
              Put  the  terminal into exclusive mode.  No further open(2) operations on the terminal are permitted.  (They
              fail with EBUSY, except for a process with the CAP_SYS_ADMIN capability.)

       TIOCGEXCL int *argp
              (since Linux 3.8) If the terminal is currently in exclusive mode, place a  nonzero  value  in  the  location
              pointed to by argp; otherwise, place zero in *argp.

       TIOCNXCL  void
              Disable exclusive mode.

   Line discipline
       TIOCGETD  int *argp
              Get the line discipline of the terminal.

       TIOCSETD  const int *argp
              Set the line discipline of the terminal.

   Pseudoterminal ioctls
       TIOCPKT   const int *argp
              Enable  (when *argp is nonzero) or disable packet mode.  Can be applied to the master side of a pseudotermi‐
              nal only (and will return ENOTTY otherwise).  In packet mode, each subsequent read(2) will return  a  packet
              that  either  contains a single nonzero control byte, or has a single byte containing zero (' ') followed by
              data written on the slave side of the pseudoterminal.  If the first byte is not TIOCPKT_DATA (0), it  is  an
              OR of one or more of the following bits:

              TIOCPKT_FLUSHREAD   The read queue for the terminal is flushed.
              TIOCPKT_FLUSHWRITE  The write queue for the terminal is flushed.
              TIOCPKT_STOP        Output to the terminal is stopped.
              TIOCPKT_START       Output to the terminal is restarted.
              TIOCPKT_DOSTOP      The start and stop characters are ^S/^Q.
              TIOCPKT_NOSTOP      The start and stop characters are not ^S/^Q.

              While this mode is in use, the presence of control status information to be read from the master side may be
              detected by a select(2) for exceptional conditions or a poll(2) for the POLLPRI event.

              This mode is used by rlogin(1) and rlogind(8) to implement a remote-echoed,  locally  ^S/^Q  flow-controlled
              remote login.

       TIOCGPKT  const int *argp
              (since Linux 3.8) Return the current packet mode setting in the integer pointed to by argp.

       TIOCSPTLCK     int *argp
              Set  (if  *argp  is  nonzero)  or  remove  (if  *argp  is  zero) the pseudoterminal slave device.  (See also
              unlockpt(3).)

       TIOCGPTLCK     int *argp
              (since Linux 3.8) Place the current lock state of the pseudoterminal slave device in the location pointed to
              by argp.

       TIOCGPTPEER    int flags
              (since  Linux  4.13)  Given  a  file descriptor in fd that refers to a pseudoterminal master, open (with the
              given open(2)-style flags) and return a new file descriptor that refers to  the  peer  pseudoterminal  slave
              device.   This operation can be performed regardless of whether the pathname of the slave device is accessi‐
              ble through the calling process's mount namespace.

              Security-conscious programs interacting with namespaces may wish to use this operation rather  than  open(2)
              with the pathname returned by ptsname(3), and similar library functions that have insecure APIs.  (For exam‐
              ple, confusion can occur in some cases using ptsname(3) with a pathname where a devpts filesystem  has  been
              mounted in a different mount namespace.)

       The BSD ioctls TIOCSTOP, TIOCSTART, TIOCUCNTL, TIOCREMOTE have not been implemented under Linux.

   Modem control
       TIOCMGET  int *argp
              Get the status of modem bits.

       TIOCMSET  const int *argp
              Set the status of modem bits.

       TIOCMBIC  const int *argp
              Clear the indicated modem bits.

       TIOCMBIS  const int *argp
              Set the indicated modem bits.

       The following bits are used by the above ioctls:

       TIOCM_LE        DSR (data set ready/line enable)
       TIOCM_DTR       DTR (data terminal ready)
       TIOCM_RTS       RTS (request to send)
       TIOCM_ST        Secondary TXD (transmit)
       TIOCM_SR        Secondary RXD (receive)
       TIOCM_CTS       CTS (clear to send)
       TIOCM_CAR       DCD (data carrier detect)
       TIOCM_CD         see TIOCM_CAR
       TIOCM_RNG       RNG (ring)
       TIOCM_RI         see TIOCM_RNG
       TIOCM_DSR       DSR (data set ready)

       TIOCMIWAIT     int arg
              Wait for any of the 4 modem bits (DCD, RI, DSR, CTS) to change.  The bits of interest are specified as a bit
              mask in arg, by ORing together any of the bit values, TIOCM_RNG, TIOCM_DSR, TIOCM_CD,  and  TIOCM_CTS.   The
              caller should use TIOCGICOUNT to see which bit has changed.

       TIOCGICOUNT    struct serial_icounter_struct *argp
              Get  counts  of  input  serial  line  interrupts  (DCD,  RI,  DSR,  CTS).   The  counts  are  written to the
              serial_icounter_struct structure pointed to by argp.

              Note: both 1->0 and 0->1 transitions are counted, except for RI, where only 0->1 transitions are counted.

   Marking a line as local
       TIOCGSOFTCAR   int *argp
              ("Get software carrier flag") Get the status of the CLOCAL flag in the c_cflag field of the  termios  struc‐
              ture.

       TIOCSSOFTCAR   const int *argp
              ("Set  software carrier flag") Set the CLOCAL flag in the termios structure when *argp is nonzero, and clear
              it otherwise.

       If the CLOCAL flag for a line is off, the hardware carrier detect (DCD) signal is significant, and  an  open(2)  of
       the  corresponding  terminal  will  block until DCD is asserted, unless the O_NONBLOCK flag is given.  If CLOCAL is
       set, the line behaves as if DCD is always asserted.  The software carrier flag  is  usually  turned  on  for  local
       devices, and is off for lines with modems.

   Linux-specific
       For the TIOCLINUX ioctl, see ioctl_console(2).

   Kernel debugging
       #include <linux/tty.h>

       TIOCTTYGSTRUCT struct tty_struct *argp
              Get the tty_struct corresponding to fd.  This command was removed in Linux 2.5.67.

RETURN VALUE
       The ioctl(2) system call returns 0 on success.  On error, it returns -1 and sets errno appropriately.

ERRORS
       EINVAL Invalid command parameter.

       ENOIOCTLCMD
              Unknown command.

       ENOTTY Inappropriate fd.

       EPERM  Insufficient permission.

EXAMPLE
       Check the condition of DTR on the serial port.

       #include <termios.h>
       #include <fcntl.h>
       #include <sys/ioctl.h>

       int
       main(void)
       {
           int fd, serial;

           fd = open("/dev/ttyS0", O_RDONLY);
           ioctl(fd, TIOCMGET, &serial);
           if (serial & TIOCM_DTR)
               puts("TIOCM_DTR is set");
           else
               puts("TIOCM_DTR is not set");
           close(fd);
       }

SEE ALSO
       ldattach(1), ioctl(2), ioctl_console(2), termios(3), pty(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            IOCTL_TTY(2)
</pre>
<pre zoom>
<span xsmall>2 kcmp</span>
KCMP(2)                                          Linux Programmer's Manual                                         KCMP(2)

NAME
       kcmp - compare two processes to determine if they share a kernel resource

SYNOPSIS
       #include <linux/kcmp.h>

       int kcmp(pid_t pid1, pid_t pid2, int type,
                unsigned long idx1, unsigned long idx2);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       The  kcmp()  system  call can be used to check whether the two processes identified by pid1 and pid2 share a kernel
       resource such as virtual memory, file descriptors, and so on.

       Permission to employ kcmp() is governed by ptrace access mode PTRACE_MODE_READ_REALCREDS checks against  both  pid1
       and pid2; see ptrace(2).

       The  type  argument  specifies  which resource is to be compared in the two processes.  It has one of the following
       values:

       KCMP_FILE
              Check whether a file descriptor idx1 in the process pid1 refers to  the  same  open  file  description  (see
              open(2))  as  file descriptor idx2 in the process pid2.  The existence of two file descriptors that refer to
              the same open file description can occur as a result of  dup(2)  (and  similar)  fork(2),  or  passing  file
              descriptors via a domain socket (see unix(7)).

       KCMP_FILES
              Check  whether  the  processes share the same set of open file descriptors.  The arguments idx1 and idx2 are
              ignored.  See the discussion of the CLONE_FILES flag in clone(2).

       KCMP_FS
              Check whether the processes share the same filesystem information (i.e., file mode  creation  mask,  working
              directory,  and  filesystem  root).   The  arguments  idx1  and idx2 are ignored.  See the discussion of the
              CLONE_FS flag in clone(2).

       KCMP_IO
              Check whether the processes share I/O context.  The arguments idx1 and idx2 are ignored.  See the discussion
              of the CLONE_IO flag in clone(2).

       KCMP_SIGHAND
              Check  whether  the  processes share the same table of signal dispositions.  The arguments idx1 and idx2 are
              ignored.  See the discussion of the CLONE_SIGHAND flag in clone(2).

       KCMP_SYSVSEM
              Check whether the processes share the same list of System V semaphore undo operations.  The  arguments  idx1
              and idx2 are ignored.  See the discussion of the CLONE_SYSVSEM flag in clone(2).

       KCMP_VM
              Check whether the processes share the same address space.  The arguments idx1 and idx2 are ignored.  See the
              discussion of the CLONE_VM flag in clone(2).

       KCMP_EPOLL_TFD (since Linux 4.13)
              Check whether the file descriptor idx1 of the process pid1 is present in the epoll(7) instance described  by
              idx2 of the process pid2.  The argument idx2 is a pointer to a structure where the target file is described.
              This structure has the form:

           struct kcmp_epoll_slot {
               __u32 efd;
               __u32 tfd;
               __u64 toff;
           };

       Within this structure, efd is an epoll file descriptor returned from epoll_create(2), tfd is a target file descrip‐
       tor  number,  and toff is a target file offset counted from zero.  Several different targets may be registered with
       the same file descriptor number and setting a specific offset helps to investigate each of them.

       Note the kcmp() is not protected against false positives which may occur if the processes  are  currently  running.
       One  should  stop  the  processes  by  sending SIGSTOP (see signal(7)) prior to inspection with this system call to
       obtain meaningful results.

RETURN VALUE
       The return value of a successful call to kcmp() is simply the result of arithmetic comparison  of  kernel  pointers
       (when the kernel compares resources, it uses their memory addresses).

       The  easiest  way  to  explain  is to consider an example.  Suppose that v1 and v2 are the addresses of appropriate
       resources, then the return value is one of the following:

           0   v1 is equal to v2; in other words, the two processes share the resource.

           1   v1 is less than v2.

           2   v1 is greater than v2.

           3   v1 is not equal to v2, but ordering information is unavailable.

       On error, -1 is returned, and errno is set appropriately.

       kcmp() was designed to return values suitable for sorting.  This is particularly handy if one needs  to  compare  a
       large number of file descriptors.

ERRORS
       EBADF  type is KCMP_FILE and fd1 or fd2 is not an open file descriptor.

       EINVAL type is invalid.

       EPERM  Insufficient  permission to inspect process resources.  The CAP_SYS_PTRACE capability is required to inspect
              processes that you do not own.  Other ptrace limitations  may  also  apply,  such  as  CONFIG_SECURITY_YAMA,
              which, when /proc/sys/kernel/yama/ptrace_scope is 2, limits kcmp() to child processes; see ptrace(2).

       ESRCH  Process pid1 or pid2 does not exist.

       EFAULT The epoll slot addressed by idx2 is outside of the user's address space.

       ENOENT The target file is not present in epoll(7) instance.

VERSIONS
       The kcmp() system call first appeared in Linux 3.5.

CONFORMING TO
       kcmp() is Linux-specific and should not be used in programs intended to be portable.

NOTES
       Glibc does not provide a wrapper for this system call; call it using syscall(2).

       This  system  call  is available only if the kernel was configured with CONFIG_CHECKPOINT_RESTORE.  The main use of
       the system call is for the checkpoint/restore in user space (CRIU) feature.  The alternative to  this  system  call
       would have been to expose suitable process information via the proc(5) filesystem; this was deemed to be unsuitable
       for security reasons.

       See clone(2) for some background information on the shared resources referred to on this page.

EXAMPLE
       The program below uses kcmp() to test whether pairs of file descriptors refer to the same  open  file  description.
       The  program  tests  different cases for the file descriptor pairs, as described in the program output.  An example
       run of the program is as follows:

           $ ./a.out
           Parent PID is 1144
           Parent opened file on FD 3

           PID of child of fork() is 1145
                Compare duplicate FDs from different processes:
                     kcmp(1145, 1144, KCMP_FILE, 3, 3) ==> same
           Child opened file on FD 4
                Compare FDs from distinct open()s in same process:
                     kcmp(1145, 1145, KCMP_FILE, 3, 4) ==> different
           Child duplicated FD 3 to create FD 5
                Compare duplicated FDs in same process:
                     kcmp(1145, 1145, KCMP_FILE, 3, 5) ==> same

   Program source

       #define _GNU_SOURCE
       #include <sys/syscall.h>
       #include <sys/wait.h>
       #include <sys/stat.h>
       #include <stdlib.h>
       #include <stdio.h>
       #include <unistd.h>
       #include <fcntl.h>
       #include <linux/kcmp.h>

       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       static int
       kcmp(pid_t pid1, pid_t pid2, int type,
            unsigned long idx1, unsigned long idx2)
       {
           return syscall(SYS_kcmp, pid1, pid2, type, idx1, idx2);
       }

       static void
       test_kcmp(char *msg, id_t pid1, pid_t pid2, int fd_a, int fd_b)
       {
           printf("\t%s\n", msg);
           printf("\t\tkcmp(%ld, %ld, KCMP_FILE, %d, %d) ==> %s\n",
                   (long) pid1, (long) pid2, fd_a, fd_b,
                   (kcmp(pid1, pid2, KCMP_FILE, fd_a, fd_b) == 0) ?
                               "same" : "different");
       }

       int
       main(int argc, char *argv[])
       {
           int fd1, fd2, fd3;
           char pathname[] = "/tmp/kcmp.test";

           fd1 = open(pathname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
           if (fd1 == -1)
               errExit("open");

           printf("Parent PID is %ld\n", (long) getpid());
           printf("Parent opened file on FD %d\n\n", fd1);

           switch (fork()) {
           case -1:
               errExit("fork");

           case 0:
               printf("PID of child of fork() is %ld\n", (long) getpid());

               test_kcmp("Compare duplicate FDs from different processes:",
                       getpid(), getppid(), fd1, fd1);

               fd2 = open(pathname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
               if (fd2 == -1)
                   errExit("open");
               printf("Child opened file on FD %d\n", fd2);

               test_kcmp("Compare FDs from distinct open()s in same process:",
                       getpid(), getpid(), fd1, fd2);

               fd3 = dup(fd1);
               if (fd3 == -1)
                   errExit("dup");
               printf("Child duplicated FD %d to create FD %d\n", fd1, fd3);

               test_kcmp("Compare duplicated FDs in same process:",
                       getpid(), getpid(), fd1, fd3);
               break;

           default:
               wait(NULL);
           }

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       clone(2), unshare(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 KCMP(2)
</pre>
<pre zoom>
<span xsmall>2 mmap</span>
MMAP(2)                                          Linux Programmer's Manual                                         MMAP(2)

NAME
       mmap, munmap - map or unmap files or devices into memory

SYNOPSIS
       #include <sys/mman.h>

       void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);
       int munmap(void *addr, size_t length);

       See NOTES for information on feature test macro requirements.

DESCRIPTION
       mmap() creates a new mapping in the virtual address space of the calling process.  The starting address for the new
       mapping is specified in addr.  The length argument specifies the length of the mapping (which must be greater  than
       0).

       If  addr  is  NULL,  then the kernel chooses the (page-aligned) address at which to create the mapping; this is the
       most portable method of creating a new mapping.  If addr is not NULL, then the kernel takes  it  as  a  hint  about
       where  to  place  the mapping; on Linux, the mapping will be created at a nearby page boundary.  The address of the
       new mapping is returned as the result of the call.

       The contents of a file mapping (as opposed to an anonymous mapping; see MAP_ANONYMOUS below), are initialized using
       length bytes starting at offset offset in the file (or other object) referred to by the file descriptor fd.  offset
       must be a multiple of the page size as returned by sysconf(_SC_PAGE_SIZE).

       The prot argument describes the desired memory protection of the mapping (and must not conflict with the open  mode
       of the file).  It is either PROT_NONE or the bitwise OR of one or more of the following flags:

       PROT_EXEC  Pages may be executed.

       PROT_READ  Pages may be read.

       PROT_WRITE Pages may be written.

       PROT_NONE  Pages may not be accessed.

       The  flags  argument  determines  whether  updates  to  the mapping are visible to other processes mapping the same
       region, and whether updates are carried through to the underlying file.  This behavior is determined  by  including
       exactly one of the following values in flags:

       MAP_SHARED
              Share  this mapping.  Updates to the mapping are visible to other processes mapping the same region, and (in
              the case of file-backed mappings) are carried through to the underlying file.  (To  precisely  control  when
              updates are carried through to the underlying file requires the use of msync(2).)

       MAP_SHARED_VALIDATE (since Linux 4.15)
              This  flag  provides the same behavior as MAP_SHARED except that MAP_SHARED mappings ignore unknown flags in
              flags.  By contrast, when creating a mapping using MAP_SHARED_VALIDATE, the kernel verifies all passed flags
              are  known  and  fails  the  mapping with the error EOPNOTSUPP for unknown flags.  This mapping type is also
              required to be able to use some mapping flags (e.g., MAP_SYNC).

       MAP_PRIVATE
              Create a private copy-on-write mapping.  Updates to the mapping are not visible to other  processes  mapping
              the  same  file, and are not carried through to the underlying file.  It is unspecified whether changes made
              to the file after the mmap() call are visible in the mapped region.

       Both MAP_SHARED and MAP_PRIVATE are described in POSIX.1-2001 and POSIX.1-2008.   MAP_SHARED_VALIDATE  is  a  Linux
       extension.

       In addition, zero or more of the following values can be ORed in flags:

       MAP_32BIT (since Linux 2.4.20, 2.6)
              Put  the  mapping  into  the first 2 Gigabytes of the process address space.  This flag is supported only on
              x86-64, for 64-bit programs.  It was added to allow thread stacks to be allocated  somewhere  in  the  first
              2 GB  of memory, so as to improve context-switch performance on some early 64-bit processors.  Modern x86-64
              processors no longer have this performance problem, so use of this flag is not required  on  those  systems.
              The MAP_32BIT flag is ignored when MAP_FIXED is set.

       MAP_ANON
              Synonym for MAP_ANONYMOUS.  Deprecated.

       MAP_ANONYMOUS
              The  mapping  is  not backed by any file; its contents are initialized to zero.  The fd argument is ignored;
              however, some implementations require fd to be -1 if MAP_ANONYMOUS (or MAP_ANON) is specified, and  portable
              applications  should ensure this.  The offset argument should be zero.  The use of MAP_ANONYMOUS in conjunc‐
              tion with MAP_SHARED is supported on Linux only since kernel 2.4.

       MAP_DENYWRITE
              This flag is ignored.  (Long ago—Linux 2.0 and earlier—it signaled that attempts to write to the  underlying
              file should fail with ETXTBUSY.  But this was a source of denial-of-service attacks.)

       MAP_EXECUTABLE
              This flag is ignored.

       MAP_FILE
              Compatibility flag.  Ignored.

       MAP_FIXED
              Don't  interpret  addr as a hint: place the mapping at exactly that address.  addr must be suitably aligned:
              for most architectures a multiple of the page size is sufficient; however,  some  architectures  may  impose
              additional restrictions.  If the memory region specified by addr and len overlaps pages of any existing map‐
              ping(s), then the overlapped part of the existing mapping(s) will be discarded.  If  the  specified  address
              cannot be used, mmap() will fail.

              Software that aspires to be portable should use the MAP_FIXED flag with care, keeping in mind that the exact
              layout of a process's memory mappings is allowed to change significantly between kernel versions, C  library
              versions, and operating system releases.  Carefully read the discussion of this flag in NOTES!

       MAP_FIXED_NOREPLACE (since Linux 4.17)
              This  flag  provides behavior that is similar to MAP_FIXED with respect to the addr enforcement, but differs
              in that MAP_FIXED_NOREPLACE never clobbers a preexisting mapped range.  If the requested range would collide
              with  an existing mapping, then this call fails with the error EEXIST.  This flag can therefore be used as a
              way to atomically (with respect to other threads) attempt to map an address range: one thread will  succeed;
              all others will report failure.

              Note that older kernels which do not recognize the MAP_FIXED_NOREPLACE flag will typically (upon detecting a
              collision with a preexisting mapping) fall back to a "non-MAP_FIXED" type of behavior: they will  return  an
              address  that is different from the requested address.  Therefore, backward-compatible software should check
              the returned address against the requested address.

       MAP_GROWSDOWN
              This flag is used for stacks.  It indicates to the kernel virtual memory  system  that  the  mapping  should
              extend  downward in memory.  The return address is one page lower than the memory area that is actually cre‐
              ated in the process's virtual address space.  Touching an address in the "guard" page below the mapping will
              cause  the  mapping to grow by a page.  This growth can be repeated until the mapping grows to within a page
              of the high end of the next lower mapping, at which point touching the "guard" page will result in a SIGSEGV
              signal.

       MAP_HUGETLB (since Linux 2.6.32)
              Allocate  the mapping using "huge pages."  See the Linux kernel source file Documentation/vm/hugetlbpage.txt
              for further information, as well as NOTES, below.

       MAP_HUGE_2MB, MAP_HUGE_1GB (since Linux 3.8)
              Used in conjunction with MAP_HUGETLB to select alternative hugetlb page sizes (respectively, 2 MB and  1 GB)
              on systems that support multiple hugetlb page sizes.

              More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired
              page size in the six bits at the offset MAP_HUGE_SHIFT.  (A value of zero in this  bit  field  provides  the
              default  huge  page size; the default huge page size can be discovered via the Hugepagesize field exposed by
              /proc/meminfo.)  Thus, the above two constants are defined as:

                  #define MAP_HUGE_2MB    (21 << MAP_HUGE_SHIFT)
                  #define MAP_HUGE_1GB    (30 << MAP_HUGE_SHIFT)

              The range of huge page sizes that are supported by the system can be discovered by listing  the  subdirecto‐
              ries in /sys/kernel/mm/hugepages.

       MAP_LOCKED (since Linux 2.5.37)
              Mark  the  mapped region to be locked in the same way as mlock(2).  This implementation will try to populate
              (prefault) the whole range but the mmap() call doesn't fail with ENOMEM  if  this  fails.   Therefore  major
              faults  might  happen  later  on.  So the semantic is not as strong as mlock(2).  One should use mmap() plus
              mlock(2) when major faults are not acceptable after the initialization of the mapping.  The MAP_LOCKED  flag
              is ignored in older kernels.

       MAP_NONBLOCK (since Linux 2.5.46)
              This flag is meaningful only in conjunction with MAP_POPULATE.  Don't perform read-ahead: create page tables
              entries only for pages that are already present in RAM.  Since Linux 2.6.23, this flag  causes  MAP_POPULATE
              to do nothing.  One day, the combination of MAP_POPULATE and MAP_NONBLOCK may be reimplemented.

       MAP_NORESERVE
              Do  not  reserve swap space for this mapping.  When swap space is reserved, one has the guarantee that it is
              possible to modify the mapping.  When swap space is not reserved one might get SIGSEGV upon a  write  if  no
              physical  memory  is  available.   See  also  the  discussion  of the file /proc/sys/vm/overcommit_memory in
              proc(5).  In kernels before 2.6, this flag had effect only for private writable mappings.

       MAP_POPULATE (since Linux 2.5.46)
              Populate (prefault) page tables for a mapping.  For a file mapping, this  causes  read-ahead  on  the  file.
              This will help to reduce blocking on page faults later.  MAP_POPULATE is supported for private mappings only
              since Linux 2.6.23.

       MAP_STACK (since Linux 2.6.27)
              Allocate the mapping at an address suitable for a process or thread stack.  This flag is currently a  no-op,
              but  is  used  in the glibc threading implementation so that if some architectures require special treatment
              for stack allocations, support can later be transparently implemented for glibc.

       MAP_SYNC (since Linux 4.15)
              This flag is available only with the MAP_SHARED_VALIDATE mapping type;  mappings  of  type  MAP_SHARED  will
              silently  ignore this flag.  This flag is supported only for files supporting DAX (direct mapping of persis‐
              tent memory).  For other files, creating a mapping with this flag results in an EOPNOTSUPP error.

              Shared file mappings with this flag provide the guarantee that while some memory is writably mapped  in  the
              address  space  of the process, it will be visible in the same file at the same offset even after the system
              crashes or is rebooted.  In conjunction with the use of appropriate CPU instructions, this provides users of
              such mappings with a more efficient way of making data modifications persistent.

       MAP_UNINITIALIZED (since Linux 2.6.33)
              Don't  clear  anonymous pages.  This flag is intended to improve performance on embedded devices.  This flag
              is honored only if the kernel was configured with the CONFIG_MMAP_ALLOW_UNINITIALIZED  option.   Because  of
              the security implications, that option is normally enabled only on embedded devices (i.e., devices where one
              has complete control of the contents of user memory).

       Of the above flags, only MAP_FIXED is specified in POSIX.1-2001 and POSIX.1-2008.  However, most systems also  sup‐
       port MAP_ANONYMOUS (or its synonym MAP_ANON).

       Memory mapped by mmap() is preserved across fork(2), with the same attributes.

       A  file is mapped in multiples of the page size.  For a file that is not a multiple of the page size, the remaining
       memory is zeroed when mapped, and writes to that region are not written out to the file.  The  effect  of  changing
       the  size  of the underlying file of a mapping on the pages that correspond to added or removed regions of the file
       is unspecified.

   munmap()
       The munmap() system call deletes the mappings for the specified address range, and  causes  further  references  to
       addresses  within  the range to generate invalid memory references.  The region is also automatically unmapped when
       the process is terminated.  On the other hand, closing the file descriptor does not unmap the region.

       The address addr must be a multiple of the page size (but length need not be).  All pages containing a part of  the
       indicated  range  are unmapped, and subsequent references to these pages will generate SIGSEGV.  It is not an error
       if the indicated range does not contain any mapped pages.

RETURN VALUE
       On success, mmap() returns a pointer to the mapped area.  On error, the value MAP_FAILED (that is, (void *) -1)  is
       returned, and errno is set to indicate the cause of the error.

       On  success,  munmap()  returns  0.  On failure, it returns -1, and errno is set to indicate the cause of the error
       (probably to EINVAL).

ERRORS
       EACCES A file descriptor refers to a non-regular file.  Or a file mapping was requested, but fd  is  not  open  for
              reading.  Or MAP_SHARED was requested and PROT_WRITE is set, but fd is not open in read/write (O_RDWR) mode.
              Or PROT_WRITE is set, but the file is append-only.

       EAGAIN The file has been locked, or too much memory has been locked (see setrlimit(2)).

       EBADF  fd is not a valid file descriptor (and MAP_ANONYMOUS was not set).

       EEXIST MAP_FIXED_NOREPLACE was specified in flags, and the range covered by addr and  length  is  clashes  with  an
              existing mapping.

       EINVAL We don't like addr, length, or offset (e.g., they are too large, or not aligned on a page boundary).

       EINVAL (since Linux 2.6.12) length was 0.

       EINVAL flags contained neither MAP_PRIVATE or MAP_SHARED, or contained both of these values.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENODEV The underlying filesystem of the specified file does not support memory mapping.

       ENOMEM No memory is available.

       ENOMEM The  process's maximum number of mappings would have been exceeded.  This error can also occur for munmap(),
              when unmapping a region in the middle of an existing mapping, since this results in two smaller mappings  on
              either side of the region being unmapped.

       ENOMEM (since Linux 4.7) The process's RLIMIT_DATA limit, described in getrlimit(2), would have been exceeded.

       EOVERFLOW
              On  32-bit  architecture  together  with  the large file extension (i.e., using 64-bit off_t): the number of
              pages used for length plus number of pages used for offset would overflow unsigned long (32 bits).

       EPERM  The prot argument asks for PROT_EXEC but the mapped area belongs to a file on a filesystem that was  mounted
              no-exec.

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       ETXTBSY
              MAP_DENYWRITE was set but the object specified by fd is open for writing.

       Use of a mapped region can result in these signals:

       SIGSEGV
              Attempted write into a region mapped as read-only.

       SIGBUS Attempted  access  to  a portion of the buffer that does not correspond to the file (for example, beyond the
              end of the file, including the case where another process has truncated the file).

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌───────────────────┬───────────────┬─────────┐
       │Interface          │ Attribute     │ Value   │
       ├───────────────────┼───────────────┼─────────┤
       │mmap(), munmap()   │ Thread safety │ MT-Safe │
       └───────────────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD.

AVAILABILITY
       On POSIX systems on which  mmap(),  msync(2),  and  munmap()  are  available,  _POSIX_MAPPED_FILES  is  defined  in
       <unistd.h> to a value greater than 0.  (See also sysconf(3).)

NOTES
       On  some  hardware  architectures (e.g., i386), PROT_WRITE implies PROT_READ.  It is architecture dependent whether
       PROT_READ implies PROT_EXEC or not.  Portable programs should always set PROT_EXEC if they intend to  execute  code
       in the new mapping.

       The  portable way to create a mapping is to specify addr as 0 (NULL), and omit MAP_FIXED from flags.  In this case,
       the system chooses the address for the mapping; the address is chosen so as not to conflict with any existing  map‐
       ping, and will not be 0.  If the MAP_FIXED flag is specified, and addr is 0 (NULL), then the mapped address will be
       0 (NULL).

       Certain flags constants are defined only if suitable  feature  test  macros  are  defined  (possibly  by  default):
       _DEFAULT_SOURCE  with  glibc  2.19  or later; or _BSD_SOURCE or _SVID_SOURCE in glibc 2.19 and earlier.  (Employing
       _GNU_SOURCE also suffices, and requiring that macro specifically would have been more logical,  since  these  flags
       are  all  Linux-specific.)   The relevant flags are: MAP_32BIT, MAP_ANONYMOUS (and the synonym MAP_ANON), MAP_DENY‐
       WRITE, MAP_EXECUTABLE, MAP_FILE, MAP_GROWSDOWN, MAP_HUGETLB, MAP_LOCKED, MAP_NONBLOCK, MAP_NORESERVE, MAP_POPULATE,
       and MAP_STACK.

       An  application  can  determine which pages of a mapping are currently resident in the buffer/page cache using min‐
       core(2).

   Using MAP_FIXED safely
       The only safe use for MAP_FIXED is where the address range specified by addr and  length  was  previously  reserved
       using  another  mapping;  otherwise, the use of MAP_FIXED is hazardous because it forcibly removes preexisting map‐
       pings, making it easy for a multithreaded process to corrupt its own address space.

       For example, suppose that thread A looks through /proc/<pid>/maps and in order to locate an  unused  address  range
       that  it  can  map  using MAP_FIXED, while thread B simultaneously acquires part or all of that same address range.
       When thread A subsequently employs mmap(MAP_FIXED), it will effectively clobber the mapping that thread B  created.
       In  this scenario, thread B need not create a mapping directly; simply making a library call that, internally, uses
       dlopen(3) to load some other shared library, will suffice.  The dlopen(3)  call  will  map  the  library  into  the
       process's  address  space.   Furthermore, almost any library call may be implemented in a way that adds memory map‐
       pings to the address space, either with this technique, or by simply allocating memory.  Examples  include  brk(2),
       malloc(3), pthread_create(3), and the PAM libraries ⟨http://www.linux-pam.org⟩.

       Since  Linux 4.17, a multithreaded program can use the MAP_FIXED_NOREPLACE flag to avoid the hazard described above
       when attempting to create a mapping at a fixed address that has not been reserved by a preexisting mapping.

   Timestamps changes for file-backed mappings
       For file-backed mappings, the st_atime field for the mapped file may be updated at any time between the mmap()  and
       the corresponding unmapping; the first reference to a mapped page will update the field if it has not been already.

       The  st_ctime  and st_mtime field for a file mapped with PROT_WRITE and MAP_SHARED will be updated after a write to
       the mapped region, and before a subsequent msync(2) with the MS_SYNC or MS_ASYNC flag, if one occurs.

   Huge page (Huge TLB) mappings
       For mappings that employ huge pages, the requirements for the arguments of mmap() and munmap() differ somewhat from
       the requirements for mappings that use the native system page size.

       For  mmap(), offset must be a multiple of the underlying huge page size.  The system automatically aligns length to
       be a multiple of the underlying huge page size.

       For munmap(), addr and length must both be a multiple of the underlying huge page size.

   C library/kernel differences
       This page describes the interface provided by the glibc mmap() wrapper function.  Originally, this function invoked
       a  system  call of the same name.  Since kernel 2.4, that system call has been superseded by mmap2(2), and nowadays
       the glibc mmap() wrapper function invokes mmap2(2) with a suitably adjusted value for offset.

BUGS
       On Linux, there are no guarantees like those suggested above under MAP_NORESERVE.  By default, any process  can  be
       killed at any moment when the system runs out of memory.

       In kernels before 2.6.7, the MAP_POPULATE flag has effect only if prot is specified as PROT_NONE.

       SUSv3  specifies  that  mmap()  should fail if length is 0.  However, in kernels before 2.6.12, mmap() succeeded in
       this case: no mapping was created and the call returned addr.  Since kernel 2.6.12, mmap()  fails  with  the  error
       EINVAL for this case.

       POSIX  specifies  that  the system shall always zero fill any partial page at the end of the object and that system
       will never write any modification of the object beyond its end.  On Linux, when you write data to such partial page
       after  the  end of the object, the data stays in the page cache even after the file is closed and unmapped and even
       though the data is never written to the file itself, subsequent mappings may see the  modified  content.   In  some
       cases, this could be fixed by calling msync(2) before the unmap takes place; however, this doesn't work on tmpfs(5)
       (for example, when using the POSIX shared memory interface documented in shm_overview(7)).

EXAMPLE
       The following program prints part of the file specified in its first command-line argument to standard output.  The
       range  of  bytes to be printed is specified via offset and length values in the second and third command-line argu‐
       ments.  The program creates a memory mapping of the required pages of the file and then uses write(2) to output the
       desired bytes.

   Program source
       #include <sys/mman.h>
       #include <sys/stat.h>
       #include <fcntl.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>

       #define handle_error(msg) \
           do { perror(msg); exit(EXIT_FAILURE); } while (0)

       int
       main(int argc, char *argv[])
       {
           char *addr;
           int fd;
           struct stat sb;
           off_t offset, pa_offset;
           size_t length;
           ssize_t s;

           if (argc < 3 || argc > 4) {
               fprintf(stderr, "%s file offset [length]\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           fd = open(argv[1], O_RDONLY);
           if (fd == -1)
               handle_error("open");

           if (fstat(fd, &sb) == -1)           /* To obtain file size */
               handle_error("fstat");

           offset = atoi(argv[2]);
           pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);
               /* offset for mmap() must be page aligned */

           if (offset >= sb.st_size) {
               fprintf(stderr, "offset is past end of file\n");
               exit(EXIT_FAILURE);
           }

           if (argc == 4) {
               length = atoi(argv[3]);
               if (offset + length > sb.st_size)
                   length = sb.st_size - offset;
                       /* Can't display bytes past end of file */

           } else {    /* No length arg ==> display to end of file */
               length = sb.st_size - offset;
           }

           addr = mmap(NULL, length + offset - pa_offset, PROT_READ,
                       MAP_PRIVATE, fd, pa_offset);
           if (addr == MAP_FAILED)
               handle_error("mmap");

           s = write(STDOUT_FILENO, addr + offset - pa_offset, length);
           if (s != length) {
               if (s == -1)
                   handle_error("write");

               fprintf(stderr, "partial write");
               exit(EXIT_FAILURE);
           }

           munmap(addr, length + offset - pa_offset);
           close(fd);

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ftruncate(2),  getpagesize(2),  memfd_create(2),  mincore(2), mlock(2), mmap2(2), mprotect(2), mremap(2), msync(2),
       remap_file_pages(2), setrlimit(2), shmat(2), userfaultfd(2), shm_open(3), shm_overview(7)

       The descriptions of the following files in proc(5): /proc/[pid]/maps, /proc/[pid]/map_files, and /proc/[pid]/smaps.

       B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128–129 and 389–391.

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                                 MMAP(2)
</pre>
<pre zoom>
<span xsmall>2 sysctl</span>
SYSCTL(2)                                        Linux Programmer's Manual                                       SYSCTL(2)

NAME
       sysctl - read/write system parameters

SYNOPSIS
       #include <unistd.h>
       #include <linux/sysctl.h>

       int _sysctl(struct __sysctl_args *args);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       Do not use this system call!  See NOTES.

       The _sysctl() call reads and/or writes kernel parameters.  For example, the hostname, or the maximum number of open
       files.  The argument has the form

           struct __sysctl_args {
               int    *name;    /* integer vector describing variable */
               int     nlen;    /* length of this vector */
               void   *oldval;  /* 0 or address where to store old value */
               size_t *oldlenp; /* available room for old value,
                                   overwritten by actual size of old value */
               void   *newval;  /* 0 or address of new value */
               size_t  newlen;  /* size of new value */
           };

       This call does a search in a tree structure, possibly resembling a directory  tree  under  /proc/sys,  and  if  the
       requested item is found calls some appropriate routine to read or modify the value.

RETURN VALUE
       Upon successful completion, _sysctl() returns 0.  Otherwise, a value of -1 is returned and errno is set to indicate
       the error.

ERRORS
       EACCES, EPERM
              No search permission for one of the encountered "directories",  or  no  read  permission  where  oldval  was
              nonzero, or no write permission where newval was nonzero.

       EFAULT The invocation asked for the previous value by setting oldval non-NULL, but allowed zero room in oldlenp.

       ENOTDIR
              name was not found.

CONFORMING TO
       This  call is Linux-specific, and should not be used in programs intended to be portable.  A sysctl() call has been
       present in Linux since version 1.3.57.  It originated in 4.4BSD.  Only Linux has  the  /proc/sys  mirror,  and  the
       object  naming schemes differ between Linux and 4.4BSD, but the declaration of the sysctl() function is the same in
       both.

NOTES
       Glibc does not provide a wrapper for this system call; call it using syscall(2).  Or rather...  don't call it:  use
       of this system call has long been discouraged, and it is so unloved that it is likely to disappear in a future ker‐
       nel version.  Since Linux 2.6.24, uses of this system call result in warnings in the kernel log.   Remove  it  from
       your programs now; use the /proc/sys interface instead.

       This system call is available only if the kernel was configured with the CONFIG_SYSCTL_SYSCALL option.

BUGS
       The object names vary between kernel versions, making this system call worthless for applications.

       Not all available objects are properly documented.

       It is not yet possible to change operating system by writing to /proc/sys/kernel/ostype.

EXAMPLE
       #define _GNU_SOURCE
       #include <unistd.h>
       #include <sys/syscall.h>
       #include <string.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <linux/sysctl.h>

       int _sysctl(struct __sysctl_args *args );

       #define OSNAMESZ 100

       int
       main(void)
       {
           struct __sysctl_args args;
           char osname[OSNAMESZ];
           size_t osnamelth;
           int name[] = { CTL_KERN, KERN_OSTYPE };

           memset(&args, 0, sizeof(struct __sysctl_args));
           args.name = name;
           args.nlen = sizeof(name)/sizeof(name[0]);
           args.oldval = osname;
           args.oldlenp = &osnamelth;

           osnamelth = sizeof(osname);

           if (syscall(SYS__sysctl, &args) == -1) {
               perror("_sysctl");
               exit(EXIT_FAILURE);
           }
           printf("This machine is running %*s\n", osnamelth, osname);
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       proc(5)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SYSCTL(2)
</pre>
<pre zoom>
<span xsmall>2 vserver</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 alarm</span>
ALARM(2)                                         Linux Programmer's Manual                                        ALARM(2)

NAME
       alarm - set an alarm clock for delivery of a signal

SYNOPSIS
       #include <unistd.h>

       unsigned int alarm(unsigned int seconds);

DESCRIPTION
       alarm() arranges for a SIGALRM signal to be delivered to the calling process in seconds seconds.

       If seconds is zero, any pending alarm is canceled.

       In any event any previously set alarm() is canceled.

RETURN VALUE
       alarm()  returns  the  number of seconds remaining until any previously scheduled alarm was due to be delivered, or
       zero if there was no previously scheduled alarm.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

NOTES
       alarm() and setitimer(2) share the same timer; calls to one will interfere with use of the other.

       Alarms created by alarm() are preserved across execve(2) and are not inherited by children created via fork(2).

       sleep(3) may be implemented using SIGALRM; mixing calls to alarm() and sleep(3) is a bad idea.

       Scheduling delays can, as ever, cause the execution of the process to be delayed by an arbitrary amount of time.

SEE ALSO
       gettimeofday(2), pause(2), select(2), setitimer(2), sigaction(2),  signal(2),  timer_create(2),  timerfd_create(2),
       sleep(3), time(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-05-03                                                ALARM(2)
</pre>
<pre zoom>
<span xsmall>2 syslog</span>
SYSLOG(2)                                        Linux Programmer's Manual                                       SYSLOG(2)

NAME
       syslog, klogctl - read and/or clear kernel message ring buffer; set console_loglevel

SYNOPSIS
       int syslog(int type, char *bufp, int len);
                       /* No wrapper provided in glibc */

       /* The glibc interface */
       #include <sys/klog.h>

       int klogctl(int type, char *bufp, int len);

DESCRIPTION
       Note:  Probably,  you are looking for the C library function syslog(), which talks to syslogd(8); see syslog(3) for
       details.

       This page describes the kernel syslog() system call, which is used to control the kernel printk() buffer; the glibc
       wrapper function for the system call is called klogctl().

   The kernel log buffer
       The  kernel  has  a cyclic buffer of length LOG_BUF_LEN in which messages given as arguments to the kernel function
       printk() are stored (regardless of their log level).  In early kernels, LOG_BUF_LEN had the value 4096; from kernel
       1.3.54,  it  was 8192; from kernel 2.1.113, it was 16384; since kernel 2.4.23/2.6, the value is a kernel configura‐
       tion option (CONFIG_LOG_BUF_SHIFT, default value dependent on the architecture).  Since Linux 2.6.6, the  size  can
       be queried with command type 10 (see below).

   Commands
       The type argument determines the action taken by this function.  The list below specifies the values for type.  The
       symbolic names are defined in the kernel source, but are not exported to user space; you will either  need  to  use
       the numbers, or define the names yourself.

       SYSLOG_ACTION_CLOSE (0)
              Close the log.  Currently a NOP.

       SYSLOG_ACTION_OPEN (1)
              Open the log.  Currently a NOP.

       SYSLOG_ACTION_READ (2)
              Read from the log.  The call waits until the kernel log buffer is nonempty, and then reads at most len bytes
              into the buffer pointed to by bufp.  The call returns the number of bytes read.  Bytes  read  from  the  log
              disappear  from the log buffer: the information can be read only once.  This is the function executed by the
              kernel when a user program reads /proc/kmsg.

       SYSLOG_ACTION_READ_ALL (3)
              Read all messages remaining in the ring buffer, placing them in the buffer pointed to  by  bufp.   The  call
              reads  the  last  len  bytes from the log buffer (nondestructively), but will not read more than was written
              into the buffer since the last "clear ring buffer" command (see command 5 below)).   The  call  returns  the
              number of bytes read.

       SYSLOG_ACTION_READ_CLEAR (4)
              Read and clear all messages remaining in the ring buffer.  The call does precisely the same as for a type of
              3, but also executes the "clear ring buffer" command.

       SYSLOG_ACTION_CLEAR (5)
              The call executes just the "clear ring buffer" command.  The bufp and len arguments are ignored.

              This command does not really clear the ring buffer.  Rather, it sets  a  kernel  bookkeeping  variable  that
              determines  the  results  returned  by commands 3 (SYSLOG_ACTION_READ_ALL) and 4 (SYSLOG_ACTION_READ_CLEAR).
              This command has no effect on commands 2 (SYSLOG_ACTION_READ) and 9 (SYSLOG_ACTION_SIZE_UNREAD).

       SYSLOG_ACTION_CONSOLE_OFF (6)
              The command saves the current value of console_loglevel  and  then  sets  console_loglevel  to  minimum_con‐
              sole_loglevel, so that no messages are printed to the console.  Before Linux 2.6.32, the command simply sets
              console_loglevel to minimum_console_loglevel.  See the discussion of /proc/sys/kernel/printk, below.

              The bufp and len arguments are ignored.

       SYSLOG_ACTION_CONSOLE_ON (7)
              If a previous SYSLOG_ACTION_CONSOLE_OFF command has been performed, this command  restores  console_loglevel
              to the value that was saved by that command.  Before Linux 2.6.32, this command simply sets console_loglevel
              to default_console_loglevel.  See the discussion of /proc/sys/kernel/printk, below.

              The bufp and len arguments are ignored.

       SYSLOG_ACTION_CONSOLE_LEVEL (8)
              The call sets console_loglevel to the value given in len, which must be an integer between 1 and  8  (inclu‐
              sive).  The kernel silently enforces a minimum value of minimum_console_loglevel for len.  See the log level
              section for details.  The bufp argument is ignored.

       SYSLOG_ACTION_SIZE_UNREAD (9) (since Linux 2.4.10)
              The call returns the number of bytes currently available to be read from the kernel log buffer via command 2
              (SYSLOG_ACTION_READ).  The bufp and len arguments are ignored.

       SYSLOG_ACTION_SIZE_BUFFER (10) (since Linux 2.6.6)
              This command returns the total size of the kernel log buffer.  The bufp and len arguments are ignored.

       All commands except 3 and 10 require privilege.  In Linux kernels before 2.6.37, command types 3 and 10 are allowed
       to unprivileged processes; since Linux 2.6.37, these  commands  are  allowed  to  unprivileged  processes  only  if
       /proc/sys/kernel/dmesg_restrict  has  the value 0.  Before Linux 2.6.37, "privileged" means that the caller has the
       CAP_SYS_ADMIN capability.  Since Linux 2.6.37, "privileged" means that the  caller  has  either  the  CAP_SYS_ADMIN
       capability (now deprecated for this purpose) or the (new) CAP_SYSLOG capability.

   /proc/sys/kernel/printk
       /proc/sys/kernel/printk  is  a writable file containing four integer values that influence kernel printk() behavior
       when printing or logging error messages.  The four values are:

       console_loglevel
              Only messages with a log level lower than this value will be printed to the console.  The default value  for
              this  field is DEFAULT_CONSOLE_LOGLEVEL (7), but it is set to 4 if the kernel command line contains the word
              "quiet", 10 if the kernel command line contains the word "debug", and to 15 in case of a kernel  fault  (the
              10 and 15 are just silly, and equivalent to 8).  The value of console_loglevel can be set (to a value in the
              range 1–8) by a syslog() call with a type of 8.

       default_message_loglevel
              This value will be used as the log level for printk() messages that do not have an explicit  level.   Up  to
              and  including  Linux  2.6.38, the hard-coded default value for this field was 4 (KERN_WARNING); since Linux
              2.6.39, the default value is a defined by the kernel configuration  option  CONFIG_DEFAULT_MESSAGE_LOGLEVEL,
              which defaults to 4.

       minimum_console_loglevel
              The value in this field is the minimum value to which console_loglevel can be set.

       default_console_loglevel
              This is the default value for console_loglevel.

   The log level
       Every printk() message has its own log level.  If the log level is not explicitly specified as part of the message,
       it defaults to default_message_loglevel.  The conventional meaning of the log level is as follows:

       Kernel constant   Level value   Meaning
       KERN_EMERG             0        System is unusable
       KERN_ALERT             1        Action must be taken immediately
       KERN_CRIT              2        Critical conditions
       KERN_ERR               3        Error conditions
       KERN_WARNING           4        Warning conditions
       KERN_NOTICE            5        Normal but significant condition
       KERN_INFO              6        Informational
       KERN_DEBUG             7        Debug-level messages

       The kernel printk() routine will print a message on the console only if it has a log level less than the  value  of
       console_loglevel.

RETURN VALUE
       For type equal to 2, 3, or 4, a successful call to syslog() returns the number of bytes read.  For type 9, syslog()
       returns the number of bytes currently available to be read on the kernel log buffer.  For type 10, syslog() returns
       the total size of the kernel log buffer.  For other values of type, 0 is returned on success.

       In case of error, -1 is returned, and errno is set to indicate the error.

ERRORS
       EINVAL Bad arguments (e.g., bad type; or for type 2, 3, or 4, buf is NULL, or len is less than zero; or for type 8,
              the level is outside the range 1 to 8).

       ENOSYS This syslog() system call is not available, because the kernel was compiled with the  CONFIG_PRINTK  kernel-
              configuration option disabled.

       EPERM  An  attempt was made to change console_loglevel or clear the kernel message ring buffer by a process without
              sufficient privilege (more precisely: without the CAP_SYS_ADMIN or CAP_SYSLOG capability).

       ERESTARTSYS
              System call was interrupted by a signal; nothing was read.  (This can be seen only during a trace.)

CONFORMING TO
       This system call is Linux-specific and should not be used in programs intended to be portable.

NOTES
       From the very start, people noted that it is unfortunate that a system call and a library routine of the same  name
       are entirely different animals.

SEE ALSO
       dmesg(1), syslog(3), capabilities(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SYSLOG(2)
</pre>
<pre zoom>
<span xsmall>2 getpmsg</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 tkill</span>
TKILL(2)                                         Linux Programmer's Manual                                        TKILL(2)

NAME
       tkill, tgkill - send a signal to a thread

SYNOPSIS
       int tkill(int tid, int sig);

       int tgkill(int tgid, int tid, int sig);

       Note: There are no glibc wrappers for these system calls; see NOTES.

DESCRIPTION
       tgkill() sends the signal sig to the thread with the thread ID tid in the thread group tgid.  (By contrast, kill(2)
       can be used to send a signal only to a process (i.e., thread group) as a whole, and the signal will be delivered to
       an arbitrary thread within that process.)

       tkill()  is  an  obsolete  predecessor to tgkill().  It allows only the target thread ID to be specified, which may
       result in the wrong thread being signaled if a thread terminates and its thread ID is recycled.  Avoid  using  this
       system call.

       These are the raw system call interfaces, meant for internal thread library use.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EINVAL An invalid thread ID, thread group ID, or signal was specified.

       EPERM  Permission denied.  For the required permissions, see kill(2).

       ESRCH  No process with the specified thread ID (and thread group ID) exists.

       EAGAIN The RLIMIT_SIGPENDING resource limit was reached and sig is a real-time signal.

       EAGAIN Insufficient kernel memory was available and sig is a real-time signal.

VERSIONS
       tkill() is supported since Linux 2.4.19 / 2.5.4.  tgkill() was added in Linux 2.5.75.

CONFORMING TO
       tkill() and tgkill() are Linux-specific and should not be used in programs that are intended to be portable.

NOTES
       See the description of CLONE_THREAD in clone(2) for an explanation of thread groups.

       Glibc does not provide wrappers for these system calls; call them using syscall(2).

SEE ALSO
       clone(2), gettid(2), kill(2), rt_sigqueueinfo(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                TKILL(2)
</pre>
<pre zoom>
<span xsmall>2 msgrcv</span>
MSGOP(2)                                         Linux Programmer's Manual                                        MSGOP(2)

NAME
       msgrcv, msgsnd - System V message queue operations

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);

       ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
                      int msgflg);

DESCRIPTION
       The  msgsnd()  and  msgrcv() system calls are used, respectively, to send messages to, and receive messages from, a
       System V message queue.  The calling process must have write permission on the message queue in  order  to  send  a
       message, and read permission to receive a message.

       The msgp argument is a pointer to a caller-defined structure of the following general form:

           struct msgbuf {
               long mtype;       /* message type, must be > 0 */
               char mtext[1];    /* message data */
           };

       The  mtext  field  is  an array (or other structure) whose size is specified by msgsz, a nonnegative integer value.
       Messages of zero length (i.e., no mtext field) are permitted.  The mtype field must have a strictly positive  inte‐
       ger  value.  This value can be used by the receiving process for message selection (see the description of msgrcv()
       below).

   msgsnd()
       The msgsnd() system call appends a copy of the message pointed to by msgp to the message queue whose identifier  is
       specified by msqid.

       If  sufficient  space  is available in the queue, msgsnd() succeeds immediately.  The queue capacity is governed by
       the msg_qbytes field in the associated data structure for the message queue.  During queue creation this  field  is
       initialized  to  MSGMNB bytes, but this limit can be modified using msgctl(2).  A message queue is considered to be
       full if either of the following conditions is true:

       * Adding a new message to the queue would cause the total number of bytes in the queue to exceed the queue's  maxi‐
         mum size (the msg_qbytes field).

       * Adding  another  message to the queue would cause the total number of messages in the queue to exceed the queue's
         maximum size (the msg_qbytes field).  This check is necessary to prevent an unlimited number of zero-length  mes‐
         sages being placed on the queue.  Although such messages contain no data, they nevertheless consume (locked) ker‐
         nel memory.

       If insufficient space is available in the queue, then the default behavior of msgsnd()  is  to  block  until  space
       becomes available.  If IPC_NOWAIT is specified in msgflg, then the call instead fails with the error EAGAIN.

       A blocked msgsnd() call may also fail if:

       * the queue is removed, in which case the system call fails with errno set to EIDRM; or

       * a  signal  is  caught,  in  which case the system call fails with errno set to EINTR;see signal(7).  (msgsnd() is
         never automatically restarted after being interrupted by a signal handler,  regardless  of  the  setting  of  the
         SA_RESTART flag when establishing a signal handler.)

       Upon successful completion the message queue data structure is updated as follows:

              msg_lspid is set to the process ID of the calling process.

              msg_qnum is incremented by 1.

              msg_stime is set to the current time.

   msgrcv()
       The msgrcv() system call removes a message from the queue specified by msqid and places it in the buffer pointed to
       by msgp.

       The argument msgsz specifies the maximum size in bytes for the member mtext of the structure pointed to by the msgp
       argument.   If  the message text has length greater than msgsz, then the behavior depends on whether MSG_NOERROR is
       specified in msgflg.  If MSG_NOERROR is specified, then the message text will be truncated (and the truncated  part
       will  be  lost); if MSG_NOERROR is not specified, then the message isn't removed from the queue and the system call
       fails returning -1 with errno set to E2BIG.

       Unless MSG_COPY is specified in msgflg (see below), the msgtyp argument specifies the type of message requested, as
       follows:

       * If msgtyp is 0, then the first message in the queue is read.

       * If  msgtyp  is  greater than 0, then the first message in the queue of type msgtyp is read, unless MSG_EXCEPT was
         specified in msgflg, in which case the first message in the queue of type not equal to msgtyp will be read.

       * If msgtyp is less than 0, then the first message in the queue with the lowest type less  than  or  equal  to  the
         absolute value of msgtyp will be read.

       The msgflg argument is a bit mask constructed by ORing together zero or more of the following flags:

       IPC_NOWAIT
              Return  immediately  if  no message of the requested type is in the queue.  The system call fails with errno
              set to ENOMSG.

       MSG_COPY (since Linux 3.8)
              Nondestructively fetch a copy of the message at the ordinal position in the queue specified by msgtyp  (mes‐
              sages are considered to be numbered starting at 0).

              This  flag  must  be  specified in conjunction with IPC_NOWAIT, with the result that, if there is no message
              available at the given position, the call fails immediately with the error ENOMSG.  Because they  alter  the
              meaning of msgtyp in orthogonal ways, MSG_COPY and MSG_EXCEPT may not both be specified in msgflg.

              The  MSG_COPY  flag was added for the implementation of the kernel checkpoint-restore facility and is avail‐
              able only if the kernel was built with the CONFIG_CHECKPOINT_RESTORE option.

       MSG_EXCEPT
              Used with msgtyp greater than 0 to read the first message in the queue with message type that  differs  from
              msgtyp.

       MSG_NOERROR
              To truncate the message text if longer than msgsz bytes.

       If  no  message of the requested type is available and IPC_NOWAIT isn't specified in msgflg, the calling process is
       blocked until one of the following conditions occurs:

       * A message of the desired type is placed in the queue.

       * The message queue is removed from the system.  In this case, the system call fails with errno set to EIDRM.

       * The calling process catches a signal.  In this case, the system call fails with errno set to EINTR.  (msgrcv() is
         never  automatically  restarted  after  being  interrupted  by a signal handler, regardless of the setting of the
         SA_RESTART flag when establishing a signal handler.)

       Upon successful completion the message queue data structure is updated as follows:

              msg_lrpid is set to the process ID of the calling process.

              msg_qnum is decremented by 1.

              msg_rtime is set to the current time.

RETURN VALUE
       On failure both functions return -1 with errno indicating the error, otherwise  msgsnd()  returns  0  and  msgrcv()
       returns the number of bytes actually copied into the mtext array.

ERRORS
       When msgsnd() fails, errno will be set to one among the following values:

       EACCES The calling process does not have write permission on the message queue, and does not have the CAP_IPC_OWNER
              capability.

       EAGAIN The message can't be sent due to the msg_qbytes limit for the queue and IPC_NOWAIT was specified in msgflg.

       EFAULT The address pointed to by msgp isn't accessible.

       EIDRM  The message queue was removed.

       EINTR  Sleeping on a full message queue condition, the process caught a signal.

       EINVAL Invalid msqid value, or nonpositive mtype value, or invalid msgsz value (less than 0  or  greater  than  the
              system value MSGMAX).

       ENOMEM The system does not have enough memory to make a copy of the message pointed to by msgp.

       When msgrcv() fails, errno will be set to one among the following values:

       E2BIG  The message text length is greater than msgsz and MSG_NOERROR isn't specified in msgflg.

       EACCES The  calling process does not have read permission on the message queue, and does not have the CAP_IPC_OWNER
              capability in the user namespace that governs its IPC namespace.

       EFAULT The address pointed to by msgp isn't accessible.

       EIDRM  While the process was sleeping to receive a message, the message queue was removed.

       EINTR  While the process was sleeping to receive a message, the process caught a signal; see signal(7).

       EINVAL msqid was invalid, or msgsz was less than 0.

       EINVAL (since Linux 3.14)
              msgflg specified MSG_COPY, but not IPC_NOWAIT.

       EINVAL (since Linux 3.14)
              msgflg specified both MSG_COPY and MSG_EXCEPT.

       ENOMSG IPC_NOWAIT was specified in msgflg and no message of the requested type existed on the message queue.

       ENOMSG IPC_NOWAIT and MSG_COPY were specified in msgflg and the queue contains less than msgtyp messages.

       ENOSYS (since Linux 3.8)
              MSG_COPY was specified in msgflg, and this kernel was configured without CONFIG_CHECKPOINT_RESTORE.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

       The MSG_EXCEPT and MSG_COPY flags are Linux-specific; their definitions can be obtained by defining the _GNU_SOURCE
       feature test macro.

NOTES
       The  inclusion  of <sys/types.h> and <sys/ipc.h> isn't required on Linux or by any version of POSIX.  However, some
       old implementations required the inclusion of these header files, and the SVID  also  documented  their  inclusion.
       Applications intended to be portable to such old systems may need to include these header files.

       The  msgp  argument is declared as struct msgbuf * in glibc 2.0 and 2.1.  It is declared as void * in glibc 2.2 and
       later, as required by SUSv2 and SUSv3.

       The following limits on message queue resources affect the msgsnd() call:

       MSGMAX Maximum size of a message text, in bytes (default value: 8192 bytes).  On Linux, this limit can be read  and
              modified via /proc/sys/kernel/msgmax.

       MSGMNB Maximum  number  of  bytes that can be held in a message queue (default value: 16384 bytes).  On Linux, this
              limit can be read and modified via /proc/sys/kernel/msgmnb.  A privileged process (Linux: a process with the
              CAP_SYS_RESOURCE  capability)  can  increase  the  size of a message queue beyond MSGMNB using the msgctl(2)
              IPC_SET operation.

       The implementation has no intrinsic system-wide limits on the number of message headers (MSGTQL) and the number  of
       bytes in the message pool (MSGPOOL).

BUGS
       In  Linux  3.13 and earlier, if msgrcv() was called with the MSG_COPY flag, but without IPC_NOWAIT, and the message
       queue contained less than msgtyp messages, then the call would block until the  next  message  is  written  to  the
       queue.   At  that point, the call would return a copy of the message, regardless of whether that message was at the
       ordinal position msgtyp.  This bug is fixed in Linux 3.14.

       Specifying both MSG_COPY and MSC_EXCEPT in msgflg is a logical error (since these flags impose different  interpre‐
       tations  on  msgtyp).   In  Linux 3.13 and earlier, this error was not diagnosed by msgrcv().  This bug is fixed in
       Linux 3.14.

EXAMPLE
       The program below demonstrates the use of msgsnd() and msgrcv().

       The example program is first run with the -s option to send a message and then run again  with  the  -r  option  to
       receive a message.

       The following shell session shows a sample run of the program:

           $ ./a.out -s
           sent: a message at Wed Mar  4 16:25:45 2015

           $ ./a.out -r
           message received: a message at Wed Mar  4 16:25:45 2015

   Program source

       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>
       #include <time.h>
       #include <unistd.h>
       #include <errno.h>
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       struct msgbuf {
           long mtype;
           char mtext[80];
       };

       static void
       usage(char *prog_name, char *msg)
       {
           if (msg != NULL)
               fputs(msg, stderr);

           fprintf(stderr, "Usage: %s [options]\n", prog_name);
           fprintf(stderr, "Options are:\n");
           fprintf(stderr, "-s        send message using msgsnd()\n");
           fprintf(stderr, "-r        read message using msgrcv()\n");
           fprintf(stderr, "-t        message type (default is 1)\n");
           fprintf(stderr, "-k        message queue key (default is 1234)\n");
           exit(EXIT_FAILURE);
       }

       static void
       send_msg(int qid, int msgtype)
       {
           struct msgbuf msg;
           time_t t;

           msg.mtype = msgtype;

           time(&t);
           snprintf(msg.mtext, sizeof(msg.mtext), "a message at %s",
                   ctime(&t));

           if (msgsnd(qid, (void *) &msg, sizeof(msg.mtext),
                       IPC_NOWAIT) == -1) {
               perror("msgsnd error");
               exit(EXIT_FAILURE);
           }
           printf("sent: %s\n", msg.mtext);
       }

       static void
       get_msg(int qid, int msgtype)
       {
           struct msgbuf msg;

           if (msgrcv(qid, (void *) &msg, sizeof(msg.mtext), msgtype,
                      MSG_NOERROR | IPC_NOWAIT) == -1) {
               if (errno != ENOMSG) {
                   perror("msgrcv");
                   exit(EXIT_FAILURE);
               }
               printf("No message available for msgrcv()\n");
           } else
               printf("message received: %s\n", msg.mtext);
       }

       int
       main(int argc, char *argv[])
       {
           int qid, opt;
           int mode = 0;               /* 1 = send, 2 = receive */
           int msgtype = 1;
           int msgkey = 1234;

           while ((opt = getopt(argc, argv, "srt:k:")) != -1) {
               switch (opt) {
               case 's':
                   mode = 1;
                   break;
               case 'r':
                   mode = 2;
                   break;
               case 't':
                   msgtype = atoi(optarg);
                   if (msgtype <= 0)
                       usage(argv[0], "-t option must be greater than 0\n");
                   break;
               case 'k':
                   msgkey = atoi(optarg);
                   break;
               default:
                   usage(argv[0], "Unrecognized option\n");
               }
           }

           if (mode == 0)
               usage(argv[0], "must use either -s or -r option\n");

           qid = msgget(msgkey, IPC_CREAT | 0666);

           if (qid == -1) {
               perror("msgget");
               exit(EXIT_FAILURE);
           }

           if (mode == 2)
               get_msg(qid, msgtype);
           else
               send_msg(qid, msgtype);

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       msgctl(2), msgget(2), capabilities(7), mq_overview(7), svipc(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                MSGOP(2)
</pre>
<pre zoom>
<span xsmall>2 setfsgid</span>
SETFSGID(2)                                      Linux Programmer's Manual                                     SETFSGID(2)

NAME
       setfsgid - set group identity used for filesystem checks

SYNOPSIS
       #include <sys/fsuid.h>

       int setfsgid(uid_t fsgid);

DESCRIPTION
       The system call setfsgid() changes the value of the caller's filesystem group ID—the group ID that the Linux kernel
       uses to check for all accesses to the filesystem.  Normally, the value of the filesystem group ID will  shadow  the
       value of the effective group ID.  In fact, whenever the effective group ID is changed, the filesystem group ID will
       also be changed to the new value of the effective group ID.

       Explicit calls to setfsuid(2) and setfsgid() are usually used only by programs such as the Linux  NFS  server  that
       need to change what user and group ID is used for file access without a corresponding change in the real and effec‐
       tive user and group IDs.  A change in the normal user IDs for a program such as the NFS server is a  security  hole
       that can expose it to unwanted signals.  (But see below.)

       setfsgid()  will succeed only if the caller is the superuser or if fsgid matches either the caller's real group ID,
       effective group ID, saved set-group-ID, or current the filesystem user ID.

RETURN VALUE
       On both success and failure, this call returns the previous filesystem group ID of the caller.

VERSIONS
       This system call is present in Linux since version 1.2.

CONFORMING TO
       setfsgid() is Linux-specific and should not be used in programs intended to be portable.

NOTES
       Note that at the time this system call was introduced, a process could send a signal to a  process  with  the  same
       effective  user  ID.   Today signal permission handling is slightly different.  See setfsuid(2) for a discussion of
       why the use of both setfsuid(2) and setfsgid() is nowadays unneeded.

       The original Linux setfsgid() system call supported only 16-bit group IDs.  Subsequently, Linux  2.4  added  setfs‐
       gid32() supporting 32-bit IDs.  The glibc setfsgid() wrapper function transparently deals with the variation across
       kernel versions.

   C library/kernel differences
       In glibc 2.15 and earlier, when the wrapper for this system call determines that the argument can't  be  passed  to
       the  kernel without integer truncation (because the kernel is old and does not support 32-bit group IDs), they will
       return -1 and set errno to EINVAL without attempting the system call.

BUGS
       No error indications of any kind are returned to the caller, and the fact that  both  successful  and  unsuccessful
       calls  return  the  same  value  makes  it  impossible  to directly determine whether the call succeeded or failed.
       Instead, the caller must resort to looking at the return value from a further call such as setfsgid(-1) (which will
       always fail), in order to determine if a preceding call to setfsgid() changed the filesystem group ID.  At the very
       least, EPERM should be returned when the call fails (because the caller lacks the CAP_SETGID capability).

SEE ALSO
       kill(2), setfsuid(2), capabilities(7), credentials(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             SETFSGID(2)
</pre>
<pre zoom>
<span xsmall>2 flistxattr</span>
LISTXATTR(2)                                     Linux Programmer's Manual                                    LISTXATTR(2)

NAME
       listxattr, llistxattr, flistxattr - list extended attribute names

SYNOPSIS
       #include <sys/types.h>
       #include <sys/xattr.h>

       ssize_t listxattr(const char *path, char *list, size_t size);
       ssize_t llistxattr(const char *path, char *list, size_t size);
       ssize_t flistxattr(int fd, char *list, size_t size);

DESCRIPTION
       Extended  attributes  are name:value pairs associated with inodes (files, directories, symbolic links, etc.).  They
       are extensions to the normal attributes which are associated with all inodes  in  the  system  (i.e.,  the  stat(2)
       data).  A complete overview of extended attributes concepts can be found in xattr(7).

       listxattr()  retrieves  the list of extended attribute names associated with the given path in the filesystem.  The
       retrieved list is placed in list, a caller-allocated buffer whose size (in bytes)  is  specified  in  the  argument
       size.   The list is the set of (null-terminated) names, one after the other.  Names of extended attributes to which
       the calling process does not have access may be omitted from the list.  The length of the attribute  name  list  is
       returned.

       llistxattr()  is  identical  to  listxattr(),  except  in  the  case of a symbolic link, where the list of names of
       extended attributes associated with the link itself is retrieved, not the file that it refers to.

       flistxattr() is identical to listxattr(), only the open file referred to by fd (as returned by open(2)) is interro‐
       gated in place of path.

       A  single  extended attribute name is a null-terminated string.  The name includes a namespace prefix; there may be
       several, disjoint namespaces associated with an individual inode.

       If size is specified as zero, these calls return the current size of the list  of  extended  attribute  names  (and
       leave  list  unchanged).   This can be used to determine the size of the buffer that should be supplied in a subse‐
       quent call.  (But, bear in mind that there is a possibility that the set of extended attributes may change  between
       the two calls, so that it is still necessary to check the return status from the second call.)

   Example
       The list of names is returned as an unordered array of null-terminated character strings (attribute names are sepa‐
       rated by null bytes ('\0')), like this:

           user.name1\0system.name1\0user.name2\0

       Filesystems that implement POSIX ACLs using extended attributes might return a list like this:

           system.posix_acl_access\0system.posix_acl_default\0

RETURN VALUE
       On success, a nonnegative number is returned indicating the size of the extended attribute name list.  On  failure,
       -1 is returned and errno is set appropriately.

ERRORS
       E2BIG  The size of the list of extended attribute names is larger than the maximum size allowed; the list cannot be
              retrieved.  This can happen on filesystems that support an unlimited number of extended attributes per  file
              such as XFS, for example.  See BUGS.

       ENOTSUP
              Extended attributes are not supported by the filesystem, or are disabled.

       ERANGE The size of the list buffer is too small to hold the result.

       In addition, the errors documented in stat(2) can also occur.

VERSIONS
       These system calls have been available on Linux since kernel 2.4; glibc support is provided since version 2.3.

CONFORMING TO
       These system calls are Linux-specific.

BUGS
       As  noted in xattr(7), the VFS imposes a limit of 64 kB on the size of the extended attribute name list returned by
       listxattr(7).  If the total size of attribute names attached to a file exceeds this limit, it is no longer possible
       to retrieve the list of attribute names.

EXAMPLE
       The  following  program demonstrates the usage of listxattr() and getxattr(2).  For the file whose pathname is pro‐
       vided as a command-line argument, it lists all extended file attributes and their values.

       To keep the code simple, the program assumes that attribute keys and values are constant during  the  execution  of
       the  program.  A production program should expect and handle changes during execution of the program.  For example,
       the number of bytes required for attribute keys might increase between the two calls to listxattr().   An  applica‐
       tion could handle this possibility using a loop that retries the call (perhaps up to a predetermined maximum number
       of attempts) with a larger buffer each time it fails with the error ERANGE.  Calls to getxattr(2) could be  handled
       similarly.

       The following output was recorded by first creating a file, setting some extended file attributes, and then listing
       the attributes with the example program.

   Example output
           $ touch /tmp/foo
           $ setfattr -n user.fred -v chocolate /tmp/foo
           $ setfattr -n user.frieda -v bar /tmp/foo
           $ setfattr -n user.empty /tmp/foo
           $ ./listxattr /tmp/foo
           user.fred: chocolate
           user.frieda: bar
           user.empty: <no value>

   Program source (listxattr.c)
       #include <malloc.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>
       #include <sys/types.h>
       #include <sys/xattr.h>

       int
       main(int argc, char *argv[])
       {
           ssize_t buflen, keylen, vallen;
           char *buf, *key, *val;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s path\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           /*
            * Determine the length of the buffer needed.
            */
           buflen = listxattr(argv[1], NULL, 0);
           if (buflen == -1) {
               perror("listxattr");
               exit(EXIT_FAILURE);
           }
           if (buflen == 0) {
               printf("%s has no attributes.\n", argv[1]);
               exit(EXIT_SUCCESS);
           }

           /*
            * Allocate the buffer.
            */
           buf = malloc(buflen);
           if (buf == NULL) {
               perror("malloc");
               exit(EXIT_FAILURE);
           }

           /*
            * Copy the list of attribute keys to the buffer.
            */
           buflen = listxattr(argv[1], buf, buflen);
           if (buflen == -1) {
               perror("listxattr");
               exit(EXIT_FAILURE);
           }

           /*
            * Loop over the list of zero terminated strings with the
            * attribute keys. Use the remaining buffer length to determine
            * the end of the list.
            */
           key = buf;
           while (buflen > 0) {

               /*
                * Output attribute key.
                */
               printf("%s: ", key);

               /*
                * Determine length of the value.
                */
               vallen = getxattr(argv[1], key, NULL, 0);
               if (vallen == -1)
                   perror("getxattr");

               if (vallen > 0) {

                   /*
                    * Allocate value buffer.
                    * One extra byte is needed to append 0x00.
                    */
                   val = malloc(vallen + 1);
                   if (val == NULL) {
                       perror("malloc");
                       exit(EXIT_FAILURE);
                   }

                   /*
                    * Copy value to buffer.
                    */
                   vallen = getxattr(argv[1], key, val, vallen);
                   if (vallen == -1)
                       perror("getxattr");
                   else {
                       /*
                        * Output attribute value.
                        */
                       val[vallen] = 0;
                       printf("%s", val);
                   }

                   free(val);
               } else if (vallen == 0)
                   printf("<no value>");

               printf("\n");

               /*
                * Forward to next attribute key.
                */
               keylen = strlen(key) + 1;
               buflen -= keylen;
               key += keylen;
           }

           free(buf);
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       getfattr(1), setfattr(1), getxattr(2), open(2), removexattr(2), setxattr(2), stat(2), symlink(7), xattr(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            LISTXATTR(2)
</pre>
<pre zoom>
<span xsmall>2 _sysctl</span>
SYSCTL(2)                                        Linux Programmer's Manual                                       SYSCTL(2)

NAME
       sysctl - read/write system parameters

SYNOPSIS
       #include <unistd.h>
       #include <linux/sysctl.h>

       int _sysctl(struct __sysctl_args *args);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       Do not use this system call!  See NOTES.

       The _sysctl() call reads and/or writes kernel parameters.  For example, the hostname, or the maximum number of open
       files.  The argument has the form

           struct __sysctl_args {
               int    *name;    /* integer vector describing variable */
               int     nlen;    /* length of this vector */
               void   *oldval;  /* 0 or address where to store old value */
               size_t *oldlenp; /* available room for old value,
                                   overwritten by actual size of old value */
               void   *newval;  /* 0 or address of new value */
               size_t  newlen;  /* size of new value */
           };

       This call does a search in a tree structure, possibly resembling a directory  tree  under  /proc/sys,  and  if  the
       requested item is found calls some appropriate routine to read or modify the value.

RETURN VALUE
       Upon successful completion, _sysctl() returns 0.  Otherwise, a value of -1 is returned and errno is set to indicate
       the error.

ERRORS
       EACCES, EPERM
              No search permission for one of the encountered "directories",  or  no  read  permission  where  oldval  was
              nonzero, or no write permission where newval was nonzero.

       EFAULT The invocation asked for the previous value by setting oldval non-NULL, but allowed zero room in oldlenp.

       ENOTDIR
              name was not found.

CONFORMING TO
       This  call is Linux-specific, and should not be used in programs intended to be portable.  A sysctl() call has been
       present in Linux since version 1.3.57.  It originated in 4.4BSD.  Only Linux has  the  /proc/sys  mirror,  and  the
       object  naming schemes differ between Linux and 4.4BSD, but the declaration of the sysctl() function is the same in
       both.

NOTES
       Glibc does not provide a wrapper for this system call; call it using syscall(2).  Or rather...  don't call it:  use
       of this system call has long been discouraged, and it is so unloved that it is likely to disappear in a future ker‐
       nel version.  Since Linux 2.6.24, uses of this system call result in warnings in the kernel log.   Remove  it  from
       your programs now; use the /proc/sys interface instead.

       This system call is available only if the kernel was configured with the CONFIG_SYSCTL_SYSCALL option.

BUGS
       The object names vary between kernel versions, making this system call worthless for applications.

       Not all available objects are properly documented.

       It is not yet possible to change operating system by writing to /proc/sys/kernel/ostype.

EXAMPLE
       #define _GNU_SOURCE
       #include <unistd.h>
       #include <sys/syscall.h>
       #include <string.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <linux/sysctl.h>

       int _sysctl(struct __sysctl_args *args );

       #define OSNAMESZ 100

       int
       main(void)
       {
           struct __sysctl_args args;
           char osname[OSNAMESZ];
           size_t osnamelth;
           int name[] = { CTL_KERN, KERN_OSTYPE };

           memset(&args, 0, sizeof(struct __sysctl_args));
           args.name = name;
           args.nlen = sizeof(name)/sizeof(name[0]);
           args.oldval = osname;
           args.oldlenp = &osnamelth;

           osnamelth = sizeof(osname);

           if (syscall(SYS__sysctl, &args) == -1) {
               perror("_sysctl");
               exit(EXIT_FAILURE);
           }
           printf("This machine is running %*s\n", osnamelth, osname);
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       proc(5)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SYSCTL(2)
</pre>
<pre zoom>
<span xsmall>2 select_tut</span>
SELECT_TUT(2)                                    Linux Programmer's Manual                                   SELECT_TUT(2)

NAME
       select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O multiplexing

SYNOPSIS
       /* According to POSIX.1-2001, POSIX.1-2008 */
       #include <sys/select.h>

       /* According to earlier standards */
       #include <sys/time.h>
       #include <sys/types.h>
       #include <unistd.h>

       int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *utimeout);

       void FD_CLR(int fd, fd_set *set);
       int  FD_ISSET(int fd, fd_set *set);
       void FD_SET(int fd, fd_set *set);
       void FD_ZERO(fd_set *set);

       #include <sys/select.h>

       int pselect(int nfds, fd_set *readfds, fd_set *writefds,
                   fd_set *exceptfds, const struct timespec *ntimeout,
                   const sigset_t *sigmask);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pselect(): _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       select()  (or  pselect())  is  used  to efficiently monitor multiple file descriptors, to see if any of them is, or
       becomes, "ready"; that is, to see whether I/O becomes possible, or an "exceptional condition" has occurred  on  any
       of the file descriptors.

       Its  principal  arguments  are  three  "sets"  of  file descriptors: readfds, writefds, and exceptfds.  Each set is
       declared as type fd_set, and its contents can be manipulated with the macros FD_CLR(),  FD_ISSET(),  FD_SET(),  and
       FD_ZERO().   A  newly  declared set should first be cleared using FD_ZERO().  select() modifies the contents of the
       sets according to the rules described below; after calling select() you can test if  a  file  descriptor  is  still
       present  in  a set with the FD_ISSET() macro.  FD_ISSET() returns nonzero if a specified file descriptor is present
       in a set and zero if it is not.  FD_CLR() removes a file descriptor from a set.

   Arguments
       readfds
              This set is watched to see if data is available for  reading  from  any  of  its  file  descriptors.   After
              select() has returned, readfds will be cleared of all file descriptors except for those that are immediately
              available for reading.

       writefds
              This set is watched to see if there is space to write data to any of its file descriptors.   After  select()
              has  returned, writefds will be cleared of all file descriptors except for those that are immediately avail‐
              able for writing.

       exceptfds
              This set is watched for "exceptional conditions".  In practice, only one such exceptional condition is  com‐
              mon:  the  availability  of out-of-band (OOB) data for reading from a TCP socket.  See recv(2), send(2), and
              tcp(7) for more details about OOB data.  (One other less common case where  select(2)  indicates  an  excep‐
              tional  condition  occurs  with  pseudoterminals  in  packet  mode;  see  ioctl_tty(2).)  After select() has
              returned, exceptfds will be cleared of all file descriptors except for those for which an exceptional condi‐
              tion has occurred.

       nfds   This  is  an  integer  one more than the maximum of any file descriptor in any of the sets.  In other words,
              while adding file descriptors to each of the sets, you must calculate the maximum integer value  of  all  of
              them, then increment this value by one, and then pass this as nfds.

       utimeout
              This  is the longest time select() may wait before returning, even if nothing interesting happened.  If this
              value is passed as NULL, then select() blocks indefinitely waiting for a file descriptor  to  become  ready.
              utimeout can be set to zero seconds, which causes select() to return immediately, with information about the
              readiness of file descriptors at the time of the call.  The structure struct timeval is defined as:

                  struct timeval {
                      time_t tv_sec;    /* seconds */
                      long tv_usec;     /* microseconds */
                  };

       ntimeout
              This argument for pselect() has the same meaning as utimeout, but struct timespec has  nanosecond  precision
              as follows:

                  struct timespec {
                      long tv_sec;    /* seconds */
                      long tv_nsec;   /* nanoseconds */
                  };

       sigmask
              This  argument  holds  a set of signals that the kernel should unblock (i.e., remove from the signal mask of
              the calling thread), while the caller is blocked inside the pselect() call (see  sigaddset(3)  and  sigproc‐
              mask(2)).   It  may be NULL, in which case the call does not modify the signal mask on entry and exit to the
              function.  In this case, pselect() will then behave just like select().

   Combining signal and data events
       pselect() is useful if you are waiting for a signal as well as for file descriptor(s)  to  become  ready  for  I/O.
       Programs  that  receive  signals normally use the signal handler only to raise a global flag.  The global flag will
       indicate that the event must be processed in the main loop of the program.  A signal will cause  the  select()  (or
       pselect())  call to return with errno set to EINTR.  This behavior is essential so that signals can be processed in
       the main loop of the program, otherwise select() would block indefinitely.  Now, somewhere in the main loop will be
       a conditional to check the global flag.  So we must ask: what if a signal arrives after the conditional, but before
       the select() call?  The answer is that select() would block indefinitely, even though an event is actually pending.
       This race condition is solved by the pselect() call.  This call can be used to set the signal mask to a set of sig‐
       nals that are to be received only within the pselect() call.  For instance, let us say that the event  in  question
       was  the  exit of a child process.  Before the start of the main loop, we would block SIGCHLD using sigprocmask(2).
       Our pselect() call would enable SIGCHLD by using an empty signal mask.  Our program would look like:

       static volatile sig_atomic_t got_SIGCHLD = 0;

       static void
       child_sig_handler(int sig)
       {
           got_SIGCHLD = 1;
       }

       int
       main(int argc, char *argv[])
       {
           sigset_t sigmask, empty_mask;
           struct sigaction sa;
           fd_set readfds, writefds, exceptfds;
           int r;

           sigemptyset(&sigmask);
           sigaddset(&sigmask, SIGCHLD);
           if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {
               perror("sigprocmask");
               exit(EXIT_FAILURE);
           }

           sa.sa_flags = 0;
           sa.sa_handler = child_sig_handler;
           sigemptyset(&sa.sa_mask);
           if (sigaction(SIGCHLD, &sa, NULL) == -1) {
               perror("sigaction");
               exit(EXIT_FAILURE);
           }

           sigemptyset(&empty_mask);

           for (;;) {          /* main loop */
               /* Initialize readfds, writefds, and exceptfds
                  before the pselect() call. (Code omitted.) */

               r = pselect(nfds, &readfds, &writefds, &exceptfds,
                           NULL, &empty_mask);
               if (r == -1 && errno != EINTR) {
                   /* Handle error */
               }

               if (got_SIGCHLD) {
                   got_SIGCHLD = 0;

                   /* Handle signalled event here; e.g., wait() for all
                      terminated children. (Code omitted.) */
               }

               /* main body of program */
           }
       }

   Practical
       So what is the point of select()?  Can't I just read and write to my file descriptors whenever I want?   The  point
       of  select()  is  that  it  watches multiple descriptors at the same time and properly puts the process to sleep if
       there is no activity.  UNIX programmers often find themselves in a position where they have to handle I/O from more
       than  one  file  descriptor  where  the  data flow may be intermittent.  If you were to merely create a sequence of
       read(2) and write(2) calls, you would find that one of your calls  may  block  waiting  for  data  from/to  a  file
       descriptor,  while  another  file  descriptor is unused though ready for I/O.  select() efficiently copes with this
       situation.

   Select law
       Many people who try to use select() come across behavior that is difficult to understand and  produces  nonportable
       or borderline results.  For instance, the above program is carefully written not to block at any point, even though
       it does not set its file descriptors to nonblocking mode.  It is easy to introduce subtle errors that  will  remove
       the advantage of using select(), so here is a list of essentials to watch for when using select().

       1.  You should always try to use select() without a timeout.  Your program should have nothing to do if there is no
           data available.  Code that depends on timeouts is not usually portable and is difficult to debug.

       2.  The value nfds must be properly calculated for efficiency as explained above.

       3.  No file descriptor must be added to any set if you do not intend to check its result after the  select()  call,
           and respond appropriately.  See next rule.

       4.  After select() returns, all file descriptors in all sets should be checked to see if they are ready.

       5.  The  functions  read(2),  recv(2),  write(2), and send(2) do not necessarily read/write the full amount of data
           that you have requested.  If they do read/write the full amount, it's because you have a low traffic load and a
           fast  stream.  This is not always going to be the case.  You should cope with the case of your functions manag‐
           ing to send or receive only a single byte.

       6.  Never read/write only in single bytes at a time unless you are really sure that you have a small amount of data
           to  process.  It is extremely inefficient not to read/write as much data as you can buffer each time.  The buf‐
           fers in the example below are 1024 bytes although they could easily be made larger.

       7.  Calls to read(2), recv(2), write(2), send(2), and select() can fail with the error EINTR, and calls to read(2),
           recv(2)  write(2), and send(2) can fail with errno set to EAGAIN (EWOULDBLOCK).  These results must be properly
           managed (not done properly above).  If your program is not going to receive any signals, then  it  is  unlikely
           you will get EINTR.  If your program does not set nonblocking I/O, you will not get EAGAIN.

       8.  Never call read(2), recv(2), write(2), or send(2) with a buffer length of zero.

       9.  If the functions read(2), recv(2), write(2), and send(2) fail with errors other than those listed in 7., or one
           of the input functions returns 0, indicating end of file, then you should not  pass  that  file  descriptor  to
           select()  again.   In the example below, I close the file descriptor immediately, and then set it to -1 to pre‐
           vent it being included in a set.

       10. The timeout value must be initialized with each new call to select(), since some operating systems  modify  the
           structure.  pselect() however does not modify its timeout structure.

       11. Since  select()  modifies  its file descriptor sets, if the call is being used in a loop, then the sets must be
           reinitialized before each call.

   Usleep emulation
       On systems that do not have a usleep(3) function, you can call select() with a finite timeout and no file  descrip‐
       tors as follows:

           struct timeval tv;
           tv.tv_sec = 0;
           tv.tv_usec = 200000;  /* 0.2 seconds */
           select(0, NULL, NULL, NULL, &tv);

       This is guaranteed to work only on UNIX systems, however.

RETURN VALUE
       On success, select() returns the total number of file descriptors still present in the file descriptor sets.

       If  select()  timed out, then the return value will be zero.  The file descriptors set should be all empty (but may
       not be on some systems).

       A return value of -1 indicates an error, with errno being set appropriately.  In the case of an error, the contents
       of the returned sets and the struct timeout contents are undefined and should not be used.  pselect() however never
       modifies ntimeout.

NOTES
       Generally speaking, all operating systems that support sockets also support select().   select()  can  be  used  to
       solve  many problems in a portable and efficient way that naive programmers try to solve in a more complicated man‐
       ner using threads, forking, IPCs, signals, memory sharing, and so on.

       The poll(2) system call has the same functionality as select(), and is  somewhat  more  efficient  when  monitoring
       sparse file descriptor sets.  It is nowadays widely available, but historically was less portable than select().

       The  Linux-specific epoll(7) API provides an interface that is more efficient than select(2) and poll(2) when moni‐
       toring large numbers of file descriptors.

EXAMPLE
       Here is an example that better demonstrates the true utility of select().  The listing below is  a  TCP  forwarding
       program that forwards from one TCP port to another.

       #include <stdlib.h>
       #include <stdio.h>
       #include <unistd.h>
       #include <sys/time.h>
       #include <sys/types.h>
       #include <string.h>
       #include <signal.h>
       #include <sys/socket.h>
       #include <netinet/in.h>
       #include <arpa/inet.h>
       #include <errno.h>

       static int forward_port;

       #undef max
       #define max(x,y) ((x) > (y) ? (x) : (y))

       static int
       listen_socket(int listen_port)
       {
           struct sockaddr_in addr;
           int lfd;
           int yes;

           lfd = socket(AF_INET, SOCK_STREAM, 0);
           if (lfd == -1) {
               perror("socket");
               return -1;
           }

           yes = 1;
           if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,
                   &yes, sizeof(yes)) == -1) {
               perror("setsockopt");
               close(lfd);
               return -1;
           }

           memset(&addr, 0, sizeof(addr));
           addr.sin_port = htons(listen_port);
           addr.sin_family = AF_INET;
           if (bind(lfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {
               perror("bind");
               close(lfd);
               return -1;
           }

           printf("accepting connections on port %d\n", listen_port);
           listen(lfd, 10);
           return lfd;
       }

       static int
       connect_socket(int connect_port, char *address)
       {
           struct sockaddr_in addr;
           int cfd;

           cfd = socket(AF_INET, SOCK_STREAM, 0);
           if (cfd == -1) {
               perror("socket");
               return -1;
           }

           memset(&addr, 0, sizeof(addr));
           addr.sin_port = htons(connect_port);
           addr.sin_family = AF_INET;

           if (!inet_aton(address, (struct in_addr *) &addr.sin_addr.s_addr)) {
               perror("bad IP address format");
               close(cfd);
               return -1;
           }

           if (connect(cfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {
               perror("connect()");
               shutdown(cfd, SHUT_RDWR);
               close(cfd);
               return -1;
           }
           return cfd;
       }

       #define SHUT_FD1 do {                                \
                            if (fd1 >= 0) {                 \
                                shutdown(fd1, SHUT_RDWR);   \
                                close(fd1);                 \
                                fd1 = -1;                   \
                            }                               \
                        } while (0)

       #define SHUT_FD2 do {                                \
                            if (fd2 >= 0) {                 \
                                shutdown(fd2, SHUT_RDWR);   \
                                close(fd2);                 \
                                fd2 = -1;                   \
                            }                               \
                        } while (0)

       #define BUF_SIZE 1024

       int
       main(int argc, char *argv[])
       {
           int h;
           int fd1 = -1, fd2 = -1;
           char buf1[BUF_SIZE], buf2[BUF_SIZE];
           int buf1_avail = 0, buf1_written = 0;
           int buf2_avail = 0, buf2_written = 0;

           if (argc != 4) {
               fprintf(stderr, "Usage\n\tfwd <listen-port> "
                        "<forward-to-port> <forward-to-ip-address>\n");
               exit(EXIT_FAILURE);
           }

           signal(SIGPIPE, SIG_IGN);

           forward_port = atoi(argv[2]);

           h = listen_socket(atoi(argv[1]));
           if (h == -1)
               exit(EXIT_FAILURE);

           for (;;) {
               int ready, nfds = 0;
               ssize_t nbytes;
               fd_set readfds, writefds, exceptfds;

               FD_ZERO(&readfds);
               FD_ZERO(&writefds);
               FD_ZERO(&exceptfds);
               FD_SET(h, &readfds);
               nfds = max(nfds, h);

               if (fd1 > 0 && buf1_avail < BUF_SIZE)
                   FD_SET(fd1, &readfds);
                   /* Note: nfds is updated below, when fd1 is added to
                      exceptfds. */
               if (fd2 > 0 && buf2_avail < BUF_SIZE)
                   FD_SET(fd2, &readfds);

               if (fd1 > 0 && buf2_avail - buf2_written > 0)
                   FD_SET(fd1, &writefds);
               if (fd2 > 0 && buf1_avail - buf1_written > 0)
                   FD_SET(fd2, &writefds);

               if (fd1 > 0) {
                   FD_SET(fd1, &exceptfds);
                   nfds = max(nfds, fd1);
               }
               if (fd2 > 0) {
                   FD_SET(fd2, &exceptfds);
                   nfds = max(nfds, fd2);
               }

               ready = select(nfds + 1, &readfds, &writefds, &exceptfds, NULL);

               if (ready == -1 && errno == EINTR)
                   continue;

               if (ready == -1) {
                   perror("select()");
                   exit(EXIT_FAILURE);
               }

               if (FD_ISSET(h, &readfds)) {
                   socklen_t addrlen;
                   struct sockaddr_in client_addr;
                   int fd;

                   addrlen = sizeof(client_addr);
                   memset(&client_addr, 0, addrlen);
                   fd = accept(h, (struct sockaddr *) &client_addr, &addrlen);
                   if (fd == -1) {
                       perror("accept()");
                   } else {
                       SHUT_FD1;
                       SHUT_FD2;
                       buf1_avail = buf1_written = 0;
                       buf2_avail = buf2_written = 0;
                       fd1 = fd;
                       fd2 = connect_socket(forward_port, argv[3]);
                       if (fd2 == -1)
                           SHUT_FD1;
                       else
                           printf("connect from %s\n",
                                   inet_ntoa(client_addr.sin_addr));

                       /* Skip any events on the old, closed file descriptors. */
                       continue;
                   }
               }

               /* NB: read OOB data before normal reads */

               if (fd1 > 0 && FD_ISSET(fd1, &exceptfds)) {
                   char c;

                   nbytes = recv(fd1, &c, 1, MSG_OOB);
                   if (nbytes < 1)
                       SHUT_FD1;
                   else
                       send(fd2, &c, 1, MSG_OOB);
               }
               if (fd2 > 0 && FD_ISSET(fd2, &exceptfds)) {
                   char c;

                   nbytes = recv(fd2, &c, 1, MSG_OOB);
                   if (nbytes < 1)
                       SHUT_FD2;
                   else
                       send(fd1, &c, 1, MSG_OOB);
               }
               if (fd1 > 0 && FD_ISSET(fd1, &readfds)) {
                   nbytes = read(fd1, buf1 + buf1_avail,
                             BUF_SIZE - buf1_avail);
                   if (nbytes < 1)
                       SHUT_FD1;
                   else
                       buf1_avail += nbytes;
               }
               if (fd2 > 0 && FD_ISSET(fd2, &readfds)) {
                   nbytes = read(fd2, buf2 + buf2_avail,
                             BUF_SIZE - buf2_avail);
                   if (nbytes < 1)
                       SHUT_FD2;
                   else
                       buf2_avail += nbytes;
               }
               if (fd1 > 0 && FD_ISSET(fd1, &writefds) && buf2_avail > 0) {
                   nbytes = write(fd1, buf2 + buf2_written,
                              buf2_avail - buf2_written);
                   if (nbytes < 1)
                       SHUT_FD1;
                   else
                       buf2_written += nbytes;
               }
               if (fd2 > 0 && FD_ISSET(fd2, &writefds) && buf1_avail > 0) {
                   nbytes = write(fd2, buf1 + buf1_written,
                              buf1_avail - buf1_written);
                   if (nbytes < 1)
                       SHUT_FD2;
                   else
                       buf1_written += nbytes;
               }

               /* Check if write data has caught read data */

               if (buf1_written == buf1_avail)
                   buf1_written = buf1_avail = 0;
               if (buf2_written == buf2_avail)
                   buf2_written = buf2_avail = 0;

               /* One side has closed the connection, keep
                  writing to the other side until empty */

               if (fd1 < 0 && buf1_avail - buf1_written == 0)
                   SHUT_FD2;
               if (fd2 < 0 && buf2_avail - buf2_written == 0)
                   SHUT_FD1;
           }
           exit(EXIT_SUCCESS);
       }

       The  above  program properly forwards most kinds of TCP connections including OOB signal data transmitted by telnet
       servers.  It handles the tricky problem of having data flow in both directions simultaneously.  You might think  it
       more  efficient  to use a fork(2) call and devote a thread to each stream.  This becomes more tricky than you might
       suspect.  Another idea is to set nonblocking I/O using fcntl(2).  This also has its problems  because  you  end  up
       using inefficient timeouts.

       The  program  does not handle more than one simultaneous connection at a time, although it could easily be extended
       to do this with a linked list of buffers—one for each connection.  At the moment, new connections cause the current
       connection to be dropped.

SEE ALSO
       accept(2),   connect(2),  ioctl(2),  poll(2),  read(2),  recv(2),  select(2),  send(2),  sigprocmask(2),  write(2),
       sigaddset(3), sigdelset(3), sigemptyset(3), sigfillset(3), sigismember(3), epoll(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           SELECT_TUT(2)
</pre>
<pre zoom>
<span xsmall>2 getdomainname</span>
GETDOMAINNAME(2)                                 Linux Programmer's Manual                                GETDOMAINNAME(2)

NAME
       getdomainname, setdomainname - get/set NIS domain name

SYNOPSIS
       #include <unistd.h>

       int getdomainname(char *name, size_t len);
       int setdomainname(const char *name, size_t len);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       getdomainname(), setdomainname():
           Since glibc 2.21:
               _DEFAULT_SOURCE
           In glibc 2.19 and 2.20:
               _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE < 500)
           Up to and including glibc 2.19:
               _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE < 500)

DESCRIPTION
       These functions are used to access or to change the NIS domain name of the host system.

       setdomainname()  sets  the  domain name to the value given in the character array name.  The len argument specifies
       the number of bytes in name.  (Thus, name does not require a terminating null byte.)

       getdomainname() returns the null-terminated domain name in the character array name, which  has  a  length  of  len
       bytes.   If  the  null-terminated  domain  name requires more than len bytes, getdomainname() returns the first len
       bytes (glibc) or gives an error (libc).

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       setdomainname() can fail with the following errors:

       EFAULT name pointed outside of user address space.

       EINVAL len was negative or too large.

       EPERM  The caller did not have the CAP_SYS_ADMIN capability in the user namespace associated with its UTS namespace
              (see namespaces(7)).

       getdomainname() can fail with the following errors:

       EINVAL For getdomainname() under libc: name is NULL or name is longer than len bytes.

CONFORMING TO
       POSIX does not specify these calls.

NOTES
       Since  Linux  1.0,  the limit on the length of a domain name, including the terminating null byte, is 64 bytes.  In
       older kernels, it was 8 bytes.

       On most Linux architectures (including x86), there is no getdomainname() system  call;  instead,  glibc  implements
       getdomainname() as a library function that returns a copy of the domainname field returned from a call to uname(2).

SEE ALSO
       gethostname(2), sethostname(2), uname(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        GETDOMAINNAME(2)
</pre>
<pre zoom>
<span xsmall>2 stime</span>
STIME(2)                                         Linux Programmer's Manual                                        STIME(2)

NAME
       stime - set time

SYNOPSIS
       #include <time.h>

       int stime(const time_t *t);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       stime():
           Since glibc 2.19:
               _DEFAULT_SOURCE
           Glibc 2.19 and earlier:
               _SVID_SOURCE

DESCRIPTION
       stime()  sets  the system's idea of the time and date.  The time, pointed to by t, is measured in seconds since the
       Epoch, 1970-01-01 00:00:00 +0000 (UTC).  stime() may be executed only by the superuser.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT Error in getting information from user space.

       EPERM  The calling process has insufficient privilege.  Under Linux, the CAP_SYS_TIME privilege is required.

CONFORMING TO
       SVr4.

SEE ALSO
       date(1), settimeofday(2), capabilities(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2016-03-15                                                STIME(2)
</pre>
<pre zoom>
<span xsmall>2 sched_getscheduler</span>
SCHED_SETSCHEDULER(2)                            Linux Programmer's Manual                           SCHED_SETSCHEDULER(2)

NAME
       sched_setscheduler, sched_getscheduler - set and get scheduling policy/parameters

SYNOPSIS
       #include <sched.h>

       int sched_setscheduler(pid_t pid, int policy,
                              const struct sched_param *param);

       int sched_getscheduler(pid_t pid);

DESCRIPTION
       The  sched_setscheduler()  system  call  sets  both the scheduling policy and parameters for the thread whose ID is
       specified in pid.  If pid equals zero, the scheduling policy and parameters of the calling thread will be set.

       The scheduling parameters are specified in the param argument, which is a pointer to a structure of  the  following
       form:

           struct sched_param {
               ...
               int sched_priority;
               ...
           };

       In  the current implementation, the structure contains only one field, sched_priority.  The interpretation of param
       depends on the selected policy.

       Currently, Linux supports the following "normal" (i.e., non-real-time) scheduling policies as values  that  may  be
       specified in policy:

       SCHED_OTHER   the standard round-robin time-sharing policy;

       SCHED_BATCH   for "batch" style execution of processes; and

       SCHED_IDLE    for running very low priority background jobs.

       For each of the above policies, param->sched_priority must be 0.

       Various  "real-time"  policies are also supported, for special time-critical applications that need precise control
       over the way in which runnable threads are selected for execution.  For the rules governing when a process may  use
       these policies, see sched(7).  The real-time policies that may be specified in policy are:

       SCHED_FIFO    a first-in, first-out policy; and

       SCHED_RR      a round-robin policy.

       For  each  of  the above policies, param->sched_priority specifies a scheduling priority for the thread.  This is a
       number in the range returned by calling sched_get_priority_min(2) and sched_get_priority_max(2) with the  specified
       policy.  On Linux, these system calls return, respectively, 1 and 99.

       Since  Linux  2.6.32,  the  SCHED_RESET_ON_FORK flag can be ORed in policy when calling sched_setscheduler().  As a
       result of including this flag, children created by fork(2) do not  inherit  privileged  scheduling  policies.   See
       sched(7) for details.

       sched_getscheduler()  returns  the  current scheduling policy of the thread identified by pid.  If pid equals zero,
       the policy of the calling thread will be retrieved.

RETURN VALUE
       On success, sched_setscheduler() returns zero.  On success, sched_getscheduler() returns the policy for the  thread
       (a nonnegative integer).  On error, both calls return -1, and errno is set appropriately.

ERRORS
       EINVAL Invalid arguments: pid is negative or param is NULL.

       EINVAL (sched_setscheduler()) policy is not one of the recognized policies.

       EINVAL (sched_setscheduler()) param does not make sense for the specified policy.

       EPERM  The calling thread does not have appropriate privileges.

       ESRCH  The thread whose ID is pid could not be found.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008 (but see BUGS below).  The SCHED_BATCH and SCHED_IDLE policies are Linux-specific.

NOTES
       Further  details  of the semantics of all of the above "normal" and "real-time" scheduling policies can be found in
       the sched(7) manual page.  That page also describes an additional policy, SCHED_DEADLINE, which  is  settable  only
       via sched_setattr(2).

       POSIX  systems on which sched_setscheduler() and sched_getscheduler() are available define _POSIX_PRIORITY_SCHEDUL‐
       ING in <unistd.h>.

       POSIX.1 does not detail the permissions that an unprivileged thread requires in order to call sched_setscheduler(),
       and details vary across systems.  For example, the Solaris 7 manual page says that the real or effective user ID of
       the caller must match the real user ID or the save set-user-ID of the target.

       The scheduling policy and parameters are in fact per-thread attributes on Linux.  The value returned from a call to
       gettid(2)  can  be  passed  in the argument pid.  Specifying pid as 0 will operate on the attributes of the calling
       thread, and passing the value returned from a call to getpid(2) will operate on the attributes of the  main  thread
       of the thread group.  (If you are using the POSIX threads API, then use pthread_setschedparam(3), pthread_getsched‐
       param(3), and pthread_setschedprio(3), instead of the sched_*(2) system calls.)

BUGS
       POSIX.1  says  that  on  success,  sched_setscheduler()  should  return  the  previous  scheduling  policy.   Linux
       sched_setscheduler() does not conform to this requirement, since it always returns 0 on success.

SEE ALSO
       chrt(1), nice(2), sched_get_priority_max(2), sched_get_priority_min(2), sched_getaffinity(2), sched_getattr(2),
       sched_getparam(2), sched_rr_get_interval(2), sched_setaffinity(2), sched_setattr(2), sched_setparam(2),
       sched_yield(2), setpriority(2), capabilities(7), cpuset(7), sched(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                   SCHED_SETSCHEDULER(2)
</pre>
<pre zoom>
<span xsmall>2 pwritev</span>
READV(2)                                         Linux Programmer's Manual                                        READV(2)

NAME
       readv, writev, preadv, pwritev, preadv2, pwritev2 - read or write data into multiple buffers

SYNOPSIS
       #include <sys/uio.h>

       ssize_t readv(int fd, const struct iovec *iov, int iovcnt);

       ssize_t writev(int fd, const struct iovec *iov, int iovcnt);

       ssize_t preadv(int fd, const struct iovec *iov, int iovcnt,
                      off_t offset);

       ssize_t pwritev(int fd, const struct iovec *iov, int iovcnt,
                       off_t offset);

       ssize_t preadv2(int fd, const struct iovec *iov, int iovcnt,
                       off_t offset, int flags);

       ssize_t pwritev2(int fd, const struct iovec *iov, int iovcnt,
                        off_t offset, int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       preadv(), pwritev():
           Since glibc 2.19:
               _DEFAULT_SOURCE
           Glibc 2.19 and earlier:
               _BSD_SOURCE

DESCRIPTION
       The  readv() system call reads iovcnt buffers from the file associated with the file descriptor fd into the buffers
       described by iov ("scatter input").

       The writev() system call writes iovcnt buffers of data described by iov  to  the  file  associated  with  the  file
       descriptor fd ("gather output").

       The pointer iov points to an array of iovec structures, defined in <sys/uio.h> as:

           struct iovec {
               void  *iov_base;    /* Starting address */
               size_t iov_len;     /* Number of bytes to transfer */
           };

       The readv() system call works just like read(2) except that multiple buffers are filled.

       The writev() system call works just like write(2) except that multiple buffers are written out.

       Buffers are processed in array order.  This means that readv() completely fills iov[0] before proceeding to iov[1],
       and so on.  (If there is insufficient data, then not all buffers pointed to by  iov  may  be  filled.)   Similarly,
       writev() writes out the entire contents of iov[0] before proceeding to iov[1], and so on.

       The  data transfers performed by readv() and writev() are atomic: the data written by writev() is written as a sin‐
       gle block that is not intermingled with output from writes in other processes (but see pipe(7) for  an  exception);
       analogously,  readv() is guaranteed to read a contiguous block of data from the file, regardless of read operations
       performed in other threads or processes that have file descriptors referring to the same open file description (see
       open(2)).

   preadv() and pwritev()
       The preadv() system call combines the functionality of readv() and pread(2).  It performs the same task as readv(),
       but adds a fourth argument, offset, which specifies the file offset at which the input  operation  is  to  be  per‐
       formed.

       The  pwritev()  system  call  combines  the  functionality of writev() and pwrite(2).  It performs the same task as
       writev(), but adds a fourth argument, offset, which specifies the file offset at which the output operation  is  to
       be performed.

       The file offset is not changed by these system calls.  The file referred to by fd must be capable of seeking.

   preadv2() and pwritev2()
       These system calls are similar to preadv() and pwritev() calls, but add a fifth argument, flags, which modifies the
       behavior on a per-call basis.

       Unlike preadv() and pwritev(), if the offset argument is -1, then the current file offset is used and updated.

       The flags argument contains a bitwise OR of zero or more of the following flags:

       RWF_DSYNC (since Linux 4.7)
              Provide a per-write equivalent of the O_DSYNC open(2) flag.  This flag is meaningful  only  for  pwritev2(),
              and its effect applies only to the data range written by the system call.

       RWF_HIPRI (since Linux 4.6)
              High priority read/write.  Allows block-based filesystems to use polling of the device, which provides lower
              latency, but may use additional resources.  (Currently, this feature is usable only  on  a  file  descriptor
              opened using the O_DIRECT flag.)

       RWF_SYNC (since Linux 4.7)
              Provide a per-write equivalent of the O_SYNC open(2) flag.  This flag is meaningful only for pwritev2(), and
              its effect applies only to the data range written by the system call.

       RWF_NOWAIT (since Linux 4.14)
              Do not wait for data which is not immediately available.  If this flag is specified,  the  preadv2()  system
              call  will  return  instantly if it would have to read data from the backing storage or wait for a lock.  If
              some data was successfully read, it will return the number of bytes read.  If no bytes were  read,  it  will
              return -1 and set errno to EAGAIN.  Currently, this flag is meaningful only for preadv2().

       RWF_APPEND (since Linux 4.16)
              Provide  a  per-write equivalent of the O_APPEND open(2) flag.  This flag is meaningful only for pwritev2(),
              and its effect applies only to the data range written by the system call.   The  offset  argument  does  not
              affect  the  write  operation;  the  data is always appended to the end of the file.  However, if the offset
              argument is -1, the current file offset is updated.

RETURN VALUE
       On success, readv(), preadv() and preadv2() return the number of bytes read;  writev(),  pwritev()  and  pwritev2()
       return the number of bytes written.

       Note  that  it  is  not  an  error  for  a  successful call to transfer fewer bytes than requested (see read(2) and
       write(2)).

       On error, -1 is returned, and errno is set appropriately.

ERRORS
       The errors are as given for read(2) and write(2).  Furthermore, preadv(), preadv2(), pwritev(), and pwritev2()  can
       also fail for the same reasons as lseek(2).  Additionally, the following errors are defined:

       EINVAL The sum of the iov_len values overflows an ssize_t value.

       EINVAL The vector count, iovcnt, is less than zero or greater than the permitted maximum.

       EINVAL An unknown flag is specified in flags.

VERSIONS
       preadv() and pwritev() first appeared in Linux 2.6.30; library support was added in glibc 2.10.

       preadv2() and pwritev2() first appeared in Linux 4.6.  Library support was added in glibc 2.26.

CONFORMING TO
       readv(), writev(): POSIX.1-2001, POSIX.1-2008, 4.4BSD (these system calls first appeared in 4.2BSD).

       preadv(), pwritev(): nonstandard, but present also on the modern BSDs.

       preadv2(), pwritev2(): nonstandard Linux extension.

NOTES
       POSIX.1 allows an implementation to place a limit on the number of items that can be passed in iov.  An implementa‐
       tion can advertise its limit by defining  IOV_MAX  in  <limits.h>  or  at  run  time  via  the  return  value  from
       sysconf(_SC_IOV_MAX).  On modern Linux systems, the limit is 1024.  Back in Linux 2.0 days, this limit was 16.

   C library/kernel differences
       The  raw preadv() and pwritev() system calls have call signatures that differ slightly from that of the correspond‐
       ing GNU C library wrapper functions shown in the SYNOPSIS.  The final argument, offset, is unpacked by the  wrapper
       functions into two arguments in the system calls:

           unsigned long pos_l, unsigned long pos

       These arguments contain, respectively, the low order and high order 32 bits of offset.

   Historical C library/kernel differences
       To  deal  with the fact that IOV_MAX was so low on early versions of Linux, the glibc wrapper functions for readv()
       and writev() did some extra work if they detected that the underlying kernel system call failed because this  limit
       was  exceeded.   In  the case of readv(), the wrapper function allocated a temporary buffer large enough for all of
       the items specified by iov, passed that buffer in a call to read(2), copied data from the buffer to  the  locations
       specified  by  the  iov_base  fields  of  the elements of iov, and then freed the buffer.  The wrapper function for
       writev() performed the analogous task using a temporary buffer and a call to write(2).

       The need for this extra effort in the glibc wrapper functions went away with Linux 2.2 and later.   However,  glibc
       continued to provide this behavior until version 2.10.  Starting with glibc version 2.9, the wrapper functions pro‐
       vide this behavior only if the library detects that the system is running a Linux kernel older than version  2.6.18
       (an  arbitrarily  selected kernel version).  And since glibc 2.20 (which requires a minimum Linux kernel version of
       2.6.32), the glibc wrapper functions always just directly invoke the system calls.

EXAMPLE
       The following code sample demonstrates the use of writev():

           char *str0 = "hello ";
           char *str1 = "world\n";
           struct iovec iov[2];
           ssize_t nwritten;

           iov[0].iov_base = str0;
           iov[0].iov_len = strlen(str0);
           iov[1].iov_base = str1;
           iov[1].iov_len = strlen(str1);

           nwritten = writev(STDOUT_FILENO, iov, 2);

SEE ALSO
       pread(2), read(2), write(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                                READV(2)
</pre>
<pre zoom>
<span xsmall>2 eventfd2</span>
EVENTFD(2)                                       Linux Programmer's Manual                                      EVENTFD(2)

NAME
       eventfd - create a file descriptor for event notification

SYNOPSIS
       #include <sys/eventfd.h>

       int eventfd(unsigned int initval, int flags);

DESCRIPTION
       eventfd()  creates  an  "eventfd  object" that can be used as an event wait/notify mechanism by user-space applica‐
       tions, and by the kernel to notify user-space applications of events.  The object contains an unsigned 64-bit inte‐
       ger  (uint64_t)  counter that is maintained by the kernel.  This counter is initialized with the value specified in
       the argument initval.

       The following values may be bitwise ORed in flags to change the behavior of eventfd():

       EFD_CLOEXEC (since Linux 2.6.27)
              Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.  See the description  of  the  O_CLOEXEC
              flag in open(2) for reasons why this may be useful.

       EFD_NONBLOCK (since Linux 2.6.27)
              Set  the O_NONBLOCK file status flag on the new open file description.  Using this flag saves extra calls to
              fcntl(2) to achieve the same result.

       EFD_SEMAPHORE (since Linux 2.6.30)
              Provide semaphore-like semantics for reads from the new file descriptor.  See below.

       In Linux up to version 2.6.26, the flags argument is unused, and must be specified as zero.

       As its return value, eventfd() returns a new file descriptor that can be used to refer to the eventfd object.   The
       following operations can be performed on the file descriptor:

       read(2)
              Each successful read(2) returns an 8-byte integer.  A read(2) fails with the error EINVAL if the size of the
              supplied buffer is less than 8 bytes.

              The value returned by read(2) is in host byte order—that is, the native byte order for integers on the  host
              machine.

              The semantics of read(2) depend on whether the eventfd counter currently has a nonzero value and whether the
              EFD_SEMAPHORE flag was specified when creating the eventfd file descriptor:

              *  If EFD_SEMAPHORE was not specified and the eventfd counter has a nonzero value, then a read(2) returns  8
                 bytes containing that value, and the counter's value is reset to zero.

              *  If  EFD_SEMAPHORE  was  specified  and  the eventfd counter has a nonzero value, then a read(2) returns 8
                 bytes containing the value 1, and the counter's value is decremented by 1.

              *  If the eventfd counter is zero at the time of the call to read(2), then the call either blocks until  the
                 counter  becomes nonzero (at which time, the read(2) proceeds as described above) or fails with the error
                 EAGAIN if the file descriptor has been made nonblocking.

       write(2)
              A write(2) call adds the 8-byte integer value supplied in its buffer to the counter.  The maximum value that
              may  be  stored  in the counter is the largest unsigned 64-bit value minus 1 (i.e., 0xfffffffffffffffe).  If
              the addition would cause the counter's value to exceed the maximum, then the write(2) either blocks until  a
              read(2)  is performed on the file descriptor, or fails with the error EAGAIN if the file descriptor has been
              made nonblocking.

              A write(2) fails with the error EINVAL if the size of the supplied buffer is less than 8  bytes,  or  if  an
              attempt is made to write the value 0xffffffffffffffff.

       poll(2), select(2) (and similar)
              The returned file descriptor supports poll(2) (and analogously epoll(7)) and select(2), as follows:

              *  The  file descriptor is readable (the select(2) readfds argument; the poll(2) POLLIN flag) if the counter
                 has a value greater than 0.

              *  The file descriptor is writable (the select(2) writefds argument; the poll(2) POLLOUT flag) if it is pos‐
                 sible to write a value of at least "1" without blocking.

              *  If  an  overflow of the counter value was detected, then select(2) indicates the file descriptor as being
                 both readable and writable, and poll(2) returns a POLLERR event.  As  noted  above,  write(2)  can  never
                 overflow the counter.  However an overflow can occur if 2^64 eventfd "signal posts" were performed by the
                 KAIO subsystem (theoretically possible, but practically unlikely).  If an  overflow  has  occurred,  then
                 read(2) will return that maximum uint64_t value (i.e., 0xffffffffffffffff).

              The  eventfd  file  descriptor  also  supports  the  other file-descriptor multiplexing APIs: pselect(2) and
              ppoll(2).

       close(2)
              When the file descriptor is no longer required it should be closed.  When all  file  descriptors  associated
              with the same eventfd object have been closed, the resources for object are freed by the kernel.

       A  copy  of  the file descriptor created by eventfd() is inherited by the child produced by fork(2).  The duplicate
       file descriptor is associated with the same eventfd object.  File descriptors created by  eventfd()  are  preserved
       across execve(2), unless the close-on-exec flag has been set.

RETURN VALUE
       On success, eventfd() returns a new eventfd file descriptor.  On error, -1 is returned and errno is set to indicate
       the error.

ERRORS
       EINVAL An unsupported value was specified in flags.

       EMFILE The per-process limit on the number of open file descriptors has been reached.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENODEV Could not mount (internal) anonymous inode device.

       ENOMEM There was insufficient memory to create a new eventfd file descriptor.

VERSIONS
       eventfd() is available on Linux since kernel 2.6.22.  Working support is provided in glibc since version 2.8.   The
       eventfd2()  system  call  (see  NOTES)  is  available  on  Linux since kernel 2.6.27.  Since version 2.9, the glibc
       eventfd() wrapper will employ the eventfd2() system call, if it is supported by the kernel.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌──────────┬───────────────┬─────────┐
       │Interface │ Attribute     │ Value   │
       ├──────────┼───────────────┼─────────┤
       │eventfd() │ Thread safety │ MT-Safe │
       └──────────┴───────────────┴─────────┘

CONFORMING TO
       eventfd() and eventfd2() are Linux-specific.

NOTES
       Applications can use an eventfd file descriptor instead of a pipe (see pipe(2)) in all cases where a pipe  is  used
       simply  to signal events.  The kernel overhead of an eventfd file descriptor is much lower than that of a pipe, and
       only one file descriptor is required (versus the two required for a pipe).

       When used in the kernel, an eventfd file descriptor can provide a bridge from kernel to user space,  allowing,  for
       example, functionalities like KAIO (kernel AIO) to signal to a file descriptor that some operation is complete.

       A  key point about an eventfd file descriptor is that it can be monitored just like any other file descriptor using
       select(2), poll(2), or epoll(7).  This means that an application can simultaneously monitor the readiness of  "tra‐
       ditional"  files  and  the  readiness  of other kernel mechanisms that support the eventfd interface.  (Without the
       eventfd() interface, these mechanisms could not be multiplexed via select(2), poll(2), or epoll(7).)

       The current value of an eventfd counter can be viewed via the entry for the corresponding file  descriptor  in  the
       process's /proc/[pid]/fdinfo directory.  See proc(5) for further details.

   C library/kernel differences
       There are two underlying Linux system calls: eventfd() and the more recent eventfd2().  The former system call does
       not implement a flags argument.  The latter system call implements the flags values  described  above.   The  glibc
       wrapper function will use eventfd2() where it is available.

   Additional glibc features
       The  GNU  C  library  defines an additional type, and two functions that attempt to abstract some of the details of
       reading and writing on an eventfd file descriptor:

           typedef uint64_t eventfd_t;

           int eventfd_read(int fd, eventfd_t *value);
           int eventfd_write(int fd, eventfd_t value);

       The functions perform the read and write operations on an eventfd file descriptor, returning 0 if the correct  num‐
       ber of bytes was transferred, or -1 otherwise.

EXAMPLE
       The  following program creates an eventfd file descriptor and then forks to create a child process.  While the par‐
       ent briefly sleeps, the child writes each of the integers supplied in the program's command-line arguments  to  the
       eventfd file descriptor.  When the parent has finished sleeping, it reads from the eventfd file descriptor.

       The following shell session shows a sample run of the program:

           $ ./a.out 1 2 4 7 14
           Child writing 1 to efd
           Child writing 2 to efd
           Child writing 4 to efd
           Child writing 7 to efd
           Child writing 14 to efd
           Child completed write loop
           Parent about to read
           Parent read 28 (0x1c) from efd

   Program source

       #include <sys/eventfd.h>
       #include <unistd.h>
       #include <stdlib.h>
       #include <stdio.h>
       #include <stdint.h>             /* Definition of uint64_t */

       #define handle_error(msg) \
           do { perror(msg); exit(EXIT_FAILURE); } while (0)

       int
       main(int argc, char *argv[])
       {
           int efd, j;
           uint64_t u;
           ssize_t s;

           if (argc < 2) {
               fprintf(stderr, "Usage: %s <num>...\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           efd = eventfd(0, 0);
           if (efd == -1)
               handle_error("eventfd");

           switch (fork()) {
           case 0:
               for (j = 1; j < argc; j++) {
                   printf("Child writing %s to efd\n", argv[j]);
                   u = strtoull(argv[j], NULL, 0);
                           /* strtoull() allows various bases */
                   s = write(efd, &u, sizeof(uint64_t));
                   if (s != sizeof(uint64_t))
                       handle_error("write");
               }
               printf("Child completed write loop\n");

               exit(EXIT_SUCCESS);

           default:
               sleep(2);

               printf("Parent about to read\n");
               s = read(efd, &u, sizeof(uint64_t));
               if (s != sizeof(uint64_t))
                   handle_error("read");
               printf("Parent read %llu (0x%llx) from efd\n",
                       (unsigned long long) u, (unsigned long long) u);
               exit(EXIT_SUCCESS);

           case -1:
               handle_error("fork");
           }
       }

SEE ALSO
       futex(2), pipe(2), poll(2), read(2), select(2), signalfd(2), timerfd_create(2), write(2), epoll(7), sem_overview(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              EVENTFD(2)
</pre>
<pre zoom>
<span xsmall>2 swapoff</span>
SWAPON(2)                                        Linux Programmer's Manual                                       SWAPON(2)

NAME
       swapon, swapoff - start/stop swapping to file/device

SYNOPSIS
       #include <unistd.h>
       #include <sys/swap.h>

       int swapon(const char *path, int swapflags);
       int swapoff(const char *path);

DESCRIPTION
       swapon() sets the swap area to the file or block device specified by path.  swapoff() stops swapping to the file or
       block device specified by path.

       If the SWAP_FLAG_PREFER flag is specified in the swapon() swapflags argument, the new swap area will have a  higher
       priority than default.  The priority is encoded within swapflags as:

           (prio << SWAP_FLAG_PRIO_SHIFT) & SWAP_FLAG_PRIO_MASK

       If  the  SWAP_FLAG_DISCARD flag is specified in the swapon() swapflags argument, freed swap pages will be discarded
       before they are reused, if the swap device supports the discard or trim operation.  (This may  improve  performance
       on some Solid State Devices, but often it does not.)  See also NOTES.

       These functions may be used only by a privileged process (one having the CAP_SYS_ADMIN capability).

   Priority
       Each  swap  area  has a priority, either high or low.  The default priority is low.  Within the low-priority areas,
       newer areas are even lower priority than older areas.

       All priorities set with swapflags are high-priority, higher than default.  They may have any nonnegative value cho‐
       sen by the caller.  Higher numbers mean higher priority.

       Swap  pages  are  allocated from areas in priority order, highest priority first.  For areas with different priori‐
       ties, a higher-priority area is exhausted before using a lower-priority area.  If two or more areas have  the  same
       priority, and it is the highest priority available, pages are allocated on a round-robin basis between them.

       As of Linux 1.3.6, the kernel usually follows these rules, but there are exceptions.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EBUSY  (for swapon()) The specified path is already being used as a swap area.

       EINVAL The file path exists, but refers neither to a regular file nor to a block device;

       EINVAL (swapon())  The indicated path does not contain a valid swap signature or resides on an in-memory filesystem
              such as tmpfs(5).

       EINVAL (since Linux 3.4)
              (swapon()) An invalid flag value was specified in flags.

       EINVAL (swapoff()) path is not currently a swap area.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENOENT The file path does not exist.

       ENOMEM The system has insufficient memory to start swapping.

       EPERM  The caller does not have the CAP_SYS_ADMIN capability.  Alternatively, the maximum number of swap files  are
              already in use; see NOTES below.

CONFORMING TO
       These  functions  are  Linux-specific  and  should  not  be  used  in programs intended to be portable.  The second
       swapflags argument was introduced in Linux 1.3.2.

NOTES
       The partition or path must be prepared with mkswap(8).

       There is an upper limit on the number of swap files that may be used, defined by the kernel constant MAX_SWAPFILES.
       Before  kernel  2.4.10,  MAX_SWAPFILES  has  the  value  8; since kernel 2.4.10, it has the value 32.  Since kernel
       2.6.18, the limit is decreased by 2 (thus: 30) if the kernel is  built  with  the  CONFIG_MIGRATION  option  (which
       reserves  two  swap  table entries for the page migration features of mbind(2) and migrate_pages(2)).  Since kernel
       2.6.32, the limit is further decreased by 1 if the kernel is built with the CONFIG_MEMORY_FAILURE option.

       Discard of swap pages was introduced in kernel 2.6.29, then made conditional on the SWAP_FLAG_DISCARD flag in  ker‐
       nel 2.6.36, which still discards the entire swap area when swapon() is called, even if that flag bit is not set.

SEE ALSO
       mkswap(8), swapoff(8), swapon(8)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SWAPON(2)
</pre>
<pre zoom>
<span xsmall>2 setitimer</span>
GETITIMER(2)                                     Linux Programmer's Manual                                    GETITIMER(2)

NAME
       getitimer, setitimer - get or set value of an interval timer

SYNOPSIS
       #include <sys/time.h>

       int getitimer(int which, struct itimerval *curr_value);
       int setitimer(int which, const struct itimerval *new_value,
                     struct itimerval *old_value);

DESCRIPTION
       These  system  calls  provide access to interval timers, that is, timers that initially expire at some point in the
       future, and (optionally) at regular intervals after that.  When a timer expires, a  signal  is  generated  for  the
       calling process, and the timer is reset to the specified interval (if the interval is nonzero).

       Three types of timers—specified via the which argument—are provided, each of which counts against a different clock
       and generates a different signal on timer expiration:

       ITIMER_REAL    This timer counts down in real (i.e., wall clock) time.  At each expiration,  a  SIGALRM  signal  is
                      generated.

       ITIMER_VIRTUAL This  timer  counts  down  against the user-mode CPU time consumed by the process.  (The measurement
                      includes CPU time consumed by all threads in the process.)  At each expiration, a  SIGVTALRM  signal
                      is generated.

       ITIMER_PROF    This  timer  counts  down  against  the  total (i.e., both user and system) CPU time consumed by the
                      process.  (The measurement includes CPU time consumed by all threads in the process.)  At each expi‐
                      ration, a SIGPROF signal is generated.

                      In  conjunction with ITIMER_VIRTUAL, this timer can be used to profile user and system CPU time con‐
                      sumed by the process.

       A process has only one of each of the three types of timers.

       Timer values are defined by the following structures:

           struct itimerval {
               struct timeval it_interval; /* Interval for periodic timer */
               struct timeval it_value;    /* Time until next expiration */
           };

           struct timeval {
               time_t      tv_sec;         /* seconds */
               suseconds_t tv_usec;        /* microseconds */
           };

   getitimer()
       The function getitimer() places the current value of the timer specified by which  in  the  buffer  pointed  to  by
       curr_value.

       The it_value substructure is populated with the amount of time remaining until the next expiration of the specified
       timer.  This value changes as the timer counts down, and will be reset to it_interval when the timer  expires.   If
       both fields of it_value are zero, then this timer is currently disarmed (inactive).

       The  it_interval  substructure  is populated with the timer interval.  If both fields of it_interval are zero, then
       this is a single-shot timer (i.e., it expires just once).

   setitimer()
       The function setitimer() arms or disarms the timer specified by which, by setting the timer to the value  specified
       by  new_value.  If old_value is non-NULL, the buffer it points to is used to return the previous value of the timer
       (i.e., the same information that is returned by getitimer()).

       If either field in new_value.it_value is nonzero, then the timer is armed to  initially  expire  at  the  specified
       time.  If both fields in new_value.it_value are zero, then the timer is disarmed.

       The  new_value.it_interval  field  specifies the new interval for the timer; if both of its subfields are zero, the
       timer is single-shot.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT new_value, old_value, or curr_value is not valid a pointer.

       EINVAL which is not one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF; or (since Linux 2.6.22) one of the  tv_usec
              fields in the structure pointed to by new_value contains a value outside the range 0 to 999999.

CONFORMING TO
       POSIX.1-2001,  SVr4,  4.4BSD  (this call first appeared in 4.2BSD).  POSIX.1-2008 marks getitimer() and setitimer()
       obsolete, recommending the use of the POSIX timers API (timer_gettime(2), timer_settime(2), etc.) instead.

NOTES
       Timers will never expire before the requested time, but may expire some (short) time afterward,  which  depends  on
       the system timer resolution and on the system load; see time(7).  (But see BUGS below.)  If the timer expires while
       the process is active (always true for ITIMER_VIRTUAL), the signal will be delivered immediately when generated.

       A child created via fork(2) does not inherit its parent's interval timers.  Interval timers are preserved across an
       execve(2).

       POSIX.1  leaves  the  interaction  between  setitimer()  and the three interfaces alarm(2), sleep(3), and usleep(3)
       unspecified.

       The standards are silent on the meaning of the call:

           setitimer(which, NULL, &old_value);

       Many systems (Solaris, the BSDs, and perhaps others) treat this as equivalent to:

           getitimer(which, &old_value);

       In Linux, this is treated as being equivalent to a call in which the new_value fields are zero; that is, the  timer
       is disabled.  Don't use this Linux misfeature: it is nonportable and unnecessary.

BUGS
       The generation and delivery of a signal are distinct, and only one instance of each of the signals listed above may
       be pending for a process.  Under very heavy loading, an ITIMER_REAL timer may expire before the signal from a  pre‐
       vious expiration has been delivered.  The second signal in such an event will be lost.

       On  Linux  kernels before 2.6.16, timer values are represented in jiffies.  If a request is made set a timer with a
       value whose jiffies representation exceeds MAX_SEC_IN_JIFFIES (defined in include/linux/jiffies.h), then the  timer
       is  silently truncated to this ceiling value.  On Linux/i386 (where, since Linux 2.6.13, the default jiffy is 0.004
       seconds), this means that the ceiling value for a timer is approximately 99.42 days.  Since Linux 2.6.16, the  ker‐
       nel uses a different internal representation for times, and this ceiling is removed.

       On  certain  systems  (including i386), Linux kernels before version 2.6.12 have a bug which will produce premature
       timer expirations of up to one jiffy under some circumstances.  This bug is fixed in kernel 2.6.12.

       POSIX.1-2001 says that setitimer() should fail if a tv_usec value is specified that is outside of the  range  0  to
       999999.  However, in kernels up to and including 2.6.21, Linux does not give an error, but instead silently adjusts
       the corresponding seconds value for the timer.  From kernel 2.6.22 onward, this nonconformance has  been  repaired:
       an improper tv_usec value results in an EINVAL error.

SEE ALSO
       gettimeofday(2), sigaction(2), signal(2), timer_create(2), timerfd_create(2), time(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            GETITIMER(2)
</pre>
<pre zoom>
<span xsmall>2 signalfd4</span>
SIGNALFD(2)                                      Linux Programmer's Manual                                     SIGNALFD(2)

NAME
       signalfd - create a file descriptor for accepting signals

SYNOPSIS
       #include <sys/signalfd.h>

       int signalfd(int fd, const sigset_t *mask, int flags);

DESCRIPTION
       signalfd()  creates  a file descriptor that can be used to accept signals targeted at the caller.  This provides an
       alternative to the use of a signal handler or sigwaitinfo(2), and has the advantage that the file descriptor may be
       monitored by select(2), poll(2), and epoll(7).

       The  mask  argument  specifies  the  set of signals that the caller wishes to accept via the file descriptor.  This
       argument is a signal set whose contents can be initialized using the macros described in  sigsetops(3).   Normally,
       the  set  of  signals to be received via the file descriptor should be blocked using sigprocmask(2), to prevent the
       signals being handled according to their default dispositions.  It is not possible to receive  SIGKILL  or  SIGSTOP
       signals via a signalfd file descriptor; these signals are silently ignored if specified in mask.

       If  the  fd  argument is -1, then the call creates a new file descriptor and associates the signal set specified in
       mask with that file descriptor.  If fd is not -1, then it must specify a valid existing signalfd  file  descriptor,
       and mask is used to replace the signal set associated with that file descriptor.

       Starting with Linux 2.6.27, the following values may be bitwise ORed in flags to change the behavior of signalfd():

       SFD_NONBLOCK  Set  the  O_NONBLOCK  file status flag on the new open file description.  Using this flag saves extra
                     calls to fcntl(2) to achieve the same result.

       SFD_CLOEXEC   Set the close-on-exec (FD_CLOEXEC) flag on the new file  descriptor.   See  the  description  of  the
                     O_CLOEXEC flag in open(2) for reasons why this may be useful.

       In Linux up to version 2.6.26, the flags argument is unused, and must be specified as zero.

       signalfd() returns a file descriptor that supports the following operations:

       read(2)
              If  one  or  more  of  the signals specified in mask is pending for the process, then the buffer supplied to
              read(2) is used to return one or more signalfd_siginfo structures (see below)  that  describe  the  signals.
              The read(2) returns information for as many signals as are pending and will fit in the supplied buffer.  The
              buffer must be at least sizeof(struct signalfd_siginfo) bytes.  The return value of the read(2) is the total
              number of bytes read.

              As  a  consequence  of  the  read(2),  the  signals are consumed, so that they are no longer pending for the
              process (i.e., will not be caught by signal handlers, and cannot be accepted using sigwaitinfo(2)).

              If none of the signals in mask is pending for the process, then the read(2) either blocks until one  of  the
              signals in mask is generated for the process, or fails with the error EAGAIN if the file descriptor has been
              made nonblocking.

       poll(2), select(2) (and similar)
              The file descriptor is readable (the select(2) readfds argument; the poll(2) POLLIN flag) if one or more  of
              the signals in mask is pending for the process.

              The  signalfd  file  descriptor  also  supports  the  other  file-descriptor  multiplexing APIs: pselect(2),
              ppoll(2), and epoll(7).

       close(2)
              When the file descriptor is no longer required it should be closed.  When all  file  descriptors  associated
              with the same signalfd object have been closed, the resources for object are freed by the kernel.

   The signalfd_siginfo structure
       The format of the signalfd_siginfo structure(s) returned by read(2)s from a signalfd file descriptor is as follows:

           struct signalfd_siginfo {
               uint32_t ssi_signo;    /* Signal number */
               int32_t  ssi_errno;    /* Error number (unused) */
               int32_t  ssi_code;     /* Signal code */
               uint32_t ssi_pid;      /* PID of sender */
               uint32_t ssi_uid;      /* Real UID of sender */
               int32_t  ssi_fd;       /* File descriptor (SIGIO) */
               uint32_t ssi_tid;      /* Kernel timer ID (POSIX timers)
               uint32_t ssi_band;     /* Band event (SIGIO) */
               uint32_t ssi_overrun;  /* POSIX timer overrun count */
               uint32_t ssi_trapno;   /* Trap number that caused signal */
               int32_t  ssi_status;   /* Exit status or signal (SIGCHLD) */
               int32_t  ssi_int;      /* Integer sent by sigqueue(3) */
               uint64_t ssi_ptr;      /* Pointer sent by sigqueue(3) */
               uint64_t ssi_utime;    /* User CPU time consumed (SIGCHLD) */
               uint64_t ssi_stime;    /* System CPU time consumed
                                         (SIGCHLD) */
               uint64_t ssi_addr;     /* Address that generated signal
                                         (for hardware-generated signals) */
               uint16_t ssi_addr_lsb; /* Least significant bit of address
                                         (SIGBUS; since Linux 2.6.37)
               uint8_t  pad[X];       /* Pad size to 128 bytes (allow for
                                         additional fields in the future) */
           };

       Each  of  the  fields  in this structure is analogous to the similarly named field in the siginfo_t structure.  The
       siginfo_t structure is described in sigaction(2).  Not all fields in the returned signalfd_siginfo  structure  will
       be  valid  for a specific signal; the set of valid fields can be determined from the value returned in the ssi_code
       field.  This field is the analog of the siginfo_t si_code field; see sigaction(2) for details.

   fork(2) semantics
       After a fork(2), the child inherits a copy of the signalfd file descriptor.  A read(2) from the file descriptor  in
       the child will return information about signals queued to the child.

   Semantics of file descriptor passing
       As with other file descriptors, signalfd file descriptors can be passed to another process via a UNIX domain socket
       (see unix(7)).  In the receiving process, a read(2) from the received file descriptor will return information about
       signals queued to that process.

   execve(2) semantics
       Just  like  any  other  file descriptor, a signalfd file descriptor remains open across an execve(2), unless it has
       been marked for close-on-exec (see fcntl(2)).  Any signals that were available for  reading  before  the  execve(2)
       remain  available to the newly loaded program.  (This is analogous to traditional signal semantics, where a blocked
       signal that is pending remains pending across an execve(2).)

   Thread semantics
       The semantics of signalfd file descriptors in a multithreaded program mirror the standard  semantics  for  signals.
       In  other words, when a thread reads from a signalfd file descriptor, it will read the signals that are directed to
       the thread itself and the signals that are directed to the process (i.e., the entire thread group).  (A thread will
       not be able to read signals that are directed to other threads in the process.)

RETURN VALUE
       On  success, signalfd() returns a signalfd file descriptor; this is either a new file descriptor (if fd was -1), or
       fd if fd was a valid signalfd file descriptor.  On error, -1 is returned and errno is set to indicate the error.

ERRORS
       EBADF  The fd file descriptor is not a valid file descriptor.

       EINVAL fd is not a valid signalfd file descriptor.

       EINVAL flags is invalid; or, in Linux 2.6.26 or earlier, flags is nonzero.

       EMFILE The per-process limit on the number of open file descriptors has been reached.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENODEV Could not mount (internal) anonymous inode device.

       ENOMEM There was insufficient memory to create a new signalfd file descriptor.

VERSIONS
       signalfd() is available on Linux since kernel 2.6.22.  Working support is provided in glibc since version 2.8.  The
       signalfd4() system call (see NOTES) is available on Linux since kernel 2.6.27.

CONFORMING TO
       signalfd() and signalfd4() are Linux-specific.

NOTES
       A  process  can  create  multiple signalfd file descriptors.  This makes it possible to accept different signals on
       different file descriptors.  (This may be useful if monitoring the file descriptors using  select(2),  poll(2),  or
       epoll(7): the arrival of different signals will make different file descriptors ready.)  If a signal appears in the
       mask of more than one of the file descriptors, then occurrences of that signal can be read (once) from any  one  of
       the file descriptors.

       Attempts to include SIGKILL and SIGSTOP in mask are silently ignored.

       The  signal  mask  employed  by  a  signalfd file descriptor can be viewed via the entry for the corresponding file
       descriptor in the process's /proc/[pid]/fdinfo directory.  See proc(5) for further details.

   Limitations
       The signalfd mechanism can't be used to receive signals that are synchronously generated, such as the SIGSEGV  sig‐
       nal  that  results  from  accessing  an invalid memory address or the SIGFPE signal that results from an arithmetic
       error.  Such signals can be caught only via signal handler.

       As described above, in normal usage one blocks the signals that will be accepted via  signalfd().   If  spawning  a
       child  process  to execute a helper program (that does not need the signalfd file descriptor), then, after the call
       to fork(2), you will normally want to unblock those signals before calling execve(2), so that  the  helper  program
       can see any signals that it expects to see.  Be aware, however, that this won't be possible in the case of a helper
       program spawned behind the scenes by any library function that the program may call.  In such cases, one must  fall
       back  to  using  a  traditional signal handler that writes to a file descriptor monitored by select(2), poll(2), or
       epoll(7),

   C library/kernel differences
       The underlying Linux system call requires an additional argument, size_t sizemask, which specifies the size of  the
       mask  argument.   The  glibc  signalfd()  wrapper  function  does  not include this argument, since it provides the
       required value for the underlying system call.

       There are two underlying Linux system calls: signalfd() and the more recent signalfd4().  The  former  system  call
       does not implement a flags argument.  The latter system call implements the flags values described above.  Starting
       with glibc 2.9, the signalfd() wrapper function will use signalfd4() where it is available.

BUGS
       In kernels before 2.6.25, the ssi_ptr and ssi_int fields are not filled in with the data accompanying a signal sent
       by sigqueue(3).

EXAMPLE
       The  program  below  accepts the signals SIGINT and SIGQUIT via a signalfd file descriptor.  The program terminates
       after accepting a SIGQUIT signal.  The following shell session demonstrates the use of the program:

           $ ./signalfd_demo
           ^C                   # Control-C generates SIGINT
           Got SIGINT
           ^C
           Got SIGINT
           ^\                    # Control-\ generates SIGQUIT
           Got SIGQUIT
           $

   Program source

       #include <sys/signalfd.h>
       #include <signal.h>
       #include <unistd.h>
       #include <stdlib.h>
       #include <stdio.h>

       #define handle_error(msg) \
           do { perror(msg); exit(EXIT_FAILURE); } while (0)

       int
       main(int argc, char *argv[])
       {
           sigset_t mask;
           int sfd;
           struct signalfd_siginfo fdsi;
           ssize_t s;

           sigemptyset(&mask);
           sigaddset(&mask, SIGINT);
           sigaddset(&mask, SIGQUIT);

           /* Block signals so that they aren't handled
              according to their default dispositions */

           if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)
               handle_error("sigprocmask");

           sfd = signalfd(-1, &mask, 0);
           if (sfd == -1)
               handle_error("signalfd");

           for (;;) {
               s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));
               if (s != sizeof(struct signalfd_siginfo))
                   handle_error("read");

               if (fdsi.ssi_signo == SIGINT) {
                   printf("Got SIGINT\n");
               } else if (fdsi.ssi_signo == SIGQUIT) {
                   printf("Got SIGQUIT\n");
                   exit(EXIT_SUCCESS);
               } else {
                   printf("Read unexpected signal\n");
               }
           }
       }

SEE ALSO
       eventfd(2), poll(2), read(2), select(2), sigaction(2), sigprocmask(2),  sigwaitinfo(2),  timerfd_create(2),  sigse‐
       tops(3), sigwait(3), epoll(7), signal(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-05-03                                             SIGNALFD(2)
</pre>
<pre zoom>
<span xsmall>2 timer_create</span>
TIMER_CREATE(2)                                  Linux Programmer's Manual                                 TIMER_CREATE(2)

NAME
       timer_create - create a POSIX per-process timer

SYNOPSIS
       #include <signal.h>
       #include <time.h>

       int timer_create(clockid_t clockid, struct sigevent *sevp,
                        timer_t *timerid);

       Link with -lrt.

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       timer_create(): _POSIX_C_SOURCE >= 199309L

DESCRIPTION
       timer_create() creates a new per-process interval timer.  The ID of the new timer is returned in the buffer pointed
       to by timerid, which must be a non-null pointer.  This ID is unique within the process, until the timer is deleted.
       The new timer is initially disarmed.

       The  clockid  argument  specifies the clock that the new timer uses to measure time.  It can be specified as one of
       the following values:

       CLOCK_REALTIME
              A settable system-wide real-time clock.

       CLOCK_MONOTONIC
              A nonsettable monotonically increasing clock that measures time from some unspecified point in the past that
              does not change after system startup.

       CLOCK_PROCESS_CPUTIME_ID (since Linux 2.6.12)
              A clock that measures (user and system) CPU time consumed by (all of the threads in) the calling process.

       CLOCK_THREAD_CPUTIME_ID (since Linux 2.6.12)
              A clock that measures (user and system) CPU time consumed by the calling thread.

       CLOCK_BOOTTIME (Since Linux 2.6.39)
              Like  CLOCK_MONOTONIC, this is a monotonically increasing clock.  However, whereas the CLOCK_MONOTONIC clock
              does not measure the time while a system is suspended, the CLOCK_BOOTTIME clock does include the time during
              which  the system is suspended.  This is useful for applications that need to be suspend-aware.  CLOCK_REAL‐
              TIME is not suitable for such applications, since that clock is affected by  discontinuous  changes  to  the
              system clock.

       CLOCK_REALTIME_ALARM (since Linux 3.0)
              This  clock  is  like CLOCK_REALTIME, but will wake the system if it is suspended.  The caller must have the
              CAP_WAKE_ALARM capability in order to set a timer against this clock.

       CLOCK_BOOTTIME_ALARM (since Linux 3.0)
              This clock is like CLOCK_BOOTTIME, but will wake the system if it is suspended.  The caller  must  have  the
              CAP_WAKE_ALARM capability in order to set a timer against this clock.

       As  well  as the above values, clockid can be specified as the clockid returned by a call to clock_getcpuclockid(3)
       or pthread_getcpuclockid(3).

       The sevp argument points to a sigevent structure that specifies how the caller should be notified  when  the  timer
       expires.  For the definition and general details of this structure, see sigevent(7).

       The sevp.sigev_notify field can have the following values:

       SIGEV_NONE
              Don't asynchronously notify when the timer expires.  Progress of the timer can be monitored using timer_get‐
              time(2).

       SIGEV_SIGNAL
              Upon timer expiration, generate the signal  sigev_signo  for  the  process.   See  sigevent(7)  for  general
              details.   The  si_code  field of the siginfo_t structure will be set to SI_TIMER.  At any point in time, at
              most one signal is queued to the process for a given timer; see timer_getoverrun(2) for more details.

       SIGEV_THREAD
              Upon timer expiration, invoke sigev_notify_function as if it were the start function of a new  thread.   See
              sigevent(7) for details.

       SIGEV_THREAD_ID (Linux-specific)
              As  for  SIGEV_SIGNAL, but the signal is targeted at the thread whose ID is given in sigev_notify_thread_id,
              which must be a thread in the same process as the caller.  The sigev_notify_thread_id field specifies a ker‐
              nel  thread ID, that is, the value returned by clone(2) or gettid(2).  This flag is intended only for use by
              threading libraries.

       Specifying sevp as NULL is equivalent to specifying a pointer to a sigevent  structure  in  which  sigev_notify  is
       SIGEV_SIGNAL, sigev_signo is SIGALRM, and sigev_value.sival_int is the timer ID.

RETURN VALUE
       On  success,  timer_create()  returns  0,  and  the  ID  of the new timer is placed in *timerid.  On failure, -1 is
       returned, and errno is set to indicate the error.

ERRORS
       EAGAIN Temporary error during kernel allocation of timer structures.

       EINVAL Clock ID, sigev_notify, sigev_signo, or sigev_notify_thread_id is invalid.

       ENOMEM Could not allocate memory.

VERSIONS
       This system call is available since Linux 2.6.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       A program may create multiple interval timers using timer_create().

       Timers are not inherited by the child of a fork(2), and are disarmed and deleted during an execve(2).

       The kernel preallocates a "queued real-time signal" for each timer created using timer_create().  Consequently, the
       number of timers is limited by the RLIMIT_SIGPENDING resource limit (see setrlimit(2)).

       The  timers  created  by timer_create() are commonly known as "POSIX (interval) timers".  The POSIX timers API con‐
       sists of the following interfaces:

       *  timer_create(): Create a timer.

       *  timer_settime(2): Arm (start) or disarm (stop) a timer.

       *  timer_gettime(2): Fetch the time remaining until the next expiration of a timer, along with the interval setting
          of the timer.

       *  timer_getoverrun(2): Return the overrun count for the last timer expiration.

       *  timer_delete(2): Disarm and delete a timer.

       Since  Linux  3.10,  the /proc/[pid]/timers file can be used to list the POSIX timers for the process with PID pid.
       See proc(5) for further information.

       Since Linux 4.10, support for POSIX timers is a configurable option that is enabled by default.  Kernel support can
       be disabled via the CONFIG_POSIX_TIMERS option.

   C library/kernel differences
       Part of the implementation of the POSIX timers API is provided by glibc.  In particular:

       *  Much of the functionality for SIGEV_THREAD is implemented within glibc, rather than the kernel.  (This is neces‐
          sarily so, since the thread involved in handling the notification is one that must be managed by the  C  library
          POSIX  threads  implementation.)  Although the notification delivered to the process is via a thread, internally
          the NPTL implementation uses a sigev_notify value of SIGEV_THREAD_ID along  with  a  real-time  signal  that  is
          reserved by the implementation (see nptl(7)).

       *  The  implementation  of the default case where evp is NULL is handled inside glibc, which invokes the underlying
          system call with a suitably populated sigevent structure.

       *  The timer IDs presented at user level are maintained by glibc, which maps these IDs to the timer IDs employed by
          the kernel.

       The  POSIX timers system calls first appeared in Linux 2.6.  Prior to this, glibc provided an incomplete user-space
       implementation (CLOCK_REALTIME timers only) using POSIX threads, and in glibc versions before 2.17, the implementa‐
       tion falls back to this technique on systems running pre-2.6 Linux kernels.

EXAMPLE
       The  program  below takes two arguments: a sleep period in seconds, and a timer frequency in nanoseconds.  The pro‐
       gram establishes a handler for the signal it uses for the timer, blocks that signal, creates and arms a timer  that
       expires  with  the given frequency, sleeps for the specified number of seconds, and then unblocks the timer signal.
       Assuming that the timer expired at least once while the program slept, the signal handler will be invoked, and  the
       handler displays some information about the timer notification.  The program terminates after one invocation of the
       signal handler.

       In the following example run, the program sleeps for 1 second, after creating a timer that has a frequency  of  100
       nanoseconds.  By the time the signal is unblocked and delivered, there have been around ten million overruns.

           $ ./a.out 1 100
           Establishing handler for signal 34
           Blocking signal 34
           timer ID is 0x804c008
           Sleeping for 1 seconds
           Unblocking signal 34
           Caught signal 34
               sival_ptr = 0xbfb174f4;     *sival_ptr = 0x804c008
               overrun count = 10004886

   Program source

       #include <stdlib.h>
       #include <unistd.h>
       #include <stdio.h>
       #include <signal.h>
       #include <time.h>

       #define CLOCKID CLOCK_REALTIME
       #define SIG SIGRTMIN

       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       static void
       print_siginfo(siginfo_t *si)
       {
           timer_t *tidp;
           int or;

           tidp = si->si_value.sival_ptr;

           printf("    sival_ptr = %p; ", si->si_value.sival_ptr);
           printf("    *sival_ptr = 0x%lx\n", (long) *tidp);

           or = timer_getoverrun(*tidp);
           if (or == -1)
               errExit("timer_getoverrun");
           else
               printf("    overrun count = %d\n", or);
       }

       static void
       handler(int sig, siginfo_t *si, void *uc)
       {
           /* Note: calling printf() from a signal handler is not safe
              (and should not be done in production programs), since
              printf() is not async-signal-safe; see signal-safety(7).
              Nevertheless, we use printf() here as a simple way of
              showing that the handler was called. */

           printf("Caught signal %d\n", sig);
           print_siginfo(si);
           signal(sig, SIG_IGN);
       }

       int
       main(int argc, char *argv[])
       {
           timer_t timerid;
           struct sigevent sev;
           struct itimerspec its;
           long long freq_nanosecs;
           sigset_t mask;
           struct sigaction sa;

           if (argc != 3) {
               fprintf(stderr, "Usage: %s <sleep-secs> <freq-nanosecs>\n",
                       argv[0]);
               exit(EXIT_FAILURE);
           }

           /* Establish handler for timer signal */

           printf("Establishing handler for signal %d\n", SIG);
           sa.sa_flags = SA_SIGINFO;
           sa.sa_sigaction = handler;
           sigemptyset(&sa.sa_mask);
           if (sigaction(SIG, &sa, NULL) == -1)
               errExit("sigaction");

           /* Block timer signal temporarily */

           printf("Blocking signal %d\n", SIG);
           sigemptyset(&mask);
           sigaddset(&mask, SIG);
           if (sigprocmask(SIG_SETMASK, &mask, NULL) == -1)
               errExit("sigprocmask");

           /* Create the timer */

           sev.sigev_notify = SIGEV_SIGNAL;
           sev.sigev_signo = SIG;
           sev.sigev_value.sival_ptr = &timerid;
           if (timer_create(CLOCKID, &sev, &timerid) == -1)
               errExit("timer_create");

           printf("timer ID is 0x%lx\n", (long) timerid);

           /* Start the timer */

           freq_nanosecs = atoll(argv[2]);
           its.it_value.tv_sec = freq_nanosecs / 1000000000;
           its.it_value.tv_nsec = freq_nanosecs % 1000000000;
           its.it_interval.tv_sec = its.it_value.tv_sec;
           its.it_interval.tv_nsec = its.it_value.tv_nsec;

           if (timer_settime(timerid, 0, &its, NULL) == -1)
                errExit("timer_settime");

           /* Sleep for a while; meanwhile, the timer may expire
              multiple times */

           printf("Sleeping for %d seconds\n", atoi(argv[1]));
           sleep(atoi(argv[1]));

           /* Unlock the timer signal, so that timer notification
              can be delivered */

           printf("Unblocking signal %d\n", SIG);
           if (sigprocmask(SIG_UNBLOCK, &mask, NULL) == -1)
               errExit("sigprocmask");

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       clock_gettime(2), setitimer(2), timer_delete(2), timer_getoverrun(2), timer_settime(2), timerfd_create(2),
       clock_getcpuclockid(3), pthread_getcpuclockid(3), pthreads(7), sigevent(7), signal(7), time(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                         TIMER_CREATE(2)
</pre>
<pre zoom>
<span xsmall>2 sethostname</span>
GETHOSTNAME(2)                                   Linux Programmer's Manual                                  GETHOSTNAME(2)

NAME
       gethostname, sethostname - get/set hostname

SYNOPSIS
       #include <unistd.h>

       int gethostname(char *name, size_t len);
       int sethostname(const char *name, size_t len);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       gethostname():
           Since glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE >= 500
           || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200112L
       sethostname():
           Since glibc 2.21:
               _DEFAULT_SOURCE
           In glibc 2.19 and 2.20:
               _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE < 500)
           Up to and including glibc 2.19:
               _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE < 500)

DESCRIPTION
       These system calls are used to access or to change the hostname of the current processor.

       sethostname()  sets  the  hostname  to the value given in the character array name.  The len argument specifies the
       number of bytes in name.  (Thus, name does not require a terminating null byte.)

       gethostname() returns the null-terminated hostname in the character array name, which has a length  of  len  bytes.
       If  the null-terminated hostname is too large to fit, then the name is truncated, and no error is returned (but see
       NOTES below).  POSIX.1 says that if such truncation occurs, then it is  unspecified  whether  the  returned  buffer
       includes a terminating null byte.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT name is an invalid address.

       EINVAL len is negative or, for sethostname(), len is larger than the maximum allowed size.

       ENAMETOOLONG
              (glibc  gethostname()) len is smaller than the actual size.  (Before version 2.1, glibc uses EINVAL for this
              case.)

       EPERM  For sethostname(), the caller did not have the CAP_SYS_ADMIN capability in  the  user  namespace  associated
              with its UTS namespace (see namespaces(7)).

CONFORMING TO
       SVr4, 4.4BSD  (these interfaces first appeared in 4.2BSD).  POSIX.1-2001 and POSIX.1-2008 specify gethostname() but
       not sethostname().

NOTES
       SUSv2 guarantees that "Host names are limited to 255 bytes".  POSIX.1 guarantees that "Host  names  (not  including
       the  terminating null byte) are limited to HOST_NAME_MAX bytes".  On Linux, HOST_NAME_MAX is defined with the value
       64, which has been the limit since Linux 1.0 (earlier kernels imposed a limit of 8 bytes).

   C library/kernel differences
       The GNU C library does not employ the gethostname() system call; instead, it implements gethostname() as a  library
       function  that  calls  uname(2) and copies up to len bytes from the returned nodename field into name.  Having per‐
       formed the copy, the function then checks if the length of the nodename was greater than or equal to len, and if it
       is,  then  the  function  returns  -1  with errno set to ENAMETOOLONG; in this case, a terminating null byte is not
       included in the returned name.

       Versions of glibc before 2.2 handle the case where the length of the nodename was greater than or equal to len dif‐
       ferently: nothing is copied into name and the function returns -1 with errno set to ENAMETOOLONG.

SEE ALSO
       hostname(1), getdomainname(2), setdomainname(2), uname(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                          GETHOSTNAME(2)
</pre>
<pre zoom>
<span xsmall>2 clock_gettime</span>
CLOCK_GETRES(2)                                  Linux Programmer's Manual                                 CLOCK_GETRES(2)

NAME
       clock_getres, clock_gettime, clock_settime - clock and time functions

SYNOPSIS
       #include <time.h>

       int clock_getres(clockid_t clk_id, struct timespec *res);

       int clock_gettime(clockid_t clk_id, struct timespec *tp);

       int clock_settime(clockid_t clk_id, const struct timespec *tp);

       Link with -lrt (only for glibc versions before 2.17).

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       clock_getres(), clock_gettime(), clock_settime():
              _POSIX_C_SOURCE >= 199309L

DESCRIPTION
       The  function  clock_getres()  finds  the resolution (precision) of the specified clock clk_id, and, if res is non-
       NULL, stores it in the struct timespec pointed to by res.  The resolution of clocks depends on  the  implementation
       and  cannot  be  configured by a particular process.  If the time value pointed to by the argument tp of clock_set‐
       time() is not a multiple of res, then it is truncated to a multiple of res.

       The functions clock_gettime() and clock_settime() retrieve and set the time of the specified clock clk_id.

       The res and tp arguments are timespec structures, as specified in <time.h>:

           struct timespec {
               time_t   tv_sec;        /* seconds */
               long     tv_nsec;       /* nanoseconds */
           };

       The clk_id argument is the identifier of the particular clock on which to act.  A  clock  may  be  system-wide  and
       hence visible for all processes, or per-process if it measures time only within a single process.

       All  implementations support the system-wide real-time clock, which is identified by CLOCK_REALTIME.  Its time rep‐
       resents seconds and nanoseconds since the Epoch.  When its time is changed, timers  for  a  relative  interval  are
       unaffected, but timers for an absolute point in time are affected.

       More  clocks  may  be implemented.  The interpretation of the corresponding time values and the effect on timers is
       unspecified.

       Sufficiently recent versions of glibc and the Linux kernel support the following clocks:

       CLOCK_REALTIME
              System-wide clock that measures real (i.e., wall-clock) time.  Setting this clock requires appropriate priv‐
              ileges.  This clock is affected by discontinuous jumps in the system time (e.g., if the system administrator
              manually changes the clock), and by the incremental adjustments performed by adjtime(3) and NTP.

       CLOCK_REALTIME_COARSE (since Linux 2.6.32; Linux-specific)
              A faster but less precise version of CLOCK_REALTIME.  Use when you need  very  fast,  but  not  fine-grained
              timestamps.   Requires per-architecture support, and probably also architecture support for this flag in the
              vdso(7).

       CLOCK_MONOTONIC
              Clock that cannot be set and represents monotonic time since some unspecified starting point.  This clock is
              not  affected  by discontinuous jumps in the system time (e.g., if the system administrator manually changes
              the clock), but is affected by the incremental adjustments performed by adjtime(3) and NTP.

       CLOCK_MONOTONIC_COARSE (since Linux 2.6.32; Linux-specific)
              A faster but less precise version of CLOCK_MONOTONIC.  Use when you need very  fast,  but  not  fine-grained
              timestamps.   Requires per-architecture support, and probably also architecture support for this flag in the
              vdso(7).

       CLOCK_MONOTONIC_RAW (since Linux 2.6.28; Linux-specific)
              Similar to CLOCK_MONOTONIC, but provides access to a raw hardware-based time that  is  not  subject  to  NTP
              adjustments or the incremental adjustments performed by adjtime(3).

       CLOCK_BOOTTIME (since Linux 2.6.39; Linux-specific)
              Identical  to  CLOCK_MONOTONIC,  except it also includes any time that the system is suspended.  This allows
              applications to get a suspend-aware monotonic clock  without  having  to  deal  with  the  complications  of
              CLOCK_REALTIME, which may have discontinuities if the time is changed using settimeofday(2) or similar.

       CLOCK_PROCESS_CPUTIME_ID (since Linux 2.6.12)
              Per-process CPU-time clock (measures CPU time consumed by all threads in the process).

       CLOCK_THREAD_CPUTIME_ID (since Linux 2.6.12)
              Thread-specific CPU-time clock.

RETURN VALUE
       clock_gettime(),  clock_settime(),  and clock_getres() return 0 for success, or -1 for failure (in which case errno
       is set appropriately).

ERRORS
       EFAULT tp points outside the accessible address space.

       EINVAL The clk_id specified is not supported on this system.

       EPERM  clock_settime() does not have permission to set the clock indicated.

VERSIONS
       These system calls first appeared in Linux 2.6.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌─────────────────────────────────┬───────────────┬─────────┐
       │Interface                        │ Attribute     │ Value   │
       ├─────────────────────────────────┼───────────────┼─────────┤
       │clock_getres(), clock_gettime(), │ Thread safety │ MT-Safe │
       │clock_settime()                  │               │         │
       └─────────────────────────────────┴───────────────┴─────────┘

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SUSv2.

AVAILABILITY
       On  POSIX  systems  on  which these functions are available, the symbol _POSIX_TIMERS is defined in <unistd.h> to a
       value greater than 0.  The symbols  _POSIX_MONOTONIC_CLOCK,  _POSIX_CPUTIME,  _POSIX_THREAD_CPUTIME  indicate  that
       CLOCK_MONOTONIC, CLOCK_PROCESS_CPUTIME_ID, CLOCK_THREAD_CPUTIME_ID are available.  (See also sysconf(3).)

NOTES
       POSIX.1 specifies the following:

              Setting  the  value of the CLOCK_REALTIME clock via clock_settime() shall have no effect on threads that are
              blocked waiting for a relative time service based upon this clock, including the nanosleep()  function;  nor
              on  the expiration of relative timers based upon this clock.  Consequently, these time services shall expire
              when the requested relative interval elapses, independently of the new or old value of the clock.

   C library/kernel differences
       On some architectures, an implementation of clock_gettime() is provided in the vdso(7).

   Historical note for SMP systems
       Before Linux added kernel support for CLOCK_PROCESS_CPUTIME_ID and CLOCK_THREAD_CPUTIME_ID, glibc implemented these
       clocks on many platforms using timer registers from the CPUs (TSC on i386, AR.ITC on Itanium).  These registers may
       differ between CPUs and as a consequence these clocks may return bogus results if a process is migrated to  another
       CPU.

       If  the  CPUs in an SMP system have different clock sources, then there is no way to maintain a correlation between
       the timer registers since each CPU will run at  a  slightly  different  frequency.   If  that  is  the  case,  then
       clock_getcpuclockid(0) will return ENOENT to signify this condition.  The two clocks will then be useful only if it
       can be ensured that a process stays on a certain CPU.

       The processors in an SMP system do not start all at exactly the same time and therefore  the  timer  registers  are
       typically  running  at  an offset.  Some architectures include code that attempts to limit these offsets on bootup.
       However, the code cannot guarantee to accurately tune the offsets.  Glibc contains no provisions to deal with these
       offsets  (unlike  the Linux Kernel).  Typically these offsets are small and therefore the effects may be negligible
       in most cases.

       Since glibc 2.4, the wrapper functions for the system calls described in this page avoid the  abovementioned  prob‐
       lems  by  employing  the  kernel implementation of CLOCK_PROCESS_CPUTIME_ID and CLOCK_THREAD_CPUTIME_ID, on systems
       that provide such an implementation (i.e., Linux 2.6.12 and later).

BUGS
       According to POSIX.1-2001, a process  with  "appropriate  privileges"  may  set  the  CLOCK_PROCESS_CPUTIME_ID  and
       CLOCK_THREAD_CPUTIME_ID  clocks  using  clock_settime().  On Linux, these clocks are not settable (i.e., no process
       has "appropriate privileges").

SEE ALSO
       date(1),  gettimeofday(2),  settimeofday(2),  time(2),  adjtime(3),  clock_getcpuclockid(3),  ctime(3),   ftime(3),
       pthread_getcpuclockid(3), sysconf(3), time(7), vdso(7), hwclock(8)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

                                                        2017-09-15                                         CLOCK_GETRES(2)
</pre>
<pre zoom>
<span xsmall>2 setns</span>
SETNS(2)                                         Linux Programmer's Manual                                        SETNS(2)

NAME
       setns - reassociate thread with a namespace

SYNOPSIS
       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <sched.h>

       int setns(int fd, int nstype);

DESCRIPTION
       Given a file descriptor referring to a namespace, reassociate the calling thread with that namespace.

       The  fd argument is a file descriptor referring to one of the namespace entries in a /proc/[pid]/ns/ directory; see
       namespaces(7) for further information on /proc/[pid]/ns/.  The calling thread will be reassociated with the  corre‐
       sponding namespace, subject to any constraints imposed by the nstype argument.

       The  nstype  argument specifies which type of namespace the calling thread may be reassociated with.  This argument
       can have one of the following values:

       0      Allow any type of namespace to be joined.

       CLONE_NEWCGROUP (since Linux 4.6)
              fd must refer to a cgroup namespace.

       CLONE_NEWIPC (since Linux 3.0)
              fd must refer to an IPC namespace.

       CLONE_NEWNET (since Linux 3.0)
              fd must refer to a network namespace.

       CLONE_NEWNS (since Linux 3.8)
              fd must refer to a mount namespace.

       CLONE_NEWPID (since Linux 3.8)
              fd must refer to a descendant PID namespace.

       CLONE_NEWUSER (since Linux 3.8)
              fd must refer to a user namespace.

       CLONE_NEWUTS (since Linux 3.0)
              fd must refer to a UTS namespace.

       Specifying nstype as 0 suffices if the caller knows (or does not care) what type of namespace is referred to by fd.
       Specifying  a  nonzero value for nstype is useful if the caller does not know what type of namespace is referred to
       by fd and wants to ensure that the namespace is of a particular type.  (The caller might not know the type  of  the
       namespace  referred  to  by fd if the file descriptor was opened by another process and, for example, passed to the
       caller via a UNIX domain socket.)

       If fd refers to a PID namespaces, the semantics are somewhat different from other  namespace  types:  reassociating
       the calling thread with a PID namespace changes only the PID namespace that subsequently created child processes of
       the caller will be placed in; it does not change the PID namespace of the caller itself.  Reassociating with a  PID
       namespace  is  allowed  only if the PID namespace specified by fd is a descendant (child, grandchild, etc.)  of the
       PID namespace of the caller.  For further details on PID namespaces, see pid_namespaces(7).

       A process reassociating itself with a user namespace must have the CAP_SYS_ADMIN  capability  in  the  target  user
       namespace.   Upon  successfully  joining a user namespace, a process is granted all capabilities in that namespace,
       regardless of its user and group IDs.  A multithreaded process may not change user namespace with setns().   It  is
       not  permitted  to  use  setns()  to  reenter the caller's current user namespace.  This prevents a caller that has
       dropped capabilities from regaining those capabilities via a call to setns().   For  security  reasons,  a  process
       can't  join  a  new  user namespace if it is sharing filesystem-related attributes (the attributes whose sharing is
       controlled by the clone(2) CLONE_FS flag) with another process.   For  further  details  on  user  namespaces,  see
       user_namespaces(7).

       A  process may not be reassociated with a new mount namespace if it is multithreaded.  Changing the mount namespace
       requires that the caller possess both CAP_SYS_CHROOT and CAP_SYS_ADMIN capabilities in its own user  namespace  and
       CAP_SYS_ADMIN  in the target mount namespace.  See user_namespaces(7) for details on the interaction of user names‐
       paces and mount namespaces.

       Using setns() to change the caller's cgroup namespace does not change the caller's cgroup memberships.

RETURN VALUE
       On success, setns() returns 0.  On failure, -1 is returned and errno is set to indicate the error.

ERRORS
       EBADF  fd is not a valid file descriptor.

       EINVAL fd refers to a namespace whose type does not match that specified in nstype.

       EINVAL There is problem with reassociating the thread with the specified namespace.

       EINVAL The caller tried to join an ancestor (parent, grandparent, and so on) PID namespace.

       EINVAL The caller attempted to join the user namespace in which it is already a member.

       EINVAL The caller shares filesystem (CLONE_FS) state (in particular, the root directory) with other  processes  and
              tried to join a new user namespace.

       EINVAL The caller is multithreaded and tried to join a new user namespace.

       ENOMEM Cannot allocate sufficient memory to change the specified namespace.

       EPERM  The calling thread did not have the required capability for this operation.

VERSIONS
       The setns() system call first appeared in Linux in kernel 3.0; library support was added to glibc in version 2.14.

CONFORMING TO
       The setns() system call is Linux-specific.

NOTES
       Not  all  of  the  attributes  that  can be shared when a new thread is created using clone(2) can be changed using
       setns().

EXAMPLE
       The program below takes two or more arguments.  The first argument specifies the pathname of a namespace file in an
       existing  /proc/[pid]/ns/  directory.   The  remaining  arguments specify a command and its arguments.  The program
       opens the namespace file, joins that namespace using setns(), and executes the specified command inside that names‐
       pace.

       The  following  shell session demonstrates the use of this program (compiled as a binary named ns_exec) in conjunc‐
       tion with the CLONE_NEWUTS example program in the clone(2) man page (complied as a binary named newuts).

       We begin by executing the example program in clone(2) in the background.  That program creates a child in  a  sepa‐
       rate UTS namespace.  The child changes the hostname in its namespace, and then both processes display the hostnames
       in their UTS namespaces, so that we can see that they are different.

           $ su                   # Need privilege for namespace operations
           Password:
           # ./newuts bizarro &
           [1] 3549
           clone() returned 3550
           uts.nodename in child:  bizarro
           uts.nodename in parent: antero
           # uname -n             # Verify hostname in the shell
           antero

       We then run the program shown below, using it to execute a shell.  Inside that shell, we verify that  the  hostname
       is the one set by the child created by the first program:

           # ./ns_exec /proc/3550/ns/uts /bin/bash
           # uname -n             # Executed in shell started by ns_exec
           bizarro

   Program source
       #define _GNU_SOURCE
       #include <fcntl.h>
       #include <sched.h>
       #include <unistd.h>
       #include <stdlib.h>
       #include <stdio.h>

       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       int
       main(int argc, char *argv[])
       {
           int fd;

           if (argc < 3) {
               fprintf(stderr, "%s /proc/PID/ns/FILE cmd args...\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           fd = open(argv[1], O_RDONLY); /* Get file descriptor for namespace */
           if (fd == -1)
               errExit("open");

           if (setns(fd, 0) == -1)       /* Join that namespace */
               errExit("setns");

           execvp(argv[2], &argv[2]);    /* Execute a command in namespace */
           errExit("execvp");
       }

SEE ALSO
       nsenter(1), clone(2), fork(2), unshare(2), vfork(2), namespaces(7), unix(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                SETNS(2)
</pre>
<pre zoom>
<span xsmall>2 iopl</span>
IOPL(2)                                          Linux Programmer's Manual                                         IOPL(2)

NAME
       iopl - change I/O privilege level

SYNOPSIS
       #include <sys/io.h>

       int iopl(int level);

DESCRIPTION
       iopl()  changes  the  I/O privilege level of the calling process, as specified by the two least significant bits in
       level.

       This call is necessary to allow 8514-compatible X servers to run under Linux.  Since these X servers require access
       to all 65536 I/O ports, the ioperm(2) call is not sufficient.

       In  addition  to  granting  unrestricted  I/O  port access, running at a higher I/O privilege level also allows the
       process to disable interrupts.  This will probably crash the system, and is not recommended.

       Permissions are not inherited by the child process created by fork(2) and are not preserved across  execve(2)  (but
       see NOTES).

       The I/O privilege level for a normal process is 0.

       This call is mostly for the i386 architecture.  On many other architectures it does not exist or will always return
       an error.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EINVAL level is greater than 3.

       ENOSYS This call is unimplemented.

       EPERM  The calling process has insufficient privilege to call iopl(); the CAP_SYS_RAWIO capability is  required  to
              raise the I/O privilege level above its current value.

CONFORMING TO
       iopl() is Linux-specific and should not be used in programs that are intended to be portable.

NOTES
       Glibc2 has a prototype both in <sys/io.h> and in <sys/perm.h>.  Avoid the latter, it is available on i386 only.

       Prior  to  Linux  3.7,  on  some  architectures (such as i386), permissions were inherited by the child produced by
       fork(2) and were preserved across execve(2).  This behavior was inadvertently changed in Linux 3.7,  and  won't  be
       reinstated.

SEE ALSO
       ioperm(2), outb(2), capabilities(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 IOPL(2)
</pre>
<pre zoom>
<span xsmall>2 wait</span>
WAIT(2)                                          Linux Programmer's Manual                                         WAIT(2)

NAME
       wait, waitpid, waitid - wait for process to change state

SYNOPSIS
       #include <sys/types.h>
       #include <sys/wait.h>

       pid_t wait(int *wstatus);

       pid_t waitpid(pid_t pid, int *wstatus, int options);

       int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
                       /* This is the glibc and POSIX interface; see
                          NOTES for information on the raw system call. */

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       waitid():
           Since glibc 2.26: _XOPEN_SOURCE >= 500 ||
               _POSIX_C_SOURCE >= 200809L
           Glibc 2.25 and earlier:
               _XOPEN_SOURCE
                   || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
                   || /* Glibc versions <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       All of these system calls are used to wait for state changes in a child of the calling process, and obtain informa‐
       tion about the child whose state has changed.  A state change is considered to be: the child terminated; the  child
       was  stopped  by  a  signal; or the child was resumed by a signal.  In the case of a terminated child, performing a
       wait allows the system to release the resources associated with the child; if a wait is  not  performed,  then  the
       terminated child remains in a "zombie" state (see NOTES below).

       If  a  child  has already changed state, then these calls return immediately.  Otherwise, they block until either a
       child changes state or a signal handler interrupts the call (assuming  that  system  calls  are  not  automatically
       restarted  using  the  SA_RESTART  flag  of  sigaction(2)).  In the remainder of this page, a child whose state has
       changed and which has not yet been waited upon by one of these system calls is termed waitable.

   wait() and waitpid()
       The wait() system call suspends execution of the calling thread until one of its  children  terminates.   The  call
       wait(&wstatus) is equivalent to:

           waitpid(-1, &wstatus, 0);

       The  waitpid()  system  call  suspends  execution of the calling thread until a child specified by pid argument has
       changed state.  By default, waitpid() waits only for terminated children, but this behavior is modifiable  via  the
       options argument, as described below.

       The value of pid can be:

       < -1   meaning wait for any child process whose process group ID is equal to the absolute value of pid.

       -1     meaning wait for any child process.

       0      meaning wait for any child process whose process group ID is equal to that of the calling process.

       > 0    meaning wait for the child whose process ID is equal to the value of pid.

       The value of options is an OR of zero or more of the following constants:

       WNOHANG     return immediately if no child has exited.

       WUNTRACED   also  return  if  a child has stopped (but not traced via ptrace(2)).  Status for traced children which
                   have stopped is provided even if this option is not specified.

       WCONTINUED (since Linux 2.6.10)
                   also return if a stopped child has been resumed by delivery of SIGCONT.

       (For Linux-only options, see below.)

       If wstatus is not NULL, wait() and waitpid() store status information in the int to which it points.  This  integer
       can  be  inspected with the following macros (which take the integer itself as an argument, not a pointer to it, as
       is done in wait() and waitpid()!):

       WIFEXITED(wstatus)
              returns true if the child terminated normally, that is, by calling exit(3) or _exit(2), or by returning from
              main().

       WEXITSTATUS(wstatus)
              returns  the exit status of the child.  This consists of the least significant 8 bits of the status argument
              that the child specified in a call to exit(3) or _exit(2) or as the  argument  for  a  return  statement  in
              main().  This macro should be employed only if WIFEXITED returned true.

       WIFSIGNALED(wstatus)
              returns true if the child process was terminated by a signal.

       WTERMSIG(wstatus)
              returns  the number of the signal that caused the child process to terminate.  This macro should be employed
              only if WIFSIGNALED returned true.

       WCOREDUMP(wstatus)
              returns true if the child produced a core dump.  This macro should be employed only if WIFSIGNALED  returned
              true.

              This  macro  is  not specified in POSIX.1-2001 and is not available on some UNIX implementations (e.g., AIX,
              SunOS).  Therefore, enclose its use inside #ifdef WCOREDUMP ... #endif.

       WIFSTOPPED(wstatus)
              returns true if the child process was stopped by delivery of a signal; this is possible only if the call was
              done using WUNTRACED or when the child is being traced (see ptrace(2)).

       WSTOPSIG(wstatus)
              returns the number of the signal which caused the child to stop.  This macro should be employed only if WIF‐
              STOPPED returned true.

       WIFCONTINUED(wstatus)
              (since Linux 2.6.10) returns true if the child process was resumed by delivery of SIGCONT.

   waitid()
       The waitid() system call (available since Linux 2.6.9) provides more precise control over which child state changes
       to wait for.

       The idtype and id arguments select the child(ren) to wait for, as follows:

       idtype == P_PID
              Wait for the child whose process ID matches id.

       idtype == P_PGID
              Wait for any child whose process group ID matches id.

       idtype == P_ALL
              Wait for any child; id is ignored.

       The child state changes to wait for are specified by ORing one or more of the following flags in options:

       WEXITED     Wait for children that have terminated.

       WSTOPPED    Wait for children that have been stopped by delivery of a signal.

       WCONTINUED  Wait for (previously stopped) children that have been resumed by delivery of SIGCONT.

       The following flags may additionally be ORed in options:

       WNOHANG     As for waitpid().

       WNOWAIT     Leave  the  child in a waitable state; a later wait call can be used to again retrieve the child status
                   information.

       Upon successful return, waitid() fills in the following fields of the siginfo_t structure pointed to by infop:

       si_pid      The process ID of the child.

       si_uid      The real user ID of the child.  (This field is not set on most other implementations.)

       si_signo    Always set to SIGCHLD.

       si_status   Either the exit status of the child, as given to _exit(2) (or exit(3)), or the signal that  caused  the
                   child  to  terminate,  stop,  or continue.  The si_code field can be used to determine how to interpret
                   this field.

       si_code     Set to one of: CLD_EXITED (child called _exit(2)); CLD_KILLED  (child  killed  by  signal);  CLD_DUMPED
                   (child  killed  by signal, and dumped core); CLD_STOPPED (child stopped by signal); CLD_TRAPPED (traced
                   child has trapped); or CLD_CONTINUED (child continued by SIGCONT).

       If WNOHANG was specified in options and there were no children in a waitable state, then waitid() returns 0 immedi‐
       ately  and  the  state of the siginfo_t structure pointed to by infop depends on the implementation.  To (portably)
       distinguish this case from that where a child was in a waitable state, zero out the si_pid field  before  the  call
       and check for a nonzero value in this field after the call returns.

       POSIX.1-2008  Technical  Corrigendum  1  (2013)  adds the requirement that when WNOHANG is specified in options and
       there were no children in a waitable state, then waitid() should zero out the si_pid and  si_signo  fields  of  the
       structure.  On Linux and other implementations that adhere to this requirement, it is not necessary to zero out the
       si_pid field before calling waitid().  However, not all implementations follow the POSIX.1  specification  on  this
       point.

RETURN VALUE
       wait(): on success, returns the process ID of the terminated child; on error, -1 is returned.

       waitpid():  on  success,  returns the process ID of the child whose state has changed; if WNOHANG was specified and
       one or more child(ren) specified by pid exist, but have not yet changed state, then 0 is returned.  On error, -1 is
       returned.

       waitid(): returns 0 on success or if WNOHANG was specified and no child(ren) specified by id has yet changed state;
       on error, -1 is returned.

       Each of these calls sets errno to an appropriate value in the case of an error.

ERRORS
       ECHILD (for wait()) The calling process does not have any unwaited-for children.

       ECHILD (for waitpid() or waitid()) The process specified by pid (waitpid()) or idtype and id  (waitid())  does  not
              exist  or  is  not  a  child of the calling process.  (This can happen for one's own child if the action for
              SIGCHLD is set to SIG_IGN.  See also the Linux Notes section about threads.)

       EINTR  WNOHANG was not set and an unblocked signal or a SIGCHLD was caught; see signal(7).

       EINVAL The options argument was invalid.

CONFORMING TO
       SVr4, 4.3BSD, POSIX.1-2001.

NOTES
       A child that terminates, but has not been waited for becomes a "zombie".  The kernel maintains  a  minimal  set  of
       information  about  the  zombie process (PID, termination status, resource usage information) in order to allow the
       parent to later perform a wait to obtain information about the child.  As long as a zombie is not removed from  the
       system via a wait, it will consume a slot in the kernel process table, and if this table fills, it will not be pos‐
       sible to create further processes.  If a parent process terminates, then its "zombie" children (if any) are adopted
       by  init(1),  (or  by  the nearest "subreaper" process as defined through the use of the prctl(2) PR_SET_CHILD_SUB‐
       REAPER operation); init(1) automatically performs a wait to remove the zombies.

       POSIX.1-2001 specifies that if the disposition of SIGCHLD is set to SIG_IGN or the SA_NOCLDWAIT  flag  is  set  for
       SIGCHLD  (see  sigaction(2)),  then children that terminate do not become zombies and a call to wait() or waitpid()
       will block until all children have terminated, and then fail with errno set to ECHILD.  (The original  POSIX  stan‐
       dard left the behavior of setting SIGCHLD to SIG_IGN unspecified.  Note that even though the default disposition of
       SIGCHLD is "ignore", explicitly setting the disposition to SIG_IGN results in different treatment of zombie process
       children.)

       Linux  2.6 conforms to the POSIX requirements.  However, Linux 2.4 (and earlier) does not: if a wait() or waitpid()
       call is made while SIGCHLD is being ignored, the call behaves just as though SIGCHLD were not being  ignored,  that
       is, the call blocks until the next child terminates and then returns the process ID and status of that child.

   Linux notes
       In  the  Linux  kernel, a kernel-scheduled thread is not a distinct construct from a process.  Instead, a thread is
       simply a process that is created using the Linux-unique clone(2) system call; other routines such as  the  portable
       pthread_create(3)  call  are  implemented  using clone(2).  Before Linux 2.4, a thread was just a special case of a
       process, and as a consequence one thread could not wait on the children of another thread,  even  when  the  latter
       belongs  to the same thread group.  However, POSIX prescribes such functionality, and since Linux 2.4 a thread can,
       and by default will, wait on children of other threads in the same thread group.

       The following Linux-specific options are for use with children created using clone(2); they can also,  since  Linux
       4.7, be used with waitid():

       __WCLONE
              Wait  for  "clone" children only.  If omitted, then wait for "non-clone" children only.  (A "clone" child is
              one which delivers no signal, or a signal other than SIGCHLD to its parent upon termination.)   This  option
              is ignored if __WALL is also specified.

       __WALL (since Linux 2.4)
              Wait for all children, regardless of type ("clone" or "non-clone").

       __WNOTHREAD (since Linux 2.4)
              Do not wait for children of other threads in the same thread group.  This was the default before Linux 2.4.

       Since Linux 4.7, the __WALL flag is automatically implied if the child is being ptraced.

   C library/kernel differences
       wait() is actually a library function that (in glibc) is implemented as a call to wait4(2).

       On  some  architectures,  there is no waitpid() system call; instead, this interface is implemented via a C library
       wrapper function that calls wait4(2).

       The raw waitid() system call takes a fifth argument, of type struct rusage *.  If this argument is  non-NULL,  then
       it  is used to return resource usage information about the child, in the same manner as wait4(2).  See getrusage(2)
       for details.

BUGS
       According to POSIX.1-2008, an application calling waitid() must ensure that infop points to a  siginfo_t  structure
       (i.e.,  that  it is a non-null pointer).  On Linux, if infop is NULL, waitid() succeeds, and returns the process ID
       of the waited-for child.  Applications should avoid relying on this inconsistent, nonstandard, and unnecessary fea‐
       ture.

EXAMPLE
       The  following  program demonstrates the use of fork(2) and waitpid().  The program creates a child process.  If no
       command-line argument is supplied to the program, then the child suspends its execution using  pause(2),  to  allow
       the  user  to  send  signals to the child.  Otherwise, if a command-line argument is supplied, then the child exits
       immediately, using the integer supplied on the command line as the exit status.  The parent process executes a loop
       that monitors the child using waitpid(), and uses the W*() macros described above to analyze the wait status value.

       The following shell session demonstrates the use of the program:

           $ ./a.out &
           Child PID is 32360
           [1] 32359
           $ kill -STOP 32360
           stopped by signal 19
           $ kill -CONT 32360
           continued
           $ kill -TERM 32360
           killed by signal 15
           [1]+  Done                    ./a.out
           $

   Program source

       #include <sys/wait.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <stdio.h>

       int
       main(int argc, char *argv[])
       {
           pid_t cpid, w;
           int wstatus;

           cpid = fork();
           if (cpid == -1) {
               perror("fork");
               exit(EXIT_FAILURE);
           }

           if (cpid == 0) {            /* Code executed by child */
               printf("Child PID is %ld\n", (long) getpid());
               if (argc == 1)
                   pause();                    /* Wait for signals */
               _exit(atoi(argv[1]));

           } else {                    /* Code executed by parent */
               do {
                   w = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);
                   if (w == -1) {
                       perror("waitpid");
                       exit(EXIT_FAILURE);
                   }

                   if (WIFEXITED(wstatus)) {
                       printf("exited, status=%d\n", WEXITSTATUS(wstatus));
                   } else if (WIFSIGNALED(wstatus)) {
                       printf("killed by signal %d\n", WTERMSIG(wstatus));
                   } else if (WIFSTOPPED(wstatus)) {
                       printf("stopped by signal %d\n", WSTOPSIG(wstatus));
                   } else if (WIFCONTINUED(wstatus)) {
                       printf("continued\n");
                   }
               } while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));
               exit(EXIT_SUCCESS);
           }
       }

SEE ALSO
       _exit(2),  clone(2),  fork(2),  kill(2),  ptrace(2),  sigaction(2), signal(2), wait4(2), pthread_create(3), creden‐
       tials(7), signal(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                                 WAIT(2)
</pre>
<pre zoom>
<span xsmall>2 rt_sigqueueinfo</span>
RT_SIGQUEUEINFO(2)                               Linux Programmer's Manual                              RT_SIGQUEUEINFO(2)

NAME
       rt_sigqueueinfo, rt_tgsigqueueinfo - queue a signal and data

SYNOPSIS
       int rt_sigqueueinfo(pid_t tgid, int sig, siginfo_t *uinfo);

       int rt_tgsigqueueinfo(pid_t tgid, pid_t tid, int sig,
                             siginfo_t *uinfo);

       Note: There are no glibc wrappers for these system calls; see NOTES.

DESCRIPTION
       The  rt_sigqueueinfo() and rt_tgsigqueueinfo() system calls are the low-level interfaces used to send a signal plus
       data to a process or thread.  The receiver of the signal can obtain the accompanying data by establishing a  signal
       handler with the sigaction(2) SA_SIGINFO flag.

       These  system  calls  are not intended for direct application use; they are provided to allow the implementation of
       sigqueue(3) and pthread_sigqueue(3).

       The rt_sigqueueinfo() system call sends the signal sig to the thread group with the ID  tgid.   (The  term  "thread
       group"  is  synonymous with "process", and tid corresponds to the traditional UNIX process ID.)  The signal will be
       delivered to an arbitrary member of the thread group (i.e., one of the threads that is not currently  blocking  the
       signal).

       The  uinfo  argument specifies the data to accompany the signal.  This argument is a pointer to a structure of type
       siginfo_t, described in sigaction(2) (and defined by including <sigaction.h>).  The caller should set the following
       fields in this structure:

       si_code
              This  must  be one of the SI_* codes in the Linux kernel source file include/asm-generic/siginfo.h, with the
              restriction that the code must be negative (i.e., cannot be SI_USER, which is used by the kernel to indicate
              a  signal sent by kill(2)) and cannot (since Linux 2.6.39) be SI_TKILL (which is used by the kernel to indi‐
              cate a signal sent using tgkill(2)).

       si_pid This should be set to a process ID, typically the process ID of the sender.

       si_uid This should be set to a user ID, typically the real user ID of the sender.

       si_value
              This field contains the user data to accompany the signal.  For more information, see the description of the
              last (union sigval) argument of sigqueue(3).

       Internally,  the  kernel  sets the si_signo field to the value specified in sig, so that the receiver of the signal
       can also obtain the signal number via that field.

       The rt_tgsigqueueinfo() system call is like rt_sigqueueinfo(), but sends the signal and data to the  single  thread
       specified by the combination of tgid, a thread group ID, and tid, a thread in that thread group.

RETURN VALUE
       On success, these system calls return 0.  On error, they return -1 and errno is set to indicate the error.

ERRORS
       EAGAIN The limit of signals which may be queued has been reached.  (See signal(7) for further information.)

       EINVAL sig, tgid, or tid was invalid.

       EPERM  The  caller  does  not  have permission to send the signal to the target.  For the required permissions, see
              kill(2).  Or: uinfo->si_code is invalid.

       ESRCH  rt_sigqueueinfo(): No thread group matching tgid was found.

       rt_tgsigqueinfo(): No thread matching tgid and tid was found.

VERSIONS
       The rt_sigqueueinfo() system call was added to Linux in version 2.2.  The rt_tgsigqueueinfo() system call was added
       to Linux in version 2.6.31.

CONFORMING TO
       These system calls are Linux-specific.

NOTES
       Since these system calls are not intended for application use, there are no glibc wrapper functions; use syscall(2)
       in the unlikely case that you want to call them directly.

       As with kill(2), the null signal (0) can be used to check if the specified process or thread exists.

SEE ALSO
       kill(2), sigaction(2), sigprocmask(2), tgkill(2), pthread_sigqueue(3), sigqueue(3), signal(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                      RT_SIGQUEUEINFO(2)
</pre>
<pre zoom>
<span xsmall>2 gethostid</span>
GETHOSTID(3)                                     Linux Programmer's Manual                                    GETHOSTID(3)

NAME
       gethostid, sethostid - get or set the unique identifier of the current host

SYNOPSIS
       #include <unistd.h>

       long gethostid(void);
       int sethostid(long hostid);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       gethostid():
           _BSD_SOURCE || _XOPEN_SOURCE >= 500
       sethostid():
           Since glibc 2.21:
               _DEFAULT_SOURCE
           In glibc 2.19 and 2.20:
               _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE < 500)
           Up to and including glibc 2.19:
               _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE < 500)

DESCRIPTION
       gethostid() and sethostid() respectively get or set a unique 32-bit identifier for the current machine.  The 32-bit
       identifier is intended to be unique among all UNIX systems in existence.   This  normally  resembles  the  Internet
       address for the local machine, as returned by gethostbyname(3), and thus usually never needs to be set.

       The sethostid() call is restricted to the superuser.

RETURN VALUE
       gethostid() returns the 32-bit identifier for the current host as set by sethostid().

       On success, sethostid() returns 0; on error, -1 is returned, and errno is set to indicate the error.

ERRORS
       sethostid() can fail with the following errors:

       EACCES The caller did not have permission to write to the file used to store the host ID.

       EPERM  The calling process's effective user or group ID is not the same as its corresponding real ID.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌────────────┬───────────────┬───────────────────────────┐
       │Interface   │ Attribute     │ Value                     │
       ├────────────┼───────────────┼───────────────────────────┤
       │gethostid() │ Thread safety │ MT-Safe hostid env locale │
       ├────────────┼───────────────┼───────────────────────────┤
       │sethostid() │ Thread safety │ MT-Unsafe const:hostid    │
       └────────────┴───────────────┴───────────────────────────┘

CONFORMING TO
       4.2BSD; these functions were dropped in 4.4BSD.  SVr4 includes gethostid() but not sethostid().

       POSIX.1-2001 and POSIX.1-2008 specify gethostid() but not sethostid().

NOTES
       In the glibc implementation, the hostid is stored in the file /etc/hostid.  (In glibc versions before 2.2, the file
       /var/adm/hostid was used.)

       In the glibc implementation, if gethostid() cannot open the file containing the host ID, then it obtains the  host‐
       name  using  gethostname(2), passes that hostname to gethostbyname_r(3) in order to obtain the host's IPv4 address,
       and returns a value obtained by bit-twiddling the IPv4 address.  (This value may not be unique.)

BUGS
       It is impossible to ensure that the identifier is globally unique.

SEE ALSO
       hostid(1), gethostbyname(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            GETHOSTID(3)
</pre>
<pre zoom>
<span xsmall>2 s390_sthyi</span>
S390_STHYI(2)                                       System Calls Manual                                      S390_STHYI(2)

NAME
       s390_sthyi - emulate STHYI instruction

SYNOPSIS
       #include <asm/unistd.h>

       int s390_sthyi(unsigned long function_code, void *resp_buffer,
                      uint64_t *return_code, unsigned long flags);

DESCRIPTION
       The  s390_sthyi()  system call emulates the STHYI (Store Hypervisor Information) instruction.  It provides hardware
       resource information for the machine and its virtualization levels.  This includes CPU type and capacity,  as  well
       as the machine model and other metrics.

       The function_code argument indicates which function to perform.  The following code(s) are supported:

       0      Return CP (Central Processor) and IFL (Integrated Facility for Linux) capacity information.

       The  resp_buffer  argument  specifies the address of a response buffer.  If the system call returns 0, the response
       buffer will be filled with CPU capacity information.  Otherwise, the response buffer's content is unchanged.

       The return_code argument stores the return code of the STHYI instruction, using one of the following values:

       0       Success.

       4       Unsupported function code.

       For further details about return_code, function_code, and resp_buffer, see the reference given in NOTES.

       The flags argument is provided to allow for future extensions and currently must be set to 0.

RETURN VALUE
       On success (that is: emulation succeeded), the return value of s390_sthyi() matches the condition code of the STHYI
       instructions, which is a value in the range [0..3].  A return value of 0 indicates that CPU capacity information is
       stored in *resp_buffer.  A return value of 3 indicates "unsupported function code" and the content of  *resp_buffer
       is unchanged.  The return values 1 and 2 are reserved.

       On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT The value specified in resp_buffer or return_code is not a valid address.

       EINVAL The value specified in flags is nonzero.

       ENOMEM Allocating memory for handling the CPU capacity information failed.

       EOPNOTSUPP
              The value specified in function_code is not valid.

VERSIONS
       This system call is available since Linux 4.15.

CONFORMING TO
       This Linux-specific system call is available only on the s390 architecture.

NOTES
       Glibc does not provide a wrapper for this system call, use syscall(2) to call it.

       For    details    of   the   STHYI   instruction,   see   ⟨https://www.ibm.com/support/knowledgecenter/SSB27U_6.3.0
       /com.ibm.zvm.v630.hcpb4/hcpb4sth.htm⟩.

SEE ALSO
       syscall(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux Programmer's Manual                               2018-02-02                                           S390_STHYI(2)
</pre>
<pre zoom>
<span xsmall>2 getsid</span>
GETSID(2)                                        Linux Programmer's Manual                                       GETSID(2)

NAME
       getsid - get session ID

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       pid_t getsid(pid_t pid);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       getsid():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L

DESCRIPTION
       getsid(0)  returns  the  session  ID  of  the calling process.  getsid() returns the session ID of the process with
       process ID pid.  If pid is 0, getsid() returns the session ID of the calling process.

RETURN VALUE
       On success, a session ID is returned.  On error, (pid_t) -1 will be returned, and errno is set appropriately.

ERRORS
       EPERM  A process with process ID pid exists, but it is not in the same session as  the  calling  process,  and  the
              implementation considers this an error.

       ESRCH  No process with process ID pid was found.

VERSIONS
       This system call is available on Linux since version 2.0.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

NOTES
       Linux does not return EPERM.

       See credentials(7) for a description of sessions and session IDs.

SEE ALSO
       getpgid(2), setsid(2), credentials(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               GETSID(2)
</pre>
<pre zoom>
<span xsmall>2 madvise1</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 oldolduname</span>
UNAME(2)                                         Linux Programmer's Manual                                        UNAME(2)

NAME
       uname - get name and information about current kernel

SYNOPSIS
       #include <sys/utsname.h>

       int uname(struct utsname *buf);

DESCRIPTION
       uname()  returns  system  information  in  the  structure  pointed  to  by  buf.   The utsname struct is defined in
       <sys/utsname.h>:

           struct utsname {
               char sysname[];    /* Operating system name (e.g., "Linux") */
               char nodename[];   /* Name within "some implementation-defined
                                     network" */
               char release[];    /* Operating system release (e.g., "2.6.28") */
               char version[];    /* Operating system version */
               char machine[];    /* Hardware identifier */
           #ifdef _GNU_SOURCE
               char domainname[]; /* NIS or YP domain name */
           #endif
           };

       The length of the arrays in a struct utsname is unspecified (see NOTES); the fields are terminated by a  null  byte
       ('\0').

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT buf is not valid.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.  There is no uname() call in 4.3BSD.

       The domainname member (the NIS or YP domain name) is a GNU extension.

NOTES
       This is a system call, and the operating system presumably knows its name, release and version.  It also knows what
       hardware it runs on.  So, four of the fields of the struct are meaningful.  On the other hand, the  field  nodename
       is  meaningless:  it gives the name of the present machine in some undefined network, but typically machines are in
       more than one network and have several names.  Moreover, the kernel has no way of knowing about such things, so  it
       has to be told what to answer here.  The same holds for the additional domainname field.

       To  this end, Linux uses the system calls sethostname(2) and setdomainname(2).  Note that there is no standard that
       says that the hostname set by sethostname(2) is the same string as the nodename field of  the  struct  returned  by
       uname()  (indeed,  some  systems allow a 256-byte hostname and an 8-byte nodename), but this is true on Linux.  The
       same holds for setdomainname(2) and the domainname field.

       The length of the fields in the struct varies.  Some operating systems or libraries use a hardcoded 9 or 33  or  65
       or  257.   Other  systems use SYS_NMLN or _SYS_NMLN or UTSLEN or _UTSNAME_LENGTH.  Clearly, it is a bad idea to use
       any of these constants; just use sizeof(...).  Often 257 is chosen in order to have room for an internet hostname.

       Part of the utsname information is also accessible  via  /proc/sys/kernel/{ostype,  hostname,  osrelease,  version,
       domainname}.

   C library/kernel differences
       Over  time,  increases  in  the  size  of  the  utsname structure have led to three successive versions of uname():
       sys_olduname() (slot __NR_oldolduname), sys_uname() (slot __NR_olduname),  and  sys_newuname()  (slot  __NR_uname).
       The  first  one  used  length  9 for all fields; the second used 65; the third also uses 65 but adds the domainname
       field.  The glibc uname() wrapper function hides these details from applications, invoking the most recent  version
       of the system call provided by the kernel.

SEE ALSO
       uname(1), getdomainname(2), gethostname(2), namespaces(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                UNAME(2)
</pre>
<pre zoom>
<span xsmall>2 inl</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 mount</span>
MOUNT(2)                                         Linux Programmer's Manual                                        MOUNT(2)

NAME
       mount - mount filesystem

SYNOPSIS
       #include <sys/mount.h>

       int mount(const char *source, const char *target,
                 const char *filesystemtype, unsigned long mountflags,
                 const void *data);

DESCRIPTION
       mount()  attaches the filesystem specified by source (which is often a pathname referring to a device, but can also
       be the pathname of a directory or file, or a dummy string) to the location (a directory or file) specified  by  the
       pathname in target.

       Appropriate privilege (Linux: the CAP_SYS_ADMIN capability) is required to mount filesystems.

       Values  for  the  filesystemtype  argument  supported by the kernel are listed in /proc/filesystems (e.g., "btrfs",
       "ext4", "jfs", "xfs", "vfat", "fuse", "tmpfs", "cgroup", "proc",  "mqueue",  "nfs",  "cifs",  "iso9660").   Further
       types may become available when the appropriate modules are loaded.

       The data argument is interpreted by the different filesystems.  Typically it is a string of comma-separated options
       understood by this filesystem.  See mount(8) for details of the options available for each filesystem type.

       A call to mount() performs one of a number of general types of operation, depending on the bits specified in mount‐
       flags.   The  choice  of  which  operation to perform is determined by testing the bits set in mountflags, with the
       tests being conducted in the order listed here:

       *  Remount an existing mount: mountflags includes MS_REMOUNT.

       *  Create a bind mount: mountflags includes MS_BIND.

       *  Change the propagation type of an existing mount: mountflags includes one of MS_SHARED, MS_PRIVATE, MS_SLAVE, or
          MS_UNBINDABLE.

       *  Move an existing mount to a new location: mountflags includes MS_MOVE.

       *  Create a new mount: mountflags includes none of the above flags.

       Each  of  these  operations is detailed later in this page.  Further flags may be specified in mountflags to modify
       the behavior of mount(), as described below.

   Additional mount flags
       The list below describes the additional flags that can be specified in mountflags.  Note that some operation  types
       ignore some or all of these flags, as described later in this page.

       MS_DIRSYNC (since Linux 2.5.19)
              Make directory changes on this filesystem synchronous.  (This property can be obtained for individual direc‐
              tories or subtrees using chattr(1).)

       MS_LAZYTIME (since Linux 4.0)
              Reduce on-disk updates of inode timestamps (atime, mtime, ctime) by maintaining these changes only  in  mem‐
              ory.  The on-disk timestamps are updated only when:

              (a)  the inode needs to be updated for some change unrelated to file timestamps;

              (b)  the application employs fsync(2), syncfs(2), or sync(2);

              (c)  an undeleted inode is evicted from memory; or

              (d)  more than 24 hours have passed since the inode was written to disk.

              This mount option significantly reduces writes needed to update the inode's timestamps, especially mtime and
              atime.  However, in the event of a system crash, the atime and mtime fields on disk might be out of date  by
              up to 24 hours.

       Examples  of workloads where this option could be of significant benefit include frequent random writes to preallo‐
       cated files, as well as cases where the MS_STRICTATIME mount option is also enabled.  (The advantage  of  combining
       MS_STRICTATIME  and MS_LAZYTIME is that stat(2) will return the correctly updated atime, but the atime updates will
       be flushed to disk only in the cases listed above.)

       MS_MANDLOCK
              Permit mandatory locking on files in this filesystem.  (Mandatory locking must still be enabled  on  a  per-
              file  basis, as described in fcntl(2).)  Since Linux 4.5, this mount option requires the CAP_SYS_ADMIN capa‐
              bility.

       MS_NOATIME
              Do not update access times for (all types of) files on this filesystem.

       MS_NODEV
              Do not allow access to devices (special files) on this filesystem.

       MS_NODIRATIME
              Do not update access times for directories on this filesystem.  This flag provides a subset of the function‐
              ality provided by MS_NOATIME; that is, MS_NOATIME implies MS_NODIRATIME.

       MS_NOEXEC
              Do not allow programs to be executed from this filesystem.

       MS_NOSUID
              Do  not  honor  set-user-ID  and  set-group-ID  bits  or file capabilities when executing programs from this
              filesystem.

       MS_RDONLY
              Mount filesystem read-only.

       MS_REC (since Linux 2.4.11)
              Used in conjunction with MS_BIND to create a recursive bind mount, and in conjunction with  the  propagation
              type flags to recursively change the propagation type of all of the mounts in a subtree.  See below for fur‐
              ther details.

       MS_RELATIME (since Linux 2.6.20)
              When a file on this filesystem is accessed, update the file's last access time (atime) only if  the  current
              value of atime is less than or equal to the file's last modification time (mtime) or last status change time
              (ctime).  This option is useful for programs, such as mutt(1), that need to know when a file has  been  read
              since  it  was last modified.  Since Linux 2.6.30, the kernel defaults to the behavior provided by this flag
              (unless MS_NOATIME was specified), and the MS_STRICTATIME flag is required to obtain traditional  semantics.
              In addition, since Linux 2.6.30, the file's last access time is always updated if it is more than 1 day old.

       MS_SILENT (since Linux 2.6.17)
              Suppress  the  display  of  certain (printk()) warning messages in the kernel log.  This flag supersedes the
              misnamed and obsolete MS_VERBOSE flag (available since Linux 2.4.12), which has the same meaning.

       MS_STRICTATIME (since Linux 2.6.30)
              Always update the last access time (atime) when files on  this  filesystem  are  accessed.   (This  was  the
              default  behavior before Linux 2.6.30.)  Specifying this flag overrides the effect of setting the MS_NOATIME
              and MS_RELATIME flags.

       MS_SYNCHRONOUS
              Make writes on this filesystem synchronous (as though the O_SYNC flag to open(2) was specified for all  file
              opens to this filesystem).

       From  Linux 2.4 onward, the MS_NODEV, MS_NOEXEC, and MS_NOSUID flags are settable on a per-mount-point basis.  From
       kernel 2.6.16 onward, MS_NOATIME and MS_NODIRATIME are also settable on a per-mount-point basis.   The  MS_RELATIME
       flag  is  also  settable on a per-mount-point basis.  Since Linux 2.6.16, MS_RDONLY can be set or cleared on a per-
       mount-point basis as well as on the underlying filesystem.  The mounted filesystem will be writable only if neither
       the filesystem nor the mountpoint are flagged as read-only.

   Remounting an existing mount
       An  existing  mount  may be remounted by specifying MS_REMOUNT in mountflags.  This allows you to change the mount‐
       flags and data of an existing mount without having to unmount and remount the filesystem.   target  should  be  the
       same value specified in the initial mount() call.

       The source and filesystemtype arguments are ignored.

       The  mountflags  and  data  arguments  should  match the values used in the original mount() call, except for those
       parameters that are being deliberately changed.  Another exception is that MS_BIND  has  a  different  meaning  for
       remount, and it should be included only if explicitly desired.

       The  following mountflags can be changed: MS_LAZYTIME, MS_MANDLOCK, MS_NOATIME, MS_NODEV, MS_NODIRATIME, MS_NOEXEC,
       MS_NOSUID, MS_RELATIME, MS_RDONLY, and MS_SYNCHRONOUS.  Attempts to change the setting of the MS_DIRSYNC flag  dur‐
       ing a remount are silently ignored.

       Since  Linux 3.17, if none of MS_NOATIME, MS_NODIRATIME, MS_RELATIME, or MS_STRICTATIME is specified in mountflags,
       then the remount operation preserves the existing values of these flags (rather than defaulting to MS_RELATIME).

       Since Linux 2.6.26, this flag can be used with MS_BIND to modify only the per-mount-point flags.  This is  particu‐
       larly useful for setting or clearing the "read-only" flag on a mount point without changing the underlying filesys‐
       tem.  Specifying mountflags as:

           MS_REMOUNT | MS_BIND | MS_RDONLY

       will make access through this mountpoint read-only, without affecting other mount points.

   Creating a bind mount
       If mountflags includes MS_BIND (available since Linux 2.4), then perform a bind mount.  A bind mount makes  a  file
       or  a  directory  subtree  visible  at  another point within the single directory hierarchy.  Bind mounts may cross
       filesystem boundaries and span chroot(2) jails.

       The filesystemtype and data arguments are ignored.

       The remaining bits in the mountflags argument are also ignored, with the exception of MS_REC.  (The bind mount  has
       the  same  mount  options  as  the underlying mount point.)  However, see the discussion of remounting above, for a
       method of making an existing bind mount read-only.

       By default, when a directory is bind mounted, only that directory is mounted; if there are any submounts under  the
       directory tree, they are not bind mounted.  If the MS_REC flag is also specified, then a recursive bind mount oper‐
       ation is performed: all submounts under the source subtree (other than unbindable mounts) are also bind mounted  at
       the corresponding location in the target subtree.

   Changing the propagation type of an existing mount
       If mountflags includes one of MS_SHARED, MS_PRIVATE, MS_SLAVE, or MS_UNBINDABLE (all available since Linux 2.6.15),
       then the propagation type of an existing mount is changed.  If more than one of these flags is specified, an  error
       results.

       The only flags that can be used with changing the propagation type are MS_REC and MS_SILENT.

       The source, filesystemtype, and data arguments are ignored.

       The meanings of the propagation type flags are as follows:

       MS_SHARED
              Make this mount point shared.  Mount and unmount events immediately under this mount point will propagate to
              the other mount points that are members of this mount's peer group.  Propagation here means  that  the  same
              mount  or  unmount  will  automatically  occur  under all of the other mount points in the peer group.  Con‐
              versely, mount and unmount events that take place under peer mount  points  will  propagate  to  this  mount
              point.

       MS_PRIVATE
              Make this mount point private.  Mount and unmount events do not propagate into or out of this mount point.

       MS_SLAVE
              If  this is a shared mount point that is a member of a peer group that contains other members, convert it to
              a slave mount.  If this is a shared mount point that is a member of a peer group that contains no other mem‐
              bers, convert it to a private mount.  Otherwise, the propagation type of the mount point is left unchanged.

       When  a  mount  point is a slave, mount and unmount events propagate into this mount point from the (master) shared
       peer group of which it was formerly a member.  Mount and unmount events under this mount point do not propagate  to
       any peer.

       A mount point can be the slave of another peer group while at the same time sharing mount and unmount events with a
       peer group of which it is a member.

       MS_UNBINDABLE
              Make this mount unbindable.  This is like a private mount, and in addition this mount can't be bind mounted.
              When a recursive bind mount (mount() with the MS_BIND and MS_REC flags) is performed on a directory subtree,
              any bind mounts within the subtree are automatically pruned (i.e., not  replicated)  when  replicating  that
              subtree to produce the target subtree.

       By  default,  changing the propagation type affects only the target mount point.  If the MS_REC flag is also speci‐
       fied in mountflags, then the propagation type of all mount points under target is also changed.

       For further details regarding mount propagation types (including the  default  propagation  type  assigned  to  new
       mounts), see mount_namespaces(7).

   Moving a mount
       If  mountflags  contains  the flag MS_MOVE (available since Linux 2.4.18), then move a subtree: source specifies an
       existing mount point and target specifies the new location to which that mount point is to be relocated.  The  move
       is atomic: at no point is the subtree unmounted.

       The remaining bits in the mountflags argument are ignored, as are the filesystemtype and data arguments.

   Creating a new mount point
       If  none  of MS_REMOUNT, MS_BIND, MS_MOVE, MS_SHARED, MS_PRIVATE, MS_SLAVE, or MS_UNBINDABLE is specified in mount‐
       flags, then mount() performs its default action: creating a new mount point.  source specifies the source  for  the
       new mount point, and target specifies the directory at which to create the mount point.

       The  filesystemtype  and data arguments are employed, and further bits may be specified in mountflags to modify the
       behavior of the call.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       The error values given below result from filesystem type independent errors.  Each filesystem type may have its own
       special errors and its own special behavior.  See the Linux kernel source code for details.

       EACCES A component of a path was not searchable.  (See also path_resolution(7).)

       EACCES Mounting a read-only filesystem was attempted without giving the MS_RDONLY flag.

       EACCES The block device source is located on a filesystem mounted with the MS_NODEV option.

       EBUSY  An attempt was made to stack a new mount directly on top of an existing mount point that was created in this
              mount namespace with the same source and target.

       EBUSY  source cannot be remounted read-only, because it still holds files open for writing.

       EFAULT One of the pointer arguments points outside the user address space.

       EINVAL source had an invalid superblock.

       EINVAL A remount operation (MS_REMOUNT) was attempted, but source was not already mounted on target.

       EINVAL A move operation (MS_MOVE) was attempted, but source was not a mount point, or was '/'.

       EINVAL mountflags includes more than one of MS_SHARED, MS_PRIVATE, MS_SLAVE, or MS_UNBINDABLE.

       EINVAL mountflags includes MS_SHARED, MS_PRIVATE, MS_SLAVE, or MS_UNBINDABLE and also includes a  flag  other  than
              MS_REC or MS_SILENT.

       EINVAL An attempt was made to bind mount an unbindable mount.

       EINVAL In an unprivileged mount namespace (i.e., a mount namespace owned by a user namespace that was created by an
              unprivileged user), a bind mount operation (MS_BIND) was attempted without specifying (MS_REC), which  would
              have revealed the filesystem tree underneath one of the submounts of the directory being bound.

       ELOOP  Too many links encountered during pathname resolution.

       ELOOP  A move operation was attempted, and target is a descendant of source.

       EMFILE (In case no block device is required:) Table of dummy devices is full.

       ENAMETOOLONG
              A pathname was longer than MAXPATHLEN.

       ENODEV filesystemtype not configured in the kernel.

       ENOENT A pathname was empty or had a nonexistent component.

       ENOMEM The kernel could not allocate a free page to copy filenames or data into.

       ENOTBLK
              source is not a block device (and a device was required).

       ENOTDIR
              target, or a prefix of source, is not a directory.

       ENXIO  The major number of the block device source is out of range.

       EPERM  The caller does not have the required privileges.

VERSIONS
       The  definitions  of  MS_DIRSYNC, MS_MOVE, MS_PRIVATE, MS_REC, MS_RELATIME, MS_SHARED, MS_SLAVE, MS_STRICTATIME and
       MS_UNBINDABLE were added to glibc headers in version 2.12.

CONFORMING TO
       This function is Linux-specific and should not be used in programs intended to be portable.

NOTES
       Since Linux 2.4 a single filesystem can be mounted at multiple mount points, and multiple mounts can be stacked  on
       the same mount point.

       The  mountflags argument may have the magic number 0xC0ED (MS_MGC_VAL) in the top 16 bits.  (All of the other flags
       discussed in DESCRIPTION occupy the low order 16 bits of mountflags.)  Specifying MS_MGC_VAL was required in kernel
       versions prior to 2.4, but since Linux 2.4 is no longer required and is ignored if specified.

       The original MS_SYNC flag was renamed MS_SYNCHRONOUS in 1.1.69 when a different MS_SYNC was added to <mman.h>.

       Before Linux 2.4 an attempt to execute a set-user-ID or set-group-ID program on a filesystem mounted with MS_NOSUID
       would fail with EPERM.  Since Linux 2.4 the set-user-ID and set-group-ID bits are just  silently  ignored  in  this
       case.

   Per-process namespaces
       Starting with kernel 2.4.19, Linux provides per-process mount namespaces.  A mount namespace is the set of filesys‐
       tem mounts that are visible to a process.  Mount-point namespaces can be (and usually are) shared between  multiple
       processes,  and  changes  to the namespace (i.e., mounts and unmounts) by one process are visible to all other pro‐
       cesses sharing the same namespace.  (The pre-2.4.19 Linux situation can be considered as  one  in  which  a  single
       namespace was shared by every process on the system.)

       A  child process created by fork(2) shares its parent's mount namespace; the mount namespace is preserved across an
       execve(2).

       A process can obtain a private mount namespace if: it was created using the clone(2)  CLONE_NEWNS  flag,  in  which
       case  its  new  namespace  is  initialized to be a copy of the namespace of the process that called clone(2); or it
       calls unshare(2) with the CLONE_NEWNS flag, which causes the caller's mount namespace to obtain a private  copy  of
       the namespace that it was previously sharing with other processes, so that future mounts and unmounts by the caller
       are invisible to other processes (except child processes that the caller subsequently creates) and vice versa.

       The Linux-specific /proc/[pid]/mounts file exposes the list of mount points in the mount namespace of  the  process
       with the specified ID; see proc(5) for details.

SEE ALSO
       mountpoint(1), umount(2), mount_namespaces(7), path_resolution(7), findmnt(8), lsblk(8), mount(8), umount(8)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-02-02                                                MOUNT(2)
</pre>
<pre zoom>
<span xsmall>2 munlock</span>
MLOCK(2)                                         Linux Programmer's Manual                                        MLOCK(2)

NAME
       mlock, mlock2, munlock, mlockall, munlockall - lock and unlock memory

SYNOPSIS
       #include <sys/mman.h>

       int mlock(const void *addr, size_t len);
       int mlock2(const void *addr, size_t len, int flags);
       int munlock(const void *addr, size_t len);

       int mlockall(int flags);
       int munlockall(void);

DESCRIPTION
       mlock(),  mlock2(),  and  mlockall() lock part or all of the calling process's virtual address space into RAM, pre‐
       venting that memory from being paged to the swap area.

       munlock() and munlockall() perform the converse operation, unlocking part or all of the calling  process's  virtual
       address  space, so that pages in the specified virtual address range may once more to be swapped out if required by
       the kernel memory manager.

       Memory locking and unlocking are performed in units of whole pages.

   mlock(), mlock2(), and munlock()
       mlock() locks pages in the address range starting at addr and continuing for len bytes.  All pages that  contain  a
       part  of  the  specified address range are guaranteed to be resident in RAM when the call returns successfully; the
       pages are guaranteed to stay in RAM until later unlocked.

       mlock2() also locks pages in the specified range starting at addr and continuing for len bytes.  However, the state
       of  the  pages  contained  in  that range after the call returns successfully will depend on the value in the flags
       argument.

       The flags argument can be either 0 or the following constant:

       MLOCK_ONFAULT
              Lock pages that are currently resident and mark the entire range so that  the  remaining  nonresident  pages
              locked when they are populated by a page fault.

       If flags is 0, mlock2() behaves exactly the same as mlock().

       munlock()  unlocks  pages in the address range starting at addr and continuing for len bytes.  After this call, all
       pages that contain a part of the specified memory range can be moved to external swap space again by the kernel.

   mlockall() and munlockall()
       mlockall() locks all pages mapped into the address space of the calling process.  This includes the  pages  of  the
       code, data and stack segment, as well as shared libraries, user space kernel data, shared memory, and memory-mapped
       files.  All mapped pages are guaranteed to be resident in RAM when the call returns  successfully;  the  pages  are
       guaranteed to stay in RAM until later unlocked.

       The flags argument is constructed as the bitwise OR of one or more of the following constants:

       MCL_CURRENT Lock all pages which are currently mapped into the address space of the process.

       MCL_FUTURE  Lock  all  pages  which  will become mapped into the address space of the process in the future.  These
                   could be, for instance, new pages required by a growing heap and stack as  well  as  new  memory-mapped
                   files or shared memory regions.

       MCL_ONFAULT (since Linux 4.4)
                   Used  together  with  MCL_CURRENT,  MCL_FUTURE, or both.  Mark all current (with MCL_CURRENT) or future
                   (with MCL_FUTURE) mappings to lock pages when they are faulted in.  When  used  with  MCL_CURRENT,  all
                   present  pages  are  locked,  but  mlockall()  will  not  fault  in  non-present pages.  When used with
                   MCL_FUTURE, all future mappings will be marked to lock pages when they are faulted in,  but  they  will
                   not  be  populated  by  the  lock  when  the  mapping is created.  MCL_ONFAULT must be used with either
                   MCL_CURRENT or MCL_FUTURE or both.

       If MCL_FUTURE has been specified, then a later system call (e.g., mmap(2), sbrk(2),  malloc(3)),  may  fail  if  it
       would  cause  the  number  of locked bytes to exceed the permitted maximum (see below).  In the same circumstances,
       stack growth may likewise fail: the kernel will deny stack expansion and deliver a SIGSEGV signal to the process.

       munlockall() unlocks all pages mapped into the address space of the calling process.

RETURN VALUE
       On success, these system calls return 0.  On error, -1 is returned, errno is set appropriately, and no changes  are
       made to any locks in the address space of the process.

ERRORS
       ENOMEM (Linux  2.6.9 and later) the caller had a nonzero RLIMIT_MEMLOCK soft resource limit, but tried to lock more
              memory than the limit permitted.  This limit is not enforced if the process is privileged (CAP_IPC_LOCK).

       ENOMEM (Linux 2.4 and earlier) the calling process tried to lock more than half of RAM.

       EPERM  The caller is not privileged, but needs privilege (CAP_IPC_LOCK) to perform the requested operation.

       For mlock(), mlock2(), and munlock():

       EAGAIN Some or all of the specified address range could not be locked.

       EINVAL The result of the addition addr+len was less than addr (e.g., the addition may have  resulted  in  an  over‐
              flow).

       EINVAL (Not on Linux) addr was not a multiple of the page size.

       ENOMEM Some of the specified address range does not correspond to mapped pages in the address space of the process.

       ENOMEM Locking  or  unlocking a region would result in the total number of mappings with distinct attributes (e.g.,
              locked versus unlocked) exceeding the allowed maximum.  (For example, unlocking a range in the middle  of  a
              currently  locked  mapping  would  result in three mappings: two locked mappings at each end and an unlocked
              mapping in the middle.)

       For mlock2():

       EINVAL Unknown flags were specified.

       For mlockall():

       EINVAL Unknown flags were specified or MCL_ONFAULT was specified without either MCL_FUTURE or MCL_CURRENT.

       For munlockall():

       EPERM  (Linux 2.6.8 and earlier) The caller was not privileged (CAP_IPC_LOCK).

VERSIONS
       mlock2() is available since Linux 4.4; glibc support was added in version 2.27.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

       mlock2 () is Linux specific.

AVAILABILITY
       On POSIX systems on which mlock() and munlock() are available, _POSIX_MEMLOCK_RANGE is defined  in  <unistd.h>  and
       the number of bytes in a page can be determined from the constant PAGESIZE (if defined) in <limits.h> or by calling
       sysconf(_SC_PAGESIZE).

       On POSIX systems on which mlockall() and munlockall() are available, _POSIX_MEMLOCK is defined in <unistd.h>  to  a
       value greater than 0.  (See also sysconf(3).)

NOTES
       Memory locking has two main applications: real-time algorithms and high-security data processing.  Real-time appli‐
       cations require deterministic timing, and, like scheduling, paging is one major cause of unexpected program  execu‐
       tion  delays.  Real-time applications will usually also switch to a real-time scheduler with sched_setscheduler(2).
       Cryptographic security software often handles critical bytes like passwords or secret keys as data structures.   As
       a  result  of  paging,  these secrets could be transferred onto a persistent swap store medium, where they might be
       accessible to the enemy long after the security software has erased the secrets in RAM  and  terminated.   (But  be
       aware  that  the  suspend  mode on laptops and some desktop computers will save a copy of the system's RAM to disk,
       regardless of memory locks.)

       Real-time processes that are using mlockall() to prevent delays on page faults should reserve enough  locked  stack
       pages  before  entering the time-critical section, so that no page fault can be caused by function calls.  This can
       be achieved by calling a function that allocates a sufficiently large automatic variable (an array) and  writes  to
       the  memory  occupied by this array in order to touch these stack pages.  This way, enough pages will be mapped for
       the stack and can be locked into RAM.  The dummy writes ensure that not even copy-on-write page faults can occur in
       the critical section.

       Memory  locks  are  not inherited by a child created via fork(2) and are automatically removed (unlocked) during an
       execve(2) or when the process terminates.  The mlockall() MCL_FUTURE and MCL_FUTURE | MCL_ONFAULT settings are  not
       inherited by a child created via fork(2) and are cleared during an execve(2).

       Note  that fork(2) will prepare the address space for a copy-on-write operation.  The consequence is that any write
       access that follows will cause a page fault that in turn may cause high latencies for a real-time process.   There‐
       fore,  it  is  crucial  not to invoke fork(2) after an mlockall() or mlock() operation—not even from a thread which
       runs at a low priority within a process which also has a thread running at elevated priority.

       The memory lock on an address range is automatically removed if the address range is unmapped via munmap(2).

       Memory locks do not stack, that is, pages which have been locked several times by calls to  mlock(),  mlock2(),  or
       mlockall()  will  be  unlocked by a single call to munlock() for the corresponding range or by munlockall().  Pages
       which are mapped to several locations or by several processes stay locked into RAM as long as they  are  locked  at
       least at one location or by at least one process.

       If a call to mlockall() which uses the MCL_FUTURE flag is followed by another call that does not specify this flag,
       the changes made by the MCL_FUTURE call will be lost.

       The mlock2() MLOCK_ONFAULT flag and the mlockall() MCL_ONFAULT flag allow efficient memory locking for applications
       that  deal  with  large  mappings where only a (small) portion of pages in the mapping are touched.  In such cases,
       locking all of the pages in a mapping would incur a significant penalty for memory locking.

   Linux notes
       Under Linux, mlock(), mlock2(), and munlock() automatically round addr down to the nearest page boundary.  However,
       the  POSIX.1  specification of mlock() and munlock() allows an implementation to require that addr is page aligned,
       so portable applications should ensure this.

       The VmLck field of the Linux-specific /proc/[pid]/status file shows how many kilobytes of memory the  process  with
       ID PID has locked using mlock(), mlock2(), mlockall(), and mmap(2) MAP_LOCKED.

   Limits and permissions
       In Linux 2.6.8 and earlier, a process must be privileged (CAP_IPC_LOCK) in order to lock memory and the RLIMIT_MEM‐
       LOCK soft resource limit defines a limit on how much memory the process may lock.

       Since Linux 2.6.9, no limits are placed on the amount of  memory  that  a  privileged  process  can  lock  and  the
       RLIMIT_MEMLOCK soft resource limit instead defines a limit on how much memory an unprivileged process may lock.

BUGS
       In Linux 4.8 and earlier, a bug in the kernel's accounting of locked memory for unprivileged processes (i.e., with‐
       out CAP_IPC_LOCK) meant that if the region specified by addr and len overlapped an existing lock, then the  already
       locked  bytes in the overlapping region were counted twice when checking against the limit.  Such double accounting
       could incorrectly calculate a "total locked memory" value for the process that exceeded the  RLIMIT_MEMLOCK  limit,
       with the result that mlock() and mlock2() would fail on requests that should have succeeded.  This bug was fixed in
       Linux 4.9

       In the 2.4 series Linux kernels up to and including 2.4.17, a bug caused  the  mlockall()  MCL_FUTURE  flag  to  be
       inherited across a fork(2).  This was rectified in kernel 2.4.18.

       Since  kernel  2.6.9,  if  a  privileged  process  calls mlockall(MCL_FUTURE) and later drops privileges (loses the
       CAP_IPC_LOCK capability by, for example, setting its effective UID to a  nonzero  value),  then  subsequent  memory
       allocations (e.g., mmap(2), brk(2)) will fail if the RLIMIT_MEMLOCK resource limit is encountered.

SEE ALSO
       mincore(2), mmap(2), setrlimit(2), shmctl(2), sysconf(3), proc(5), capabilities(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-02-02                                                MLOCK(2)
</pre>
<pre zoom>
<span xsmall>2 sendfile</span>
SENDFILE(2)                                      Linux Programmer's Manual                                     SENDFILE(2)

NAME
       sendfile - transfer data between file descriptors

SYNOPSIS
       #include <sys/sendfile.h>

       ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);

DESCRIPTION
       sendfile()  copies  data  between one file descriptor and another.  Because this copying is done within the kernel,
       sendfile() is more efficient than the combination of read(2) and write(2), which would require transferring data to
       and from user space.

       in_fd should be a file descriptor opened for reading and out_fd should be a descriptor opened for writing.

       If  offset is not NULL, then it points to a variable holding the file offset from which sendfile() will start read‐
       ing data from in_fd.  When sendfile() returns, this variable will be set to the offset of the  byte  following  the
       last  byte  that was read.  If offset is not NULL, then sendfile() does not modify the file offset of in_fd; other‐
       wise the file offset is adjusted to reflect the number of bytes read from in_fd.

       If offset is NULL, then data will be read from in_fd starting at the file offset,  and  the  file  offset  will  be
       updated by the call.

       count is the number of bytes to copy between the file descriptors.

       The in_fd argument must correspond to a file which supports mmap(2)-like operations (i.e., it cannot be a socket).

       In  Linux kernels before 2.6.33, out_fd must refer to a socket.  Since Linux 2.6.33 it can be any file.  If it is a
       regular file, then sendfile() changes the file offset appropriately.

RETURN VALUE
       If the transfer was successful, the number of bytes written to out_fd is returned.  Note that a successful call  to
       sendfile()  may  write  fewer  bytes  than requested; the caller should be prepared to retry the call if there were
       unsent bytes.  See also NOTES.

       On error, -1 is returned, and errno is set appropriately.

ERRORS
       EAGAIN Nonblocking I/O has been selected using O_NONBLOCK and the write would block.

       EBADF  The input file was not opened for reading or the output file was not opened for writing.

       EFAULT Bad address.

       EINVAL Descriptor is not valid or locked, or an mmap(2)-like operation is not available for in_fd, or count is neg‐
              ative.

       EINVAL out_fd has the O_APPEND flag set.  This is not currently supported by sendfile().

       EIO    Unspecified error while reading from in_fd.

       ENOMEM Insufficient memory to read from in_fd.

       EOVERFLOW
              count is too large, the operation would result in exceeding the maximum size of either the input file or the
              output file.

       ESPIPE offset is not NULL but the input file is not seek(2)-able.

VERSIONS
       sendfile() first appeared in Linux 2.2.  The include file <sys/sendfile.h> is present since glibc 2.1.

CONFORMING TO
       Not specified in POSIX.1-2001, nor in other standards.

       Other UNIX systems implement sendfile() with different semantics and prototypes.  It should not be used in portable
       programs.

NOTES
       sendfile()  will  transfer  at most 0x7ffff000 (2,147,479,552) bytes, returning the number of bytes actually trans‐
       ferred.  (This is true on both 32-bit and 64-bit systems.)

       If you plan to use sendfile() for sending files to a TCP socket, but need to send some header data in front of  the
       file  contents,  you will find it useful to employ the TCP_CORK option, described in tcp(7), to minimize the number
       of packets and to tune performance.

       In Linux 2.4 and earlier, out_fd could also refer to a regular file; this possibility went away in the Linux  2.6.x
       kernel series, but was restored in Linux 2.6.33.

       The  original  Linux sendfile() system call was not designed to handle large file offsets.  Consequently, Linux 2.4
       added sendfile64(), with a wider type for the offset argument.  The glibc sendfile() wrapper function transparently
       deals with the kernel differences.

       Applications may wish to fall back to read(2)/write(2) in the case where sendfile() fails with EINVAL or ENOSYS.

       If  out_fd  refers  to a socket or pipe with zero-copy support, callers must ensure the transferred portions of the
       file referred to by in_fd remain unmodified until the reader on the other end of out_fd  has  consumed  the  trans‐
       ferred data.

       The  Linux-specific  splice(2)  call supports transferring data between arbitrary file descriptors provided one (or
       both) of them is a pipe.

SEE ALSO
       copy_file_range(2), mmap(2), open(2), socket(2), splice(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             SENDFILE(2)
</pre>
<pre zoom>
<span xsmall>2 rt_sigsuspend</span>
SIGSUSPEND(2)                                    Linux Programmer's Manual                                   SIGSUSPEND(2)

NAME
       sigsuspend, rt_sigsuspend - wait for a signal

SYNOPSIS
       #include <signal.h>

       int sigsuspend(const sigset_t *mask);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       sigsuspend(): _POSIX_C_SOURCE

DESCRIPTION
       sigsuspend()  temporarily replaces the signal mask of the calling process with the mask given by mask and then sus‐
       pends the process until delivery of a signal whose action is to invoke a signal handler or to terminate a process.

       If the signal terminates the process, then sigsuspend() does not return.  If the signal  is  caught,  then  sigsus‐
       pend()  returns  after  the signal handler returns, and the signal mask is restored to the state before the call to
       sigsuspend().

       It is not possible to block SIGKILL or SIGSTOP; specifying these signals in mask, has no effect  on  the  process's
       signal mask.

RETURN VALUE
       sigsuspend() always returns -1, with errno set to indicate the error (normally, EINTR).

ERRORS
       EFAULT mask points to memory which is not a valid part of the process address space.

       EINTR  The call was interrupted by a signal; signal(7).

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       Normally,  sigsuspend()  is used in conjunction with sigprocmask(2) in order to prevent delivery of a signal during
       the execution of a critical code section.  The caller first blocks the signals with sigprocmask(2).  When the crit‐
       ical  code  has  completed, the caller then waits for the signals by calling sigsuspend() with the signal mask that
       was returned by sigprocmask(2) (in the oldset argument).

       See sigsetops(3) for details on manipulating signal sets.

   C library/kernel differences
       The original Linux system call was named sigsuspend().  However, with the addition of real-time  signals  in  Linux
       2.2,  the  fixed-size,  32-bit  sigset_t  type supported by that system call was no longer fit for purpose.  Conse‐
       quently, a new system call, rt_sigsuspend(), was added to support an enlarged sigset_t type.  The new  system  call
       takes  a  second  argument,  size_t  sigsetsize, which specifies the size in bytes of the signal set in mask.  This
       argument is currently required to have the value sizeof(sigset_t) (or the error EINVAL results).  The glibc sigsus‐
       pend() wrapper function hides these details from us, transparently calling rt_sigsuspend() when the kernel provides
       it.

SEE ALSO
       kill(2), pause(2), sigaction(2), signal(2), sigprocmask(2), sigwaitinfo(2), sigsetops(3), sigwait(3), signal(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           SIGSUSPEND(2)
</pre>
<pre zoom>
<span xsmall>2 setregid</span>
SETREUID(2)                                      Linux Programmer's Manual                                     SETREUID(2)

NAME
       setreuid, setregid - set real and/or effective user or group ID

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int setreuid(uid_t ruid, uid_t euid);
       int setregid(gid_t rgid, gid_t egid);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       setreuid(), setregid():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.19: */ _DEFAULT_SOURCE
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       setreuid() sets real and effective user IDs of the calling process.

       Supplying a value of -1 for either the real or effective user ID forces the system to leave that ID unchanged.

       Unprivileged  processes may only set the effective user ID to the real user ID, the effective user ID, or the saved
       set-user-ID.

       Unprivileged users may only set the real user ID to the real user ID or the effective user ID.

       If the real user ID is set (i.e., ruid is not -1) or the effective user ID is set to a value not equal to the  pre‐
       vious real user ID, the saved set-user-ID will be set to the new effective user ID.

       Completely  analogously, setregid() sets real and effective group ID's of the calling process, and all of the above
       holds with "group" instead of "user".

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

       Note: there are cases where setreuid() can fail even when the caller is UID 0; it is a grave security error to omit
       checking for a failure return from setreuid().

ERRORS
       EAGAIN The call would change the caller's real UID (i.e., ruid does not match the caller's real UID), but there was
              a temporary failure allocating the necessary kernel data structures.

       EAGAIN ruid does not match the caller's real UID and this call would bring the number of processes belonging to the
              real user ID ruid over the caller's RLIMIT_NPROC resource limit.  Since Linux 3.1, this error case no longer
              occurs (but robust applications should check for this error); see the description of EAGAIN in execve(2).

       EINVAL One or more of the target user or group IDs is not valid in this user namespace.

       EPERM  The calling process is not privileged (on Linux, does not have the necessary capability in its  user  names‐
              pace: CAP_SETUID in the case of setreuid(), or CAP_SETGID in the case of setregid()) and a change other than
              (i) swapping the effective user (group) ID with the real user (group) ID, or (ii) setting one to  the  value
              of  the  other  or  (iii) setting the effective user (group) ID to the value of the saved set-user-ID (saved
              set-group-ID) was specified.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD (setreuid() and setregid() first appeared in 4.2BSD).

NOTES
       Setting the effective user (group) ID to the saved set-user-ID (saved set-group-ID) is possible since Linux  1.1.37
       (1.1.38).

       POSIX.1  does  not  specify all of the UID changes that Linux permits for an unprivileged process.  For setreuid(),
       the effective user ID can be made the same as the real user ID or the saved  set-user-ID,  and  it  is  unspecified
       whether  unprivileged  processes  may set the real user ID to the real user ID, the effective user ID, or the saved
       set-user-ID.  For setregid(), the real group ID can be changed to the value of  the  saved  set-group-ID,  and  the
       effective group ID can be changed to the value of the real group ID or the saved set-group-ID.  The precise details
       of what ID changes are permitted vary across implementations.

       POSIX.1 makes no specification about the effect of these calls on the saved set-user-ID and saved set-group-ID.

       The original Linux setreuid() and setregid() system calls supported only 16-bit user and group IDs.   Subsequently,
       Linux  2.4 added setreuid32() and setregid32(), supporting 32-bit IDs.  The glibc setreuid() and setregid() wrapper
       functions transparently deal with the variations across kernel versions.

   C library/kernel differences
       At the kernel level, user IDs and group IDs are a per-thread attribute.  However, POSIX requires that  all  threads
       in  a process share the same credentials.  The NPTL threading implementation handles the POSIX requirements by pro‐
       viding wrapper functions for the various system calls that change process UIDs and GIDs.  These  wrapper  functions
       (including  those  for  setreuid()  and  setregid()) employ a signal-based technique to ensure that when one thread
       changes credentials, all of the other threads in the process also  change  their  credentials.   For  details,  see
       nptl(7).

SEE ALSO
       getgid(2),  getuid(2), seteuid(2), setgid(2), setresuid(2), setuid(2), capabilities(7), credentials(7), user_names‐
       paces(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             SETREUID(2)
</pre>
<pre zoom>
<span xsmall>2 socket</span>
SOCKET(2)                                        Linux Programmer's Manual                                       SOCKET(2)

NAME
       socket - create an endpoint for communication

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>

       int socket(int domain, int type, int protocol);

DESCRIPTION
       socket()  creates  an  endpoint  for communication and returns a file descriptor that refers to that endpoint.  The
       file descriptor returned by a successful call will be the lowest-numbered file descriptor not  currently  open  for
       the process.

       The  domain argument specifies a communication domain; this selects the protocol family which will be used for com‐
       munication.  These families are defined in <sys/socket.h>.  The currently understood formats include:

       Name                Purpose                          Man page
       AF_UNIX, AF_LOCAL   Local communication              unix(7)
       AF_INET             IPv4 Internet protocols          ip(7)
       AF_INET6            IPv6 Internet protocols          ipv6(7)
       AF_IPX              IPX - Novell protocols
       AF_NETLINK          Kernel user interface device     netlink(7)
       AF_X25              ITU-T X.25 / ISO-8208 protocol   x25(7)
       AF_AX25             Amateur radio AX.25 protocol
       AF_ATMPVC           Access to raw ATM PVCs
       AF_APPLETALK        AppleTalk                        ddp(7)
       AF_PACKET           Low level packet interface       packet(7)
       AF_ALG              Interface to kernel crypto API

       The socket has the indicated type, which specifies the communication semantics.  Currently defined types are:

       SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based byte streams.  An out-of-band  data  trans‐
                       mission mechanism may be supported.

       SOCK_DGRAM      Supports datagrams (connectionless, unreliable messages of a fixed maximum length).

       SOCK_SEQPACKET  Provides  a  sequenced,  reliable, two-way connection-based data transmission path for datagrams of
                       fixed maximum length; a consumer is required to read an entire packet with each input system call.

       SOCK_RAW        Provides raw network protocol access.

       SOCK_RDM        Provides a reliable datagram layer that does not guarantee ordering.

       SOCK_PACKET     Obsolete and should not be used in new programs; see packet(7).

       Some socket types may not be implemented by all protocol families.

       Since Linux 2.6.27, the type argument serves a second purpose: in addition to specifying  a  socket  type,  it  may
       include the bitwise OR of any of the following values, to modify the behavior of socket():

       SOCK_NONBLOCK   Set  the O_NONBLOCK file status flag on the new open file description.  Using this flag saves extra
                       calls to fcntl(2) to achieve the same result.

       SOCK_CLOEXEC    Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.  See  the  description  of  the
                       O_CLOEXEC flag in open(2) for reasons why this may be useful.

       The protocol specifies a particular protocol to be used with the socket.  Normally only a single protocol exists to
       support a particular socket type within a given protocol family, in which case protocol  can  be  specified  as  0.
       However,  it  is  possible  that many protocols may exist, in which case a particular protocol must be specified in
       this manner.  The protocol number to use is specific to the “communication domain” in  which  communication  is  to
       take place; see protocols(5).  See getprotoent(3) on how to map protocol name strings to protocol numbers.

       Sockets of type SOCK_STREAM are full-duplex byte streams.  They do not preserve record boundaries.  A stream socket
       must be in a connected state before any data may be sent or received on it.  A connection to another socket is cre‐
       ated  with  a  connect(2)  call.   Once connected, data may be transferred using read(2) and write(2) calls or some
       variant of the send(2) and recv(2) calls.  When a session has been completed a close(2) may be performed.   Out-of-
       band data may also be transmitted as described in send(2) and received as described in recv(2).

       The  communications protocols which implement a SOCK_STREAM ensure that data is not lost or duplicated.  If a piece
       of data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable  length
       of  time,  then  the  connection is considered to be dead.  When SO_KEEPALIVE is enabled on the socket the protocol
       checks in a protocol-specific manner if the other end is still alive.  A SIGPIPE signal  is  raised  if  a  process
       sends  or  receives  on  a  broken  stream;  this  causes naive processes, which do not handle the signal, to exit.
       SOCK_SEQPACKET sockets employ the same system calls as SOCK_STREAM sockets.  The only difference  is  that  read(2)
       calls  will  return  only  the amount of data requested, and any data remaining in the arriving packet will be dis‐
       carded.  Also all message boundaries in incoming datagrams are preserved.

       SOCK_DGRAM and SOCK_RAW sockets allow sending of datagrams to correspondents named in sendto(2)  calls.   Datagrams
       are generally received with recvfrom(2), which returns the next datagram along with the address of its sender.

       SOCK_PACKET  is  an  obsolete  socket  type  to receive raw packets directly from the device driver.  Use packet(7)
       instead.

       An fcntl(2) F_SETOWN operation can be used to specify a process or process group to receive a  SIGURG  signal  when
       the  out-of-band  data arrives or SIGPIPE signal when a SOCK_STREAM connection breaks unexpectedly.  This operation
       may also be used to set the process or process group that receives the I/O and  asynchronous  notification  of  I/O
       events via SIGIO.  Using F_SETOWN is equivalent to an ioctl(2) call with the FIOSETOWN or SIOCSPGRP argument.

       When the network signals an error condition to the protocol module (e.g., using an ICMP message for IP) the pending
       error flag is set for the socket.  The next operation on this socket will return the  error  code  of  the  pending
       error.  For some protocols it is possible to enable a per-socket error queue to retrieve detailed information about
       the error; see IP_RECVERR in ip(7).

       The operation of sockets is controlled by socket level options.  These options are defined in <sys/socket.h>.   The
       functions setsockopt(2) and getsockopt(2) are used to set and get options, respectively.

RETURN VALUE
       On success, a file descriptor for the new socket is returned.  On error, -1 is returned, and errno is set appropri‐
       ately.

ERRORS
       EACCES Permission to create a socket of the specified type and/or protocol is denied.

       EAFNOSUPPORT
              The implementation does not support the specified address family.

       EINVAL Unknown protocol, or protocol family not available.

       EINVAL Invalid flags in type.

       EMFILE The per-process limit on the number of open file descriptors has been reached.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENOBUFS or ENOMEM
              Insufficient memory is available.  The socket cannot be created until sufficient resources are freed.

       EPROTONOSUPPORT
              The protocol type or the specified protocol is not supported within this domain.

       Other errors may be generated by the underlying protocol modules.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.4BSD.

       The SOCK_NONBLOCK and SOCK_CLOEXEC flags are Linux-specific.

       socket() appeared in 4.2BSD.  It is generally portable to/from non-BSD systems supporting clones of the BSD  socket
       layer (including System V variants).

NOTES
       POSIX.1  does  not require the inclusion of <sys/types.h>, and this header file is not required on Linux.  However,
       some historical (BSD) implementations required this header file, and portable applications  are  probably  wise  to
       include it.

       The  manifest  constants  used  under 4.x BSD for protocol families are PF_UNIX, PF_INET, and so on, while AF_UNIX,
       AF_INET, and so on are used for address families.  However, already the BSD man page promises: "The protocol family
       generally is the same as the address family", and subsequent standards use AF_* everywhere.

       The AF_ALG protocol type was added in Linux 2.6.38.  More information on this interface is provided with the kernel
       HTML documentation at https://www.kernel.org/doc/htmldocs/crypto-API/User.html.

EXAMPLE
       An example of the use of socket() is shown in getaddrinfo(3).

SEE ALSO
       accept(2), bind(2), close(2), connect(2), fcntl(2), getpeername(2), getsockname(2), getsockopt(2),  ioctl(2),  lis‐
       ten(2),  read(2),  recv(2),  select(2),  send(2),  shutdown(2),  socketpair(2),  write(2),  getprotoent(3),  ip(7),
       socket(7), tcp(7), udp(7), unix(7)

       “An Introductory 4.3BSD  Interprocess  Communication  Tutorial”  and  “BSD  Interprocess  Communication  Tutorial”,
       reprinted in UNIX Programmer's Supplementary Documents Volume 1.

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SOCKET(2)
</pre>
<pre zoom>
<span xsmall>2 getcontext</span>
GETCONTEXT(3)                                    Linux Programmer's Manual                                   GETCONTEXT(3)

NAME
       getcontext, setcontext - get or set the user context

SYNOPSIS
       #include <ucontext.h>

       int getcontext(ucontext_t *ucp);
       int setcontext(const ucontext_t *ucp);

DESCRIPTION
       In  a  System  V-like  environment, one has the two types mcontext_t and ucontext_t defined in <ucontext.h> and the
       four functions getcontext(), setcontext(), makecontext(3), and swapcontext(3) that allow user-level context switch‐
       ing between multiple threads of control within a process.

       The mcontext_t type is machine-dependent and opaque.  The ucontext_t type is a structure that has at least the fol‐
       lowing fields:

           typedef struct ucontext_t {
               struct ucontext_t *uc_link;
               sigset_t          uc_sigmask;
               stack_t           uc_stack;
               mcontext_t        uc_mcontext;
               ...
           } ucontext_t;

       with sigset_t and stack_t defined in <signal.h>.  Here uc_link points to the context that will be resumed when  the
       current context terminates (in case the current context was created using makecontext(3)), uc_sigmask is the set of
       signals blocked in this context (see sigprocmask(2)), uc_stack is the stack  used  by  this  context  (see  sigalt‐
       stack(2)),  and  uc_mcontext is the machine-specific representation of the saved context, that includes the calling
       thread's machine registers.

       The function getcontext() initializes the structure pointed at by ucp to the currently active context.

       The function setcontext() restores the user context pointed at by ucp.  A successful call  does  not  return.   The
       context  should  have  been obtained by a call of getcontext(), or makecontext(3), or passed as third argument to a
       signal handler.

       If the context was obtained by a call of getcontext(), program execution continues as if this call just returned.

       If the context was obtained by a call of makecontext(3), program execution continues by a call to the function func
       specified  as the second argument of that call to makecontext(3).  When the function func returns, we continue with
       the uc_link member of the structure ucp specified as the first argument of that call to makecontext(3).  When  this
       member is NULL, the thread exits.

       If the context was obtained by a call to a signal handler, then old standard text says that "program execution con‐
       tinues with the program instruction following the instruction interrupted by the signal".  However,  this  sentence
       was removed in SUSv2, and the present verdict is "the result is unspecified".

RETURN VALUE
       When  successful,  getcontext() returns 0 and setcontext() does not return.  On error, both return -1 and set errno
       appropriately.

ERRORS
       None defined.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌───────────────────────────┬───────────────┬──────────────────┐
       │Interface                  │ Attribute     │ Value            │
       ├───────────────────────────┼───────────────┼──────────────────┤
       │getcontext(), setcontext() │ Thread safety │ MT-Safe race:ucp │
       └───────────────────────────┴───────────────┴──────────────────┘
CONFORMING TO
       SUSv2, POSIX.1-2001.  POSIX.1-2008 removes the specification of getcontext(), citing portability issues, and recom‐
       mending that applications be rewritten to use POSIX threads instead.

NOTES
       The  earliest incarnation of this mechanism was the setjmp(3)/longjmp(3) mechanism.  Since that does not define the
       handling of the signal context, the next stage was the  sigsetjmp(3)/siglongjmp(3)  pair.   The  present  mechanism
       gives  much  more control.  On the other hand, there is no easy way to detect whether a return from getcontext() is
       from the first call, or via a setcontext() call.  The user has to invent her own bookkeeping device, and a register
       variable won't do since registers are restored.

       When  a  signal occurs, the current user context is saved and a new context is created by the kernel for the signal
       handler.  Do not leave the handler using longjmp(3): it is undefined what would happen  with  contexts.   Use  sig‐
       longjmp(3) or setcontext() instead.

SEE ALSO
       sigaction(2), sigaltstack(2), sigprocmask(2), longjmp(3), makecontext(3), sigsetjmp(3)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           GETCONTEXT(3)
</pre>
<pre zoom>
<span xsmall>2 kexec_file_load</span>
KEXEC_LOAD(2)                                    Linux Programmer's Manual                                   KEXEC_LOAD(2)

NAME
       kexec_load, kexec_file_load - load a new kernel for later execution

SYNOPSIS
       #include <linux/kexec.h>

       long kexec_load(unsigned long entry, unsigned long nr_segments,
                       struct kexec_segment *segments, unsigned long flags);

       long kexec_file_load(int kernel_fd, int initrd_fd,
                           unsigned long cmdline_len, const char *cmdline,
                           unsigned long flags);

       Note: There are no glibc wrappers for these system calls; see NOTES.

DESCRIPTION
       The kexec_load() system call loads a new kernel that can be executed later by reboot(2).

       The flags argument is a bit mask that controls the operation of the call.  The following values can be specified in
       flags:

       KEXEC_ON_CRASH (since Linux 2.6.13)
              Execute the new kernel automatically on a system crash.  This "crash kernel"  is  loaded  into  an  area  of
              reserved  memory  that  is determined at boot time using the crashkernel kernel command-line parameter.  The
              location of this reserved memory is exported to user space via the /proc/iomem file,  in  an  entry  labeled
              "Crash  kernel".   A  user-space  application can parse this file and prepare a list of segments (see below)
              that specify this reserved memory as destination.  If this flag is specified, the  kernel  checks  that  the
              target segments specified in segments fall within the reserved region.

       KEXEC_PRESERVE_CONTEXT (since Linux 2.6.27)
              Preserve  the  system  hardware and software states before executing the new kernel.  This could be used for
              system suspend.  This flag is available only if the kernel was configured  with  CONFIG_KEXEC_JUMP,  and  is
              effective only if nr_segments is greater than 0.

       The  high-order bits (corresponding to the mask 0xffff0000) of flags contain the architecture of the to-be-executed
       kernel.  Specify (OR) the constant KEXEC_ARCH_DEFAULT to use the current architecture,  or  one  of  the  following
       architecture   constants   KEXEC_ARCH_386,  KEXEC_ARCH_68K,  KEXEC_ARCH_X86_64,  KEXEC_ARCH_PPC,  KEXEC_ARCH_PPC64,
       KEXEC_ARCH_IA_64, KEXEC_ARCH_ARM, KEXEC_ARCH_S390, KEXEC_ARCH_SH,  KEXEC_ARCH_MIPS,  and  KEXEC_ARCH_MIPS_LE.   The
       architecture must be executable on the CPU of the system.

       The  entry  argument  is the physical entry address in the kernel image.  The nr_segments argument is the number of
       segments pointed to by the segments pointer; the kernel imposes an (arbitrary) limit of 16 on the  number  of  seg‐
       ments.  The segments argument is an array of kexec_segment structures which define the kernel layout:

           struct kexec_segment {
               void   *buf;        /* Buffer in user space */
               size_t  bufsz;      /* Buffer length in user space */
               void   *mem;        /* Physical address of kernel */
               size_t  memsz;      /* Physical address length */
           };

       The kernel image defined by segments is copied from the calling process into the kernel either in regular memory or
       in reserved memory (if KEXEC_ON_CRASH is set).  The kernel first performs various sanity checks on the  information
       passed in segments.  If these checks pass, the kernel copies the segment data to kernel memory.  Each segment spec‐
       ified in segments is copied as follows:

       *  buf and bufsz identify a memory region in the caller's virtual address space that is the  source  of  the  copy.
          The value in bufsz may not exceed the value in the memsz field.

       *  mem  and  memsz  specify  a physical address range that is the target of the copy.  The values specified in both
          fields must be multiples of the system page size.

       *  bufsz bytes are copied from the source buffer to the target kernel buffer.  If bufsz is less  than  memsz,  then
          the excess bytes in the kernel buffer are zeroed out.

       In  case  of a normal kexec (i.e., the KEXEC_ON_CRASH flag is not set), the segment data is loaded in any available
       memory and is moved to the final destination at kexec reboot time (e.g., when the kexec(8) command is executed with
       the -e option).

       In  case of kexec on panic (i.e., the KEXEC_ON_CRASH flag is set), the segment data is loaded to reserved memory at
       the time of the call, and, after a crash, the kexec mechanism simply passes control to that kernel.

       The kexec_load() system call is available only if the kernel was configured with CONFIG_KEXEC.

   kexec_file_load()
       The kexec_file_load() system call is similar to kexec_load(), but it takes a different set of arguments.  It  reads
       the  kernel  to  be  loaded from the file referred to by the file descriptor kernel_fd, and the initrd (initial RAM
       disk) to be loaded from file referred to by the file descriptor initrd_fd.  The cmdline argument is a pointer to  a
       buffer containing the command line for the new kernel.  The cmdline_len argument specifies size of the buffer.  The
       last byte in the buffer must be a null byte ('\0').

       The flags argument is a bit mask which modifies the behavior of the call.  The following values can be specified in
       flags:

       KEXEC_FILE_UNLOAD
              Unload the currently loaded kernel.

       KEXEC_FILE_ON_CRASH
              Load the new kernel in the memory region reserved for the crash kernel (as for KEXEC_ON_CRASH).  This kernel
              is booted if the currently running kernel crashes.

       KEXEC_FILE_NO_INITRAMFS
              Loading initrd/initramfs is optional.  Specify this flag if no initramfs is being loaded.  If this  flag  is
              set, the value passed in initrd_fd is ignored.

       The  kexec_file_load()  system  call  was  added  to  provide  support  for systems where "kexec" loading should be
       restricted to only kernels that are signed.  This system call is available only if the kernel was  configured  with
       CONFIG_KEXEC_FILE.

RETURN VALUE
       On success, these system calls returns 0.  On error, -1 is returned and errno is set to indicate the error.

ERRORS
       EADDRNOTAVAIL
              The  KEXEC_ON_CRASH  flags was specified, but the region specified by the mem and memsz fields of one of the
              segments entries lies outside the range of memory reserved for the crash kernel.

       EADDRNOTAVAIL
              The value in a mem or memsz field in one of the segments entries is not a multiple of the system page size.

       EBADF  kernel_fd or initrd_fd is not a valid file descriptor.

       EBUSY  Another crash kernel is already being loaded or a crash kernel is already in use.

       EINVAL flags is invalid.

       EINVAL The value of a bufsz field in one of the segments entries exceeds  the  value  in  the  corresponding  memsz
              field.

       EINVAL nr_segments exceeds KEXEC_SEGMENT_MAX (16).

       EINVAL Two or more of the kernel target buffers overlap.

       EINVAL The value in cmdline[cmdline_len-1] is not '\0'.

       EINVAL The file referred to by kernel_fd or initrd_fd is empty (length zero).

       ENOEXEC
              kernel_fd does not refer to an open file, or the kernel can't load this file.  Currently, the file must be a
              bzImage and contain an x86 kernel that is loadable above 4 GiB in memory (see the kernel source  file  Docu‐
              mentation/x86/boot.txt).

       ENOMEM Could not allocate memory.

       EPERM  The caller does not have the CAP_SYS_BOOT capability.

VERSIONS
       The  kexec_load()  system call first appeared in Linux 2.6.13.  The kexec_file_load() system call first appeared in
       Linux 3.17.

CONFORMING TO
       These system calls are Linux-specific.

NOTES
       Currently, there is no glibc support for these system calls.  Call them using syscall(2).

SEE ALSO
       reboot(2), syscall(2), kexec(8)

       The kernel source files Documentation/kdump/kdump.txt and Documentation/admin-guide/kernel-parameters.txt

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           KEXEC_LOAD(2)
</pre>
<pre zoom>
<span xsmall>2 setpgid</span>
SETPGID(2)                                       Linux Programmer's Manual                                      SETPGID(2)

NAME
       setpgid, getpgid, setpgrp, getpgrp - set/get process group

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int setpgid(pid_t pid, pid_t pgid);
       pid_t getpgid(pid_t pid);

       pid_t getpgrp(void);                 /* POSIX.1 version */
       pid_t getpgrp(pid_t pid);            /* BSD version */

       int setpgrp(void);                   /* System V version */
       int setpgrp(pid_t pid, pid_t pgid);  /* BSD version */

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       getpgid():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L

       setpgrp() (POSIX.1):
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.19: */ _DEFAULT_SOURCE
               || /* Glibc versions <= 2.19: */ _SVID_SOURCE

       setpgrp() (BSD), getpgrp() (BSD):
           [These are available only before glibc 2.19]
           _BSD_SOURCE &&
               ! (_POSIX_SOURCE || _POSIX_C_SOURCE || _XOPEN_SOURCE ||
                   _GNU_SOURCE || _SVID_SOURCE)

DESCRIPTION
       All of these interfaces are available on Linux, and are used for getting and setting the process group ID (PGID) of
       a process.  The preferred, POSIX.1-specified ways of doing this are:  getpgrp(void),  for  retrieving  the  calling
       process's PGID; and setpgid(), for setting a process's PGID.

       setpgid()  sets the PGID of the process specified by pid to pgid.  If pid is zero, then the process ID of the call‐
       ing process is used.  If pgid is zero, then the PGID of the process specified by  pid  is  made  the  same  as  its
       process  ID.   If  setpgid() is used to move a process from one process group to another (as is done by some shells
       when creating pipelines), both process groups must be part of the same session (see setsid(2) and  credentials(7)).
       In this case, the pgid specifies an existing process group to be joined and the session ID of that group must match
       the session ID of the joining process.

       The POSIX.1 version of getpgrp(), which takes no arguments, returns the PGID of the calling process.

       getpgid() returns the PGID of the process specified by pid.  If pid is zero, the process ID of the calling  process
       is used.  (Retrieving the PGID of a process other than the caller is rarely necessary, and the POSIX.1 getpgrp() is
       preferred for that task.)

       The System V-style setpgrp(), which takes no arguments, is equivalent to setpgid(0, 0).

       The BSD-specific setpgrp() call, which takes arguments pid and pgid, is a wrapper function that calls

           setpgid(pid, pgid)

       Since glibc 2.19, the BSD-specific setpgrp() function is no longer exposed by <unistd.h>; calls should be  replaced
       with the setpgid() call shown above.

       The BSD-specific getpgrp() call, which takes a single pid argument, is a wrapper function that calls

           getpgid(pid)

       Since  glibc 2.19, the BSD-specific getpgrp() function is no longer exposed by <unistd.h>; calls should be replaced
       with calls to the POSIX.1 getpgrp() which takes no arguments (if the intent is to obtain  the  caller's  PGID),  or
       with the getpgid() call shown above.

RETURN VALUE
       On success, setpgid() and setpgrp() return zero.  On error, -1 is returned, and errno is set appropriately.

       The POSIX.1 getpgrp() always returns the PGID of the caller.

       getpgid(),  and  the BSD-specific getpgrp() return a process group on success.  On error, -1 is returned, and errno
       is set appropriately.

ERRORS
       EACCES An attempt was made to change the process group ID of one of the children of the  calling  process  and  the
              child had already performed an execve(2) (setpgid(), setpgrp()).

       EINVAL pgid is less than 0 (setpgid(), setpgrp()).

       EPERM  An  attempt was made to move a process into a process group in a different session, or to change the process
              group ID of one of the children of the calling process and the child was  in  a  different  session,  or  to
              change the process group ID of a session leader (setpgid(), setpgrp()).

       ESRCH  For  getpgid():  pid  does  not  match any process.  For setpgid(): pid is not the calling process and not a
              child of the calling process.

CONFORMING TO
       setpgid() and the version of getpgrp() with no arguments conform to POSIX.1-2001.

       POSIX.1-2001 also specifies getpgid() and the version of setpgrp() that takes no  arguments.   (POSIX.1-2008  marks
       this setpgrp() specification as obsolete.)

       The  version  of  getpgrp()  with  one  argument  and the version of setpgrp() that takes two arguments derive from
       4.2BSD, and are not specified by POSIX.1.

NOTES
       A child created via fork(2) inherits its parent's process group ID.  The PGID is preserved across an execve(2).

       Each process group is a member of a session and each process is a member of the session of which its process  group
       is a member.  (See credentials(7).)

       A  session  can  have a controlling terminal.  At any time, one (and only one) of the process groups in the session
       can be the foreground process group for the terminal; the remaining process groups are in  the  background.   If  a
       signal  is  generated from the terminal (e.g., typing the interrupt key to generate SIGINT), that signal is sent to
       the foreground process group.  (See termios(3) for a description of the characters that  generate  signals.)   Only
       the foreground process group may read(2) from the terminal; if a background process group tries to read(2) from the
       terminal, then the group is sent a SIGTTIN signal, which suspends it.  The tcgetpgrp(3) and tcsetpgrp(3)  functions
       are used to get/set the foreground process group of the controlling terminal.

       The  setpgid() and getpgrp() calls are used by programs such as bash(1) to create process groups in order to imple‐
       ment shell job control.

       If the termination of a process causes a process group to become orphaned, and if any member of the newly  orphaned
       process  group  is  stopped,  then a SIGHUP signal followed by a SIGCONT signal will be sent to each process in the
       newly orphaned process group.  An orphaned process group is one in which the parent  of  every  member  of  process
       group  is either itself also a member of the process group or is a member of a process group in a different session
       (see also credentials(7)).

SEE ALSO
       getuid(2), setsid(2), tcgetpgrp(3), tcsetpgrp(3), termios(3), credentials(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              SETPGID(2)
</pre>
<pre zoom>
<span xsmall>2 getuid32</span>
GETUID(2)                                        Linux Programmer's Manual                                       GETUID(2)

NAME
       getuid, geteuid - get user identity

SYNOPSIS
       #include <unistd.h>
       #include <sys/types.h>

       uid_t getuid(void);
       uid_t geteuid(void);

DESCRIPTION
       getuid() returns the real user ID of the calling process.

       geteuid() returns the effective user ID of the calling process.

ERRORS
       These functions are always successful.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD.

NOTES
   History
       In UNIX V6 the getuid() call returned (euid << 8) + uid.  UNIX V7 introduced separate calls getuid() and geteuid().

       The  original  Linux  getuid()  and geteuid() system calls supported only 16-bit user IDs.  Subsequently, Linux 2.4
       added getuid32() and geteuid32(), supporting 32-bit IDs.  The glibc getuid() and geteuid() wrapper functions trans‐
       parently deal with the variations across kernel versions.

SEE ALSO
       getresuid(2), setreuid(2), setuid(2), credentials(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               GETUID(2)
</pre>
<pre zoom>
<span xsmall>2 io_destroy</span>
IO_DESTROY(2)                                    Linux Programmer's Manual                                   IO_DESTROY(2)

NAME
       io_destroy - destroy an asynchronous I/O context

SYNOPSIS
       #include <linux/aio_abi.h>          /* Defines needed types */

       int io_destroy(aio_context_t ctx_id);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       The  io_destroy()  system  call  will attempt to cancel all outstanding asynchronous I/O operations against ctx_id,
       will block on the completion of all operations that could not be canceled, and will destroy the ctx_id.

RETURN VALUE
       On success, io_destroy() returns 0.  For the failure return, see NOTES.

ERRORS
       EFAULT The context pointed to is invalid.

       EINVAL The AIO context specified by ctx_id is invalid.

       ENOSYS io_destroy() is not implemented on this architecture.

VERSIONS
       The asynchronous I/O system calls first appeared in Linux 2.5.

CONFORMING TO
       io_destroy() is Linux-specific and should not be used in programs that are intended to be portable.

NOTES
       Glibc does not provide a wrapper function for this system  call.   You  could  invoke  it  using  syscall(2).   But
       instead, you probably want to use the io_destroy() wrapper function provided by libaio.

       Note that the libaio wrapper function uses a different type (io_context_t) for the ctx_id argument.  Note also that
       the libaio wrapper does not follow the usual C library conventions for indicating errors: on  error  it  returns  a
       negated  error  number  (the  negative  of  one of the values listed in ERRORS).  If the system call is invoked via
       syscall(2), then the return value follows the usual conventions for indicating an error: -1, with errno  set  to  a
       (positive) value that indicates the error.

SEE ALSO
       io_cancel(2), io_getevents(2), io_setup(2), io_submit(2), aio(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           IO_DESTROY(2)
</pre>
<pre zoom>
<span xsmall>2 shmop</span>
SHMOP(2)                                         Linux Programmer's Manual                                        SHMOP(2)

NAME
       shmat, shmdt - System V shared memory operations

SYNOPSIS
       #include <sys/types.h>
       #include <sys/shm.h>

       void *shmat(int shmid, const void *shmaddr, int shmflg);

       int shmdt(const void *shmaddr);

DESCRIPTION
   shmat()
       shmat()  attaches  the  System V  shared  memory  segment  identified  by shmid to the address space of the calling
       process.  The attaching address is specified by shmaddr with one of the following criteria:

       *  If shmaddr is NULL, the system chooses a suitable (unused) page-aligned address to attach the segment.

       *  If shmaddr isn't NULL and SHM_RND is specified in shmflg, the attach occurs at  the  address  equal  to  shmaddr
          rounded down to the nearest multiple of SHMLBA.

       *  Otherwise, shmaddr must be a page-aligned address at which the attach occurs.

       In addition to SHM_RND, the following flags may be specified in the shmflg bit-mask argument:

       SHM_EXEC (Linux-specific; since Linux 2.6.9)
              Allow the contents of the segment to be executed.  The caller must have execute permission on the segment.

       SHM_RDONLY
              Attach  the  segment  for read-only access.  The process must have read permission for the segment.  If this
              flag is not specified, the segment is attached for read and write access, and the process must have read and
              write permission for the segment.  There is no notion of a write-only shared memory segment.

       SHM_REMAP (Linux-specific)
              This  flag specifies that the mapping of the segment should replace any existing mapping in the range start‐
              ing at shmaddr and continuing for the size of the segment.  (Normally, an EINVAL error  would  result  if  a
              mapping already exists in this address range.)  In this case, shmaddr must not be NULL.

       The  brk(2)  value of the calling process is not altered by the attach.  The segment will automatically be detached
       at process exit.  The same segment may be attached as a read and as a read-write one, and more than  once,  in  the
       process's address space.

       A  successful shmat() call updates the members of the shmid_ds structure (see shmctl(2)) associated with the shared
       memory segment as follows:

              shm_atime is set to the current time.

              shm_lpid is set to the process-ID of the calling process.

              shm_nattch is incremented by one.

   shmdt()
       shmdt() detaches the shared memory segment located at the address specified by shmaddr from the  address  space  of
       the  calling  process.   The  to-be-detached  segment  must  be  currently attached with shmaddr equal to the value
       returned by the attaching shmat() call.

       On a successful shmdt() call, the system updates the members of the shmid_ds structure associated with  the  shared
       memory segment as follows:

              shm_dtime is set to the current time.

              shm_lpid is set to the process-ID of the calling process.

              shm_nattch  is  decremented  by one.  If it becomes 0 and the segment is marked for deletion, the segment is
              deleted.

RETURN VALUE
       On success, shmat() returns the address of the attached shared memory segment; on error, (void *) -1  is  returned,
       and errno is set to indicate the cause of the error.

       On success, shmdt() returns 0; on error -1 is returned, and errno is set to indicate the cause of the error.

ERRORS
       When shmat() fails, errno is set to one of the following:

       EACCES The  calling process does not have the required permissions for the requested attach type, and does not have
              the CAP_IPC_OWNER capability in the user namespace that governs its IPC namespace.

       EIDRM  shmid points to a removed identifier.

       EINVAL Invalid shmid value, unaligned (i.e., not page-aligned and SHM_RND was not  specified)  or  invalid  shmaddr
              value, or can't attach segment at shmaddr, or SHM_REMAP was specified and shmaddr was NULL.

       ENOMEM Could not allocate memory for the descriptor or for the page tables.

       When shmdt() fails, errno is set as follows:

       EINVAL There is no shared memory segment attached at shmaddr; or, shmaddr is not aligned on a page boundary.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

       In SVID 3 (or perhaps earlier), the type of the shmaddr argument was changed from char * into const void *, and the
       returned type of shmat() from char * into void *.

NOTES
       After a fork(2), the child inherits the attached shared memory segments.

       After an execve(2), all attached shared memory segments are detached from the process.

       Upon _exit(2), all attached shared memory segments are detached from the process.

       Using shmat() with shmaddr equal to NULL is the preferred, portable way of attaching a shared memory  segment.   Be
       aware  that the shared memory segment attached in this way may be attached at different addresses in different pro‐
       cesses.  Therefore, any pointers maintained within the shared memory must be made relative (typically to the start‐
       ing address of the segment), rather than absolute.

       On  Linux,  it  is possible to attach a shared memory segment even if it is already marked to be deleted.  However,
       POSIX.1 does not specify this behavior and many other implementations do not support it.

       The following system parameter affects shmat():

       SHMLBA Segment low boundary address multiple.  When explicitly specifying an attach address in a call  to  shmat(),
              the  caller should ensure that the address is a multiple of this value.  This is necessary on some architec‐
              tures, in order either to ensure good CPU cache performance or to ensure that different attaches of the same
              segment  have  consistent  views  within the CPU cache.  SHMLBA is normally some multiple of the system page
              size.  (On many Linux architectures, SHMLBA is the same as the system page size.)

       The implementation places no intrinsic per-process limit on the number of shared memory segments (SHMSEG).

SEE ALSO
       brk(2), mmap(2), shmctl(2), shmget(2), capabilities(7), shm_overview(7), svipc(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                SHMOP(2)
</pre>
<pre zoom>
<span xsmall>2 lstat64</span>
STAT(2)                                          Linux Programmer's Manual                                         STAT(2)

NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       int fstat(int fd, struct stat *statbuf);
       int lstat(const char *pathname, struct stat *statbuf);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
                   int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       lstat():
           /* glibc 2.19 and earlier */ _BSD_SOURCE
               || /* Since glibc 2.20 */ _DEFAULT_SOURCE
               || _XOPEN_SOURCE >= 500
               || /* Since glibc 2.10: */ _POSIX_C_SOURCE >= 200112L

       fstatat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  functions return information about a file, in the buffer pointed to by statbuf.  No permissions are required
       on the file itself, but—in the case of stat(), fstatat(), and lstat()—execute (search) permission  is  required  on
       all of the directories in pathname that lead to the file.

       stat()  and fstatat() retrieve information about the file pointed to by pathname; the differences for fstatat() are
       described below.

       lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information  about  the
       link itself, not the file that it refers to.

       fstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the
       file descriptor fd.

   The stat structure
       All of these system calls return a stat structure, which contains the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

       Note: the order of fields in the stat structure varies somewhat across architectures.  In addition, the  definition
       above  does  not  show the padding bytes that may be present between some fields on various architectures.  Consult
       the glibc and kernel source code if you need to know the details.

       Note: for performance and simplicity reasons, different fields in the stat structure may contain state  information
       from  different  moments  during the execution of the system call.  For example, if st_mode or st_uid is changed by
       another process by calling chmod(2) or chown(2), stat() might return the old st_mode together with the new  st_uid,
       or the old st_uid together with the new st_mode.

       The fields in the stat structure are as follows:

       st_dev This field describes the device on which this file resides.  (The major(3) and minor(3) macros may be useful
              to decompose the device ID in this field.)

       st_ino This field contains the file's inode number.

       st_mode
              This field contains the file type and mode.  See inode(7) for further information.

       st_nlink
              This field contains the number of hard links to the file.

       st_uid This field contains the user ID of the owner of the file.

       st_gid This field contains the ID of the group owner of the file.

       st_rdev
              This field describes the device that this file (inode) represents.

       st_size
              This field gives the size of the file (if it is a regular file or a symbolic link) in bytes.  The size of  a
              symbolic link is the length of the pathname it contains, without a terminating null byte.

       st_blksize
              This field gives the "preferred" block size for efficient filesystem I/O.

       st_blocks
              This  field  indicates  the number of blocks allocated to the file, in 512-byte units.  (This may be smaller
              than st_size/512 when the file has holes.)

       st_atime
              This is the file's last access timestamp.

       st_mtime
              This is the file's last modification timestamp.

       st_ctime
              This is the file's last status change timestamp.

       For further information on the above fields, see inode(7).

   fstatat()
       The fstatat() system call is a more general interface for  accessing  file  information  which  can  still  provide
       exactly the behavior of each of stat(), lstat(), and fstat().

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       stat() and lstat() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like stat() and lstat()).

       If pathname is absolute, then dirfd is ignored.

       flags can either be 0, or include one or more of the following flags ORed:

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2) O_PATH flag).  In this case, dirfd can refer to any type of file, not just a directory, and the
              behavior of fstatat() is similar to that of fstat().  If dirfd is AT_FDCWD, the call operates on the current
              working directory.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.

       AT_NO_AUTOMOUNT (since Linux 2.6.38)
              Don't  automount  the  terminal ("basename") component of pathname if it is a directory that is an automount
              point.  This allows the caller to gather attributes of an automount point (rather than the location it would
              mount).   Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand directory such as used
              for automounter indirect maps.  This flag can be used in tools that scan directories to  prevent  mass-auto‐
              mounting  of a directory of automount points.  The AT_NO_AUTOMOUNT flag has no effect if the mount point has
              already been mounted over.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.   Both
              stat() and lstat() act as though AT_NO_AUTOMOUNT was set.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a  symbolic link, do not dereference it: instead return information about the link itself,
              like lstat().  (By default, fstatat() dereferences symbolic links, like stat().)

       See openat(2) for an explanation of the need for fstatat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Search permission is denied for one of the directories in the path prefix of pathname.  (See also path_reso‐
              lution(7).)

       EBADF  fd is not a valid open file descriptor.

       EFAULT Bad address.

       ELOOP  Too many symbolic links encountered while traversing the path.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A  component  of pathname does not exist, or pathname is an empty string and AT_EMPTY_PATH was not specified
              in flags.

       ENOMEM Out of memory (i.e., kernel memory).

       ENOTDIR
              A component of the path prefix of pathname is not a directory.

       EOVERFLOW
              pathname or fd refers to a file whose size, inode number, or number of  blocks  cannot  be  represented  in,
              respectively,  the  types off_t, ino_t, or blkcnt_t.  This error can occur when, for example, an application
              compiled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 calls stat()  on  a  file  whose  size  exceeds
              (1<<31)-1 bytes.

       The following additional errors can occur for fstatat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fstatat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       stat(), fstat(), lstat(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.

       fstatat(): POSIX.1-2008.

       According  to  POSIX.1-2001, lstat() on a symbolic link need return valid information only in the st_size field and
       the file type of the st_mode field of the stat  structure.   POSIX.1-2008  tightens  the  specification,  requiring
       lstat() to return valid information in all fields except the mode bits in st_mode.

       Use of the st_blocks and st_blksize fields may be less portable.  (They were introduced in BSD.  The interpretation
       differs between systems, and possibly on a single system when NFS mounts are involved.)

NOTES
   Timestamp fields
       Older kernels and older standards did not support nanosecond timestamp fields.  Instead, there were three timestamp
       fields—st_atime, st_mtime, and st_ctime—typed as time_t that recorded timestamps with one-second precision.

       Since  kernel  2.5.48,  the stat structure supports nanosecond resolution for the three file timestamp fields.  The
       nanosecond components of each timestamp are available via names of the form st_atim.tv_nsec,  if  suitable  feature
       test macros are defined.  Nanosecond timestamps were standardized in POSIX.1-2008, and, starting with version 2.12,
       glibc exposes the nanosecond component names if _POSIX_C_SOURCE is defined with the value 200809L  or  greater,  or
       _XOPEN_SOURCE  is  defined  with  the value 700 or greater.  Up to and including glibc 2.19, the definitions of the
       nanoseconds components are also defined if _BSD_SOURCE or _SVID_SOURCE is defined.  If none of  the  aforementioned
       macros are defined, then the nanosecond values are exposed with names of the form st_atimensec.

   C library/kernel differences
       Over  time, increases in the size of the stat structure have led to three successive versions of stat(): sys_stat()
       (slot __NR_oldstat), sys_newstat() (slot __NR_stat), and sys_stat64() (slot __NR_stat64) on 32-bit  platforms  such
       as  i386.   The  first  two  versions were already present in Linux 1.0 (albeit with different names); the last was
       added in Linux 2.4.  Similar remarks apply for fstat() and lstat().

       The kernel-internal versions of the stat structure dealt with by the different versions are, respectively:

       __old_kernel_stat
              The original structure, with rather narrow fields, and no padding.

       stat   Larger st_ino field and padding added to various parts of the structure to allow for future expansion.

       stat64 Even larger st_ino field, larger st_uid and st_gid fields to accommodate the Linux-2.4 expansion of UIDs and
              GIDs  to  32 bits, and various other enlarged fields and further padding in the structure.  (Various padding
              bytes were eventually consumed in Linux 2.6, with the advent of 32-bit device IDs and nanosecond  components
              for the timestamp fields.)

       The  glibc  stat()  wrapper function hides these details from applications, invoking the most recent version of the
       system call provided by the kernel, and repacking the returned information if required for old binaries.

       On modern 64-bit systems, life is simpler: there is a single stat() system call and the kernel deals  with  a  stat
       structure that contains fields of a sufficient size.

       The  underlying  system call employed by the glibc fstatat() wrapper function is actually called fstatat64() or, on
       some architectures, newfstatat().

EXAMPLE
       The following program calls lstat() and displays selected fields in the returned stat structure.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/sysmacros.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           printf("ID of containing device:  [%lx,%lx]\n",
                (long) major(sb.st_dev), (long) minor(sb.st_dev));

           printf("File type:                ");

           switch (sb.st_mode & S_IFMT) {
           case S_IFBLK:  printf("block device\n");            break;
           case S_IFCHR:  printf("character device\n");        break;
           case S_IFDIR:  printf("directory\n");               break;
           case S_IFIFO:  printf("FIFO/pipe\n");               break;
           case S_IFLNK:  printf("symlink\n");                 break;
           case S_IFREG:  printf("regular file\n");            break;
           case S_IFSOCK: printf("socket\n");                  break;
           default:       printf("unknown?\n");                break;
           }

           printf("I-node number:            %ld\n", (long) sb.st_ino);

           printf("Mode:                     %lo (octal)\n",
                   (unsigned long) sb.st_mode);

           printf("Link count:               %ld\n", (long) sb.st_nlink);
           printf("Ownership:                UID=%ld   GID=%ld\n",
                   (long) sb.st_uid, (long) sb.st_gid);

           printf("Preferred I/O block size: %ld bytes\n",
                   (long) sb.st_blksize);
           printf("File size:                %lld bytes\n",
                   (long long) sb.st_size);
           printf("Blocks allocated:         %lld\n",
                   (long long) sb.st_blocks);

           printf("Last status change:       %s", ctime(&sb.st_ctime));
           printf("Last file access:         %s", ctime(&sb.st_atime));
           printf("Last file modification:   %s", ctime(&sb.st_mtime));

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ls(1), stat(1), access(2), chmod(2), chown(2), readlink(2), utime(2), capabilities(7), inode(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 STAT(2)
</pre>
<pre zoom>
<span xsmall>2 set_mempolicy</span>
SET_MEMPOLICY(2)                                 Linux Programmer's Manual                                SET_MEMPOLICY(2)

NAME
       set_mempolicy - set default NUMA memory policy for a thread and its children

SYNOPSIS
       #include <numaif.h>

       long set_mempolicy(int mode, const unsigned long *nodemask,
                          unsigned long maxnode);

       Link with -lnuma.

DESCRIPTION
       set_mempolicy() sets the NUMA memory policy of the calling thread, which consists of a policy mode and zero or more
       nodes, to the values specified by the mode, nodemask and maxnode arguments.

       A NUMA machine has different memory controllers with different distances  to  specific  CPUs.   The  memory  policy
       defines from which node memory is allocated for the thread.

       This  system  call defines the default policy for the thread.  The thread policy governs allocation of pages in the
       process's address space outside of memory ranges controlled by a more specific policy set by mbind(2).  The  thread
       default policy also controls allocation of any pages for memory-mapped files mapped using the mmap(2) call with the
       MAP_PRIVATE flag and that are only read (loaded) from by the thread and of memory-mapped  files  mapped  using  the
       mmap(2)  call  with the MAP_SHARED flag, regardless of the access type.  The policy is applied only when a new page
       is allocated for the thread.  For anonymous memory this is when the page is first touched by the thread.

       The mode argument must specify one of  MPOL_DEFAULT,  MPOL_BIND,  MPOL_INTERLEAVE,  MPOL_PREFERRED,  or  MPOL_LOCAL
       (which  are  described  in  detail below).  All modes except MPOL_DEFAULT require the caller to specify the node or
       nodes to which the mode applies, via the nodemask argument.

       The mode argument may also include an optional mode flag.  The supported mode flags are:

       MPOL_F_STATIC_NODES (since Linux 2.6.26)
              A nonempty nodemask specifies physical node IDs.  Linux will not remap the nodemask when the  process  moves
              to  a  different  cpuset  context, nor when the set of nodes allowed by the process's current cpuset context
              changes.

       MPOL_F_RELATIVE_NODES (since Linux 2.6.26)
              A nonempty nodemask specifies node IDs that are relative to the set of node IDs  allowed  by  the  process's
              current cpuset.

       nodemask  points  to  a bit mask of node IDs that contains up to maxnode bits.  The bit mask size is rounded to the
       next multiple of sizeof(unsigned long), but the kernel will use bits only up to maxnode.  A NULL value of  nodemask
       or  a  maxnode value of zero specifies the empty set of nodes.  If the value of maxnode is zero, the nodemask argu‐
       ment is ignored.

       Where a nodemask is required, it must contain at least one node that is on-line, allowed by the  process's  current
       cpuset   context,  (unless  the  MPOL_F_STATIC_NODES  mode  flag  is  specified),  and  contains  memory.   If  the
       MPOL_F_STATIC_NODES is set in mode and a required nodemask contains no nodes that are allowed by the process's cur‐
       rent  cpuset context, the memory policy reverts to local allocation.  This effectively overrides the specified pol‐
       icy until the process's cpuset context includes one or more of the nodes specified by nodemask.

       The mode argument must include one of the following values:

       MPOL_DEFAULT
              This mode specifies that any nondefault thread memory policy be removed, so that the  memory  policy  "falls
              back"  to the system default policy.  The system default policy is "local allocation"—that is, allocate mem‐
              ory on the node of the CPU that triggered the allocation.  nodemask must  be  specified  as  NULL.   If  the
              "local node" contains no free memory, the system will attempt to allocate memory from a "near by" node.

       MPOL_BIND
              This  mode  defines a strict policy that restricts memory allocation to the nodes specified in nodemask.  If
              nodemask specifies more than one node, page allocations will come from the node with the lowest numeric node
              ID  first,  until that node contains no free memory.  Allocations will then come from the node with the next
              highest node ID specified in nodemask and so forth, until none of the specified nodes contain  free  memory.
              Pages will not be allocated from any node not specified in the nodemask.

       MPOL_INTERLEAVE
              This  mode  interleaves  page  allocations  across the nodes specified in nodemask in numeric node ID order.
              This optimizes for bandwidth instead of latency by spreading out pages and memory accesses  to  those  pages
              across  multiple nodes.  However, accesses to a single page will still be limited to the memory bandwidth of
              a single node.

       MPOL_PREFERRED
              This mode sets the preferred node for allocation.  The kernel will try to  allocate  pages  from  this  node
              first  and  fall back to "near by" nodes if the preferred node is low on free memory.  If nodemask specifies
              more than one node ID, the first node in the mask will be selected as the preferred node.  If  the  nodemask
              and  maxnode  arguments specify the empty set, then the policy specifies "local allocation" (like the system
              default policy discussed above).

       MPOL_LOCAL (since Linux 3.8)
              This mode specifies "local allocation"; the memory is allocated on the node of the CPU  that  triggered  the
              allocation  (the  "local  node").   The  nodemask  and maxnode arguments must specify the empty set.  If the
              "local node" is low on free memory, the kernel will try to allocate memory from  other  nodes.   The  kernel
              will  allocate memory from the "local node" whenever memory for this node is available.  If the "local node"
              is not allowed by the process's current cpuset context, the kernel will try to allocate  memory  from  other
              nodes.   The  kernel will allocate memory from the "local node" whenever it becomes allowed by the process's
              current cpuset context.

       The thread memory policy is preserved across an execve(2), and is inherited by child threads created using  fork(2)
       or clone(2).

RETURN VALUE
       On success, set_mempolicy() returns 0; on error, -1 is returned and errno is set to indicate the error.

ERRORS
       EFAULT Part  of  all  of  the memory range specified by nodemask and maxnode points outside your accessible address
              space.

       EINVAL mode is invalid.  Or, mode is MPOL_DEFAULT and nodemask is nonempty, or mode is MPOL_BIND or MPOL_INTERLEAVE
              and nodemask is empty.  Or, maxnode specifies more than a page worth of bits.  Or, nodemask specifies one or
              more node IDs that are greater than the maximum supported node ID.  Or, none of the node  IDs  specified  by
              nodemask  are  on-line  and  allowed by the process's current cpuset context, or none of the specified nodes
              contain memory.  Or, the mode argument specified both MPOL_F_STATIC_NODES and MPOL_F_RELATIVE_NODES.

       ENOMEM Insufficient kernel memory was available.

VERSIONS
       The set_mempolicy() system call was added to the Linux kernel in version 2.6.7.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       Memory policy is not remembered if the page is swapped out.  When such a page is paged back in,  it  will  use  the
       policy of the thread or memory range that is in effect at the time the page is allocated.

       For information on library support, see numa(7).

SEE ALSO
       get_mempolicy(2), getcpu(2), mbind(2), mmap(2), numa(3), cpuset(7), numa(7), numactl(8)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        SET_MEMPOLICY(2)
</pre>
<pre zoom>
<span xsmall>2 sched_setscheduler</span>
SCHED_SETSCHEDULER(2)                            Linux Programmer's Manual                           SCHED_SETSCHEDULER(2)

NAME
       sched_setscheduler, sched_getscheduler - set and get scheduling policy/parameters

SYNOPSIS
       #include <sched.h>

       int sched_setscheduler(pid_t pid, int policy,
                              const struct sched_param *param);

       int sched_getscheduler(pid_t pid);

DESCRIPTION
       The  sched_setscheduler()  system  call  sets  both the scheduling policy and parameters for the thread whose ID is
       specified in pid.  If pid equals zero, the scheduling policy and parameters of the calling thread will be set.

       The scheduling parameters are specified in the param argument, which is a pointer to a structure of  the  following
       form:

           struct sched_param {
               ...
               int sched_priority;
               ...
           };

       In  the current implementation, the structure contains only one field, sched_priority.  The interpretation of param
       depends on the selected policy.

       Currently, Linux supports the following "normal" (i.e., non-real-time) scheduling policies as values  that  may  be
       specified in policy:

       SCHED_OTHER   the standard round-robin time-sharing policy;

       SCHED_BATCH   for "batch" style execution of processes; and

       SCHED_IDLE    for running very low priority background jobs.

       For each of the above policies, param->sched_priority must be 0.

       Various  "real-time"  policies are also supported, for special time-critical applications that need precise control
       over the way in which runnable threads are selected for execution.  For the rules governing when a process may  use
       these policies, see sched(7).  The real-time policies that may be specified in policy are:

       SCHED_FIFO    a first-in, first-out policy; and

       SCHED_RR      a round-robin policy.

       For  each  of  the above policies, param->sched_priority specifies a scheduling priority for the thread.  This is a
       number in the range returned by calling sched_get_priority_min(2) and sched_get_priority_max(2) with the  specified
       policy.  On Linux, these system calls return, respectively, 1 and 99.

       Since  Linux  2.6.32,  the  SCHED_RESET_ON_FORK flag can be ORed in policy when calling sched_setscheduler().  As a
       result of including this flag, children created by fork(2) do not  inherit  privileged  scheduling  policies.   See
       sched(7) for details.

       sched_getscheduler()  returns  the  current scheduling policy of the thread identified by pid.  If pid equals zero,
       the policy of the calling thread will be retrieved.

RETURN VALUE
       On success, sched_setscheduler() returns zero.  On success, sched_getscheduler() returns the policy for the  thread
       (a nonnegative integer).  On error, both calls return -1, and errno is set appropriately.

ERRORS
       EINVAL Invalid arguments: pid is negative or param is NULL.

       EINVAL (sched_setscheduler()) policy is not one of the recognized policies.

       EINVAL (sched_setscheduler()) param does not make sense for the specified policy.

       EPERM  The calling thread does not have appropriate privileges.

       ESRCH  The thread whose ID is pid could not be found.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008 (but see BUGS below).  The SCHED_BATCH and SCHED_IDLE policies are Linux-specific.

NOTES
       Further  details  of the semantics of all of the above "normal" and "real-time" scheduling policies can be found in
       the sched(7) manual page.  That page also describes an additional policy, SCHED_DEADLINE, which  is  settable  only
       via sched_setattr(2).

       POSIX  systems on which sched_setscheduler() and sched_getscheduler() are available define _POSIX_PRIORITY_SCHEDUL‐
       ING in <unistd.h>.

       POSIX.1 does not detail the permissions that an unprivileged thread requires in order to call sched_setscheduler(),
       and details vary across systems.  For example, the Solaris 7 manual page says that the real or effective user ID of
       the caller must match the real user ID or the save set-user-ID of the target.

       The scheduling policy and parameters are in fact per-thread attributes on Linux.  The value returned from a call to
       gettid(2)  can  be  passed  in the argument pid.  Specifying pid as 0 will operate on the attributes of the calling
       thread, and passing the value returned from a call to getpid(2) will operate on the attributes of the  main  thread
       of the thread group.  (If you are using the POSIX threads API, then use pthread_setschedparam(3), pthread_getsched‐
       param(3), and pthread_setschedprio(3), instead of the sched_*(2) system calls.)

BUGS
       POSIX.1  says  that  on  success,  sched_setscheduler()  should  return  the  previous  scheduling  policy.   Linux
       sched_setscheduler() does not conform to this requirement, since it always returns 0 on success.

SEE ALSO
       chrt(1), nice(2), sched_get_priority_max(2), sched_get_priority_min(2), sched_getaffinity(2), sched_getattr(2),
       sched_getparam(2), sched_rr_get_interval(2), sched_setaffinity(2), sched_setattr(2), sched_setparam(2),
       sched_yield(2), setpriority(2), capabilities(7), cpuset(7), sched(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                   SCHED_SETSCHEDULER(2)
</pre>
<pre zoom>
<span xsmall>2 semget</span>
SEMGET(2)                                        Linux Programmer's Manual                                       SEMGET(2)

NAME
       semget - get a System V semaphore set identifier

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/sem.h>

       int semget(key_t key, int nsems, int semflg);

DESCRIPTION
       The semget() system call returns the System V semaphore set identifier associated with the argument key.  It may be
       used either to obtain the identifier of a previously created semaphore set (when semflg is zero and  key  does  not
       have the value IPC_PRIVATE), or to create a new set.

       A  new set of nsems semaphores is created if key has the value IPC_PRIVATE or if no existing semaphore set is asso‐
       ciated with key and IPC_CREAT is specified in semflg.

       If semflg specifies both IPC_CREAT and IPC_EXCL and a semaphore set already exists for  key,  then  semget()  fails
       with errno set to EEXIST.  (This is analogous to the effect of the combination O_CREAT | O_EXCL for open(2).)

       Upon  creation,  the  least  significant 9 bits of the argument semflg define the permissions (for owner, group and
       others) for the semaphore set.  These bits have the same format, and the same meaning,  as  the  mode  argument  of
       open(2) (though the execute permissions are not meaningful for semaphores, and write permissions mean permission to
       alter semaphore values).

       When creating a new semaphore set, semget() initializes the set's associated data  structure,  semid_ds  (see  sem‐
       ctl(2)), as follows:

              sem_perm.cuid and sem_perm.uid are set to the effective user ID of the calling process.

              sem_perm.cgid and sem_perm.gid are set to the effective group ID of the calling process.

              The least significant 9 bits of sem_perm.mode are set to the least significant 9 bits of semflg.

              sem_nsems is set to the value of nsems.

              sem_otime is set to 0.

              sem_ctime is set to the current time.

       The  argument  nsems  can  be 0 (a don't care) when a semaphore set is not being created.  Otherwise, nsems must be
       greater than 0 and less than or equal to the maximum number of semaphores per semaphore set (SEMMSL).

       If the semaphore set already exists, the permissions are verified.

RETURN VALUE
       If successful, the return value will be the semaphore set identifier (a  nonnegative  integer),  otherwise,  -1  is
       returned, with errno indicating the error.

ERRORS
       On failure, errno will be set to one of the following:

       EACCES A semaphore set exists for key, but the calling process does not have permission to access the set, and does
              not have the CAP_IPC_OWNER capability in the user namespace that governs its IPC namespace.

       EEXIST IPC_CREAT and IPC_EXCL were specified in semflg, but a semaphore set already exists for key.

       EINVAL nsems is less than 0 or greater than the limit on the number of semaphores per semaphore set (SEMMSL).

       EINVAL A semaphore set corresponding to key already exists, but nsems is larger than the number  of  semaphores  in
              that set.

       ENOENT No semaphore set exists for key and semflg did not specify IPC_CREAT.

       ENOMEM A semaphore set has to be created but the system does not have enough memory for the new data structure.

       ENOSPC A semaphore set has to be created but the system limit for the maximum number of semaphore sets (SEMMNI), or
              the system wide maximum number of semaphores (SEMMNS), would be exceeded.

CONFORMING TO
       SVr4, POSIX.1-2001.

NOTES
       The inclusion of <sys/types.h> and <sys/ipc.h> isn't required on Linux or by any version of POSIX.   However,  some
       old  implementations  required  the  inclusion of these header files, and the SVID also documented their inclusion.
       Applications intended to be portable to such old systems may need to include these header files.

       IPC_PRIVATE isn't a flag field but a key_t type.  If this special value is used for key, the  system  call  ignores
       all but the least significant 9 bits of semflg and creates a new semaphore set (on success).

   Semaphore initialization
       The values of the semaphores in a newly created set are indeterminate.  (POSIX.1-2001 and POSIX.1-2008 are explicit
       on this point, although POSIX.1-2008 notes that a future version of the standard may require an  implementation  to
       initialize the semaphores to 0.)  Although Linux, like many other implementations, initializes the semaphore values
       to 0, a portable application cannot rely on this: it should explicitly initialize the  semaphores  to  the  desired
       values.

       Initialization  can  be done using semctl(2) SETVAL or SETALL operation.  Where multiple peers do not know who will
       be the first to initialize the set, checking for a nonzero sem_otime in the associated data structure retrieved  by
       a semctl(2) IPC_STAT operation can be used to avoid races.

   Semaphore limits
       The following limits on semaphore set resources affect the semget() call:

       SEMMNI System-wide  limit on the number of semaphore sets.  On Linux systems before version 3.19, the default value
              for this limit was 128.  Since Linux 3.19, the default value is 32,000.  On Linux, this limit  can  be  read
              and modified via the fourth field of /proc/sys/kernel/sem.

       SEMMSL Maximum  number of semaphores per semaphore ID.  On Linux systems before version 3.19, the default value for
              this limit was 250.  Since Linux 3.19, the default value is 32,000.  On Linux, this limit can  be  read  and
              modified via the first field of /proc/sys/kernel/sem.

       SEMMNS System-wide  limit on the number of semaphores: policy dependent (on Linux, this limit can be read and modi‐
              fied via the second field of /proc/sys/kernel/sem).  Note that the number of semaphores system-wide is  also
              limited by the product of SEMMSL and SEMMNI.

BUGS
       The name choice IPC_PRIVATE was perhaps unfortunate, IPC_NEW would more clearly show its function.

SEE ALSO
       semctl(2), semop(2), ftok(3), capabilities(7), sem_overview(7), svipc(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                               SEMGET(2)
</pre>
<pre zoom>
<span xsmall>2 mq_notify</span>
MQ_NOTIFY(3)                                     Linux Programmer's Manual                                    MQ_NOTIFY(3)

NAME
       mq_notify - register for notification when a message is available

SYNOPSIS
       #include <mqueue.h>

       int mq_notify(mqd_t mqdes, const struct sigevent *sevp);

       Link with -lrt.

DESCRIPTION
       mq_notify()  allows the calling process to register or unregister for delivery of an asynchronous notification when
       a new message arrives on the empty message queue referred to by the message queue descriptor mqdes.

       The sevp argument is a pointer to a sigevent structure.  For the definition and general details of this  structure,
       see sigevent(7).

       If sevp is a non-null pointer, then mq_notify() registers the calling process to receive message notification.  The
       sigev_notify field of the sigevent structure to which sevp points specifies how notification is  to  be  performed.
       This field has one of the following values:

       SIGEV_NONE
              A  "null" notification: the calling process is registered as the target for notification, but when a message
              arrives, no notification is sent.

       SIGEV_SIGNAL
              Notify the process by sending the signal specified in sigev_signo.  See  sigevent(7)  for  general  details.
              The  si_code  field  of the siginfo_t structure will be set to SI_MESGQ.  In addition, si_pid will be set to
              the PID of the process that sent the message, and si_uid will be set to the real  user  ID  of  the  sending
              process.

       SIGEV_THREAD
              Upon  message  delivery, invoke sigev_notify_function as if it were the start function of a new thread.  See
              sigevent(7) for details.

       Only one process can be registered to receive notification from a message queue.

       If sevp is NULL, and the calling process is currently registered to receive notifications for this  message  queue,
       then  the  registration  is  removed;  another process can then register to receive a message notification for this
       queue.

       Message notification occurs only when a new message arrives and the queue was previously empty.  If the  queue  was
       not  empty at the time mq_notify() was called, then a notification will occur only after the queue is emptied and a
       new message arrives.

       If another process or thread is waiting to read a message from an empty queue using mq_receive(3), then any message
       notification  registration is ignored: the message is delivered to the process or thread calling mq_receive(3), and
       the message notification registration remains in effect.

       Notification occurs once: after a notification is delivered, the notification registration is removed, and  another
       process can register for message notification.  If the notified process wishes to receive the next notification, it
       can use mq_notify() to request a further notification.  This should be done before  emptying  all  unread  messages
       from the queue.  (Placing the queue in nonblocking mode is useful for emptying the queue of messages without block‐
       ing once it is empty.)

RETURN VALUE
       On success mq_notify() returns 0; on error, -1 is returned, with errno set to indicate the error.

ERRORS
       EBADF  The message queue descriptor specified in mqdes is invalid.

       EBUSY  Another process has already registered to receive notification for this message queue.

       EINVAL sevp->sigev_notify  is  not  one  of  the  permitted  values;  or  sevp->sigev_notify  is  SIGEV_SIGNAL  and
              sevp->sigev_signo is not a valid signal number.

       ENOMEM Insufficient memory.

       POSIX.1-2008  says  that an implementation may generate an EINVAL error if sevp is NULL, and the caller is not cur‐
       rently registered to receive notifications for the queue mqdes.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌────────────┬───────────────┬─────────┐
       │Interface   │ Attribute     │ Value   │
       ├────────────┼───────────────┼─────────┤
       │mq_notify() │ Thread safety │ MT-Safe │
       └────────────┴───────────────┴─────────┘

CONFORMING TO
       POSIX.1-2001.

NOTES
   C library/kernel differences
       In the glibc implementation, the mq_notify() library function is implemented on top of the system call of the  same
       name.   When  sevp  is  NULL,  or  specifies a notification mechanism other than SIGEV_THREAD, the library function
       directly invokes the system call.  For SIGEV_THREAD, much of the implementation resides within the library,  rather
       than  the kernel.  (This is necessarily so, since the thread involved in handling the notification is one that must
       be managed by the C library POSIX threads implementation.)  The implementation involves the use of a raw netlink(7)
       socket and creates a new thread for each notification that is delivered to the process.

EXAMPLE
       The  following  program  registers a notification request for the message queue named in its command-line argument.
       Notification is performed by creating a thread.  The thread executes a function which reads one  message  from  the
       queue and then terminates the process.

   Program source
       #include <pthread.h>
       #include <mqueue.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>

       #define handle_error(msg) \
           do { perror(msg); exit(EXIT_FAILURE); } while (0)

       static void                     /* Thread start function */
       tfunc(union sigval sv)
       {
           struct mq_attr attr;
           ssize_t nr;
           void *buf;
           mqd_t mqdes = *((mqd_t *) sv.sival_ptr);

           /* Determine max. msg size; allocate buffer to receive msg */

           if (mq_getattr(mqdes, &attr) == -1)
               handle_error("mq_getattr");
           buf = malloc(attr.mq_msgsize);
           if (buf == NULL)
               handle_error("malloc");

           nr = mq_receive(mqdes, buf, attr.mq_msgsize, NULL);
           if (nr == -1)
               handle_error("mq_receive");

           printf("Read %zd bytes from MQ\n", nr);
           free(buf);
           exit(EXIT_SUCCESS);         /* Terminate the process */
       }

       int
       main(int argc, char *argv[])
       {
           mqd_t mqdes;
           struct sigevent sev;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <mq-name>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           mqdes = mq_open(argv[1], O_RDONLY);
           if (mqdes == (mqd_t) -1)
               handle_error("mq_open");

           sev.sigev_notify = SIGEV_THREAD;
           sev.sigev_notify_function = tfunc;
           sev.sigev_notify_attributes = NULL;
           sev.sigev_value.sival_ptr = &mqdes;   /* Arg. to thread func. */
           if (mq_notify(mqdes, &sev) == -1)
               handle_error("mq_notify");

           pause();    /* Process will be terminated by thread function */
       }

SEE ALSO
       mq_close(3), mq_getattr(3), mq_open(3), mq_receive(3), mq_send(3), mq_unlink(3), mq_overview(7), sigevent(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            MQ_NOTIFY(3)
</pre>
<pre zoom>
<span xsmall>2 get_mempolicy</span>
GET_MEMPOLICY(2)                                 Linux Programmer's Manual                                GET_MEMPOLICY(2)

NAME
       get_mempolicy - retrieve NUMA memory policy for a thread

SYNOPSIS
       #include <numaif.h>

       long get_mempolicy(int *mode, unsigned long *nodemask,
                         unsigned long maxnode, void *addr,
                         unsigned long flags);

       Link with -lnuma.

DESCRIPTION
       get_mempolicy() retrieves the NUMA policy of the calling thread or of a memory address, depending on the setting of
       flags.

       A NUMA machine has different memory controllers with different distances  to  specific  CPUs.   The  memory  policy
       defines from which node memory is allocated for the thread.

       If flags is specified as 0, then information about the calling thread's default policy (as set by set_mempolicy(2))
       is returned, in the buffers pointed to by mode and nodemask.  The value returned in these arguments may be used  to
       restore  the  thread's policy to its state at the time of the call to get_mempolicy() using set_mempolicy(2).  When
       flags is 0, addr must be specified as NULL.

       If flags specifies MPOL_F_MEMS_ALLOWED (available since Linux 2.6.24), the mode argument is ignored and the set  of
       nodes  (memories) that the thread is allowed to specify in subsequent calls to mbind(2) or set_mempolicy(2) (in the
       absence of any mode flags) is returned in nodemask.  It is not permitted to combine MPOL_F_MEMS_ALLOWED with either
       MPOL_F_ADDR or MPOL_F_NODE.

       If flags specifies MPOL_F_ADDR, then information is returned about the policy governing the memory address given in
       addr.  This policy may be different from the thread's default policy if mbind(2) or one  of  the  helper  functions
       described in numa(3) has been used to establish a policy for the memory range containing addr.

       If  the  mode  argument is not NULL, then get_mempolicy() will store the policy mode and any optional mode flags of
       the requested NUMA policy in the location pointed to by this argument.  If nodemask is not NULL, then the  nodemask
       associated  with the policy will be stored in the location pointed to by this argument.  maxnode specifies the num‐
       ber of node IDs that can be stored into nodemask—that is, the maximum node ID plus one.   The  value  specified  by
       maxnode is always rounded to a multiple of sizeof(unsigned long)*8.

       If  flags  specifies both MPOL_F_NODE and MPOL_F_ADDR, get_mempolicy() will return the node ID of the node on which
       the address addr is allocated into the location pointed to by mode.  If no page has  yet  been  allocated  for  the
       specified address, get_mempolicy() will allocate a page as if the thread had performed a read (load) access to that
       address, and return the ID of the node where that page was allocated.

       If flags specifies MPOL_F_NODE, but not MPOL_F_ADDR, and the  thread's  current  policy  is  MPOL_INTERLEAVE,  then
       get_mempolicy()  will  return  in the location pointed to by a non-NULL mode argument, the node ID of the next node
       that will be used for interleaving of internal kernel pages allocated on behalf of the thread.   These  allocations
       include  pages  for memory-mapped files in process memory ranges mapped using the mmap(2) call with the MAP_PRIVATE
       flag for read accesses, and in memory ranges mapped with the MAP_SHARED flag for all accesses.

       Other flag values are reserved.

       For an overview of the possible policies see set_mempolicy(2).

RETURN VALUE
       On success, get_mempolicy() returns 0; on error, -1 is returned and errno is set to indicate the error.

ERRORS
       EFAULT Part of all of the memory range specified by nodemask and maxnode points  outside  your  accessible  address
              space.

       EINVAL The value specified by maxnode is less than the number of node IDs supported by the system.  Or flags speci‐
              fied values other than MPOL_F_NODE or MPOL_F_ADDR; or flags specified MPOL_F_ADDR and addr is NULL, or flags
              did  not  specify MPOL_F_ADDR and addr is not NULL.  Or, flags specified MPOL_F_NODE but not MPOL_F_ADDR and
              the current thread policy is not MPOL_INTERLEAVE.   Or,  flags  specified  MPOL_F_MEMS_ALLOWED  with  either
              MPOL_F_ADDR or MPOL_F_NODE.  (And there are other EINVAL cases.)

VERSIONS
       The get_mempolicy() system call was added to the Linux kernel in version 2.6.7.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       For information on library support, see numa(7).

SEE ALSO
       getcpu(2), mbind(2), mmap(2), set_mempolicy(2), numa(3), numa(7), numactl(8)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        GET_MEMPOLICY(2)
</pre>
<pre zoom>
<span xsmall>2 setup</span>
SETUP(2)                                         Linux Programmer's Manual                                        SETUP(2)

NAME
       setup - setup devices and filesystems, mount root filesystem

SYNOPSIS
       #include <unistd.h>

       int setup(void);

DESCRIPTION
       setup()  is  called once from within linux/init/main.c.  It calls initialization functions for devices and filesys‐
       tems configured into the kernel and then mounts the root filesystem.

       No user process may call setup().  Any user process, even a process with superuser permission, will receive EPERM.

RETURN VALUE
       setup() always returns -1 for a user process.

ERRORS
       EPERM  Always, for a user process.

VERSIONS
       Since Linux 2.1.121, no such function exists anymore.

CONFORMING TO
       This function is Linux-specific, and should not be used in programs intended to be portable, or indeed in any  pro‐
       grams at all.

NOTES
       The calling sequence varied: at some times setup() has had a single argument void *BIOS and at other times a single
       argument int magic.

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2008-12-03                                                SETUP(2)
</pre>
<pre zoom>
<span xsmall>2 newfstatat</span>
STAT(2)                                          Linux Programmer's Manual                                         STAT(2)

NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       int fstat(int fd, struct stat *statbuf);
       int lstat(const char *pathname, struct stat *statbuf);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
                   int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       lstat():
           /* glibc 2.19 and earlier */ _BSD_SOURCE
               || /* Since glibc 2.20 */ _DEFAULT_SOURCE
               || _XOPEN_SOURCE >= 500
               || /* Since glibc 2.10: */ _POSIX_C_SOURCE >= 200112L

       fstatat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  functions return information about a file, in the buffer pointed to by statbuf.  No permissions are required
       on the file itself, but—in the case of stat(), fstatat(), and lstat()—execute (search) permission  is  required  on
       all of the directories in pathname that lead to the file.

       stat()  and fstatat() retrieve information about the file pointed to by pathname; the differences for fstatat() are
       described below.

       lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information  about  the
       link itself, not the file that it refers to.

       fstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the
       file descriptor fd.

   The stat structure
       All of these system calls return a stat structure, which contains the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

       Note: the order of fields in the stat structure varies somewhat across architectures.  In addition, the  definition
       above  does  not  show the padding bytes that may be present between some fields on various architectures.  Consult
       the glibc and kernel source code if you need to know the details.

       Note: for performance and simplicity reasons, different fields in the stat structure may contain state  information
       from  different  moments  during the execution of the system call.  For example, if st_mode or st_uid is changed by
       another process by calling chmod(2) or chown(2), stat() might return the old st_mode together with the new  st_uid,
       or the old st_uid together with the new st_mode.

       The fields in the stat structure are as follows:

       st_dev This field describes the device on which this file resides.  (The major(3) and minor(3) macros may be useful
              to decompose the device ID in this field.)

       st_ino This field contains the file's inode number.

       st_mode
              This field contains the file type and mode.  See inode(7) for further information.

       st_nlink
              This field contains the number of hard links to the file.

       st_uid This field contains the user ID of the owner of the file.

       st_gid This field contains the ID of the group owner of the file.

       st_rdev
              This field describes the device that this file (inode) represents.

       st_size
              This field gives the size of the file (if it is a regular file or a symbolic link) in bytes.  The size of  a
              symbolic link is the length of the pathname it contains, without a terminating null byte.

       st_blksize
              This field gives the "preferred" block size for efficient filesystem I/O.

       st_blocks
              This  field  indicates  the number of blocks allocated to the file, in 512-byte units.  (This may be smaller
              than st_size/512 when the file has holes.)

       st_atime
              This is the file's last access timestamp.

       st_mtime
              This is the file's last modification timestamp.

       st_ctime
              This is the file's last status change timestamp.

       For further information on the above fields, see inode(7).

   fstatat()
       The fstatat() system call is a more general interface for  accessing  file  information  which  can  still  provide
       exactly the behavior of each of stat(), lstat(), and fstat().

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       stat() and lstat() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like stat() and lstat()).

       If pathname is absolute, then dirfd is ignored.

       flags can either be 0, or include one or more of the following flags ORed:

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2) O_PATH flag).  In this case, dirfd can refer to any type of file, not just a directory, and the
              behavior of fstatat() is similar to that of fstat().  If dirfd is AT_FDCWD, the call operates on the current
              working directory.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.

       AT_NO_AUTOMOUNT (since Linux 2.6.38)
              Don't  automount  the  terminal ("basename") component of pathname if it is a directory that is an automount
              point.  This allows the caller to gather attributes of an automount point (rather than the location it would
              mount).   Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand directory such as used
              for automounter indirect maps.  This flag can be used in tools that scan directories to  prevent  mass-auto‐
              mounting  of a directory of automount points.  The AT_NO_AUTOMOUNT flag has no effect if the mount point has
              already been mounted over.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.   Both
              stat() and lstat() act as though AT_NO_AUTOMOUNT was set.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a  symbolic link, do not dereference it: instead return information about the link itself,
              like lstat().  (By default, fstatat() dereferences symbolic links, like stat().)

       See openat(2) for an explanation of the need for fstatat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Search permission is denied for one of the directories in the path prefix of pathname.  (See also path_reso‐
              lution(7).)

       EBADF  fd is not a valid open file descriptor.

       EFAULT Bad address.

       ELOOP  Too many symbolic links encountered while traversing the path.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A  component  of pathname does not exist, or pathname is an empty string and AT_EMPTY_PATH was not specified
              in flags.

       ENOMEM Out of memory (i.e., kernel memory).

       ENOTDIR
              A component of the path prefix of pathname is not a directory.

       EOVERFLOW
              pathname or fd refers to a file whose size, inode number, or number of  blocks  cannot  be  represented  in,
              respectively,  the  types off_t, ino_t, or blkcnt_t.  This error can occur when, for example, an application
              compiled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 calls stat()  on  a  file  whose  size  exceeds
              (1<<31)-1 bytes.

       The following additional errors can occur for fstatat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fstatat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       stat(), fstat(), lstat(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.

       fstatat(): POSIX.1-2008.

       According  to  POSIX.1-2001, lstat() on a symbolic link need return valid information only in the st_size field and
       the file type of the st_mode field of the stat  structure.   POSIX.1-2008  tightens  the  specification,  requiring
       lstat() to return valid information in all fields except the mode bits in st_mode.

       Use of the st_blocks and st_blksize fields may be less portable.  (They were introduced in BSD.  The interpretation
       differs between systems, and possibly on a single system when NFS mounts are involved.)

NOTES
   Timestamp fields
       Older kernels and older standards did not support nanosecond timestamp fields.  Instead, there were three timestamp
       fields—st_atime, st_mtime, and st_ctime—typed as time_t that recorded timestamps with one-second precision.

       Since  kernel  2.5.48,  the stat structure supports nanosecond resolution for the three file timestamp fields.  The
       nanosecond components of each timestamp are available via names of the form st_atim.tv_nsec,  if  suitable  feature
       test macros are defined.  Nanosecond timestamps were standardized in POSIX.1-2008, and, starting with version 2.12,
       glibc exposes the nanosecond component names if _POSIX_C_SOURCE is defined with the value 200809L  or  greater,  or
       _XOPEN_SOURCE  is  defined  with  the value 700 or greater.  Up to and including glibc 2.19, the definitions of the
       nanoseconds components are also defined if _BSD_SOURCE or _SVID_SOURCE is defined.  If none of  the  aforementioned
       macros are defined, then the nanosecond values are exposed with names of the form st_atimensec.

   C library/kernel differences
       Over  time, increases in the size of the stat structure have led to three successive versions of stat(): sys_stat()
       (slot __NR_oldstat), sys_newstat() (slot __NR_stat), and sys_stat64() (slot __NR_stat64) on 32-bit  platforms  such
       as  i386.   The  first  two  versions were already present in Linux 1.0 (albeit with different names); the last was
       added in Linux 2.4.  Similar remarks apply for fstat() and lstat().

       The kernel-internal versions of the stat structure dealt with by the different versions are, respectively:

       __old_kernel_stat
              The original structure, with rather narrow fields, and no padding.

       stat   Larger st_ino field and padding added to various parts of the structure to allow for future expansion.

       stat64 Even larger st_ino field, larger st_uid and st_gid fields to accommodate the Linux-2.4 expansion of UIDs and
              GIDs  to  32 bits, and various other enlarged fields and further padding in the structure.  (Various padding
              bytes were eventually consumed in Linux 2.6, with the advent of 32-bit device IDs and nanosecond  components
              for the timestamp fields.)

       The  glibc  stat()  wrapper function hides these details from applications, invoking the most recent version of the
       system call provided by the kernel, and repacking the returned information if required for old binaries.

       On modern 64-bit systems, life is simpler: there is a single stat() system call and the kernel deals  with  a  stat
       structure that contains fields of a sufficient size.

       The  underlying  system call employed by the glibc fstatat() wrapper function is actually called fstatat64() or, on
       some architectures, newfstatat().

EXAMPLE
       The following program calls lstat() and displays selected fields in the returned stat structure.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/sysmacros.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           printf("ID of containing device:  [%lx,%lx]\n",
                (long) major(sb.st_dev), (long) minor(sb.st_dev));

           printf("File type:                ");

           switch (sb.st_mode & S_IFMT) {
           case S_IFBLK:  printf("block device\n");            break;
           case S_IFCHR:  printf("character device\n");        break;
           case S_IFDIR:  printf("directory\n");               break;
           case S_IFIFO:  printf("FIFO/pipe\n");               break;
           case S_IFLNK:  printf("symlink\n");                 break;
           case S_IFREG:  printf("regular file\n");            break;
           case S_IFSOCK: printf("socket\n");                  break;
           default:       printf("unknown?\n");                break;
           }

           printf("I-node number:            %ld\n", (long) sb.st_ino);

           printf("Mode:                     %lo (octal)\n",
                   (unsigned long) sb.st_mode);

           printf("Link count:               %ld\n", (long) sb.st_nlink);
           printf("Ownership:                UID=%ld   GID=%ld\n",
                   (long) sb.st_uid, (long) sb.st_gid);

           printf("Preferred I/O block size: %ld bytes\n",
                   (long) sb.st_blksize);
           printf("File size:                %lld bytes\n",
                   (long long) sb.st_size);
           printf("Blocks allocated:         %lld\n",
                   (long long) sb.st_blocks);

           printf("Last status change:       %s", ctime(&sb.st_ctime));
           printf("Last file access:         %s", ctime(&sb.st_atime));
           printf("Last file modification:   %s", ctime(&sb.st_mtime));

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ls(1), stat(1), access(2), chmod(2), chown(2), readlink(2), utime(2), capabilities(7), inode(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 STAT(2)
</pre>
<pre zoom>
<span xsmall>2 symlinkat</span>
SYMLINK(2)                                       Linux Programmer's Manual                                      SYMLINK(2)

NAME
       symlink, symlinkat - make a new name for a file

SYNOPSIS
       #include <unistd.h>

       int symlink(const char *target, const char *linkpath);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <unistd.h>

       int symlinkat(const char *target, int newdirfd, const char *linkpath);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       symlink():
           _XOPEN_SOURCE >= 500 || _POSIX_C_SOURCE >= 200112L
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

       symlinkat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       symlink() creates a symbolic link named linkpath which contains the string target.

       Symbolic  links are interpreted at run time as if the contents of the link had been substituted into the path being
       followed to find a file or directory.

       Symbolic links may contain ..  path components, which (if used at the start of the link) refer to the parent direc‐
       tories of that in which the link resides.

       A  symbolic link (also known as a soft link) may point to an existing file or to a nonexistent one; the latter case
       is known as a dangling link.

       The permissions of a symbolic link are irrelevant; the ownership is ignored when following the link, but is checked
       when removal or renaming of the link is requested and the link is in a directory with the sticky bit (S_ISVTX) set.

       If linkpath exists, it will not be overwritten.

   symlinkat()
       The  symlinkat()  system  call  operates in exactly the same way as symlink(), except for the differences described
       here.

       If the pathname given in linkpath is relative, then it is interpreted relative to the directory referred to by  the
       file  descriptor newdirfd (rather than relative to the current working directory of the calling process, as is done
       by symlink() for a relative pathname).

       If linkpath is relative and newdirfd is the special value AT_FDCWD, then linkpath is interpreted  relative  to  the
       current working directory of the calling process (like symlink()).

       If linkpath is absolute, then newdirfd is ignored.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Write access to the directory containing linkpath is denied, or one of the directories in the path prefix of
              linkpath did not allow search permission.  (See also path_resolution(7).)

       EDQUOT The user's quota of resources on the filesystem has been exhausted.  The resources could be inodes  or  disk
              blocks, depending on the filesystem implementation.

       EEXIST linkpath already exists.

       EFAULT target or linkpath points outside your accessible address space.

       EIO    An I/O error occurred.

       ELOOP  Too many symbolic links were encountered in resolving linkpath.

       ENAMETOOLONG
              target or linkpath was too long.

       ENOENT A directory component in linkpath does not exist or is a dangling symbolic link, or target or linkpath is an
              empty string.

       ENOMEM Insufficient kernel memory was available.

       ENOSPC The device containing the file has no room for the new directory entry.

       ENOTDIR
              A component used as a directory in linkpath is not, in fact, a directory.

       EPERM  The filesystem containing linkpath does not support the creation of symbolic links.

       EROFS  linkpath is on a read-only filesystem.

       The following additional errors can occur for symlinkat():

       EBADF  newdirfd is not a valid file descriptor.

       ENOENT linkpath is a relative pathname and newdirfd refers to a directory that has been deleted.

       ENOTDIR
              linkpath is relative and newdirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       symlinkat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       symlink(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       symlinkat(): POSIX.1-2008.

NOTES
       No checking of target is done.

       Deleting the name referred to by a symbolic link will actually delete the file  (unless  it  also  has  other  hard
       links).  If this behavior is not desired, use link(2).

   Glibc notes
       On  older  kernels where symlinkat() is unavailable, the glibc wrapper function falls back to the use of symlink().
       When linkpath is a relative pathname, glibc constructs a pathname based on the symbolic link in /proc/self/fd  that
       corresponds to the newdirfd argument.

SEE ALSO
       ln(1), namei(1), lchown(2), link(2), lstat(2), open(2), readlink(2), rename(2), unlink(2), path_resolution(7), sym‐
       link(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              SYMLINK(2)
</pre>
<pre zoom>
<span xsmall>2 inb_p</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 ioctl_getfsmap</span>
IOCTL_GETFSMAP(2)                                Linux Programmer's Manual                               IOCTL_GETFSMAP(2)

NAME
       ioctl_getfsmap - retrieve the physical layout of the filesystem

SYNOPSIS
       #include <sys/ioctl.h>
       #include <linux/fs.h>
       #include <linux/fsmap.h>

       int ioctl(int fd, FS_IOC_GETFSMAP, struct fsmap_head * arg);

DESCRIPTION
       This  ioctl(2) operation retrieves physical extent mappings for a filesystem.  This information can be used to dis‐
       cover which files are mapped to a physical block, examine free space, or find known bad blocks, among other things.

       The sole argument to this operation should be a pointer to a single struct fsmap_head:

           struct fsmap {
               __u32 fmr_device;      /* Device ID */
               __u32 fmr_flags;       /* Mapping flags */
               __u64 fmr_physical;    /* Device offset of segment */
               __u64 fmr_owner;       /* Owner ID */
               __u64 fmr_offset;      /* File offset of segment */
               __u64 fmr_length;      /* Length of segment */
               __u64 fmr_reserved[3]; /* Must be zero */
           };

           struct fsmap_head {
               __u32 fmh_iflags;       /* Control flags */
               __u32 fmh_oflags;       /* Output flags */
               __u32 fmh_count;        /* # of entries in array incl. input */
               __u32 fmh_entries;      /* # of entries filled in (output) */
               __u64 fmh_reserved[6];  /* Must be zero */

               struct fsmap fmh_keys[2];  /* Low and high keys for
                                             the mapping search */
               struct fsmap fmh_recs[];   /* Returned records */
           };

       The two fmh_keys array elements specify the lowest and highest reverse-mapping key for which the application  would
       like  physical  mapping  information.   A reverse mapping key consists of the tuple (device, block, owner, offset).
       The owner and offset fields are part of the key because some filesystems support sharing  physical  blocks  between
       multiple files and therefore may return multiple mappings for a given physical block.

       Filesystem mappings are copied into the fmh_recs array, which immediately follows the header data.

   Fields of struct fsmap_head
       The  fmh_iflags  field  is a bit mask passed to the kernel to alter the output.  No flags are currently defined, so
       the caller must set this value to zero.

       The fmh_oflags field is a bit mask of flags set by the kernel concerning the returned mappings.  If FMH_OF_DEV_T is
       set,  then  the  fmr_device  field represents a dev_t structure containing the major and minor numbers of the block
       device.

       The fmh_count field contains the number of elements in the array being passed to the kernel.  If this value  is  0,
       fmh_entries  will be set to the number of records that would have been returned had the array been large enough; no
       mapping information will be returned.

       The fmh_entries field contains the number of elements in the fmh_recs array that contain useful information.

       The fmh_reserved fields must be set to zero.

   Keys
       The two key records in fsmap_head.fmh_keys specify the lowest and highest extent records in the keyspace  that  the
       caller  wants returned.  A filesystem that can share blocks between files likely requires the tuple (device, physi‐
       cal, owner, offset, flags) to uniquely index any filesystem mapping record.  Classic non-sharing filesystems  might
       be  able  to  identify any record with only (device, physical, flags).  For example, if the low key is set to (8:0,
       36864, 0, 0, 0), the filesystem will only return records for extents starting at or above 36 KiB on disk.   If  the
       high key is set to (8:0, 1048576, 0, 0, 0), only records below 1 MiB will be returned.  The format of fmr_device in
       the keys must match the format of the same field in the output records, as defined below.  By convention, the field
       fsmap_head.fmh_keys[0]  must  contain  the  low  key  and  fsmap_head.fmh_keys[1] must contain the high key for the
       request.

       For convenience, if fmr_length is set in the low key, it will be added to fmr_block or fmr_offset  as  appropriate.
       The    caller    can    take   advantage   of   this   subtlety   to   set   up   subsequent   calls   by   copying
       fsmap_head.fmh_recs[fsmap_head.fmh_entries -  1]  into  the  low  key.   The  function  fsmap_advance  (defined  in
       linux/fsmap.h) provides this functionality.

   Fields of struct fsmap
       The  fmr_device  field  uniquely  identifies the underlying storage device.  If the FMH_OF_DEV_T flag is set in the
       header's fmh_oflags field, this field contains a dev_t from which major and minor numbers can be extracted.  If the
       flag is not set, this field contains a value that must be unique for each unique storage device.

       The fmr_physical field contains the disk address of the extent in bytes.

       The  fmr_owner  field contains the owner of the extent.  This is an inode number unless FMR_OF_SPECIAL_OWNER is set
       in the fmr_flags field, in which case the value is determined by the filesystem.  See the section below about owner
       values for more details.

       The fmr_offset field contains the logical address in the mapping record in bytes.  This field has no meaning if the
       FMR_OF_SPECIAL_OWNER or FMR_OF_EXTENT_MAP flags are set in fmr_flags.

       The fmr_length field contains the length of the extent in bytes.

       The fmr_flags field is a bit mask of extent state flags.  The bits are:

           FMR_OF_PREALLOC
                  The extent is allocated but not yet written.

           FMR_OF_ATTR_FORK
                  This extent contains extended attribute data.

           FMR_OF_EXTENT_MAP
                  This extent contains extent map information for the owner.

           FMR_OF_SHARED
                  Parts of this extent may be shared.

           FMR_OF_SPECIAL_OWNER
                  The fmr_owner field contains a special value instead of an inode number.

           FMR_OF_LAST
                  This is the last record in the data set.

       The fmr_reserved field will be set to zero.

   Owner values
       Generally, the value of the fmr_owner field for non-metadata extents should be an inode number.  However,  filesys‐
       tems  are  under no obligation to report inode numbers; they may instead report FMR_OWN_UNKNOWN if the inode number
       cannot easily be retrieved, if the caller lacks sufficient privilege, if the filesystem  does  not  support  stable
       inode  numbers,  or for any other reason.  If a filesystem wishes to condition the reporting of inode numbers based
       on process capabilities, it is strongly urged that the CAP_SYS_ADMIN capability be used for this purpose.

       The following special owner values are generic to all filesystems:

           FMR_OWN_FREE
                  Free space.

           FMR_OWN_UNKNOWN
                  This extent is in use but its owner is not known or not easily retrieved.

           FMR_OWN_METADATA
                  This extent is filesystem metadata.

       XFS can return the following special owner values:

           XFS_FMR_OWN_FREE
                  Free space.

           XFS_FMR_OWN_UNKNOWN
                  This extent is in use but its owner is not known or not easily retrieved.

           XFS_FMR_OWN_FS
                  Static filesystem metadata which exists at a fixed address.  These are the AG superblock, the  AGF,  the
                  AGFL, and the AGI headers.

           XFS_FMR_OWN_LOG
                  The filesystem journal.

           XFS_FMR_OWN_AG
                  Allocation group metadata, such as the free space btrees and the reverse mapping btrees.

           XFS_FMR_OWN_INOBT
                  The inode and free inode btrees.

           XFS_FMR_OWN_INODES
                  Inode records.

           XFS_FMR_OWN_REFC
                  Reference count information.

           XFS_FMR_OWN_COW
                  This extent is being used to stage a copy-on-write.

           XFS_FMR_OWN_DEFECTIVE:
                  This extent has been marked defective either by the filesystem or the underlying device.

       ext4 can return the following special owner values:

           EXT4_FMR_OWN_FREE
                  Free space.

           EXT4_FMR_OWN_UNKNOWN
                  This extent is in use but its owner is not known or not easily retrieved.

           EXT4_FMR_OWN_FS
                  Static  filesystem  metadata  which  exists  at  a  fixed address.  This is the superblock and the group
                  descriptors.

           EXT4_FMR_OWN_LOG
                  The filesystem journal.

           EXT4_FMR_OWN_INODES
                  Inode records.

           EXT4_FMR_OWN_BLKBM
                  Block bit map.

           EXT4_FMR_OWN_INOBM
                  Inode bit map.

RETURN VALUE
       On error, -1 is returned, and errno is set to indicate the error.

ERRORS
       The error placed in errno can be one of, but is not limited to, the following:

       EBADF  fd is not open for reading.

       EBADMSG
              The filesystem has detected a checksum error in the metadata.

       EFAULT The pointer passed in was not mapped to a valid memory address.

       EINVAL The array is not long enough, the keys do not point to a valid part of the filesystem, the low key points to
              a  higher point in the filesystem's physical storage address space than the high key, or a nonzero value was
              passed in one of the fields that must be zero.

       ENOMEM Insufficient memory to process the request.

       EOPNOTSUPP
              The filesystem does not support this command.

       EUCLEAN
              The filesystem metadata is corrupt and needs repair.

VERSIONS
       The FS_IOC_GETFSMAP operation first appeared in Linux 4.12.

CONFORMING TO
       This API is Linux-specific.  Not all filesystems support it.

EXAMPLE
       See io/fsmap.c in the xfsprogs distribution for a sample program.

SEE ALSO
       ioctl(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                       IOCTL_GETFSMAP(2)
</pre>
<pre zoom>
<span xsmall>2 break</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 ptrace</span>
PTRACE(2)                                        Linux Programmer's Manual                                       PTRACE(2)

NAME
       ptrace - process trace

SYNOPSIS
       #include <sys/ptrace.h>

       long ptrace(enum __ptrace_request request, pid_t pid,
                   void *addr, void *data);

DESCRIPTION
       The ptrace() system call provides a means by which one process (the "tracer") may observe and control the execution
       of another process (the "tracee"), and examine and change the tracee's memory and registers.  It is primarily  used
       to implement breakpoint debugging and system call tracing.

       A  tracee first needs to be attached to the tracer.  Attachment and subsequent commands are per thread: in a multi‐
       threaded process, every thread can be individually attached to  a  (potentially  different)  tracer,  or  left  not
       attached and thus not debugged.  Therefore, "tracee" always means "(one) thread", never "a (possibly multithreaded)
       process".  Ptrace commands are always sent to a specific tracee using a call of the form

           ptrace(PTRACE_foo, pid, ...)

       where pid is the thread ID of the corresponding Linux thread.

       (Note that in this page, a "multithreaded process" means a thread group consisting of  threads  created  using  the
       clone(2) CLONE_THREAD flag.)

       A  process  can  initiate  a  trace by calling fork(2) and having the resulting child do a PTRACE_TRACEME, followed
       (typically) by an execve(2).  Alternatively, one process may commence tracing another process  using  PTRACE_ATTACH
       or PTRACE_SEIZE.

       While being traced, the tracee will stop each time a signal is delivered, even if the signal is being ignored.  (An
       exception is SIGKILL, which has its usual effect.)  The tracer will be notified at its next call to waitpid(2)  (or
       one of the related "wait" system calls); that call will return a status value containing information that indicates
       the cause of the stop in the tracee.  While the tracee is stopped, the tracer can use various  ptrace  requests  to
       inspect  and  modify  the tracee.  The tracer then causes the tracee to continue, optionally ignoring the delivered
       signal (or even delivering a different signal instead).

       If the PTRACE_O_TRACEEXEC option is not in effect, all successful calls to execve(2) by  the  traced  process  will
       cause it to be sent a SIGTRAP signal, giving the parent a chance to gain control before the new program begins exe‐
       cution.

       When the tracer is finished tracing, it can cause the tracee to continue executing in a normal, untraced  mode  via
       PTRACE_DETACH.

       The value of request determines the action to be performed:

       PTRACE_TRACEME
              Indicate that this process is to be traced by its parent.  A process probably shouldn't make this request if
              its parent isn't expecting to trace it.  (pid, addr, and data are ignored.)

              The PTRACE_TRACEME request is used only by the tracee; the remaining requests are used only by  the  tracer.
              In  the  following  requests,  pid specifies the thread ID of the tracee to be acted on.  For requests other
              than PTRACE_ATTACH, PTRACE_SEIZE, PTRACE_INTERRUPT, and PTRACE_KILL, the tracee must be stopped.

       PTRACE_PEEKTEXT, PTRACE_PEEKDATA
              Read a word at the address addr in the tracee's memory, returning the word as the  result  of  the  ptrace()
              call.  Linux does not have separate text and data address spaces, so these two requests are currently equiv‐
              alent.  (data is ignored; but see NOTES.)

       PTRACE_PEEKUSER
              Read a word at offset addr in the tracee's USER area, which holds the registers and other information  about
              the  process  (see  <sys/user.h>).  The word is returned as the result of the ptrace() call.  Typically, the
              offset must be word-aligned, though this might vary by architecture.  See NOTES.  (data is ignored; but  see
              NOTES.)

       PTRACE_POKETEXT, PTRACE_POKEDATA
              Copy  the word data to the address addr in the tracee's memory.  As for PTRACE_PEEKTEXT and PTRACE_PEEKDATA,
              these two requests are currently equivalent.

       PTRACE_POKEUSER
              Copy the word data to offset addr in the tracee's USER area.  As for PTRACE_PEEKUSER, the offset must  typi‐
              cally  be  word-aligned.   In  order to maintain the integrity of the kernel, some modifications to the USER
              area are disallowed.

       PTRACE_GETREGS, PTRACE_GETFPREGS
              Copy the tracee's general-purpose or floating-point registers, respectively, to  the  address  data  in  the
              tracer.   See  <sys/user.h> for information on the format of this data.  (addr is ignored.)  Note that SPARC
              systems have the meaning of data and addr reversed; that is, data is ignored and the registers are copied to
              the address addr.  PTRACE_GETREGS and PTRACE_GETFPREGS are not present on all architectures.

       PTRACE_GETREGSET (since Linux 2.6.34)
              Read  the tracee's registers.  addr specifies, in an architecture-dependent way, the type of registers to be
              read.  NT_PRSTATUS (with numerical value 1) usually results in reading of general-purpose registers.  If the
              CPU  has,  for example, floating-point and/or vector registers, they can be retrieved by setting addr to the
              corresponding NT_foo constant.  data points to a struct iovec,  which  describes  the  destination  buffer's
              location  and  length.   On  return,  the  kernel  modifies  iov.len  to indicate the actual number of bytes
              returned.

       PTRACE_SETREGS, PTRACE_SETFPREGS
              Modify the tracee's general-purpose or floating-point registers, respectively, from the address data in  the
              tracer.   As  for  PTRACE_POKEUSER, some general-purpose register modifications may be disallowed.  (addr is
              ignored.)  Note that SPARC systems have the meaning of data and addr reversed; that is, data is ignored  and
              the  registers are copied from the address addr.  PTRACE_SETREGS and PTRACE_SETFPREGS are not present on all
              architectures.

       PTRACE_SETREGSET (since Linux 2.6.34)
              Modify the tracee's registers.  The meaning of addr and data is analogous to PTRACE_GETREGSET.

       PTRACE_GETSIGINFO (since Linux 2.3.99-pre6)
              Retrieve information about the signal that caused the stop.  Copy a siginfo_t structure  (see  sigaction(2))
              from the tracee to the address data in the tracer.  (addr is ignored.)

       PTRACE_SETSIGINFO (since Linux 2.3.99-pre6)
              Set  signal information: copy a siginfo_t structure from the address data in the tracer to the tracee.  This
              will affect only signals that would normally be delivered to the tracee and were caught by the  tracer.   It
              may be difficult to tell these normal signals from synthetic signals generated by ptrace() itself.  (addr is
              ignored.)

       PTRACE_PEEKSIGINFO (since Linux 3.10)
              Retrieve siginfo_t structures without removing signals from a  queue.   addr  points  to  a  ptrace_peeksig‐
              info_args  structure that specifies the ordinal position from which copying of signals should start, and the
              number of signals to copy.  siginfo_t structures are copied into the buffer pointed to by data.  The  return
              value  contains  the  number  of copied signals (zero indicates that there is no signal corresponding to the
              specified ordinal position).  Within the returned siginfo structures, the si_code field includes information
              (__SI_CHLD, __SI_FAULT, etc.) that are not otherwise exposed to user space.

           struct ptrace_peeksiginfo_args {
               u64 off;    /* Ordinal position in queue at which
                              to start copying signals */
               u32 flags;  /* PTRACE_PEEKSIGINFO_SHARED or 0 */
               s32 nr;     /* Number of signals to copy */
           };

              Currently, there is only one flag, PTRACE_PEEKSIGINFO_SHARED, for dumping signals from the process-wide sig‐
              nal queue.  If this flag is not set, signals are read from the per-thread queue of the specified thread.

       PTRACE_GETSIGMASK (since Linux 3.11)
              Place a copy of the mask of blocked signals (see sigprocmask(2)) in the buffer pointed  to  by  data,  which
              should be a pointer to a buffer of type sigset_t.  The addr argument contains the size of the buffer pointed
              to by data (i.e., sizeof(sigset_t)).

       PTRACE_SETSIGMASK (since Linux 3.11)
              Change the mask of blocked signals (see sigprocmask(2)) to the value specified in the buffer pointed  to  by
              data,  which  should  be a pointer to a buffer of type sigset_t.  The addr argument contains the size of the
              buffer pointed to by data (i.e., sizeof(sigset_t)).

       PTRACE_SETOPTIONS (since Linux 2.4.6; see BUGS for caveats)
              Set ptrace options from data.  (addr is ignored.)  data is interpreted as a bit mask of options,  which  are
              specified by the following flags:

              PTRACE_O_EXITKILL (since Linux 3.8)
                     Send  a  SIGKILL  signal to the tracee if the tracer exits.  This option is useful for ptrace jailers
                     that want to ensure that tracees can never escape the tracer's control.

              PTRACE_O_TRACECLONE (since Linux 2.5.46)
                     Stop the tracee at the next clone(2) and automatically start tracing the newly cloned process,  which
                     will start with a SIGSTOP, or PTRACE_EVENT_STOP if PTRACE_SEIZE was used.  A waitpid(2) by the tracer
                     will return a status value such that

                       status>>8 == (SIGTRAP | (PTRACE_EVENT_CLONE<<8))

                     The PID of the new process can be retrieved with PTRACE_GETEVENTMSG.

                     This option may not catch clone(2) calls in all  cases.   If  the  tracee  calls  clone(2)  with  the
                     CLONE_VFORK  flag, PTRACE_EVENT_VFORK will be delivered instead if PTRACE_O_TRACEVFORK is set; other‐
                     wise if the tracee calls clone(2) with the exit signal set  to  SIGCHLD,  PTRACE_EVENT_FORK  will  be
                     delivered if PTRACE_O_TRACEFORK is set.

              PTRACE_O_TRACEEXEC (since Linux 2.5.46)
                     Stop  the  tracee  at the next execve(2).  A waitpid(2) by the tracer will return a status value such
                     that

                       status>>8 == (SIGTRAP | (PTRACE_EVENT_EXEC<<8))

                     If the execing thread is not a thread group leader, the thread ID is reset to thread  group  leader's
                     ID before this stop.  Since Linux 3.0, the former thread ID can be retrieved with PTRACE_GETEVENTMSG.

              PTRACE_O_TRACEEXIT (since Linux 2.5.60)
                     Stop the tracee at exit.  A waitpid(2) by the tracer will return a status value such that

                       status>>8 == (SIGTRAP | (PTRACE_EVENT_EXIT<<8))

                     The tracee's exit status can be retrieved with PTRACE_GETEVENTMSG.

                     The  tracee  is  stopped  early during process exit, when registers are still available, allowing the
                     tracer to see where the exit occurred, whereas the normal exit notification is done after the process
                     is  finished exiting.  Even though context is available, the tracer cannot prevent the exit from hap‐
                     pening at this point.

              PTRACE_O_TRACEFORK (since Linux 2.5.46)
                     Stop the tracee at the next fork(2) and automatically start tracing the newly forked  process,  which
                     will start with a SIGSTOP, or PTRACE_EVENT_STOP if PTRACE_SEIZE was used.  A waitpid(2) by the tracer
                     will return a status value such that

                       status>>8 == (SIGTRAP | (PTRACE_EVENT_FORK<<8))

                     The PID of the new process can be retrieved with PTRACE_GETEVENTMSG.

              PTRACE_O_TRACESYSGOOD (since Linux 2.4.6)
                     When delivering system call traps, set bit 7 in the signal number (i.e., deliver SIGTRAP|0x80).  This
                     makes  it  easy  for  the  tracer  to  distinguish  normal  traps from those caused by a system call.
                     (PTRACE_O_TRACESYSGOOD may not work on all architectures.)

              PTRACE_O_TRACEVFORK (since Linux 2.5.46)
                     Stop the tracee at the next vfork(2) and automatically start tracing the newly vforked process, which
                     will start with a SIGSTOP, or PTRACE_EVENT_STOP if PTRACE_SEIZE was used.  A waitpid(2) by the tracer
                     will return a status value such that

                       status>>8 == (SIGTRAP | (PTRACE_EVENT_VFORK<<8))

                     The PID of the new process can be retrieved with PTRACE_GETEVENTMSG.

              PTRACE_O_TRACEVFORKDONE (since Linux 2.5.60)
                     Stop the tracee at the completion of the next vfork(2).  A waitpid(2) by the  tracer  will  return  a
                     status value such that

                       status>>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONE<<8))

                     The PID of the new process can (since Linux 2.6.18) be retrieved with PTRACE_GETEVENTMSG.

              PTRACE_O_TRACESECCOMP (since Linux 3.5)
                     Stop  the  tracee  when a seccomp(2) SECCOMP_RET_TRACE rule is triggered.  A waitpid(2) by the tracer
                     will return a status value such that

                       status>>8 == (SIGTRAP | (PTRACE_EVENT_SECCOMP<<8))

                     While this triggers a PTRACE_EVENT stop, it is similar to a syscall-enter-stop.  For details, see the
                     note  on  PTRACE_EVENT_SECCOMP below.  The seccomp event message data (from the SECCOMP_RET_DATA por‐
                     tion of the seccomp filter rule) can be retrieved with PTRACE_GETEVENTMSG.

              PTRACE_O_SUSPEND_SECCOMP (since Linux 4.3)
                     Suspend the tracee's seccomp protections.  This applies regardless of mode, and can be used when  the
                     tracee  has  not  yet  installed seccomp filters.  That is, a valid use case is to suspend a tracee's
                     seccomp protections before they are installed by the tracee, let the tracee install the filters,  and
                     then  clear  this  flag  when  the  filters should be resumed.  Setting this option requires that the
                     tracer have the CAP_SYS_ADMIN capability, not have any seccomp protections installed,  and  not  have
                     PTRACE_O_SUSPEND_SECCOMP set on itself.

       PTRACE_GETEVENTMSG (since Linux 2.5.46)
              Retrieve  a  message  (as  an  unsigned  long)  about the ptrace event that just happened, placing it at the
              address  data  in  the  tracer.   For  PTRACE_EVENT_EXIT,  this  is   the   tracee's   exit   status.    For
              PTRACE_EVENT_FORK,  PTRACE_EVENT_VFORK,  PTRACE_EVENT_VFORK_DONE, and PTRACE_EVENT_CLONE, this is the PID of
              the new process.  For PTRACE_EVENT_SECCOMP, this is the seccomp(2) filter's SECCOMP_RET_DATA associated with
              the triggered rule.  (addr is ignored.)

       PTRACE_CONT
              Restart  the  stopped tracee process.  If data is nonzero, it is interpreted as the number of a signal to be
              delivered to the tracee; otherwise, no signal is delivered.  Thus,  for  example,  the  tracer  can  control
              whether a signal sent to the tracee is delivered or not.  (addr is ignored.)

       PTRACE_SYSCALL, PTRACE_SINGLESTEP
              Restart the stopped tracee as for PTRACE_CONT, but arrange for the tracee to be stopped at the next entry to
              or exit from a system call, or after execution of a single  instruction,  respectively.   (The  tracee  will
              also, as usual, be stopped upon receipt of a signal.)  From the tracer's perspective, the tracee will appear
              to have been stopped by receipt of a SIGTRAP.  So, for PTRACE_SYSCALL, for example, the idea is  to  inspect
              the  arguments  to  the system call at the first stop, then do another PTRACE_SYSCALL and inspect the return
              value of the system call at the second stop.  The data argument is treated as  for  PTRACE_CONT.   (addr  is
              ignored.)

       PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP (since Linux 2.6.14)
              For  PTRACE_SYSEMU, continue and stop on entry to the next system call, which will not be executed.  See the
              documentation on syscall-stops below.  For PTRACE_SYSEMU_SINGLESTEP, do the same but also singlestep if  not
              a  system  call.   This  call is used by programs like User Mode Linux that want to emulate all the tracee's
              system calls.  The data argument is treated as for  PTRACE_CONT.   The  addr  argument  is  ignored.   These
              requests are currently supported only on x86.

       PTRACE_LISTEN (since Linux 3.4)
              Restart  the stopped tracee, but prevent it from executing.  The resulting state of the tracee is similar to
              a process which has been stopped by a SIGSTOP (or other stopping signal).  See the  "group-stop"  subsection
              for additional information.  PTRACE_LISTEN works only on tracees attached by PTRACE_SEIZE.

       PTRACE_KILL
              Send the tracee a SIGKILL to terminate it.  (addr and data are ignored.)

              This  operation  is deprecated; do not use it!  Instead, send a SIGKILL directly using kill(2) or tgkill(2).
              The problem with PTRACE_KILL is that it requires the tracee to be in signal-delivery-stop, otherwise it  may
              not  work  (i.e.,  may  complete  successfully  but  won't kill the tracee).  By contrast, sending a SIGKILL
              directly has no such limitation.

       PTRACE_INTERRUPT (since Linux 3.4)
              Stop a tracee.  If the tracee is running or sleeping in kernel space and PTRACE_SYSCALL is  in  effect,  the
              system  call  is  interrupted  and syscall-exit-stop is reported.  (The interrupted system call is restarted
              when the tracee is restarted.)  If the tracee was already stopped by a signal and PTRACE_LISTEN was sent  to
              it,  the  tracee  stops  with  PTRACE_EVENT_STOP and WSTOPSIG(status) returns the stop signal.  If any other
              ptrace-stop is generated at the same time (for example, if a signal is sent to the tracee), this ptrace-stop
              happens.   If none of the above applies (for example, if the tracee is running in user space), it stops with
              PTRACE_EVENT_STOP with WSTOPSIG(status) == SIGTRAP.  PTRACE_INTERRUPT only  works  on  tracees  attached  by
              PTRACE_SEIZE.

       PTRACE_ATTACH
              Attach  to  the  process  specified in pid, making it a tracee of the calling process.  The tracee is sent a
              SIGSTOP, but will not necessarily have stopped by the completion of this call; use waitpid(2)  to  wait  for
              the  tracee  to  stop.   See the "Attaching and detaching" subsection for additional information.  (addr and
              data are ignored.)

              Permission to perform a PTRACE_ATTACH is governed  by  a  ptrace  access  mode  PTRACE_MODE_ATTACH_REALCREDS
              check; see below.

       PTRACE_SEIZE (since Linux 3.4)
              Attach  to  the  process specified in pid, making it a tracee of the calling process.  Unlike PTRACE_ATTACH,
              PTRACE_SEIZE does not stop the process.  Group-stops are reported as PTRACE_EVENT_STOP and  WSTOPSIG(status)
              returns  the  stop signal.  Automatically attached children stop with PTRACE_EVENT_STOP and WSTOPSIG(status)
              returns SIGTRAP instead of having SIGSTOP signal delivered to them.  execve(2) does  not  deliver  an  extra
              SIGTRAP.  Only a PTRACE_SEIZEd process can accept PTRACE_INTERRUPT and PTRACE_LISTEN commands.  The "seized"
              behavior just described is inherited by children that are automatically attached  using  PTRACE_O_TRACEFORK,
              PTRACE_O_TRACEVFORK,  and  PTRACE_O_TRACECLONE.   addr  must  be  zero.   data contains a bit mask of ptrace
              options to activate immediately.

              Permission to perform a PTRACE_SEIZE is governed by a ptrace access mode PTRACE_MODE_ATTACH_REALCREDS check;
              see below.

       PTRACE_SECCOMP_GET_FILTER (since Linux 4.4)
              This operation allows the tracer to dump the tracee's classic BPF filters.

              addr  is an integer specifying the index of the filter to be dumped.  The most recently installed filter has
              the index 0.  If addr is greater than the number of installed filters, the operation fails  with  the  error
              ENOENT.

              data  is  either  a  pointer to a struct sock_filter array that is large enough to store the BPF program, or
              NULL if the program is not to be stored.

              Upon success, the return value is the number of instructions in the BPF program.  If  data  was  NULL,  then
              this return value can be used to correctly size the struct sock_filter array passed in a subsequent call.

              This  operation  fails with the error EACCESS if the caller does not have the CAP_SYS_ADMIN capability or if
              the caller is in strict or filter seccomp mode.  If the filter referred to by addr is not a classic BPF fil‐
              ter, the operation fails with the error EMEDIUMTYPE.

              This  operation  is  available if the kernel was configured with both the CONFIG_SECCOMP_FILTER and the CON‐
              FIG_CHECKPOINT_RESTORE options.

       PTRACE_DETACH
              Restart the stopped tracee as for PTRACE_CONT, but first detach from it.   Under  Linux,  a  tracee  can  be
              detached in this way regardless of which method was used to initiate tracing.  (addr is ignored.)

       PTRACE_GET_THREAD_AREA (since Linux 2.6.0)
              This operation performs a similar task to get_thread_area(2).  It reads the TLS entry in the GDT whose index
              is given in addr, placing a copy of the entry into the struct user_desc pointed to by  data.   (By  contrast
              with get_thread_area(2), the entry_number of the struct user_desc is ignored.)

       PTRACE_SET_THREAD_AREA (since Linux 2.6.0)
              This  operation performs a similar task to set_thread_area(2).  It sets the TLS entry in the GDT whose index
              is given in addr, assigning it the data supplied in the struct user_desc pointed to by data.   (By  contrast
              with  set_thread_area(2),  the  entry_number of the struct user_desc is ignored; in other words, this ptrace
              operation can't be used to allocate a free TLS entry.)

   Death under ptrace
       When a (possibly multithreaded) process receives a killing signal (one whose disposition  is  set  to  SIG_DFL  and
       whose  default  action  is  to kill the process), all threads exit.  Tracees report their death to their tracer(s).
       Notification of this event is delivered via waitpid(2).

       Note that the killing signal will first cause signal-delivery-stop (on one tracee  only),  and  only  after  it  is
       injected by the tracer (or after it was dispatched to a thread which isn't traced), will death from the signal hap‐
       pen on all tracees within a multithreaded process.  (The term "signal-delivery-stop" is explained below.)

       SIGKILL does not generate signal-delivery-stop and therefore the tracer can't  suppress  it.   SIGKILL  kills  even
       within system calls (syscall-exit-stop is not generated prior to death by SIGKILL).  The net effect is that SIGKILL
       always kills the process (all its threads), even if some threads of the process are ptraced.

       When the tracee calls _exit(2), it reports its death to its tracer.  Other threads are not affected.

       When any thread executes exit_group(2), every tracee in its thread group reports its death to its tracer.

       If the PTRACE_O_TRACEEXIT option is on, PTRACE_EVENT_EXIT will happen before actual death.  This applies  to  exits
       via  exit(2),  exit_group(2),  and signal deaths (except SIGKILL, depending on the kernel version; see BUGS below),
       and when threads are torn down on execve(2) in a multithreaded process.

       The tracer cannot assume that the ptrace-stopped tracee exists.  There are many scenarios when the tracee  may  die
       while  stopped  (such  as  SIGKILL).  Therefore, the tracer must be prepared to handle an ESRCH error on any ptrace
       operation.  Unfortunately, the same error is returned if the tracee exists but is not ptrace-stopped (for  commands
       which  require  a  stopped tracee), or if it is not traced by the process which issued the ptrace call.  The tracer
       needs to keep track of the stopped/running state of the tracee, and interpret ESRCH as "tracee  died  unexpectedly"
       only  if  it  knows  that  the tracee has been observed to enter ptrace-stop.  Note that there is no guarantee that
       waitpid(WNOHANG) will reliably report the tracee's death status if a ptrace operation returned ESRCH.  waitpid(WNO‐
       HANG)  may  return  0 instead.  In other words, the tracee may be "not yet fully dead", but already refusing ptrace
       requests.

       The tracer can't assume that the tracee always ends its life by reporting WIFEXITED(status) or WIFSIGNALED(status);
       there  are  cases  where  this  does  not  occur.   For example, if a thread other than thread group leader does an
       execve(2), it disappears; its PID will never be seen again, and any subsequent ptrace stops will be reported  under
       the thread group leader's PID.

   Stopped states
       A tracee can be in two states: running or stopped.  For the purposes of ptrace, a tracee which is blocked in a sys‐
       tem call (such as read(2), pause(2), etc.)  is nevertheless considered to be running, even if the tracee is blocked
       for  a long time.  The state of the tracee after PTRACE_LISTEN is somewhat of a gray area: it is not in any ptrace-
       stop (ptrace commands won't work on it, and it will deliver waitpid(2) notifications), but it also may  be  consid‐
       ered  "stopped"  because  it  is  not executing instructions (is not scheduled), and if it was in group-stop before
       PTRACE_LISTEN, it will not respond to signals until SIGCONT is received.

       There are many kinds of states when the tracee is stopped, and in ptrace  discussions  they  are  often  conflated.
       Therefore, it is important to use precise terms.

       In  this  manual  page, any stopped state in which the tracee is ready to accept ptrace commands from the tracer is
       called ptrace-stop.  Ptrace-stops can be further subdivided into  signal-delivery-stop,  group-stop,  syscall-stop,
       PTRACE_EVENT stops, and so on.  These stopped states are described in detail below.

       When  the  running  tracee  enters ptrace-stop, it notifies its tracer using waitpid(2) (or one of the other "wait"
       system calls).  Most of this manual page assumes that the tracer waits with:

           pid = waitpid(pid_or_minus_1, &status, __WALL);

       Ptrace-stopped tracees are reported as returns with pid greater than 0 and WIFSTOPPED(status) true.

       The __WALL flag does not include the WSTOPPED and WEXITED flags, but implies their functionality.

       Setting the WCONTINUED flag when calling waitpid(2) is not recommended: the "continued" state  is  per-process  and
       consuming it can confuse the real parent of the tracee.

       Use of the WNOHANG flag may cause waitpid(2) to return 0 ("no wait results available yet") even if the tracer knows
       there should be a notification.  Example:

           errno = 0;
           ptrace(PTRACE_CONT, pid, 0L, 0L);
           if (errno == ESRCH) {
               /* tracee is dead */
               r = waitpid(tracee, &status, __WALL | WNOHANG);
               /* r can still be 0 here! */
           }

       The following kinds of ptrace-stops exist: signal-delivery-stops, group-stops, PTRACE_EVENT  stops,  syscall-stops.
       They  all  are  reported  by  waitpid(2) with WIFSTOPPED(status) true.  They may be differentiated by examining the
       value status>>8, and if there is ambiguity in that value, by querying PTRACE_GETSIGINFO.  (Note: the  WSTOPSIG(sta‐
       tus) macro can't be used to perform this examination, because it returns the value (status>>8) & 0xff.)

   Signal-delivery-stop
       When  a (possibly multithreaded) process receives any signal except SIGKILL, the kernel selects an arbitrary thread
       which handles the signal.  (If the signal is generated with tgkill(2), the target thread can be explicitly selected
       by  the  caller.)   If the selected thread is traced, it enters signal-delivery-stop.  At this point, the signal is
       not yet delivered to the process, and can be suppressed by the tracer.  If the tracer doesn't suppress the  signal,
       it  passes  the  signal  to  the tracee in the next ptrace restart request.  This second step of signal delivery is
       called signal injection in this manual page.  Note that if the signal is blocked, signal-delivery-stop doesn't hap‐
       pen until the signal is unblocked, with the usual exception that SIGSTOP can't be blocked.

       Signal-delivery-stop  is observed by the tracer as waitpid(2) returning with WIFSTOPPED(status) true, with the sig‐
       nal returned by WSTOPSIG(status).  If the signal is SIGTRAP, this may be a different kind of ptrace-stop;  see  the
       "Syscall-stops"  and  "execve" sections below for details.  If WSTOPSIG(status) returns a stopping signal, this may
       be a group-stop; see below.

   Signal injection and suppression
       After signal-delivery-stop is observed by the tracer, the tracer should restart the tracee with the call

           ptrace(PTRACE_restart, pid, 0, sig)

       where PTRACE_restart is one of the restarting ptrace requests.  If sig is 0, then a signal is not delivered.   Oth‐
       erwise, the signal sig is delivered.  This operation is called signal injection in this manual page, to distinguish
       it from signal-delivery-stop.

       The sig value may be different from the WSTOPSIG(status) value: the tracer can  cause  a  different  signal  to  be
       injected.

       Note  that a suppressed signal still causes system calls to return prematurely.  In this case, system calls will be
       restarted: the tracer will observe the tracee to reexecute the interrupted system call (or restart_syscall(2)  sys‐
       tem  call for a few system calls which use a different mechanism for restarting) if the tracer uses PTRACE_SYSCALL.
       Even system calls (such as poll(2)) which are not restartable after signal  are  restarted  after  signal  is  sup‐
       pressed; however, kernel bugs exist which cause some system calls to fail with EINTR even though no observable sig‐
       nal is injected to the tracee.

       Restarting ptrace commands issued in ptrace-stops other than signal-delivery-stop are not guaranteed  to  inject  a
       signal,  even  if  sig is nonzero.  No error is reported; a nonzero sig may simply be ignored.  Ptrace users should
       not try to "create a new signal" this way: use tgkill(2) instead.

       The fact that signal injection requests may be ignored when restarting the tracee after ptrace stops that  are  not
       signal-delivery-stops is a cause of confusion among ptrace users.  One typical scenario is that the tracer observes
       group-stop, mistakes it for signal-delivery-stop, restarts the tracee with

           ptrace(PTRACE_restart, pid, 0, stopsig)

       with the intention of injecting stopsig, but stopsig gets ignored and the tracee continues to run.

       The SIGCONT signal has a side effect of waking up (all threads of) a group-stopped process.  This side effect  hap‐
       pens  before  signal-delivery-stop.  The tracer can't suppress this side effect (it can only suppress signal injec‐
       tion, which only causes the SIGCONT handler to not be executed in the tracee, if such a handler is installed).   In
       fact,  waking  up from group-stop may be followed by signal-delivery-stop for signal(s) other than SIGCONT, if they
       were pending when SIGCONT was delivered.  In other words, SIGCONT may be not  the  first  signal  observed  by  the
       tracee after it was sent.

       Stopping  signals  cause  (all  threads  of)  a process to enter group-stop.  This side effect happens after signal
       injection, and therefore can be suppressed by the tracer.

       In Linux 2.4 and earlier, the SIGSTOP signal can't be injected.

       PTRACE_GETSIGINFO can be used to retrieve  a  siginfo_t  structure  which  corresponds  to  the  delivered  signal.
       PTRACE_SETSIGINFO  may  be  used to modify it.  If PTRACE_SETSIGINFO has been used to alter siginfo_t, the si_signo
       field and the sig parameter in the restarting command must match, otherwise the result is undefined.

   Group-stop
       When a (possibly multithreaded) process receives a stopping signal, all threads stop.  If some threads are  traced,
       they enter a group-stop.  Note that the stopping signal will first cause signal-delivery-stop (on one tracee only),
       and only after it is injected by the tracer (or after it was dispatched to  a  thread  which  isn't  traced),  will
       group-stop be initiated on all tracees within the multithreaded process.  As usual, every tracee reports its group-
       stop separately to the corresponding tracer.

       Group-stop is observed by the tracer as waitpid(2) returning with WIFSTOPPED(status) true, with the stopping signal
       available  via  WSTOPSIG(status).  The same result is returned by some other classes of ptrace-stops, therefore the
       recommended practice is to perform the call

           ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)

       The call can be avoided if the signal is not SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU; only  these  four  signals  are
       stopping  signals.   If  the  tracer sees something else, it can't be a group-stop.  Otherwise, the tracer needs to
       call PTRACE_GETSIGINFO.  If PTRACE_GETSIGINFO fails with EINVAL, then it is definitely a group-stop.  (Other  fail‐
       ure codes are possible, such as ESRCH ("no such process") if a SIGKILL killed the tracee.)

       If   tracee  was  attached  using  PTRACE_SEIZE,  group-stop  is  indicated  by  PTRACE_EVENT_STOP:  status>>16  ==
       PTRACE_EVENT_STOP.  This allows detection of group-stops without requiring an extra PTRACE_GETSIGINFO call.

       As of Linux 2.6.38, after the tracer sees the tracee ptrace-stop and until it restarts or kills it, the tracee will
       not  run,  and  will  not  send  notifications (except SIGKILL death) to the tracer, even if the tracer enters into
       another waitpid(2) call.

       The kernel behavior described in the previous paragraph causes a problem with transparent handling of stopping sig‐
       nals.   If  the  tracer restarts the tracee after group-stop, the stopping signal is effectively ignored—the tracee
       doesn't remain stopped, it runs.  If the tracer doesn't restart the tracee before  entering  into  the  next  wait‐
       pid(2),  future SIGCONT signals will not be reported to the tracer; this would cause the SIGCONT signals to have no
       effect on the tracee.

       Since Linux 3.4, there is a method to overcome this problem: instead of PTRACE_CONT, a PTRACE_LISTEN command can be
       used  to  restart  a  tracee  in a way where it does not execute, but waits for a new event which it can report via
       waitpid(2) (such as when it is restarted by a SIGCONT).

   PTRACE_EVENT stops
       If the tracer sets PTRACE_O_TRACE_* options, the tracee will enter ptrace-stops called PTRACE_EVENT stops.

       PTRACE_EVENT stops are observed by the tracer as waitpid(2) returning with WIFSTOPPED(status), and WSTOPSIG(status)
       returns SIGTRAP.  An additional bit is set in the higher byte of the status word: the value status>>8 will be

           (SIGTRAP | PTRACE_EVENT_foo << 8).

       The following events exist:

       PTRACE_EVENT_VFORK
              Stop  before return from vfork(2) or clone(2) with the CLONE_VFORK flag.  When the tracee is continued after
              this stop, it will wait for child to exit/exec before continuing its execution (in other  words,  the  usual
              behavior on vfork(2)).

       PTRACE_EVENT_FORK
              Stop before return from fork(2) or clone(2) with the exit signal set to SIGCHLD.

       PTRACE_EVENT_CLONE
              Stop before return from clone(2).

       PTRACE_EVENT_VFORK_DONE
              Stop  before  return from vfork(2) or clone(2) with the CLONE_VFORK flag, but after the child unblocked this
              tracee by exiting or execing.

       For all four stops described above, the stop occurs in the parent (i.e., the tracee),  not  in  the  newly  created
       thread.  PTRACE_GETEVENTMSG can be used to retrieve the new thread's ID.

       PTRACE_EVENT_EXEC
              Stop before return from execve(2).  Since Linux 3.0, PTRACE_GETEVENTMSG returns the former thread ID.

       PTRACE_EVENT_EXIT
              Stop before exit (including death from exit_group(2)), signal death, or exit caused by execve(2) in a multi‐
              threaded process.  PTRACE_GETEVENTMSG returns the exit status.   Registers  can  be  examined  (unlike  when
              "real"  exit happens).  The tracee is still alive; it needs to be PTRACE_CONTed or PTRACE_DETACHed to finish
              exiting.

       PTRACE_EVENT_STOP
              Stop induced by PTRACE_INTERRUPT command, or group-stop, or initial ptrace-stop when a new child is attached
              (only if attached using PTRACE_SEIZE).

       PTRACE_EVENT_SECCOMP
              Stop  triggered  by a seccomp(2) rule on tracee syscall entry when PTRACE_O_TRACESECCOMP has been set by the
              tracer.  The seccomp event message data (from the SECCOMP_RET_DATA portion of the seccomp filter  rule)  can
              be retrieved with PTRACE_GETEVENTMSG.  The semantics of this stop are described in detail in a separate sec‐
              tion below.

       PTRACE_GETSIGINFO on PTRACE_EVENT stops returns SIGTRAP in si_signo, with si_code set to (event<<8) | SIGTRAP.

   Syscall-stops
       If the tracee was restarted by PTRACE_SYSCALL or PTRACE_SYSEMU, the tracee enters syscall-enter-stop just prior  to
       entering  any  system  call  (which  will not be executed if the restart was using PTRACE_SYSEMU, regardless of any
       change made to registers at this point or how the tracee is restarted after this stop).   No  matter  which  method
       caused  the  syscall-entry-stop,  if the tracer restarts the tracee with PTRACE_SYSCALL, the tracee enters syscall-
       exit-stop when the system call is finished, or if it is interrupted by a signal.   (That  is,  signal-delivery-stop
       never  happens  between  syscall-enter-stop  and  syscall-exit-stop;  it happens after syscall-exit-stop.).  If the
       tracee is continued using any other method (including PTRACE_SYSEMU), no syscall-exit-stop occurs.  Note  that  all
       mentions PTRACE_SYSEMU apply equally to PTRACE_SYSEMU_SINGLESTEP.

       However,  even if the tracee was continued using PTRACE_SYSCALL , it is not guaranteed that the next stop will be a
       syscall-exit-stop.  Other possibilities are that the tracee may stop in  a  PTRACE_EVENT  stop  (including  seccomp
       stops),  exit  (if  it entered _exit(2) or exit_group(2)), be killed by SIGKILL, or die silently (if it is a thread
       group leader, the execve(2) happened in another thread, and that thread is not traced by the same tracer; this sit‐
       uation is discussed later).

       Syscall-enter-stop and syscall-exit-stop are observed by the tracer as waitpid(2) returning with WIFSTOPPED(status)
       true, and WSTOPSIG(status) giving SIGTRAP.  If the PTRACE_O_TRACESYSGOOD option was set by the tracer, then  WSTOP‐
       SIG(status) will give the value (SIGTRAP | 0x80).

       Syscall-stops  can  be  distinguished  from signal-delivery-stop with SIGTRAP by querying PTRACE_GETSIGINFO for the
       following cases:

       si_code <= 0
              SIGTRAP was delivered as a result of a user-space action, for example, a system  call  (tgkill(2),  kill(2),
              sigqueue(3),  etc.), expiration of a POSIX timer, change of state on a POSIX message queue, or completion of
              an asynchronous I/O request.

       si_code == SI_KERNEL (0x80)
              SIGTRAP was sent by the kernel.

       si_code == SIGTRAP or si_code == (SIGTRAP|0x80)
              This is a syscall-stop.

       However, syscall-stops happen very often (twice per  system  call),  and  performing  PTRACE_GETSIGINFO  for  every
       syscall-stop may be somewhat expensive.

       Some architectures allow the cases to be distinguished by examining registers.  For example, on x86, rax == -ENOSYS
       in syscall-enter-stop.  Since SIGTRAP (like any other signal) always happens after syscall-exit-stop, and  at  this
       point  rax almost never contains -ENOSYS, the SIGTRAP looks like "syscall-stop which is not syscall-enter-stop"; in
       other words, it looks like a "stray syscall-exit-stop" and can be detected this way.  But such detection is fragile
       and is best avoided.

       Using  the  PTRACE_O_TRACESYSGOOD option is the recommended method to distinguish syscall-stops from other kinds of
       ptrace-stops, since it is reliable and does not incur a performance penalty.

       Syscall-enter-stop and syscall-exit-stop are indistinguishable from each other by the tracer.  The tracer needs  to
       keep  track of the sequence of ptrace-stops in order to not misinterpret syscall-enter-stop as syscall-exit-stop or
       vice versa.  In general, a syscall-enter-stop is always followed by syscall-exit-stop, PTRACE_EVENT  stop,  or  the
       tracee's  death;  no other kinds of ptrace-stop can occur in between.  However, note that seccomp stops (see below)
       can cause syscall-exit-stops, without preceding syscall-entry-stops.  If seccomp is in use, care needs to be  taken
       not to misinterpret such stops as syscall-entry-stops.

       If  after  syscall-enter-stop, the tracer uses a restarting command other than PTRACE_SYSCALL, syscall-exit-stop is
       not generated.

       PTRACE_GETSIGINFO on syscall-stops returns SIGTRAP in si_signo, with si_code set to SIGTRAP or (SIGTRAP|0x80).

   PTRACE_EVENT_SECCOMP stops (Linux 3.5 to 4.7)
       The behavior of PTRACE_EVENT_SECCOMP stops and their interaction with other  kinds  of  ptrace  stops  has  changed
       between  kernel  versions.   This  documents the behavior from their introduction until Linux 4.7 (inclusive).  The
       behavior in later kernel versions is documented in the next section.

       A PTRACE_EVENT_SECCOMP stop occurs whenever a SECCOMP_RET_TRACE rule is triggered.  This is  independent  of  which
       methods  was  used  to restart the system call.  Notably, seccomp still runs even if the tracee was restarted using
       PTRACE_SYSEMU and this system call is unconditionally skipped.

       Restarts from this stop will behave as if the stop had occurred right before the system call in question.  In  par‐
       ticular,  both  PTRACE_SYSCALL  and PTRACE_SYSEMU will normally cause a subsequent syscall-entry-stop.  However, if
       after the PTRACE_EVENT_SECCOMP the system call number is negative, both the syscall-entry-stop and the system  call
       itself will be skipped.  This means that if the system call number is negative after a PTRACE_EVENT_SECCOMP and the
       tracee is restarted using PTRACE_SYSCALL, the next observed stop will  be  a  syscall-exit-stop,  rather  than  the
       syscall-entry-stop that might have been expected.

   PTRACE_EVENT_SECCOMP stops (since Linux 4.8)
       Starting  with  Linux  4.8,  the  PTRACE_EVENT_SECCOMP  stop  was reordered to occur between syscall-entry-stop and
       syscall-exit-stop.  Note that seccomp no longer runs (and no PTRACE_EVENT_SECCOMP will be reported) if  the  system
       call is skipped due to PTRACE_SYSEMU.

       Functionally,  a  PTRACE_EVENT_SECCOMP stop functions comparably to a syscall-entry-stop (i.e., continuations using
       PTRACE_SYSCALL will cause syscall-exit-stops, the system call number may be changed and any other  modified  regis‐
       ters are visible to the to-be-executed system call as well).  Note that there may be, but need not have been a pre‐
       ceding syscall-entry-stop.

       After a PTRACE_EVENT_SECCOMP stop, seccomp will be rerun, with a SECCOMP_RET_TRACE rule now functioning the same as
       a  SECCOMP_RET_ALLOW.   Specifically, this means that if registers are not modified during the PTRACE_EVENT_SECCOMP
       stop, the system call will then be allowed.

   PTRACE_SINGLESTEP stops
       [Details of these kinds of stops are yet to be documented.]

   Informational and restarting ptrace commands
       Most ptrace commands (all except PTRACE_ATTACH, PTRACE_SEIZE, PTRACE_TRACEME,  PTRACE_INTERRUPT,  and  PTRACE_KILL)
       require the tracee to be in a ptrace-stop, otherwise they fail with ESRCH.

       When  the  tracee is in ptrace-stop, the tracer can read and write data to the tracee using informational commands.
       These commands leave the tracee in ptrace-stopped state:

           ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);
           ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);
           ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);
           ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);
           ptrace(PTRACE_GETREGSET, pid, NT_foo, &iov);
           ptrace(PTRACE_SETREGSET, pid, NT_foo, &iov);
           ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);
           ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);
           ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);
           ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);

       Note that some errors are not reported.  For example, setting signal information (siginfo) may have  no  effect  in
       some  ptrace-stops,  yet the call may succeed (return 0 and not set errno); querying PTRACE_GETEVENTMSG may succeed
       and return some random value if current ptrace-stop is not documented as returning a meaningful event message.

       The call

           ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);

       affects one tracee.  The tracee's current flags are replaced.  Flags are  inherited  by  new  tracees  created  and
       "auto-attached" via active PTRACE_O_TRACEFORK, PTRACE_O_TRACEVFORK, or PTRACE_O_TRACECLONE options.

       Another group of commands makes the ptrace-stopped tracee run.  They have the form:

           ptrace(cmd, pid, 0, sig);

       where  cmd  is  PTRACE_CONT,  PTRACE_LISTEN,  PTRACE_DETACH,  PTRACE_SYSCALL,  PTRACE_SINGLESTEP, PTRACE_SYSEMU, or
       PTRACE_SYSEMU_SINGLESTEP.  If the tracee is in signal-delivery-stop, sig is the signal to be  injected  (if  it  is
       nonzero).  Otherwise, sig may be ignored.  (When restarting a tracee from a ptrace-stop other than signal-delivery-
       stop, recommended practice is to always pass 0 in sig.)

   Attaching and detaching
       A thread can be attached to the tracer using the call

           ptrace(PTRACE_ATTACH, pid, 0, 0);

       or

           ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);

       PTRACE_ATTACH sends SIGSTOP to this thread.  If the tracer wants this SIGSTOP to have no effect, it needs  to  sup‐
       press  it.   Note  that if other signals are concurrently sent to this thread during attach, the tracer may see the
       tracee enter signal-delivery-stop with other signal(s) first!  The usual practice  is  to  reinject  these  signals
       until  SIGSTOP is seen, then suppress SIGSTOP injection.  The design bug here is that a ptrace attach and a concur‐
       rently delivered SIGSTOP may race and the concurrent SIGSTOP may be lost.

       Since attaching sends SIGSTOP and the tracer usually suppresses it, this may cause a stray EINTR  return  from  the
       currently executing system call in the tracee, as described in the "Signal injection and suppression" section.

       Since  Linux  3.4,  PTRACE_SEIZE  can  be  used  instead of PTRACE_ATTACH.  PTRACE_SEIZE does not stop the attached
       process.  If you need to stop it after attach  (or  at  any  other  time)  without  sending  it  any  signals,  use
       PTRACE_INTERRUPT command.

       The request

           ptrace(PTRACE_TRACEME, 0, 0, 0);

       turns  the  calling thread into a tracee.  The thread continues to run (doesn't enter ptrace-stop).  A common prac‐
       tice is to follow the PTRACE_TRACEME with

           raise(SIGSTOP);

       and allow the parent (which is our tracer now) to observe our signal-delivery-stop.

       If the PTRACE_O_TRACEFORK, PTRACE_O_TRACEVFORK, or PTRACE_O_TRACECLONE options are in effect, then children created
       by,  respectively,  vfork(2) or clone(2) with the CLONE_VFORK flag, fork(2) or clone(2) with the exit signal set to
       SIGCHLD, and other kinds of clone(2), are automatically attached to the same  tracer  which  traced  their  parent.
       SIGSTOP  is  delivered  to the children, causing them to enter signal-delivery-stop after they exit the system call
       which created them.

       Detaching of the tracee is performed by:

           ptrace(PTRACE_DETACH, pid, 0, sig);

       PTRACE_DETACH is a restarting operation; therefore it requires the tracee to be in ptrace-stop.  If the  tracee  is
       in signal-delivery-stop, a signal can be injected.  Otherwise, the sig parameter may be silently ignored.

       If  the  tracee  is  running  when  the  tracer  wants  to  detach it, the usual solution is to send SIGSTOP (using
       tgkill(2), to make sure it goes to the correct thread), wait for the tracee to  stop  in  signal-delivery-stop  for
       SIGSTOP  and  then  detach  it (suppressing SIGSTOP injection).  A design bug is that this can race with concurrent
       SIGSTOPs.  Another complication is that the tracee may enter other ptrace-stops  and  needs  to  be  restarted  and
       waited  for  again,  until  SIGSTOP is seen.  Yet another complication is to be sure that the tracee is not already
       ptrace-stopped, because no signal delivery happens while it is—not even SIGSTOP.

       If the tracer dies, all tracees are automatically detached and restarted, unless they were in group-stop.  Handling
       of restart from group-stop is currently buggy, but the "as planned" behavior is to leave tracee stopped and waiting
       for SIGCONT.  If the tracee is restarted from signal-delivery-stop, the pending signal is injected.

   execve(2) under ptrace
       When one thread in a multithreaded process calls execve(2), the kernel destroys all other threads in  the  process,
       and  resets  the  thread  ID of the execing thread to the thread group ID (process ID).  (Or, to put things another
       way, when a multithreaded process does an execve(2), at completion of the call, it appears as though the  execve(2)
       occurred  in  the thread group leader, regardless of which thread did the execve(2).)  This resetting of the thread
       ID looks very confusing to tracers:

       *  All other threads stop in PTRACE_EVENT_EXIT stop, if the PTRACE_O_TRACEEXIT option  was  turned  on.   Then  all
          other threads except the thread group leader report death as if they exited via _exit(2) with exit code 0.

       *  The  execing  tracee  changes  its  thread  ID while it is in the execve(2).  (Remember, under ptrace, the "pid"
          returned from waitpid(2), or fed into ptrace calls, is the tracee's thread ID.)  That is, the tracee's thread ID
          is reset to be the same as its process ID, which is the same as the thread group leader's thread ID.

       *  Then a PTRACE_EVENT_EXEC stop happens, if the PTRACE_O_TRACEEXEC option was turned on.

       *  If  the  thread group leader has reported its PTRACE_EVENT_EXIT stop by this time, it appears to the tracer that
          the dead thread leader "reappears from nowhere".  (Note: the thread group  leader  does  not  report  death  via
          WIFEXITED(status)  until  there  is  at  least  one other live thread.  This eliminates the possibility that the
          tracer will see it dying and then reappearing.)  If the thread group leader was still alive, for the tracer this
          may  look as if thread group leader returns from a different system call than it entered, or even "returned from
          a system call even though it was not in any system call".  If the thread group leader was  not  traced  (or  was
          traced  by  a different tracer), then during execve(2) it will appear as if it has become a tracee of the tracer
          of the execing tracee.

       All of the above effects are the artifacts of the thread ID change in the tracee.

       The PTRACE_O_TRACEEXEC option is the  recommended  tool  for  dealing  with  this  situation.   First,  it  enables
       PTRACE_EVENT_EXEC stop, which occurs before execve(2) returns.  In this stop, the tracer can use PTRACE_GETEVENTMSG
       to  retrieve  the  tracee's  former  thread  ID.   (This  feature  was  introduced  in  Linux  3.0.)   Second,  the
       PTRACE_O_TRACEEXEC option disables legacy SIGTRAP generation on execve(2).

       When  the  tracer  receives  PTRACE_EVENT_EXEC  stop notification, it is guaranteed that except this tracee and the
       thread group leader, no other threads from the process are alive.

       On receiving the PTRACE_EVENT_EXEC stop notification, the tracer should clean up all its internal  data  structures
       describing  the  threads  of  this process, and retain only one data structure—one which describes the single still
       running tracee, with

           thread ID == thread group ID == process ID.

       Example: two threads call execve(2) at the same time:

       *** we get syscall-enter-stop in thread 1: **
       PID1 execve("/bin/foo", "foo" <unfinished ...>
       *** we issue PTRACE_SYSCALL for thread 1 **
       *** we get syscall-enter-stop in thread 2: **
       PID2 execve("/bin/bar", "bar" <unfinished ...>
       *** we issue PTRACE_SYSCALL for thread 2 **
       *** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **
       *** we get syscall-exit-stop for PID0: **
       PID0 <... execve resumed> )             = 0

       If the PTRACE_O_TRACEEXEC option is not in effect for the execing tracee, and if  the  tracee  was  PTRACE_ATTACHed
       rather  that PTRACE_SEIZEd, the kernel delivers an extra SIGTRAP to the tracee after execve(2) returns.  This is an
       ordinary signal (similar to one which can be generated by kill -TRAP), not a special kind of ptrace-stop.   Employ‐
       ing  PTRACE_GETSIGINFO  for  this  signal returns si_code set to 0 (SI_USER).  This signal may be blocked by signal
       mask, and thus may be delivered (much) later.

       Usually, the tracer (for example, strace(1)) would not want to show this extra post-execve SIGTRAP  signal  to  the
       user,  and  would suppress its delivery to the tracee (if SIGTRAP is set to SIG_DFL, it is a killing signal).  How‐
       ever, determining which SIGTRAP  to  suppress  is  not  easy.   Setting  the  PTRACE_O_TRACEEXEC  option  or  using
       PTRACE_SEIZE and thus suppressing this extra SIGTRAP is the recommended approach.

   Real parent
       The ptrace API (ab)uses the standard UNIX parent/child signaling over waitpid(2).  This used to cause the real par‐
       ent of the process to stop receiving several kinds of waitpid(2) notifications when the child process is traced  by
       some other process.

       Many of these bugs have been fixed, but as of Linux 2.6.38 several still exist; see BUGS below.

       As of Linux 2.6.38, the following is believed to work correctly:

       *  exit/death  by  signal is reported first to the tracer, then, when the tracer consumes the waitpid(2) result, to
          the real parent (to the real parent only when the whole multithreaded process exits).  If  the  tracer  and  the
          real parent are the same process, the report is sent only once.

RETURN VALUE
       On  success,  the  PTRACE_PEEK*  requests  return the requested data (but see NOTES), the PTRACE_SECCOMP_GET_FILTER
       request returns the number of instructions in the BPF program, and other requests return zero.

       On error, all requests return -1, and errno is set  appropriately.   Since  the  value  returned  by  a  successful
       PTRACE_PEEK*  request may be -1, the caller must clear errno before the call, and then check it afterward to deter‐
       mine whether or not an error occurred.

ERRORS
       EBUSY  (i386 only) There was an error with allocating or freeing a debug register.

       EFAULT There was an attempt to read from or write to an invalid area in the tracer's or the tracee's memory, proba‐
              bly  because the area wasn't mapped or accessible.  Unfortunately, under Linux, different variations of this
              fault will return EIO or EFAULT more or less arbitrarily.

       EINVAL An attempt was made to set an invalid option.

       EIO    request is invalid, or an attempt was made to read from or write to an invalid area in the tracer's  or  the
              tracee's  memory,  or  there  was  a  word-alignment  violation, or an invalid signal was specified during a
              restart request.

       EPERM  The specified process cannot be traced.  This could be because the tracer has insufficient  privileges  (the
              required  capability is CAP_SYS_PTRACE); unprivileged processes cannot trace processes that they cannot send
              signals to or those running set-user-ID/set-group-ID programs,  for  obvious  reasons.   Alternatively,  the
              process may already be being traced, or (on kernels before 2.6.26) be init(1) (PID 1).

       ESRCH  The specified process does not exist, or is not currently being traced by the caller, or is not stopped (for
              requests that require a stopped tracee).

CONFORMING TO
       SVr4, 4.3BSD.

NOTES
       Although arguments to ptrace() are interpreted according to the prototype given, glibc currently declares  ptrace()
       as  a  variadic  function with only the request argument fixed.  It is recommended to always supply four arguments,
       even if the requested operation does not use them, setting unused/ignored arguments to 0L or (void *) 0.

       In Linux kernels before 2.6.26, init(1), the process with PID 1, may not be traced.

       A tracees parent continues to be the tracer even if that tracer calls execve(2).

       The layout of the contents of memory and the USER area are quite operating-system- and architecture-specific.   The
       offset supplied, and the data returned, might not entirely match with the definition of struct user.

       The size of a "word" is determined by the operating-system variant (e.g., for 32-bit Linux it is 32 bits).

       This  page  documents  the  way  the ptrace() call works currently in Linux.  Its behavior differs significantly on
       other flavors of UNIX.  In any case, use of ptrace() is highly specific to the operating system and architecture.

   Ptrace access mode checking
       Various parts of the kernel-user-space API (not just ptrace() operations), require so-called "ptrace  access  mode"
       checks,  whose  outcome determines whether an operation is permitted (or, in a few cases, causes a "read" operation
       to return sanitized data).  These checks are performed in cases where one process can inspect sensitive information
       about,  or in some cases modify the state of, another process.  The checks are based on factors such as the creden‐
       tials and capabilities of the two processes, whether or not the "target" process is dumpable, and  the  results  of
       checks performed by any enabled Linux Security Module (LSM)—for example, SELinux, Yama, or Smack—and by the common‐
       cap LSM (which is always invoked).

       Prior to Linux 2.6.27, all access checks were of a single type.  Since Linux 2.6.27, two  access  mode  levels  are
       distinguished:

       PTRACE_MODE_READ
              For  "read"  operations  or  other operations that are less dangerous, such as: get_robust_list(2); kcmp(2);
              reading /proc/[pid]/auxv, /proc/[pid]/environ, or /proc/[pid]/stat; or  readlink(2)  of  a  /proc/[pid]/ns/*
              file.

       PTRACE_MODE_ATTACH
              For   "write"  operations,  or  other  operations  that  are  more  dangerous,  such  as:  ptrace  attaching
              (PTRACE_ATTACH) to another process or calling process_vm_writev(2).  (PTRACE_MODE_ATTACH was effectively the
              default before Linux 2.6.27.)

       Since Linux 4.5, the above access mode checks are combined (ORed) with one of the following modifiers:

       PTRACE_MODE_FSCREDS
              Use the caller's filesystem UID and GID (see credentials(7)) or effective capabilities for LSM checks.

       PTRACE_MODE_REALCREDS
              Use  the  caller's  real  UID  and  GID  or permitted capabilities for LSM checks.  This was effectively the
              default before Linux 4.5.

       Because combining one of the credential modifiers with one of the aforementioned  access  modes  is  typical,  some
       macros are defined in the kernel sources for the combinations:

       PTRACE_MODE_READ_FSCREDS
              Defined as PTRACE_MODE_READ | PTRACE_MODE_FSCREDS.

       PTRACE_MODE_READ_REALCREDS
              Defined as PTRACE_MODE_READ | PTRACE_MODE_REALCREDS.

       PTRACE_MODE_ATTACH_FSCREDS
              Defined as PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS.

       PTRACE_MODE_ATTACH_REALCREDS
              Defined as PTRACE_MODE_ATTACH | PTRACE_MODE_REALCREDS.

       One further modifier can be ORed with the access mode:

       PTRACE_MODE_NOAUDIT (since Linux 3.3)
              Don't audit this access mode check.  This modifier is employed for ptrace access mode checks (such as checks
              when reading /proc/[pid]/stat) that merely cause the output to be filtered or sanitized, rather than causing
              an  error  to be returned to the caller.  In these cases, accessing the file is not a security violation and
              there is no reason to generate a security audit record.  This modifier suppresses the generation of such  an
              audit record for the particular access check.

       Note  that  all of the PTRACE_MODE_* constants described in this subsection are kernel-internal, and not visible to
       user space.  The constant names are mentioned here in order to label the various kinds of ptrace access mode checks
       that  are  performed for various system calls and accesses to various pseudofiles (e.g., under /proc).  These names
       are used in other manual pages to provide a simple shorthand for labeling the different kernel checks.

       The algorithm employed for ptrace access mode checking determines whether the calling process is allowed to perform
       the  corresponding  action on the target process.  (In the case of opening /proc/[pid] files, the "calling process"
       is the one opening the file, and the process with the corresponding PID is the "target process".)  The algorithm is
       as follows:

       1. If the calling thread and the target thread are in the same thread group, access is always allowed.

       2. If  the  access  mode  specifies  PTRACE_MODE_FSCREDS, then, for the check in the next step, employ the caller's
          filesystem UID and GID.  (As noted in credentials(7), the filesystem UID and GID almost  always  have  the  same
          values as the corresponding effective IDs.)

          Otherwise,  the access mode specifies PTRACE_MODE_REALCREDS, so use the caller's real UID and GID for the checks
          in the next step.  (Most APIs that check the caller's UID and GID use the effective IDs.   For  historical  rea‐
          sons, the PTRACE_MODE_REALCREDS check uses the real IDs instead.)

       3. Deny access if neither of the following is true:

          · The real, effective, and saved-set user IDs of the target match the caller's user ID, and the real, effective,
            and saved-set group IDs of the target match the caller's group ID.

          · The caller has the CAP_SYS_PTRACE capability in the user namespace of the target.

       4. Deny access if the target process "dumpable" attribute has a value other than 1 (SUID_DUMP_USER; see the discus‐
          sion  of  PR_SET_DUMPABLE  in  prctl(2)), and the caller does not have the CAP_SYS_PTRACE capability in the user
          namespace of the target process.

       5. The kernel LSM security_ptrace_access_check() interface is invoked to see if ptrace access  is  permitted.   The
          results  depend on the LSM(s).  The implementation of this interface in the commoncap LSM performs the following
          steps:

          a) If the access mode includes PTRACE_MODE_FSCREDS, then use the caller's effective capability set in  the  fol‐
             lowing  check;  otherwise  (the  access  mode specifies PTRACE_MODE_REALCREDS, so) use the caller's permitted
             capability set.

          b) Deny access if neither of the following is true:

             · The caller and the target process are in the same user namespace,  and  the  caller's  capabilities  are  a
               proper superset of the target process's permitted capabilities.

             · The caller has the CAP_SYS_PTRACE capability in the target process's user namespace.

             Note that the commoncap LSM does not distinguish between PTRACE_MODE_READ and PTRACE_MODE_ATTACH.

       6. If access has not been denied by any of the preceding steps, then access is allowed.

   /proc/sys/kernel/yama/ptrace_scope
       On  systems  with the Yama Linux Security Module (LSM) installed (i.e., the kernel was configured with CONFIG_SECU‐
       RITY_YAMA), the /proc/sys/kernel/yama/ptrace_scope file (available since Linux 3.4) can be  used  to  restrict  the
       ability  to  trace  a  process with ptrace() (and thus also the ability to use tools such as strace(1) and gdb(1)).
       The goal of such restrictions is to prevent attack escalation whereby a compromised process  can  ptrace-attach  to
       other  sensitive processes (e.g., a GPG agent or an SSH session) owned by the user in order to gain additional cre‐
       dentials that may exist in memory and thus expand the scope of the attack.

       More precisely, the Yama LSM limits two types of operations:

       *  Any operation that performs a ptrace access mode PTRACE_MODE_ATTACH check—for example,  ptrace()  PTRACE_ATTACH.
          (See the "Ptrace access mode checking" discussion above.)

       *  ptrace() PTRACE_TRACEME.

       A process that has the CAP_SYS_PTRACE capability can update the /proc/sys/kernel/yama/ptrace_scope file with one of
       the following values:

       0 ("classic ptrace permissions")
              No additional restrictions on operations that perform PTRACE_MODE_ATTACH checks (beyond those imposed by the
              commoncap and other LSMs).

              The use of PTRACE_TRACEME is unchanged.

       1 ("restricted ptrace") [default value]
              When  performing an operation that requires a PTRACE_MODE_ATTACH check, the calling process must either have
              the CAP_SYS_PTRACE capability in the user namespace of the target process or it must have a predefined rela‐
              tionship  with  the target process.  By default, the predefined relationship is that the target process must
              be a descendant of the caller.

              A target process can employ the prctl(2) PR_SET_PTRACER operation to  declare  an  additional  PID  that  is
              allowed  to  perform  PTRACE_MODE_ATTACH  operations  on  the target.  See the kernel source file Documenta‐
              tion/admin-guide/LSM/Yama.rst (or Documentation/security/Yama.txt before Linux 4.13) for further details.

              The use of PTRACE_TRACEME is unchanged.

       2 ("admin-only attach")
              Only processes with the CAP_SYS_PTRACE capability in the user namespace of the target  process  may  perform
              PTRACE_MODE_ATTACH operations or trace children that employ PTRACE_TRACEME.

       3 ("no attach")
              No process may perform PTRACE_MODE_ATTACH operations or trace children that employ PTRACE_TRACEME.

              Once this value has been written to the file, it cannot be changed.

       With  respect to values 1 and 2, note that creating a new user namespace effectively removes the protection offered
       by Yama.  This is because a process in the parent user namespace whose effective UID matches the UID of the creator
       of  a  child  namespace has all capabilities (including CAP_SYS_PTRACE) when performing operations within the child
       user namespace (and further-removed descendants of that namespace).  Consequently, when a process tries to use user
       namespaces to sandbox itself, it inadvertently weakens the protections offered by the Yama LSM.

   C library/kernel differences
       At  the system call level, the PTRACE_PEEKTEXT, PTRACE_PEEKDATA, and PTRACE_PEEKUSER requests have a different API:
       they store the result at the address specified by the data parameter, and the return value is the error flag.   The
       glibc wrapper function provides the API given in DESCRIPTION above, with the result being returned via the function
       return value.

BUGS
       On hosts with 2.6 kernel headers, PTRACE_SETOPTIONS is declared with a different value than the one for 2.4.   This
       leads  to applications compiled with 2.6 kernel headers failing when run on 2.4 kernels.  This can be worked around
       by redefining PTRACE_SETOPTIONS to PTRACE_OLDSETOPTIONS, if that is defined.

       Group-stop notifications are sent to the tracer, but not to real parent.  Last confirmed on 2.6.38.6.

       If a thread group leader is traced and exits by calling _exit(2), a PTRACE_EVENT_EXIT stop will happen for  it  (if
       requested),  but  the  subsequent  WIFEXITED  notification  will not be delivered until all other threads exit.  As
       explained above, if one of other threads calls execve(2), the death of  the  thread  group  leader  will  never  be
       reported.   If  the execed thread is not traced by this tracer, the tracer will never know that execve(2) happened.
       One possible workaround is to PTRACE_DETACH the thread group leader instead of restarting it in  this  case.   Last
       confirmed on 2.6.38.6.

       A  SIGKILL  signal may still cause a PTRACE_EVENT_EXIT stop before actual signal death.  This may be changed in the
       future; SIGKILL is meant to always immediately kill tasks even under ptrace.  Last confirmed on Linux 3.13.

       Some system calls return with EINTR if a signal was sent to a tracee, but delivery was suppressed  by  the  tracer.
       (This is very typical operation: it is usually done by debuggers on every attach, in order to not introduce a bogus
       SIGSTOP).  As of Linux  3.2.9,  the  following  system  calls  are  affected  (this  list  is  likely  incomplete):
       epoll_wait(2),  and  read(2)  from  an  inotify(7) file descriptor.  The usual symptom of this bug is that when you
       attach to a quiescent process with the command

           strace -p <process-ID>

       then, instead of the usual and expected one-line output such as

           restart_syscall(<... resuming interrupted call ...>_

       or

           select(6, [5], NULL, [5], NULL_

       ('_' denotes the cursor position), you observe more than one line.  For example:

               clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0
               epoll_wait(4,_

       What is not visible here is that the process was blocked in epoll_wait(2) before  strace(1)  has  attached  to  it.
       Attaching  caused epoll_wait(2) to return to user space with the error EINTR.  In this particular case, the program
       reacted to EINTR by checking the current time, and then executing epoll_wait(2)  again.   (Programs  which  do  not
       expect such "stray" EINTR errors may behave in an unintended way upon an strace(1) attach.)

SEE ALSO
       gdb(1),  ltrace(1),  strace(1),  clone(2),  execve(2),  fork(2),  gettid(2),  prctl(2),  seccomp(2),  sigaction(2),
       tgkill(2), vfork(2), waitpid(2), exec(3), capabilities(7), signal(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                               PTRACE(2)
</pre>
<pre zoom>
<span xsmall>2 setfsuid</span>
SETFSUID(2)                                      Linux Programmer's Manual                                     SETFSUID(2)

NAME
       setfsuid - set user identity used for filesystem checks

SYNOPSIS
       #include <sys/fsuid.h>

       int setfsuid(uid_t fsuid);

DESCRIPTION
       The  system  call setfsuid() changes the value of the caller's filesystem user ID—the user ID that the Linux kernel
       uses to check for all accesses to the filesystem.  Normally, the value of the filesystem user ID  will  shadow  the
       value  of  the  effective user ID.  In fact, whenever the effective user ID is changed, the filesystem user ID will
       also be changed to the new value of the effective user ID.

       Explicit calls to setfsuid() and setfsgid(2) are usually used only by programs such as the Linux  NFS  server  that
       need to change what user and group ID is used for file access without a corresponding change in the real and effec‐
       tive user and group IDs.  A change in the normal user IDs for a program such as the NFS server is a  security  hole
       that can expose it to unwanted signals.  (But see below.)

       setfsuid()  will  succeed only if the caller is the superuser or if fsuid matches either the caller's real user ID,
       effective user ID, saved set-user-ID, or current filesystem user ID.

RETURN VALUE
       On both success and failure, this call returns the previous filesystem user ID of the caller.

VERSIONS
       This system call is present in Linux since version 1.2.

CONFORMING TO
       setfsuid() is Linux-specific and should not be used in programs intended to be portable.

NOTES
       At the time when this system call was introduced, one process could send a signal to another process with the  same
       effective  user  ID.  This meant that if a privileged process changed its effective user ID for the purpose of file
       permission checking, then it could become vulnerable to receiving signals sent by  another  (unprivileged)  process
       with  the  same  user ID.  The filesystem user ID attribute was thus added to allow a process to change its user ID
       for the purposes of file permission checking without at the same time becoming  vulnerable  to  receiving  unwanted
       signals.   Since  Linux  2.0, signal permission handling is different (see kill(2)), with the result that a process
       change can change its effective user ID without being vulnerable to  receiving  signals  from  unwanted  processes.
       Thus, setfsuid() is nowadays unneeded and should be avoided in new applications (likewise for setfsgid(2)).

       The  original  Linux  setfsuid()  system  call supported only 16-bit user IDs.  Subsequently, Linux 2.4 added setf‐
       suid32() supporting 32-bit IDs.  The glibc setfsuid() wrapper  function  transparently  deals  with  the  variation
       across kernel versions.

   C library/kernel differences
       In  glibc  2.15  and earlier, when the wrapper for this system call determines that the argument can't be passed to
       the kernel without integer truncation (because the kernel is old and does not support 32-bit user IDs),  they  will
       return -1 and set errno to EINVAL without attempting the system call.

BUGS
       No  error  indications  of  any kind are returned to the caller, and the fact that both successful and unsuccessful
       calls return the same value makes it impossible to  directly  determine  whether  the  call  succeeded  or  failed.
       Instead, the caller must resort to looking at the return value from a further call such as setfsuid(-1) (which will
       always fail), in order to determine if a preceding call to setfsuid() changed the filesystem user ID.  At the  very
       least, EPERM should be returned when the call fails (because the caller lacks the CAP_SETUID capability).

SEE ALSO
       kill(2), setfsgid(2), capabilities(7), credentials(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             SETFSUID(2)
</pre>
<pre zoom>
<span xsmall>2 lstat</span>
STAT(2)                                          Linux Programmer's Manual                                         STAT(2)

NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       int fstat(int fd, struct stat *statbuf);
       int lstat(const char *pathname, struct stat *statbuf);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
                   int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       lstat():
           /* glibc 2.19 and earlier */ _BSD_SOURCE
               || /* Since glibc 2.20 */ _DEFAULT_SOURCE
               || _XOPEN_SOURCE >= 500
               || /* Since glibc 2.10: */ _POSIX_C_SOURCE >= 200112L

       fstatat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  functions return information about a file, in the buffer pointed to by statbuf.  No permissions are required
       on the file itself, but—in the case of stat(), fstatat(), and lstat()—execute (search) permission  is  required  on
       all of the directories in pathname that lead to the file.

       stat()  and fstatat() retrieve information about the file pointed to by pathname; the differences for fstatat() are
       described below.

       lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information  about  the
       link itself, not the file that it refers to.

       fstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the
       file descriptor fd.

   The stat structure
       All of these system calls return a stat structure, which contains the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

       Note: the order of fields in the stat structure varies somewhat across architectures.  In addition, the  definition
       above  does  not  show the padding bytes that may be present between some fields on various architectures.  Consult
       the glibc and kernel source code if you need to know the details.

       Note: for performance and simplicity reasons, different fields in the stat structure may contain state  information
       from  different  moments  during the execution of the system call.  For example, if st_mode or st_uid is changed by
       another process by calling chmod(2) or chown(2), stat() might return the old st_mode together with the new  st_uid,
       or the old st_uid together with the new st_mode.

       The fields in the stat structure are as follows:

       st_dev This field describes the device on which this file resides.  (The major(3) and minor(3) macros may be useful
              to decompose the device ID in this field.)

       st_ino This field contains the file's inode number.

       st_mode
              This field contains the file type and mode.  See inode(7) for further information.

       st_nlink
              This field contains the number of hard links to the file.

       st_uid This field contains the user ID of the owner of the file.

       st_gid This field contains the ID of the group owner of the file.

       st_rdev
              This field describes the device that this file (inode) represents.

       st_size
              This field gives the size of the file (if it is a regular file or a symbolic link) in bytes.  The size of  a
              symbolic link is the length of the pathname it contains, without a terminating null byte.

       st_blksize
              This field gives the "preferred" block size for efficient filesystem I/O.

       st_blocks
              This  field  indicates  the number of blocks allocated to the file, in 512-byte units.  (This may be smaller
              than st_size/512 when the file has holes.)

       st_atime
              This is the file's last access timestamp.

       st_mtime
              This is the file's last modification timestamp.

       st_ctime
              This is the file's last status change timestamp.

       For further information on the above fields, see inode(7).

   fstatat()
       The fstatat() system call is a more general interface for  accessing  file  information  which  can  still  provide
       exactly the behavior of each of stat(), lstat(), and fstat().

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       stat() and lstat() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like stat() and lstat()).

       If pathname is absolute, then dirfd is ignored.

       flags can either be 0, or include one or more of the following flags ORed:

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2) O_PATH flag).  In this case, dirfd can refer to any type of file, not just a directory, and the
              behavior of fstatat() is similar to that of fstat().  If dirfd is AT_FDCWD, the call operates on the current
              working directory.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.

       AT_NO_AUTOMOUNT (since Linux 2.6.38)
              Don't  automount  the  terminal ("basename") component of pathname if it is a directory that is an automount
              point.  This allows the caller to gather attributes of an automount point (rather than the location it would
              mount).   Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand directory such as used
              for automounter indirect maps.  This flag can be used in tools that scan directories to  prevent  mass-auto‐
              mounting  of a directory of automount points.  The AT_NO_AUTOMOUNT flag has no effect if the mount point has
              already been mounted over.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.   Both
              stat() and lstat() act as though AT_NO_AUTOMOUNT was set.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a  symbolic link, do not dereference it: instead return information about the link itself,
              like lstat().  (By default, fstatat() dereferences symbolic links, like stat().)

       See openat(2) for an explanation of the need for fstatat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Search permission is denied for one of the directories in the path prefix of pathname.  (See also path_reso‐
              lution(7).)

       EBADF  fd is not a valid open file descriptor.

       EFAULT Bad address.

       ELOOP  Too many symbolic links encountered while traversing the path.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A  component  of pathname does not exist, or pathname is an empty string and AT_EMPTY_PATH was not specified
              in flags.

       ENOMEM Out of memory (i.e., kernel memory).

       ENOTDIR
              A component of the path prefix of pathname is not a directory.

       EOVERFLOW
              pathname or fd refers to a file whose size, inode number, or number of  blocks  cannot  be  represented  in,
              respectively,  the  types off_t, ino_t, or blkcnt_t.  This error can occur when, for example, an application
              compiled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 calls stat()  on  a  file  whose  size  exceeds
              (1<<31)-1 bytes.

       The following additional errors can occur for fstatat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fstatat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       stat(), fstat(), lstat(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.

       fstatat(): POSIX.1-2008.

       According  to  POSIX.1-2001, lstat() on a symbolic link need return valid information only in the st_size field and
       the file type of the st_mode field of the stat  structure.   POSIX.1-2008  tightens  the  specification,  requiring
       lstat() to return valid information in all fields except the mode bits in st_mode.

       Use of the st_blocks and st_blksize fields may be less portable.  (They were introduced in BSD.  The interpretation
       differs between systems, and possibly on a single system when NFS mounts are involved.)

NOTES
   Timestamp fields
       Older kernels and older standards did not support nanosecond timestamp fields.  Instead, there were three timestamp
       fields—st_atime, st_mtime, and st_ctime—typed as time_t that recorded timestamps with one-second precision.

       Since  kernel  2.5.48,  the stat structure supports nanosecond resolution for the three file timestamp fields.  The
       nanosecond components of each timestamp are available via names of the form st_atim.tv_nsec,  if  suitable  feature
       test macros are defined.  Nanosecond timestamps were standardized in POSIX.1-2008, and, starting with version 2.12,
       glibc exposes the nanosecond component names if _POSIX_C_SOURCE is defined with the value 200809L  or  greater,  or
       _XOPEN_SOURCE  is  defined  with  the value 700 or greater.  Up to and including glibc 2.19, the definitions of the
       nanoseconds components are also defined if _BSD_SOURCE or _SVID_SOURCE is defined.  If none of  the  aforementioned
       macros are defined, then the nanosecond values are exposed with names of the form st_atimensec.

   C library/kernel differences
       Over  time, increases in the size of the stat structure have led to three successive versions of stat(): sys_stat()
       (slot __NR_oldstat), sys_newstat() (slot __NR_stat), and sys_stat64() (slot __NR_stat64) on 32-bit  platforms  such
       as  i386.   The  first  two  versions were already present in Linux 1.0 (albeit with different names); the last was
       added in Linux 2.4.  Similar remarks apply for fstat() and lstat().

       The kernel-internal versions of the stat structure dealt with by the different versions are, respectively:

       __old_kernel_stat
              The original structure, with rather narrow fields, and no padding.

       stat   Larger st_ino field and padding added to various parts of the structure to allow for future expansion.

       stat64 Even larger st_ino field, larger st_uid and st_gid fields to accommodate the Linux-2.4 expansion of UIDs and
              GIDs  to  32 bits, and various other enlarged fields and further padding in the structure.  (Various padding
              bytes were eventually consumed in Linux 2.6, with the advent of 32-bit device IDs and nanosecond  components
              for the timestamp fields.)

       The  glibc  stat()  wrapper function hides these details from applications, invoking the most recent version of the
       system call provided by the kernel, and repacking the returned information if required for old binaries.

       On modern 64-bit systems, life is simpler: there is a single stat() system call and the kernel deals  with  a  stat
       structure that contains fields of a sufficient size.

       The  underlying  system call employed by the glibc fstatat() wrapper function is actually called fstatat64() or, on
       some architectures, newfstatat().

EXAMPLE
       The following program calls lstat() and displays selected fields in the returned stat structure.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/sysmacros.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           printf("ID of containing device:  [%lx,%lx]\n",
                (long) major(sb.st_dev), (long) minor(sb.st_dev));

           printf("File type:                ");

           switch (sb.st_mode & S_IFMT) {
           case S_IFBLK:  printf("block device\n");            break;
           case S_IFCHR:  printf("character device\n");        break;
           case S_IFDIR:  printf("directory\n");               break;
           case S_IFIFO:  printf("FIFO/pipe\n");               break;
           case S_IFLNK:  printf("symlink\n");                 break;
           case S_IFREG:  printf("regular file\n");            break;
           case S_IFSOCK: printf("socket\n");                  break;
           default:       printf("unknown?\n");                break;
           }

           printf("I-node number:            %ld\n", (long) sb.st_ino);

           printf("Mode:                     %lo (octal)\n",
                   (unsigned long) sb.st_mode);

           printf("Link count:               %ld\n", (long) sb.st_nlink);
           printf("Ownership:                UID=%ld   GID=%ld\n",
                   (long) sb.st_uid, (long) sb.st_gid);

           printf("Preferred I/O block size: %ld bytes\n",
                   (long) sb.st_blksize);
           printf("File size:                %lld bytes\n",
                   (long long) sb.st_size);
           printf("Blocks allocated:         %lld\n",
                   (long long) sb.st_blocks);

           printf("Last status change:       %s", ctime(&sb.st_ctime));
           printf("Last file access:         %s", ctime(&sb.st_atime));
           printf("Last file modification:   %s", ctime(&sb.st_mtime));

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ls(1), stat(1), access(2), chmod(2), chown(2), readlink(2), utime(2), capabilities(7), inode(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 STAT(2)
</pre>
<pre zoom>
<span xsmall>2 oldlstat</span>
STAT(2)                                          Linux Programmer's Manual                                         STAT(2)

NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       int fstat(int fd, struct stat *statbuf);
       int lstat(const char *pathname, struct stat *statbuf);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
                   int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       lstat():
           /* glibc 2.19 and earlier */ _BSD_SOURCE
               || /* Since glibc 2.20 */ _DEFAULT_SOURCE
               || _XOPEN_SOURCE >= 500
               || /* Since glibc 2.10: */ _POSIX_C_SOURCE >= 200112L

       fstatat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  functions return information about a file, in the buffer pointed to by statbuf.  No permissions are required
       on the file itself, but—in the case of stat(), fstatat(), and lstat()—execute (search) permission  is  required  on
       all of the directories in pathname that lead to the file.

       stat()  and fstatat() retrieve information about the file pointed to by pathname; the differences for fstatat() are
       described below.

       lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information  about  the
       link itself, not the file that it refers to.

       fstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the
       file descriptor fd.

   The stat structure
       All of these system calls return a stat structure, which contains the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

       Note: the order of fields in the stat structure varies somewhat across architectures.  In addition, the  definition
       above  does  not  show the padding bytes that may be present between some fields on various architectures.  Consult
       the glibc and kernel source code if you need to know the details.

       Note: for performance and simplicity reasons, different fields in the stat structure may contain state  information
       from  different  moments  during the execution of the system call.  For example, if st_mode or st_uid is changed by
       another process by calling chmod(2) or chown(2), stat() might return the old st_mode together with the new  st_uid,
       or the old st_uid together with the new st_mode.

       The fields in the stat structure are as follows:

       st_dev This field describes the device on which this file resides.  (The major(3) and minor(3) macros may be useful
              to decompose the device ID in this field.)

       st_ino This field contains the file's inode number.

       st_mode
              This field contains the file type and mode.  See inode(7) for further information.

       st_nlink
              This field contains the number of hard links to the file.

       st_uid This field contains the user ID of the owner of the file.

       st_gid This field contains the ID of the group owner of the file.

       st_rdev
              This field describes the device that this file (inode) represents.

       st_size
              This field gives the size of the file (if it is a regular file or a symbolic link) in bytes.  The size of  a
              symbolic link is the length of the pathname it contains, without a terminating null byte.

       st_blksize
              This field gives the "preferred" block size for efficient filesystem I/O.

       st_blocks
              This  field  indicates  the number of blocks allocated to the file, in 512-byte units.  (This may be smaller
              than st_size/512 when the file has holes.)

       st_atime
              This is the file's last access timestamp.

       st_mtime
              This is the file's last modification timestamp.

       st_ctime
              This is the file's last status change timestamp.

       For further information on the above fields, see inode(7).

   fstatat()
       The fstatat() system call is a more general interface for  accessing  file  information  which  can  still  provide
       exactly the behavior of each of stat(), lstat(), and fstat().

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       stat() and lstat() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like stat() and lstat()).

       If pathname is absolute, then dirfd is ignored.

       flags can either be 0, or include one or more of the following flags ORed:

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2) O_PATH flag).  In this case, dirfd can refer to any type of file, not just a directory, and the
              behavior of fstatat() is similar to that of fstat().  If dirfd is AT_FDCWD, the call operates on the current
              working directory.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.

       AT_NO_AUTOMOUNT (since Linux 2.6.38)
              Don't  automount  the  terminal ("basename") component of pathname if it is a directory that is an automount
              point.  This allows the caller to gather attributes of an automount point (rather than the location it would
              mount).   Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand directory such as used
              for automounter indirect maps.  This flag can be used in tools that scan directories to  prevent  mass-auto‐
              mounting  of a directory of automount points.  The AT_NO_AUTOMOUNT flag has no effect if the mount point has
              already been mounted over.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.   Both
              stat() and lstat() act as though AT_NO_AUTOMOUNT was set.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a  symbolic link, do not dereference it: instead return information about the link itself,
              like lstat().  (By default, fstatat() dereferences symbolic links, like stat().)

       See openat(2) for an explanation of the need for fstatat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Search permission is denied for one of the directories in the path prefix of pathname.  (See also path_reso‐
              lution(7).)

       EBADF  fd is not a valid open file descriptor.

       EFAULT Bad address.

       ELOOP  Too many symbolic links encountered while traversing the path.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A  component  of pathname does not exist, or pathname is an empty string and AT_EMPTY_PATH was not specified
              in flags.

       ENOMEM Out of memory (i.e., kernel memory).

       ENOTDIR
              A component of the path prefix of pathname is not a directory.

       EOVERFLOW
              pathname or fd refers to a file whose size, inode number, or number of  blocks  cannot  be  represented  in,
              respectively,  the  types off_t, ino_t, or blkcnt_t.  This error can occur when, for example, an application
              compiled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 calls stat()  on  a  file  whose  size  exceeds
              (1<<31)-1 bytes.

       The following additional errors can occur for fstatat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fstatat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       stat(), fstat(), lstat(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.

       fstatat(): POSIX.1-2008.

       According  to  POSIX.1-2001, lstat() on a symbolic link need return valid information only in the st_size field and
       the file type of the st_mode field of the stat  structure.   POSIX.1-2008  tightens  the  specification,  requiring
       lstat() to return valid information in all fields except the mode bits in st_mode.

       Use of the st_blocks and st_blksize fields may be less portable.  (They were introduced in BSD.  The interpretation
       differs between systems, and possibly on a single system when NFS mounts are involved.)

NOTES
   Timestamp fields
       Older kernels and older standards did not support nanosecond timestamp fields.  Instead, there were three timestamp
       fields—st_atime, st_mtime, and st_ctime—typed as time_t that recorded timestamps with one-second precision.

       Since  kernel  2.5.48,  the stat structure supports nanosecond resolution for the three file timestamp fields.  The
       nanosecond components of each timestamp are available via names of the form st_atim.tv_nsec,  if  suitable  feature
       test macros are defined.  Nanosecond timestamps were standardized in POSIX.1-2008, and, starting with version 2.12,
       glibc exposes the nanosecond component names if _POSIX_C_SOURCE is defined with the value 200809L  or  greater,  or
       _XOPEN_SOURCE  is  defined  with  the value 700 or greater.  Up to and including glibc 2.19, the definitions of the
       nanoseconds components are also defined if _BSD_SOURCE or _SVID_SOURCE is defined.  If none of  the  aforementioned
       macros are defined, then the nanosecond values are exposed with names of the form st_atimensec.

   C library/kernel differences
       Over  time, increases in the size of the stat structure have led to three successive versions of stat(): sys_stat()
       (slot __NR_oldstat), sys_newstat() (slot __NR_stat), and sys_stat64() (slot __NR_stat64) on 32-bit  platforms  such
       as  i386.   The  first  two  versions were already present in Linux 1.0 (albeit with different names); the last was
       added in Linux 2.4.  Similar remarks apply for fstat() and lstat().

       The kernel-internal versions of the stat structure dealt with by the different versions are, respectively:

       __old_kernel_stat
              The original structure, with rather narrow fields, and no padding.

       stat   Larger st_ino field and padding added to various parts of the structure to allow for future expansion.

       stat64 Even larger st_ino field, larger st_uid and st_gid fields to accommodate the Linux-2.4 expansion of UIDs and
              GIDs  to  32 bits, and various other enlarged fields and further padding in the structure.  (Various padding
              bytes were eventually consumed in Linux 2.6, with the advent of 32-bit device IDs and nanosecond  components
              for the timestamp fields.)

       The  glibc  stat()  wrapper function hides these details from applications, invoking the most recent version of the
       system call provided by the kernel, and repacking the returned information if required for old binaries.

       On modern 64-bit systems, life is simpler: there is a single stat() system call and the kernel deals  with  a  stat
       structure that contains fields of a sufficient size.

       The  underlying  system call employed by the glibc fstatat() wrapper function is actually called fstatat64() or, on
       some architectures, newfstatat().

EXAMPLE
       The following program calls lstat() and displays selected fields in the returned stat structure.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/sysmacros.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           printf("ID of containing device:  [%lx,%lx]\n",
                (long) major(sb.st_dev), (long) minor(sb.st_dev));

           printf("File type:                ");

           switch (sb.st_mode & S_IFMT) {
           case S_IFBLK:  printf("block device\n");            break;
           case S_IFCHR:  printf("character device\n");        break;
           case S_IFDIR:  printf("directory\n");               break;
           case S_IFIFO:  printf("FIFO/pipe\n");               break;
           case S_IFLNK:  printf("symlink\n");                 break;
           case S_IFREG:  printf("regular file\n");            break;
           case S_IFSOCK: printf("socket\n");                  break;
           default:       printf("unknown?\n");                break;
           }

           printf("I-node number:            %ld\n", (long) sb.st_ino);

           printf("Mode:                     %lo (octal)\n",
                   (unsigned long) sb.st_mode);

           printf("Link count:               %ld\n", (long) sb.st_nlink);
           printf("Ownership:                UID=%ld   GID=%ld\n",
                   (long) sb.st_uid, (long) sb.st_gid);

           printf("Preferred I/O block size: %ld bytes\n",
                   (long) sb.st_blksize);
           printf("File size:                %lld bytes\n",
                   (long long) sb.st_size);
           printf("Blocks allocated:         %lld\n",
                   (long long) sb.st_blocks);

           printf("Last status change:       %s", ctime(&sb.st_ctime));
           printf("Last file access:         %s", ctime(&sb.st_atime));
           printf("Last file modification:   %s", ctime(&sb.st_mtime));

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ls(1), stat(1), access(2), chmod(2), chown(2), readlink(2), utime(2), capabilities(7), inode(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 STAT(2)
</pre>
<pre zoom>
<span xsmall>2 sched_getattr</span>
SCHED_SETATTR(2)                                 Linux Programmer's Manual                                SCHED_SETATTR(2)

NAME
       sched_setattr, sched_getattr - set and get scheduling policy and attributes

SYNOPSIS
       #include <sched.h>

       int sched_setattr(pid_t pid, struct sched_attr *attr,
                         unsigned int flags);

       int sched_getattr(pid_t pid, struct sched_attr *attr,
                         unsigned int size, unsigned int flags);

DESCRIPTION
   sched_setattr()
       The  sched_setattr()  system  call  sets the scheduling policy and associated attributes for the thread whose ID is
       specified in pid.  If pid equals zero, the scheduling policy and attributes of the calling thread will be set.

       Currently, Linux supports the following "normal" (i.e., non-real-time) scheduling policies as values  that  may  be
       specified in policy:

       SCHED_OTHER   the standard round-robin time-sharing policy;

       SCHED_BATCH   for "batch" style execution of processes; and

       SCHED_IDLE    for running very low priority background jobs.

       Various  "real-time"  policies are also supported, for special time-critical applications that need precise control
       over the way in which runnable threads are selected for execution.  For the rules governing when a process may  use
       these policies, see sched(7).  The real-time policies that may be specified in policy are:

       SCHED_FIFO    a first-in, first-out policy; and

       SCHED_RR      a round-robin policy.

       Linux also provides the following policy:

       SCHED_DEADLINE
                     a deadline scheduling policy; see sched(7) for details.

       The  attr argument is a pointer to a structure that defines the new scheduling policy and attributes for the speci‐
       fied thread.  This structure has the following form:

           struct sched_attr {
               u32 size;              /* Size of this structure */
               u32 sched_policy;      /* Policy (SCHED_*) */
               u64 sched_flags;       /* Flags */
               s32 sched_nice;        /* Nice value (SCHED_OTHER,
                                         SCHED_BATCH) */
               u32 sched_priority;    /* Static priority (SCHED_FIFO,
                                         SCHED_RR) */
               /* Remaining fields are for SCHED_DEADLINE */
               u64 sched_runtime;
               u64 sched_deadline;
               u64 sched_period;
           };

       The fields of this structure are as follows:

       size   This field should be set to the size of the structure in bytes, as in  sizeof(struct  sched_attr).   If  the
              provided  structure  is  smaller than the kernel structure, any additional fields are assumed to be '0'.  If
              the provided structure is larger than the kernel structure, the kernel verifies that all  additional  fields
              are  0;  if they are not, sched_setattr() fails with the error E2BIG and updates size to contain the size of
              the kernel structure.

              The above behavior when the size of the user-space sched_attr structure does not match the size of the  ker‐
              nel  structure  allows for future extensibility of the interface.  Malformed applications that pass oversize
              structures won't break in the future if the size of the kernel sched_attr structure is  increased.   In  the
              future,  it could also allow applications that know about a larger user-space sched_attr structure to deter‐
              mine whether they are running on an older kernel that does not support the larger structure.

       sched_policy
              This field specifies the scheduling policy, as one of the SCHED_* values listed above.

       sched_flags
              This field contains flags controlling scheduling  behavior.   Only  one  such  flag  is  currently  defined:
              SCHED_FLAG_RESET_ON_FORK.   As  a  result of including this flag, children created by fork(2) do not inherit
              privileged scheduling policies.  See sched(7) for details.

       sched_nice
              This field specifies the nice value to be set when specifying sched_policy as  SCHED_OTHER  or  SCHED_BATCH.
              The nice value is a number in the range -20 (high priority) to +19 (low priority); see sched(7).

       sched_priority
              This  field  specifies the static priority to be set when specifying sched_policy as SCHED_FIFO or SCHED_RR.
              The allowed range of priorities for these policies can be  determined  using  sched_get_priority_min(2)  and
              sched_get_priority_max(2).  For other policies, this field must be specified as 0.

       sched_runtime
              This  field  specifies  the "Runtime" parameter for deadline scheduling.  The value is expressed in nanosec‐
              onds.  This field, and the next two fields,  are  used  only  for  SCHED_DEADLINE  scheduling;  for  further
              details, see sched(7).

       sched_deadline
              This  field  specifies the "Deadline" parameter for deadline scheduling.  The value is expressed in nanosec‐
              onds.

       sched_period
              This field specifies the "Period" parameter for deadline scheduling.  The value is expressed in nanoseconds.

       The flags argument is provided to allow for future extensions to the interface; in the  current  implementation  it
       must be specified as 0.

   sched_getattr()
       The sched_getattr() system call fetches the scheduling policy and the associated attributes for the thread whose ID
       is specified in pid.  If pid equals zero, the scheduling policy and  attributes  of  the  calling  thread  will  be
       retrieved.

       The  size argument should be set to the size of the sched_attr structure as known to user space.  The value must be
       at least as large as the size of the initially published sched_attr structure, or the call  fails  with  the  error
       EINVAL.

       The  retrieved  scheduling attributes are placed in the fields of the sched_attr structure pointed to by attr.  The
       kernel sets attr.size to the size of its sched_attr structure.

       If the caller-provided attr buffer is larger than the kernel's sched_attr structure, the additional  bytes  in  the
       user-space  structure  are  not  touched.   If  the caller-provided structure is smaller than the kernel sched_attr
       structure and the kernel needs to return values outside the provided space, sched_getattr() fails  with  the  error
       E2BIG.  As with sched_setattr(), these semantics allow for future extensibility of the interface.

       The  flags  argument  is provided to allow for future extensions to the interface; in the current implementation it
       must be specified as 0.

RETURN VALUE
       On success, sched_setattr() and sched_getattr() return 0.  On error, -1 is returned, and errno is set  to  indicate
       the cause of the error.

ERRORS
       sched_getattr() and sched_setattr() can both fail for the following reasons:

       EINVAL attr is NULL; or pid is negative; or flags is not zero.

       ESRCH  The thread whose ID is pid could not be found.

       In addition, sched_getattr() can fail for the following reasons:

       E2BIG  The buffer specified by size and attr is too small.

       EINVAL size  is  invalid; that is, it is smaller than the initial version of the sched_attr structure (48 bytes) or
              larger than the system page size.

       In addition, sched_setattr() can fail for the following reasons:

       E2BIG  The buffer specified by size and attr is larger than the kernel structure, and one or  more  of  the  excess
              bytes is nonzero.

       EBUSY  SCHED_DEADLINE admission control failure, see sched(7).

       EINVAL attr.sched_policy  is  not  one  of  the  recognized  policies;  attr.sched_flags contains a flag other than
              SCHED_FLAG_RESET_ON_FORK; or attr.sched_priority is invalid; or attr.sched_policy is SCHED_DEADLINE and  the
              deadline scheduling parameters in attr are invalid.

       EPERM  The caller does not have appropriate privileges.

       EPERM  The  CPU  affinity  mask  of  the  thread  specified  by  pid  does  not include all CPUs in the system (see
              sched_setaffinity(2)).

VERSIONS
       These system calls first appeared in Linux 3.14.

CONFORMING TO
       These system calls are nonstandard Linux extensions.

NOTES
       sched_setattr() provides a superset of the functionality of sched_setscheduler(2), sched_setparam(2), nice(2),  and
       (other  than  the  ability to set the priority of all processes belonging to a specified user or all processes in a
       specified group) setpriority(2).   Analogously,  sched_getattr()  provides  a  superset  of  the  functionality  of
       sched_getscheduler(2), sched_getparam(2), and (partially) getpriority(2).

BUGS
       In Linux versions up to 3.15, sched_settattr() failed with the error EFAULT instead of E2BIG for the case described
       in ERRORS.

SEE ALSO
       chrt(1), nice(2), sched_get_priority_max(2), sched_get_priority_min(2), sched_getaffinity(2), sched_getparam(2),
       sched_getscheduler(2), sched_rr_get_interval(2), sched_setaffinity(2), sched_setparam(2), sched_setscheduler(2),
       sched_yield(2), setpriority(2), pthread_getschedparam(3), pthread_setschedparam(3), pthread_setschedprio(3),
       capabilities(7), cpuset(7), sched(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        SCHED_SETATTR(2)
</pre>
<pre zoom>
<span xsmall>2 outw_p</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 write</span>
WRITE(2)                                         Linux Programmer's Manual                                        WRITE(2)

NAME
       write - write to a file descriptor

SYNOPSIS
       #include <unistd.h>

       ssize_t write(int fd, const void *buf, size_t count);

DESCRIPTION
       write() writes up to count bytes from the buffer starting at buf to the file referred to by the file descriptor fd.

       The  number  of bytes written may be less than count if, for example, there is insufficient space on the underlying
       physical medium, or the RLIMIT_FSIZE resource limit is encountered (see setrlimit(2)), or the call was  interrupted
       by a signal handler after having written less than count bytes.  (See also pipe(7).)

       For  a  seekable file (i.e., one to which lseek(2) may be applied, for example, a regular file) writing takes place
       at the file offset, and the file offset is incremented by the number of bytes actually written.  If  the  file  was
       open(2)ed with O_APPEND, the file offset is first set to the end of the file before writing.  The adjustment of the
       file offset and the write operation are performed as an atomic step.

       POSIX requires that a read(2) that can be proved to occur after a write() has returned will return  the  new  data.
       Note that not all filesystems are POSIX conforming.

       According  to  POSIX.1, if count is greater than SSIZE_MAX, the result is implementation-defined; see NOTES for the
       upper limit on Linux.

RETURN VALUE
       On success, the number of bytes written is returned (zero indicates nothing was written).  It is not  an  error  if
       this  number is smaller than the number of bytes requested; this may happen for example because the disk device was
       filled.  See also NOTES.

       On error, -1 is returned, and errno is set appropriately.

       If count is zero and fd refers to a regular file, then write() may return a failure status if  one  of  the  errors
       below  is  detected.   If  no  errors are detected, or error detection is not performed, 0 will be returned without
       causing any other effect.  If count is zero and fd refers to a file other than a regular file, the results are  not
       specified.

ERRORS
       EAGAIN The  file  descriptor  fd refers to a file other than a socket and has been marked nonblocking (O_NONBLOCK),
              and the write would block.  See open(2) for further details on the O_NONBLOCK flag.

       EAGAIN or EWOULDBLOCK
              The file descriptor fd refers to a socket and has been marked nonblocking (O_NONBLOCK), and the write  would
              block.   POSIX.1-2001 allows either error to be returned for this case, and does not require these constants
              to have the same value, so a portable application should check for both possibilities.

       EBADF  fd is not a valid file descriptor or is not open for writing.

       EDESTADDRREQ
              fd refers to a datagram socket for which a peer address has not been set using connect(2).

       EDQUOT The user's quota of disk blocks on the filesystem containing the file referred to by fd has been exhausted.

       EFAULT buf is outside your accessible address space.

       EFBIG  An attempt was made to write a file that  exceeds  the  implementation-defined  maximum  file  size  or  the
              process's file size limit, or to write at a position past the maximum allowed offset.

       EINTR  The call was interrupted by a signal before any data was written; see signal(7).

       EINVAL fd  is attached to an object which is unsuitable for writing; or the file was opened with the O_DIRECT flag,
              and either the address specified in buf, the value specified in count, or the file offset  is  not  suitably
              aligned.

       EIO    A  low-level  I/O error occurred while modifying the inode.  This error may relate to the write-back of data
              written by an earlier write(2), which may have been issued to a different file descriptor on the same  file.
              Since  Linux  4.13,  errors  from  write-back  come  with a promise that they may be reported by subsequent.
              write(2) requests, and will be reported by a subsequent fsync(2) (whether or not they were also reported  by
              write(2)).   An  alternate cause of EIO on networked filesystems is when an advisory lock had been taken out
              on the file descriptor and this lock has been lost.  See the Lost locks  section  of  fcntl(2)  for  further
              details.

       ENOSPC The device containing the file referred to by fd has no room for the data.

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       EPIPE  fd is connected to a pipe or socket whose reading end is closed.  When this happens the writing process will
              also receive a SIGPIPE signal.  (Thus, the write return value is seen only if the program catches, blocks or
              ignores this signal.)

       Other errors may occur, depending on the object connected to fd.

CONFORMING TO
       SVr4, 4.3BSD, POSIX.1-2001.

       Under SVr4 a write may be interrupted and return EINTR at any point, not just before any data is written.

NOTES
       The types size_t and ssize_t are, respectively, unsigned and signed integer data types specified by POSIX.1.

       A  successful  return  from  write()  does  not  make  any guarantee that data has been committed to disk.  On some
       filesystems, including NFS, it does not even guarantee that space has successfully been reserved for the data.   In
       this  case,  some  errors might be delayed until a future write(2), fsync(2), or even close(2).  The only way to be
       sure is to call fsync(2) after you are done writing all your data.

       If a write() is interrupted by a signal handler before any bytes are written, then the call fails  with  the  error
       EINTR;  if it is interrupted after at least one byte has been written, the call succeeds, and returns the number of
       bytes written.

       On Linux, write() (and similar system calls) will transfer at most 0x7ffff000 (2,147,479,552) bytes, returning  the
       number of bytes actually transferred.  (This is true on both 32-bit and 64-bit systems.)

BUGS
       According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 ("Thread Interactions with Regular File Operations"):

           All  of  the  following  functions  shall  be  atomic  with  respect  to each other in the effects specified in
           POSIX.1-2008 when they operate on regular files or symbolic links: ...

       Among the APIs subsequently listed are write() and writev(2).  And among the effects that should be  atomic  across
       threads  (and  processes)  are updates of the file offset.  However, on Linux before version 3.14, this was not the
       case: if two processes that share an open file description (see open(2)) perform a write() (or  writev(2))  at  the
       same  time, then the I/O operations were not atomic with respect updating the file offset, with the result that the
       blocks of data output by the two processes might (incorrectly) overlap.  This problem was fixed in Linux 3.14.

SEE ALSO
       close(2), fcntl(2), fsync(2), ioctl(2), lseek(2), open(2), pwrite(2), read(2), select(2), writev(2), fwrite(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-02-02                                                WRITE(2)
</pre>
<pre zoom>
<span xsmall>2 unimplemented</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 inw_p</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 set_thread_area</span>
SET_THREAD_AREA(2)                               Linux Programmer's Manual                              SET_THREAD_AREA(2)

NAME
       get_thread_area, set_thread_area - set a GDT entry for thread-local storage

SYNOPSIS
       #include <linux/unistd.h>
       #include <asm/ldt.h>

       int get_thread_area(struct user_desc *u_info);
       int set_thread_area(struct user_desc *u_info);

       Note: There are no glibc wrappers for these system calls; see NOTES.

DESCRIPTION
       Linux  dedicates  three global descriptor table (GDT) entries for thread-local storage.  For more information about
       the GDT, see the Intel Software Developer's Manual or the AMD Architecture Programming Manual.

       Both of these system calls take an argument that is a pointer to a structure of the following type:

           struct user_desc {
               unsigned int  entry_number;
               unsigned long base_addr;
               unsigned int  limit;
               unsigned int  seg_32bit:1;
               unsigned int  contents:2;
               unsigned int  read_exec_only:1;
               unsigned int  limit_in_pages:1;
               unsigned int  seg_not_present:1;
               unsigned int  useable:1;
           };

       get_thread_area() reads the GDT entry indicated by u_info->entry_number and fills in the  rest  of  the  fields  in
       u_info.

       set_thread_area() sets a TLS entry in the GDT.

       The  TLS  array  entry  set  by set_thread_area() corresponds to the value of u_info->entry_number passed in by the
       user.  If this value is in bounds, set_thread_area() writes the TLS  descriptor  pointed  to  by  u_info  into  the
       thread's TLS array.

       When  set_thread_area()  is  passed  an entry_number of -1, it searches for a free TLS entry.  If set_thread_area()
       finds a free TLS entry, the value of u_info->entry_number is set upon return to show which entry was changed.

       A user_desc is considered "empty" if read_exec_only and seg_not_present are set to 1 and all of  the  other  fields
       are  0.   If  an "empty" descriptor is passed to set_thread_area, the corresponding TLS entry will be cleared.  See
       BUGS for additional details.

       Since Linux 3.19, set_thread_area() cannot be used to write non-present segments, 16-bit  segments,  or  code  seg‐
       ments, although clearing a segment is still acceptable.

RETURN VALUE
       These system calls return 0 on success, and -1 on failure, with errno set appropriately.

ERRORS
       EFAULT u_info is an invalid pointer.

       EINVAL u_info->entry_number is out of bounds.

       ENOSYS get_thread_area() or set_thread_area() was invoked as a 64-bit system call.

       ESRCH  (set_thread_area()) A free TLS entry could not be located.

VERSIONS
       set_thread_area() first appeared in Linux 2.5.29.  get_thread_area() first appeared in Linux 2.5.32.

CONFORMING TO
       set_thread_area() is Linux-specific and should not be used in programs that are intended to be portable.

NOTES
       Glibc does not provide wrappers for these system calls, since they are generally intended for use only by threading
       libraries.  In the unlikely event that you want to call them directly, use syscall(2).

       arch_prctl(2) can interfere with set_thread_area().  See arch_prctl(2) for more details.  This is  not  normally  a
       problem, as arch_prctl(2) is normally used only by 64-bit programs.

BUGS
       On  64-bit  kernels  before  Linux 3.19, one of the padding bits in user_desc, if set, would prevent the descriptor
       from being considered empty (see modify_ldt(2)).  As a result, the only reliable way to clear a TLS entry is to use
       memset(3)  to  zero  the entire user_desc structure, including padding bits, and then to set the read_exec_only and
       seg_not_present bits.  On Linux 3.19, a user_desc consisting entirely of zeros except for entry_number will also be
       interpreted as a request to clear a TLS entry, but this behaved differently on older kernels.

       Prior to Linux 3.19, the DS and ES segment registers must not reference TLS entries.

SEE ALSO
       arch_prctl(2), modify_ldt(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                      SET_THREAD_AREA(2)
</pre>
<pre zoom>
<span xsmall>2 mkdirat</span>
MKDIR(2)                                         Linux Programmer's Manual                                        MKDIR(2)

NAME
       mkdir, mkdirat - create a directory

SYNOPSIS
       #include <sys/stat.h>
       #include <sys/types.h>

       int mkdir(const char *pathname, mode_t mode);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int mkdirat(int dirfd, const char *pathname, mode_t mode);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       mkdirat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       mkdir() attempts to create a directory named pathname.

       The  argument  mode specifies the mode for the new directory (see inode(7)).  It is modified by the process's umask
       in the usual way: in the absence of a default ACL, the mode of the created directory is (mode  &  ~umask  &  0777).
       Whether  other  mode  bits  are  honored for the created directory depends on the operating system.  For Linux, see
       NOTES below.

       The newly created directory will be owned by the effective user ID of the process.  If the directory containing the
       file has the set-group-ID bit set, or if the filesystem is mounted with BSD group semantics (mount -o bsdgroups or,
       synonymously mount -o grpid), the new directory will inherit the group ownership from its parent; otherwise it will
       be owned by the effective group ID of the process.

       If the parent directory has the set-group-ID bit set, then so will the newly created directory.

   mkdirat()
       The mkdirat() system call operates in exactly the same way as mkdir(), except for the differences described here.

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       mkdir() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like mkdir()).

       If pathname is absolute, then dirfd is ignored.

       See openat(2) for an explanation of the need for mkdirat().

RETURN VALUE
       mkdir() and mkdirat() return zero on success, or -1 if an error occurred (in which case,  errno  is  set  appropri‐
       ately).

ERRORS
       EACCES The  parent  directory does not allow write permission to the process, or one of the directories in pathname
              did not allow search permission.  (See also path_resolution(7).)

       EDQUOT The user's quota of disk blocks or inodes on the filesystem has been exhausted.

       EEXIST pathname already exists (not necessarily as a directory).  This includes the case where pathname is  a  sym‐
              bolic link, dangling or not.

       EFAULT pathname points outside your accessible address space.

       EINVAL The  final  component  ("basename") of the new directory's pathname is invalid (e.g., it contains characters
              not permitted by the underlying filesystem).

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       EMLINK The number of links to the parent directory would exceed LINK_MAX.

       ENAMETOOLONG
              pathname was too long.

       ENOENT A directory component in pathname does not exist or is a dangling symbolic link.

       ENOMEM Insufficient kernel memory was available.

       ENOSPC The device containing pathname has no room for the new directory.

       ENOSPC The new directory cannot be created because the user's disk quota is exhausted.

       ENOTDIR
              A component used as a directory in pathname is not, in fact, a directory.

       EPERM  The filesystem containing pathname does not support the creation of directories.

       EROFS  pathname refers to a file on a read-only filesystem.

       The following additional errors can occur for mkdirat():

       EBADF  dirfd is not a valid file descriptor.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       mkdirat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       mkdir(): SVr4, BSD, POSIX.1-2001, POSIX.1-2008.

       mkdirat(): POSIX.1-2008.

NOTES
       Under Linux, apart from the permission bits, the S_ISVTX mode bit is also honored.

       There are many infelicities in the protocol underlying NFS.  Some of these affect mkdir().

   Glibc notes
       On older kernels where mkdirat() is unavailable, the glibc wrapper function falls back to the use of mkdir().  When
       pathname  is a relative pathname, glibc constructs a pathname based on the symbolic link in /proc/self/fd that cor‐
       responds to the dirfd argument.

SEE ALSO
       mkdir(1), chmod(2), chown(2), mknod(2), mount(2), rmdir(2), stat(2), umask(2), unlink(2), acl(5) path_resolution(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                MKDIR(2)
</pre>
<pre zoom>
<span xsmall>2 sync_file_range2</span>
SYNC_FILE_RANGE(2)                               Linux Programmer's Manual                              SYNC_FILE_RANGE(2)

NAME
       sync_file_range - sync a file segment with disk

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <fcntl.h>

       int sync_file_range(int fd, off64_t offset, off64_t nbytes,
                           unsigned int flags);

DESCRIPTION
       sync_file_range()  permits fine control when synchronizing the open file referred to by the file descriptor fd with
       disk.

       offset is the starting byte of the file range to be synchronized.  nbytes specifies the length of the range  to  be
       synchronized,  in bytes; if nbytes is zero, then all bytes from offset through to the end of file are synchronized.
       Synchronization is in units of the system page size: offset is rounded down to a page  boundary;  (offset+nbytes-1)
       is rounded up to a page boundary.

       The flags bit-mask argument can include any of the following values:

       SYNC_FILE_RANGE_WAIT_BEFORE
              Wait  upon  write-out  of  all  pages  in the specified range that have already been submitted to the device
              driver for write-out before performing any write.

       SYNC_FILE_RANGE_WRITE
              Initiate write-out of all dirty pages in the specified range which are not  presently  submitted  write-out.
              Note that even this may block if you attempt to write more than request queue size.

       SYNC_FILE_RANGE_WAIT_AFTER
              Wait upon write-out of all pages in the range after performing any write.

       Specifying flags as 0 is permitted, as a no-op.

   Warning
       This  system  call  is  extremely  dangerous and should not be used in portable programs.  None of these operations
       writes out the file's metadata.  Therefore, unless the application is strictly performing  overwrites  of  already-
       instantiated  disk blocks, there are no guarantees that the data will be available after a crash.  There is no user
       interface to know if a write is purely an overwrite.  On filesystems using copy-on-write semantics (e.g., btrfs) an
       overwrite  of existing allocated blocks is impossible.  When writing into preallocated space, many filesystems also
       require calls into the block allocator, which this system call does not sync out to disk.  This  system  call  does
       not  flush  disk  write  caches  and  thus  does not provide any data integrity on systems with volatile disk write
       caches.

   Some details
       SYNC_FILE_RANGE_WAIT_BEFORE and SYNC_FILE_RANGE_WAIT_AFTER will detect any I/O errors or ENOSPC conditions and will
       return these to the caller.

       Useful combinations of the flags bits are:

       SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE
              Ensures  that all pages in the specified range which were dirty when sync_file_range() was called are placed
              under write-out.  This is a start-write-for-data-integrity operation.

       SYNC_FILE_RANGE_WRITE
              Start write-out of all dirty pages in the specified range which are not presently under write-out.  This  is
              an asynchronous flush-to-disk operation.  This is not suitable for data integrity operations.

       SYNC_FILE_RANGE_WAIT_BEFORE (or SYNC_FILE_RANGE_WAIT_AFTER)
              Wait  for  completion  of  write-out of all pages in the specified range.  This can be used after an earlier
              SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE operation to wait for completion of that operation,  and
              obtain its result.

       SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_AFTER
              This  is  a  write-for-data-integrity operation that will ensure that all pages in the specified range which
              were dirty when sync_file_range() was called are committed to disk.

RETURN VALUE
       On success, sync_file_range() returns 0; on failure -1 is returned and errno is set to indicate the error.

ERRORS
       EBADF  fd is not a valid file descriptor.

       EINVAL flags specifies an invalid bit; or offset or nbytes is invalid.

       EIO    I/O error.

       ENOMEM Out of memory.

       ENOSPC Out of disk space.

       ESPIPE fd refers to something other than a regular file, a block device, or a directory.

VERSIONS
       sync_file_range() appeared on Linux in kernel 2.6.17.

CONFORMING TO
       This system call is Linux-specific, and should be avoided in portable programs.

NOTES
   sync_file_range2()
       Some architectures (e.g., PowerPC, ARM) need 64-bit arguments to be aligned in a suitable pair  of  registers.   On
       such  architectures,  the  call  signature  of sync_file_range() shown in the SYNOPSIS would force a register to be
       wasted as padding between the fd and offset arguments.  (See syscall(2) for details.)  Therefore,  these  architec‐
       tures define a different system call that orders the arguments suitably:

           int sync_file_range2(int fd, unsigned int flags,
                                off64_t offset, off64_t nbytes);

       The behavior of this system call is otherwise exactly the same as sync_file_range().

       A  system  call  with  this  signature  first  appeared  on  the  ARM  architecture  in Linux 2.6.20, with the name
       arm_sync_file_range().  It was renamed in Linux 2.6.22, when the analogous system call was added for  PowerPC.   On
       architectures  where  glibc  support  is  provided,  glibc  transparently  wraps  sync_file_range2() under the name
       sync_file_range().

SEE ALSO
       fdatasync(2), fsync(2), msync(2), sync(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                      SYNC_FILE_RANGE(2)
</pre>
<pre zoom>
<span xsmall>2 ssetmask</span>
SGETMASK(2)                                      Linux Programmer's Manual                                     SGETMASK(2)

NAME
       sgetmask, ssetmask - manipulation of signal mask (obsolete)

SYNOPSIS
       long sgetmask(void);

       long ssetmask(long newmask);

       Note: There are no glibc wrappers for these system calls; see NOTES.

DESCRIPTION
       These system calls are obsolete.  Do not use them; use sigprocmask(2) instead.

       sgetmask() returns the signal mask of the calling process.

       ssetmask()  sets the signal mask of the calling process to the value given in newmask.  The previous signal mask is
       returned.

       The signal masks dealt with by these two system calls are plain bit masks (unlike the  sigset_t  used  by  sigproc‐
       mask(2)); use sigmask(3) to create and inspect these masks.

RETURN VALUE
       sgetmask()  always successfully returns the signal mask.  ssetmask() always succeeds, and returns the previous sig‐
       nal mask.

ERRORS
       These system calls always succeed.

VERSIONS
       Since Linux 3.16, support for these system calls is optional, depending on whether the kernel was  built  with  the
       CONFIG_SGETMASK_SYSCALL option.

CONFORMING TO
       These system calls are Linux-specific.

NOTES
       Glibc  does not provide wrappers for these obsolete system calls; in the unlikely event that you want to call them,
       use syscall(2).

       These system calls are unaware of signal numbers greater than 31 (i.e., real-time signals).

       These system calls do not exist on x86-64.

       It is not possible to block SIGSTOP or SIGKILL.

SEE ALSO
       sigprocmask(2), signal(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             SGETMASK(2)
</pre>
<pre zoom>
<span xsmall>2 mincore</span>
MINCORE(2)                                       Linux Programmer's Manual                                      MINCORE(2)

NAME
       mincore - determine whether pages are resident in memory

SYNOPSIS
       #include <unistd.h>
       #include <sys/mman.h>

       int mincore(void *addr, size_t length, unsigned char *vec);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       mincore():
           Since glibc 2.19:
               _DEFAULT_SOURCE
           Glibc 2.19 and earlier:
               _BSD_SOURCE || _SVID_SOURCE

DESCRIPTION
       mincore()  returns  a  vector  that indicates whether pages of the calling process's virtual memory are resident in
       core (RAM), and so will not cause a disk access (page fault) if referenced.  The kernel returns residency  informa‐
       tion about the pages starting at the address addr, and continuing for length bytes.

       The  addr  argument  must be a multiple of the system page size.  The length argument need not be a multiple of the
       page size, but since residency information is returned for whole pages, length is effectively  rounded  up  to  the
       next multiple of the page size.  One may obtain the page size (PAGE_SIZE) using sysconf(_SC_PAGESIZE).

       The vec argument must point to an array containing at least (length+PAGE_SIZE-1) / PAGE_SIZE bytes.  On return, the
       least significant bit of each byte will be set if the corresponding page is currently resident in  memory,  and  be
       clear  otherwise.  (The settings of the other bits in each byte are undefined; these bits are reserved for possible
       later use.)  Of course the information returned in vec is only a snapshot: pages that are not locked in memory  can
       come and go at any moment, and the contents of vec may already be stale by the time this call returns.

RETURN VALUE
       On success, mincore() returns zero.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EAGAIN kernel is temporarily out of resources.

       EFAULT vec points to an invalid address.

       EINVAL addr is not a multiple of the page size.

       ENOMEM length  is  greater than (TASK_SIZE - addr).  (This could occur if a negative value is specified for length,
              since that value will be interpreted as a large unsigned integer.)  In Linux 2.6.11 and earlier,  the  error
              EINVAL was returned for this condition.

       ENOMEM addr to addr + length contained unmapped memory.

VERSIONS
       Available since Linux 2.3.99pre1 and glibc 2.2.

CONFORMING TO
       mincore() is not specified in POSIX.1, and it is not available on all UNIX implementations.

BUGS
       Before  kernel 2.6.21, mincore() did not return correct information for MAP_PRIVATE mappings, or for nonlinear map‐
       pings (established using remap_file_pages(2)).

SEE ALSO
       fincore(1), madvise(2), mlock(2), mmap(2), posix_fadvise(2), posix_madvise(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              MINCORE(2)
</pre>
<pre zoom>
<span xsmall>2 olduname</span>
UNAME(2)                                         Linux Programmer's Manual                                        UNAME(2)

NAME
       uname - get name and information about current kernel

SYNOPSIS
       #include <sys/utsname.h>

       int uname(struct utsname *buf);

DESCRIPTION
       uname()  returns  system  information  in  the  structure  pointed  to  by  buf.   The utsname struct is defined in
       <sys/utsname.h>:

           struct utsname {
               char sysname[];    /* Operating system name (e.g., "Linux") */
               char nodename[];   /* Name within "some implementation-defined
                                     network" */
               char release[];    /* Operating system release (e.g., "2.6.28") */
               char version[];    /* Operating system version */
               char machine[];    /* Hardware identifier */
           #ifdef _GNU_SOURCE
               char domainname[]; /* NIS or YP domain name */
           #endif
           };

       The length of the arrays in a struct utsname is unspecified (see NOTES); the fields are terminated by a  null  byte
       ('\0').

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT buf is not valid.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.  There is no uname() call in 4.3BSD.

       The domainname member (the NIS or YP domain name) is a GNU extension.

NOTES
       This is a system call, and the operating system presumably knows its name, release and version.  It also knows what
       hardware it runs on.  So, four of the fields of the struct are meaningful.  On the other hand, the  field  nodename
       is  meaningless:  it gives the name of the present machine in some undefined network, but typically machines are in
       more than one network and have several names.  Moreover, the kernel has no way of knowing about such things, so  it
       has to be told what to answer here.  The same holds for the additional domainname field.

       To  this end, Linux uses the system calls sethostname(2) and setdomainname(2).  Note that there is no standard that
       says that the hostname set by sethostname(2) is the same string as the nodename field of  the  struct  returned  by
       uname()  (indeed,  some  systems allow a 256-byte hostname and an 8-byte nodename), but this is true on Linux.  The
       same holds for setdomainname(2) and the domainname field.

       The length of the fields in the struct varies.  Some operating systems or libraries use a hardcoded 9 or 33  or  65
       or  257.   Other  systems use SYS_NMLN or _SYS_NMLN or UTSLEN or _UTSNAME_LENGTH.  Clearly, it is a bad idea to use
       any of these constants; just use sizeof(...).  Often 257 is chosen in order to have room for an internet hostname.

       Part of the utsname information is also accessible  via  /proc/sys/kernel/{ostype,  hostname,  osrelease,  version,
       domainname}.

   C library/kernel differences
       Over  time,  increases  in  the  size  of  the  utsname structure have led to three successive versions of uname():
       sys_olduname() (slot __NR_oldolduname), sys_uname() (slot __NR_olduname),  and  sys_newuname()  (slot  __NR_uname).
       The  first  one  used  length  9 for all fields; the second used 65; the third also uses 65 but adds the domainname
       field.  The glibc uname() wrapper function hides these details from applications, invoking the most recent  version
       of the system call provided by the kernel.

SEE ALSO
       uname(1), getdomainname(2), gethostname(2), namespaces(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                UNAME(2)
</pre>
<pre zoom>
<span xsmall>2 sync_file_range</span>
SYNC_FILE_RANGE(2)                               Linux Programmer's Manual                              SYNC_FILE_RANGE(2)

NAME
       sync_file_range - sync a file segment with disk

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <fcntl.h>

       int sync_file_range(int fd, off64_t offset, off64_t nbytes,
                           unsigned int flags);

DESCRIPTION
       sync_file_range()  permits fine control when synchronizing the open file referred to by the file descriptor fd with
       disk.

       offset is the starting byte of the file range to be synchronized.  nbytes specifies the length of the range  to  be
       synchronized,  in bytes; if nbytes is zero, then all bytes from offset through to the end of file are synchronized.
       Synchronization is in units of the system page size: offset is rounded down to a page  boundary;  (offset+nbytes-1)
       is rounded up to a page boundary.

       The flags bit-mask argument can include any of the following values:

       SYNC_FILE_RANGE_WAIT_BEFORE
              Wait  upon  write-out  of  all  pages  in the specified range that have already been submitted to the device
              driver for write-out before performing any write.

       SYNC_FILE_RANGE_WRITE
              Initiate write-out of all dirty pages in the specified range which are not  presently  submitted  write-out.
              Note that even this may block if you attempt to write more than request queue size.

       SYNC_FILE_RANGE_WAIT_AFTER
              Wait upon write-out of all pages in the range after performing any write.

       Specifying flags as 0 is permitted, as a no-op.

   Warning
       This  system  call  is  extremely  dangerous and should not be used in portable programs.  None of these operations
       writes out the file's metadata.  Therefore, unless the application is strictly performing  overwrites  of  already-
       instantiated  disk blocks, there are no guarantees that the data will be available after a crash.  There is no user
       interface to know if a write is purely an overwrite.  On filesystems using copy-on-write semantics (e.g., btrfs) an
       overwrite  of existing allocated blocks is impossible.  When writing into preallocated space, many filesystems also
       require calls into the block allocator, which this system call does not sync out to disk.  This  system  call  does
       not  flush  disk  write  caches  and  thus  does not provide any data integrity on systems with volatile disk write
       caches.

   Some details
       SYNC_FILE_RANGE_WAIT_BEFORE and SYNC_FILE_RANGE_WAIT_AFTER will detect any I/O errors or ENOSPC conditions and will
       return these to the caller.

       Useful combinations of the flags bits are:

       SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE
              Ensures  that all pages in the specified range which were dirty when sync_file_range() was called are placed
              under write-out.  This is a start-write-for-data-integrity operation.

       SYNC_FILE_RANGE_WRITE
              Start write-out of all dirty pages in the specified range which are not presently under write-out.  This  is
              an asynchronous flush-to-disk operation.  This is not suitable for data integrity operations.

       SYNC_FILE_RANGE_WAIT_BEFORE (or SYNC_FILE_RANGE_WAIT_AFTER)
              Wait  for  completion  of  write-out of all pages in the specified range.  This can be used after an earlier
              SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE operation to wait for completion of that operation,  and
              obtain its result.

       SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_AFTER
              This  is  a  write-for-data-integrity operation that will ensure that all pages in the specified range which
              were dirty when sync_file_range() was called are committed to disk.

RETURN VALUE
       On success, sync_file_range() returns 0; on failure -1 is returned and errno is set to indicate the error.

ERRORS
       EBADF  fd is not a valid file descriptor.

       EINVAL flags specifies an invalid bit; or offset or nbytes is invalid.

       EIO    I/O error.

       ENOMEM Out of memory.

       ENOSPC Out of disk space.

       ESPIPE fd refers to something other than a regular file, a block device, or a directory.

VERSIONS
       sync_file_range() appeared on Linux in kernel 2.6.17.

CONFORMING TO
       This system call is Linux-specific, and should be avoided in portable programs.

NOTES
   sync_file_range2()
       Some architectures (e.g., PowerPC, ARM) need 64-bit arguments to be aligned in a suitable pair  of  registers.   On
       such  architectures,  the  call  signature  of sync_file_range() shown in the SYNOPSIS would force a register to be
       wasted as padding between the fd and offset arguments.  (See syscall(2) for details.)  Therefore,  these  architec‐
       tures define a different system call that orders the arguments suitably:

           int sync_file_range2(int fd, unsigned int flags,
                                off64_t offset, off64_t nbytes);

       The behavior of this system call is otherwise exactly the same as sync_file_range().

       A  system  call  with  this  signature  first  appeared  on  the  ARM  architecture  in Linux 2.6.20, with the name
       arm_sync_file_range().  It was renamed in Linux 2.6.22, when the analogous system call was added for  PowerPC.   On
       architectures  where  glibc  support  is  provided,  glibc  transparently  wraps  sync_file_range2() under the name
       sync_file_range().

SEE ALSO
       fdatasync(2), fsync(2), msync(2), sync(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                      SYNC_FILE_RANGE(2)
</pre>
<pre zoom>
<span xsmall>2 kexec_load</span>
KEXEC_LOAD(2)                                    Linux Programmer's Manual                                   KEXEC_LOAD(2)

NAME
       kexec_load, kexec_file_load - load a new kernel for later execution

SYNOPSIS
       #include <linux/kexec.h>

       long kexec_load(unsigned long entry, unsigned long nr_segments,
                       struct kexec_segment *segments, unsigned long flags);

       long kexec_file_load(int kernel_fd, int initrd_fd,
                           unsigned long cmdline_len, const char *cmdline,
                           unsigned long flags);

       Note: There are no glibc wrappers for these system calls; see NOTES.

DESCRIPTION
       The kexec_load() system call loads a new kernel that can be executed later by reboot(2).

       The flags argument is a bit mask that controls the operation of the call.  The following values can be specified in
       flags:

       KEXEC_ON_CRASH (since Linux 2.6.13)
              Execute the new kernel automatically on a system crash.  This "crash kernel"  is  loaded  into  an  area  of
              reserved  memory  that  is determined at boot time using the crashkernel kernel command-line parameter.  The
              location of this reserved memory is exported to user space via the /proc/iomem file,  in  an  entry  labeled
              "Crash  kernel".   A  user-space  application can parse this file and prepare a list of segments (see below)
              that specify this reserved memory as destination.  If this flag is specified, the  kernel  checks  that  the
              target segments specified in segments fall within the reserved region.

       KEXEC_PRESERVE_CONTEXT (since Linux 2.6.27)
              Preserve  the  system  hardware and software states before executing the new kernel.  This could be used for
              system suspend.  This flag is available only if the kernel was configured  with  CONFIG_KEXEC_JUMP,  and  is
              effective only if nr_segments is greater than 0.

       The  high-order bits (corresponding to the mask 0xffff0000) of flags contain the architecture of the to-be-executed
       kernel.  Specify (OR) the constant KEXEC_ARCH_DEFAULT to use the current architecture,  or  one  of  the  following
       architecture   constants   KEXEC_ARCH_386,  KEXEC_ARCH_68K,  KEXEC_ARCH_X86_64,  KEXEC_ARCH_PPC,  KEXEC_ARCH_PPC64,
       KEXEC_ARCH_IA_64, KEXEC_ARCH_ARM, KEXEC_ARCH_S390, KEXEC_ARCH_SH,  KEXEC_ARCH_MIPS,  and  KEXEC_ARCH_MIPS_LE.   The
       architecture must be executable on the CPU of the system.

       The  entry  argument  is the physical entry address in the kernel image.  The nr_segments argument is the number of
       segments pointed to by the segments pointer; the kernel imposes an (arbitrary) limit of 16 on the  number  of  seg‐
       ments.  The segments argument is an array of kexec_segment structures which define the kernel layout:

           struct kexec_segment {
               void   *buf;        /* Buffer in user space */
               size_t  bufsz;      /* Buffer length in user space */
               void   *mem;        /* Physical address of kernel */
               size_t  memsz;      /* Physical address length */
           };

       The kernel image defined by segments is copied from the calling process into the kernel either in regular memory or
       in reserved memory (if KEXEC_ON_CRASH is set).  The kernel first performs various sanity checks on the  information
       passed in segments.  If these checks pass, the kernel copies the segment data to kernel memory.  Each segment spec‐
       ified in segments is copied as follows:

       *  buf and bufsz identify a memory region in the caller's virtual address space that is the  source  of  the  copy.
          The value in bufsz may not exceed the value in the memsz field.

       *  mem  and  memsz  specify  a physical address range that is the target of the copy.  The values specified in both
          fields must be multiples of the system page size.

       *  bufsz bytes are copied from the source buffer to the target kernel buffer.  If bufsz is less  than  memsz,  then
          the excess bytes in the kernel buffer are zeroed out.

       In  case  of a normal kexec (i.e., the KEXEC_ON_CRASH flag is not set), the segment data is loaded in any available
       memory and is moved to the final destination at kexec reboot time (e.g., when the kexec(8) command is executed with
       the -e option).

       In  case of kexec on panic (i.e., the KEXEC_ON_CRASH flag is set), the segment data is loaded to reserved memory at
       the time of the call, and, after a crash, the kexec mechanism simply passes control to that kernel.

       The kexec_load() system call is available only if the kernel was configured with CONFIG_KEXEC.

   kexec_file_load()
       The kexec_file_load() system call is similar to kexec_load(), but it takes a different set of arguments.  It  reads
       the  kernel  to  be  loaded from the file referred to by the file descriptor kernel_fd, and the initrd (initial RAM
       disk) to be loaded from file referred to by the file descriptor initrd_fd.  The cmdline argument is a pointer to  a
       buffer containing the command line for the new kernel.  The cmdline_len argument specifies size of the buffer.  The
       last byte in the buffer must be a null byte ('\0').

       The flags argument is a bit mask which modifies the behavior of the call.  The following values can be specified in
       flags:

       KEXEC_FILE_UNLOAD
              Unload the currently loaded kernel.

       KEXEC_FILE_ON_CRASH
              Load the new kernel in the memory region reserved for the crash kernel (as for KEXEC_ON_CRASH).  This kernel
              is booted if the currently running kernel crashes.

       KEXEC_FILE_NO_INITRAMFS
              Loading initrd/initramfs is optional.  Specify this flag if no initramfs is being loaded.  If this  flag  is
              set, the value passed in initrd_fd is ignored.

       The  kexec_file_load()  system  call  was  added  to  provide  support  for systems where "kexec" loading should be
       restricted to only kernels that are signed.  This system call is available only if the kernel was  configured  with
       CONFIG_KEXEC_FILE.

RETURN VALUE
       On success, these system calls returns 0.  On error, -1 is returned and errno is set to indicate the error.

ERRORS
       EADDRNOTAVAIL
              The  KEXEC_ON_CRASH  flags was specified, but the region specified by the mem and memsz fields of one of the
              segments entries lies outside the range of memory reserved for the crash kernel.

       EADDRNOTAVAIL
              The value in a mem or memsz field in one of the segments entries is not a multiple of the system page size.

       EBADF  kernel_fd or initrd_fd is not a valid file descriptor.

       EBUSY  Another crash kernel is already being loaded or a crash kernel is already in use.

       EINVAL flags is invalid.

       EINVAL The value of a bufsz field in one of the segments entries exceeds  the  value  in  the  corresponding  memsz
              field.

       EINVAL nr_segments exceeds KEXEC_SEGMENT_MAX (16).

       EINVAL Two or more of the kernel target buffers overlap.

       EINVAL The value in cmdline[cmdline_len-1] is not '\0'.

       EINVAL The file referred to by kernel_fd or initrd_fd is empty (length zero).

       ENOEXEC
              kernel_fd does not refer to an open file, or the kernel can't load this file.  Currently, the file must be a
              bzImage and contain an x86 kernel that is loadable above 4 GiB in memory (see the kernel source  file  Docu‐
              mentation/x86/boot.txt).

       ENOMEM Could not allocate memory.

       EPERM  The caller does not have the CAP_SYS_BOOT capability.

VERSIONS
       The  kexec_load()  system call first appeared in Linux 2.6.13.  The kexec_file_load() system call first appeared in
       Linux 3.17.

CONFORMING TO
       These system calls are Linux-specific.

NOTES
       Currently, there is no glibc support for these system calls.  Call them using syscall(2).

SEE ALSO
       reboot(2), syscall(2), kexec(8)

       The kernel source files Documentation/kdump/kdump.txt and Documentation/admin-guide/kernel-parameters.txt

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           KEXEC_LOAD(2)
</pre>
<pre zoom>
<span xsmall>2 mpx</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 getcpu</span>
GETCPU(2)                                        Linux Programmer's Manual                                       GETCPU(2)

NAME
       getcpu - determine CPU and NUMA node on which the calling thread is running

SYNOPSIS
       #include <linux/getcpu.h>

       int getcpu(unsigned *cpu, unsigned *node, struct getcpu_cache *tcache);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       The getcpu() system call identifies the processor and node on which the calling thread or process is currently run‐
       ning and writes them into the integers pointed to by the cpu and node arguments.  The processor is a  unique  small
       integer identifying a CPU.  The node is a unique small identifier identifying a NUMA node.  When either cpu or node
       is NULL nothing is written to the respective pointer.

       The third argument to this system call is nowadays unused, and should be specified as NULL  unless  portability  to
       Linux 2.6.23 or earlier is required (see NOTES).

       The information placed in cpu is guaranteed to be current only at the time of the call: unless the CPU affinity has
       been fixed using sched_setaffinity(2), the kernel might change the CPU at any time.  (Normally this does not happen
       because the scheduler tries to minimize movements between CPUs to keep caches hot, but it is possible.)  The caller
       must allow for the possibility that the information returned in cpu and node is no longer current by the  time  the
       call returns.

RETURN VALUE
       On success, 0 is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT Arguments point outside the calling process's address space.

VERSIONS
       getcpu() was added in kernel 2.6.19 for x86-64 and i386.

CONFORMING TO
       getcpu() is Linux-specific.

NOTES
       Linux  makes  a  best  effort  to  make this call as fast as possible.  (On some architectures, this is done via an
       implementation in the vdso(7).)  The intention of getcpu() is to allow programs to make optimizations with  per-CPU
       data or for NUMA optimization.

       Glibc does not provide a wrapper for this system call; call it using syscall(2); or use sched_getcpu(3) instead.

       The tcache argument is unused since Linux 2.6.24.  In earlier kernels, if this argument was non-NULL, then it spec‐
       ified a pointer to a caller-allocated buffer in thread-local storage that was used to provide a  caching  mechanism
       for getcpu().  Use of the cache could speed getcpu() calls, at the cost that there was a very small chance that the
       returned information would be out of date.  The caching mechanism was considered to cause problems  when  migrating
       threads between CPUs, and so the argument is now ignored.

SEE ALSO
       mbind(2), sched_setaffinity(2), set_mempolicy(2), sched_getcpu(3), cpuset(7), vdso(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               GETCPU(2)
</pre>
<pre zoom>
<span xsmall>2 utimes</span>
UTIME(2)                                         Linux Programmer's Manual                                        UTIME(2)

NAME
       utime, utimes - change file last access and modification times

SYNOPSIS
       #include <sys/types.h>
       #include <utime.h>

       int utime(const char *filename, const struct utimbuf *times);

       #include <sys/time.h>

       int utimes(const char *filename, const struct timeval times[2]);

DESCRIPTION
       Note: modern applications may prefer to use the interfaces described in utimensat(2).

       The  utime() system call changes the access and modification times of the inode specified by filename to the actime
       and modtime fields of times respectively.

       If times is NULL, then the access and modification times of the file are set to the current time.

       Changing timestamps is permitted when: either the process has appropriate privileges,  or  the  effective  user  ID
       equals the user ID of the file, or times is NULL and the process has write permission for the file.

       The utimbuf structure is:

           struct utimbuf {
               time_t actime;       /* access time */
               time_t modtime;      /* modification time */
           };

       The utime() system call allows specification of timestamps with a resolution of 1 second.

       The  utimes()  system call is similar, but the times argument refers to an array rather than a structure.  The ele‐
       ments of this array are timeval structures, which allow a precision of 1  microsecond  for  specifying  timestamps.
       The timeval structure is:

           struct timeval {
               long tv_sec;        /* seconds */
               long tv_usec;       /* microseconds */
           };

       times[0]  specifies  the new access time, and times[1] specifies the new modification time.  If times is NULL, then
       analogously to utime(), the access and modification times of the file are set to the current time.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Search permission is denied for one of the directories in the path prefix of  path  (see  also  path_resolu‐
              tion(7)).

       EACCES times is NULL, the caller's effective user ID does not match the owner of the file, the caller does not have
              write access to the file, and the caller is not privileged (Linux: does not have either the CAP_DAC_OVERRIDE
              or the CAP_FOWNER capability).

       ENOENT filename does not exist.

       EPERM  times  is  not  NULL, the caller's effective UID does not match the owner of the file, and the caller is not
              privileged (Linux: does not have the CAP_FOWNER capability).

       EROFS  path resides on a read-only filesystem.

CONFORMING TO
       utime(): SVr4, POSIX.1-2001.  POSIX.1-2008 marks utime() as obsolete.

       utimes(): 4.3BSD, POSIX.1-2001.

NOTES
       Linux does not allow changing the timestamps on an immutable file, or setting the  timestamps  to  something  other
       than the current time on an append-only file.

SEE ALSO
       chattr(1), touch(1), futimesat(2), stat(2), utimensat(2), futimens(3), futimes(3), inode(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                UTIME(2)
</pre>
<pre zoom>
<span xsmall>2 fstatat</span>
STAT(2)                                          Linux Programmer's Manual                                         STAT(2)

NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       int fstat(int fd, struct stat *statbuf);
       int lstat(const char *pathname, struct stat *statbuf);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
                   int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       lstat():
           /* glibc 2.19 and earlier */ _BSD_SOURCE
               || /* Since glibc 2.20 */ _DEFAULT_SOURCE
               || _XOPEN_SOURCE >= 500
               || /* Since glibc 2.10: */ _POSIX_C_SOURCE >= 200112L

       fstatat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  functions return information about a file, in the buffer pointed to by statbuf.  No permissions are required
       on the file itself, but—in the case of stat(), fstatat(), and lstat()—execute (search) permission  is  required  on
       all of the directories in pathname that lead to the file.

       stat()  and fstatat() retrieve information about the file pointed to by pathname; the differences for fstatat() are
       described below.

       lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information  about  the
       link itself, not the file that it refers to.

       fstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the
       file descriptor fd.

   The stat structure
       All of these system calls return a stat structure, which contains the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

       Note: the order of fields in the stat structure varies somewhat across architectures.  In addition, the  definition
       above  does  not  show the padding bytes that may be present between some fields on various architectures.  Consult
       the glibc and kernel source code if you need to know the details.

       Note: for performance and simplicity reasons, different fields in the stat structure may contain state  information
       from  different  moments  during the execution of the system call.  For example, if st_mode or st_uid is changed by
       another process by calling chmod(2) or chown(2), stat() might return the old st_mode together with the new  st_uid,
       or the old st_uid together with the new st_mode.

       The fields in the stat structure are as follows:

       st_dev This field describes the device on which this file resides.  (The major(3) and minor(3) macros may be useful
              to decompose the device ID in this field.)

       st_ino This field contains the file's inode number.

       st_mode
              This field contains the file type and mode.  See inode(7) for further information.

       st_nlink
              This field contains the number of hard links to the file.

       st_uid This field contains the user ID of the owner of the file.

       st_gid This field contains the ID of the group owner of the file.

       st_rdev
              This field describes the device that this file (inode) represents.

       st_size
              This field gives the size of the file (if it is a regular file or a symbolic link) in bytes.  The size of  a
              symbolic link is the length of the pathname it contains, without a terminating null byte.

       st_blksize
              This field gives the "preferred" block size for efficient filesystem I/O.

       st_blocks
              This  field  indicates  the number of blocks allocated to the file, in 512-byte units.  (This may be smaller
              than st_size/512 when the file has holes.)

       st_atime
              This is the file's last access timestamp.

       st_mtime
              This is the file's last modification timestamp.

       st_ctime
              This is the file's last status change timestamp.

       For further information on the above fields, see inode(7).

   fstatat()
       The fstatat() system call is a more general interface for  accessing  file  information  which  can  still  provide
       exactly the behavior of each of stat(), lstat(), and fstat().

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       stat() and lstat() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like stat() and lstat()).

       If pathname is absolute, then dirfd is ignored.

       flags can either be 0, or include one or more of the following flags ORed:

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2) O_PATH flag).  In this case, dirfd can refer to any type of file, not just a directory, and the
              behavior of fstatat() is similar to that of fstat().  If dirfd is AT_FDCWD, the call operates on the current
              working directory.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.

       AT_NO_AUTOMOUNT (since Linux 2.6.38)
              Don't  automount  the  terminal ("basename") component of pathname if it is a directory that is an automount
              point.  This allows the caller to gather attributes of an automount point (rather than the location it would
              mount).   Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand directory such as used
              for automounter indirect maps.  This flag can be used in tools that scan directories to  prevent  mass-auto‐
              mounting  of a directory of automount points.  The AT_NO_AUTOMOUNT flag has no effect if the mount point has
              already been mounted over.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.   Both
              stat() and lstat() act as though AT_NO_AUTOMOUNT was set.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a  symbolic link, do not dereference it: instead return information about the link itself,
              like lstat().  (By default, fstatat() dereferences symbolic links, like stat().)

       See openat(2) for an explanation of the need for fstatat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Search permission is denied for one of the directories in the path prefix of pathname.  (See also path_reso‐
              lution(7).)

       EBADF  fd is not a valid open file descriptor.

       EFAULT Bad address.

       ELOOP  Too many symbolic links encountered while traversing the path.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A  component  of pathname does not exist, or pathname is an empty string and AT_EMPTY_PATH was not specified
              in flags.

       ENOMEM Out of memory (i.e., kernel memory).

       ENOTDIR
              A component of the path prefix of pathname is not a directory.

       EOVERFLOW
              pathname or fd refers to a file whose size, inode number, or number of  blocks  cannot  be  represented  in,
              respectively,  the  types off_t, ino_t, or blkcnt_t.  This error can occur when, for example, an application
              compiled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 calls stat()  on  a  file  whose  size  exceeds
              (1<<31)-1 bytes.

       The following additional errors can occur for fstatat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fstatat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       stat(), fstat(), lstat(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.

       fstatat(): POSIX.1-2008.

       According  to  POSIX.1-2001, lstat() on a symbolic link need return valid information only in the st_size field and
       the file type of the st_mode field of the stat  structure.   POSIX.1-2008  tightens  the  specification,  requiring
       lstat() to return valid information in all fields except the mode bits in st_mode.

       Use of the st_blocks and st_blksize fields may be less portable.  (They were introduced in BSD.  The interpretation
       differs between systems, and possibly on a single system when NFS mounts are involved.)

NOTES
   Timestamp fields
       Older kernels and older standards did not support nanosecond timestamp fields.  Instead, there were three timestamp
       fields—st_atime, st_mtime, and st_ctime—typed as time_t that recorded timestamps with one-second precision.

       Since  kernel  2.5.48,  the stat structure supports nanosecond resolution for the three file timestamp fields.  The
       nanosecond components of each timestamp are available via names of the form st_atim.tv_nsec,  if  suitable  feature
       test macros are defined.  Nanosecond timestamps were standardized in POSIX.1-2008, and, starting with version 2.12,
       glibc exposes the nanosecond component names if _POSIX_C_SOURCE is defined with the value 200809L  or  greater,  or
       _XOPEN_SOURCE  is  defined  with  the value 700 or greater.  Up to and including glibc 2.19, the definitions of the
       nanoseconds components are also defined if _BSD_SOURCE or _SVID_SOURCE is defined.  If none of  the  aforementioned
       macros are defined, then the nanosecond values are exposed with names of the form st_atimensec.

   C library/kernel differences
       Over  time, increases in the size of the stat structure have led to three successive versions of stat(): sys_stat()
       (slot __NR_oldstat), sys_newstat() (slot __NR_stat), and sys_stat64() (slot __NR_stat64) on 32-bit  platforms  such
       as  i386.   The  first  two  versions were already present in Linux 1.0 (albeit with different names); the last was
       added in Linux 2.4.  Similar remarks apply for fstat() and lstat().

       The kernel-internal versions of the stat structure dealt with by the different versions are, respectively:

       __old_kernel_stat
              The original structure, with rather narrow fields, and no padding.

       stat   Larger st_ino field and padding added to various parts of the structure to allow for future expansion.

       stat64 Even larger st_ino field, larger st_uid and st_gid fields to accommodate the Linux-2.4 expansion of UIDs and
              GIDs  to  32 bits, and various other enlarged fields and further padding in the structure.  (Various padding
              bytes were eventually consumed in Linux 2.6, with the advent of 32-bit device IDs and nanosecond  components
              for the timestamp fields.)

       The  glibc  stat()  wrapper function hides these details from applications, invoking the most recent version of the
       system call provided by the kernel, and repacking the returned information if required for old binaries.

       On modern 64-bit systems, life is simpler: there is a single stat() system call and the kernel deals  with  a  stat
       structure that contains fields of a sufficient size.

       The  underlying  system call employed by the glibc fstatat() wrapper function is actually called fstatat64() or, on
       some architectures, newfstatat().

EXAMPLE
       The following program calls lstat() and displays selected fields in the returned stat structure.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/sysmacros.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           printf("ID of containing device:  [%lx,%lx]\n",
                (long) major(sb.st_dev), (long) minor(sb.st_dev));

           printf("File type:                ");

           switch (sb.st_mode & S_IFMT) {
           case S_IFBLK:  printf("block device\n");            break;
           case S_IFCHR:  printf("character device\n");        break;
           case S_IFDIR:  printf("directory\n");               break;
           case S_IFIFO:  printf("FIFO/pipe\n");               break;
           case S_IFLNK:  printf("symlink\n");                 break;
           case S_IFREG:  printf("regular file\n");            break;
           case S_IFSOCK: printf("socket\n");                  break;
           default:       printf("unknown?\n");                break;
           }

           printf("I-node number:            %ld\n", (long) sb.st_ino);

           printf("Mode:                     %lo (octal)\n",
                   (unsigned long) sb.st_mode);

           printf("Link count:               %ld\n", (long) sb.st_nlink);
           printf("Ownership:                UID=%ld   GID=%ld\n",
                   (long) sb.st_uid, (long) sb.st_gid);

           printf("Preferred I/O block size: %ld bytes\n",
                   (long) sb.st_blksize);
           printf("File size:                %lld bytes\n",
                   (long long) sb.st_size);
           printf("Blocks allocated:         %lld\n",
                   (long long) sb.st_blocks);

           printf("Last status change:       %s", ctime(&sb.st_ctime));
           printf("Last file access:         %s", ctime(&sb.st_atime));
           printf("Last file modification:   %s", ctime(&sb.st_mtime));

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ls(1), stat(1), access(2), chmod(2), chown(2), readlink(2), utime(2), capabilities(7), inode(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 STAT(2)
</pre>
<pre zoom>
<span xsmall>2 sched_get_priority_min</span>
SCHED_GET_PRIORITY_MAX(2)                        Linux Programmer's Manual                       SCHED_GET_PRIORITY_MAX(2)

NAME
       sched_get_priority_max, sched_get_priority_min  - get static priority range

SYNOPSIS
       #include <sched.h>

       int sched_get_priority_max(int policy);

       int sched_get_priority_min(int policy);

DESCRIPTION
       sched_get_priority_max()  returns the maximum priority value that can be used with the scheduling algorithm identi‐
       fied by policy.  sched_get_priority_min() returns the minimum priority value that can be used with  the  scheduling
       algorithm  identified  by  policy.   Supported  policy  values  are SCHED_FIFO, SCHED_RR, SCHED_OTHER, SCHED_BATCH,
       SCHED_IDLE, and SCHED_DEADLINE.  Further details about these policies can be found in sched(7).

       Processes with numerically higher priority values are scheduled before processes with  numerically  lower  priority
       values.   Thus,  the  value  returned  by  sched_get_priority_max()  will  be  greater  than  the value returned by
       sched_get_priority_min().

       Linux allows the static priority range 1 to 99 for the SCHED_FIFO and SCHED_RR policies, and the priority 0 for the
       remaining policies.  Scheduling priority ranges for the various policies are not alterable.

       The  range  of  scheduling priorities may vary on other POSIX systems, thus it is a good idea for portable applica‐
       tions to use a  virtual  priority  range  and  map  it  to  the  interval  given  by  sched_get_priority_max()  and
       sched_get_priority_min  POSIX.1  requires  a  spread  of at least 32 between the maximum and the minimum values for
       SCHED_FIFO and SCHED_RR.

       POSIX systems on which sched_get_priority_max() and sched_get_priority_min()  are  available  define  _POSIX_PRIOR‐
       ITY_SCHEDULING in <unistd.h>.

RETURN VALUE
       On success, sched_get_priority_max() and sched_get_priority_min() return the maximum/minimum priority value for the
       named scheduling policy.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EINVAL The argument policy does not identify a defined scheduling policy.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

SEE ALSO
       sched_getaffinity(2), sched_getparam(2), sched_getscheduler(2), sched_setaffinity(2), sched_setparam(2),
       sched_setscheduler(2), sched(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                               SCHED_GET_PRIORITY_MAX(2)
</pre>
<pre zoom>
<span xsmall>2 seccomp</span>
SECCOMP(2)                                       Linux Programmer's Manual                                      SECCOMP(2)

NAME
       seccomp - operate on Secure Computing state of the process

SYNOPSIS
       #include <linux/seccomp.h>
       #include <linux/filter.h>
       #include <linux/audit.h>
       #include <linux/signal.h>
       #include <sys/ptrace.h>

       int seccomp(unsigned int operation, unsigned int flags, void *args);

DESCRIPTION
       The seccomp() system call operates on the Secure Computing (seccomp) state of the calling process.

       Currently, Linux supports the following operation values:

       SECCOMP_SET_MODE_STRICT
              The  only system calls that the calling thread is permitted to make are read(2), write(2), _exit(2) (but not
              exit_group(2)), and sigreturn(2).  Other system calls result in the delivery of a  SIGKILL  signal.   Strict
              secure  computing  mode  is useful for number-crunching applications that may need to execute untrusted byte
              code, perhaps obtained by reading from a pipe or socket.

              Note that although the calling thread can no longer call sigprocmask(2), it can use  sigreturn(2)  to  block
              all  signals  apart  from SIGKILL and SIGSTOP.  This means that alarm(2) (for example) is not sufficient for
              restricting the process's execution time.  Instead, to reliably terminate the process, SIGKILL must be used.
              This  can  be  done  by  using timer_create(2) with SIGEV_SIGNAL and sigev_signo set to SIGKILL, or by using
              setrlimit(2) to set the hard limit for RLIMIT_CPU.

              This operation is available only if the kernel is configured with CONFIG_SECCOMP enabled.

              The value of flags must be 0, and args must be NULL.

              This operation is functionally identical to the call:

                  prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);

       SECCOMP_SET_MODE_FILTER
              The system calls allowed are defined by a pointer to a Berkeley Packet Filter (BPF) passed via  args.   This
              argument is a pointer to a struct sock_fprog; it can be designed to filter arbitrary system calls and system
              call arguments.  If the filter is invalid, seccomp() fails, returning EINVAL in errno.

              If fork(2) or clone(2) is allowed by the filter, any child processes will be constrained to the same  system
              call  filters  as the parent.  If execve(2) is allowed, the existing filters will be preserved across a call
              to execve(2).

              In order to use the SECCOMP_SET_MODE_FILTER operation, either the caller must have the  CAP_SYS_ADMIN  capa‐
              bility in its user namespace, or the thread must already have the no_new_privs bit set.  If that bit was not
              already set by an ancestor of this thread, the thread must make the following call:

                  prctl(PR_SET_NO_NEW_PRIVS, 1);

              Otherwise, the SECCOMP_SET_MODE_FILTER operation fails  and  returns  EACCES  in  errno.   This  requirement
              ensures  that an unprivileged process cannot apply a malicious filter and then invoke a set-user-ID or other
              privileged program using execve(2), thus potentially compromising that program.  (Such  a  malicious  filter
              might,  for  example,  cause  an  attempt to use setuid(2) to set the caller's user IDs to nonzero values to
              instead return 0 without actually making the system call.  Thus, the program might be tricked into retaining
              superuser privileges in circumstances where it is possible to influence it to do dangerous things because it
              did not actually drop privileges.)

              If prctl(2) or seccomp() is allowed by the attached  filter,  further  filters  may  be  added.   This  will
              increase  evaluation  time,  but  allows  for  further reduction of the attack surface during execution of a
              thread.

              The SECCOMP_SET_MODE_FILTER operation is available only if the kernel is configured with CONFIG_SECCOMP_FIL‐
              TER enabled.

              When flags is 0, this operation is functionally identical to the call:

                  prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, args);

              The recognized flags are:

              SECCOMP_FILTER_FLAG_TSYNC
                     When  adding  a  new filter, synchronize all other threads of the calling process to the same seccomp
                     filter tree.  A "filter tree" is the ordered list of filters attached to a thread.  (Attaching  iden‐
                     tical filters in separate seccomp() calls results in different filters from this perspective.)

                     If  any  thread  cannot synchronize to the same filter tree, the call will not attach the new seccomp
                     filter, and will fail, returning the first thread ID found that cannot synchronize.   Synchronization
                     will  fail  if another thread in the same process is in SECCOMP_MODE_STRICT or if it has attached new
                     seccomp filters to itself, diverging from the calling thread's filter tree.

              SECCOMP_FILTER_FLAG_LOG (since Linux 4.14)
                     All filter return actions except SECCOMP_RET_ALLOW should be logged.  An administrator  may  override
                     this  filter  flag  by  preventing  specific  actions from being logged via the /proc/sys/kernel/sec‐
                     comp/actions_logged file.

       SECCOMP_GET_ACTION_AVAIL (since Linux 4.14)
              Test to see if an action is supported by the kernel.  This operation is helpful to confirm that  the  kernel
              knows  of  a  more  recently  added filter return action since the kernel treats all unknown actions as SEC‐
              COMP_RET_KILL_PROCESS.

              The value of flags must be 0, and args must be a pointer to an unsigned 32-bit filter return action.

   Filters
       When adding filters via SECCOMP_SET_MODE_FILTER, args points to a filter program:

           struct sock_fprog {
               unsigned short      len;    /* Number of BPF instructions */
               struct sock_filter *filter; /* Pointer to array of
                                              BPF instructions */
           };

       Each program must contain one or more BPF instructions:

           struct sock_filter {            /* Filter block */
               __u16 code;                 /* Actual filter code */
               __u8  jt;                   /* Jump true */
               __u8  jf;                   /* Jump false */
               __u32 k;                    /* Generic multiuse field */
           };

       When executing the instructions, the BPF program operates on the system call information made available (i.e.,  use
       the BPF_ABS addressing mode) as a (read-only) buffer of the following form:

           struct seccomp_data {
               int   nr;                   /* System call number */
               __u32 arch;                 /* AUDIT_ARCH_* value
                                              (see <linux/audit.h>) */
               __u64 instruction_pointer;  /* CPU instruction pointer */
               __u64 args[6];              /* Up to 6 system call arguments */
           };

       Because  numbering  of  system calls varies between architectures and some architectures (e.g., x86-64) allow user-
       space code to use the calling conventions of multiple architectures (and the convention being used  may  vary  over
       the life of a process that uses execve(2) to execute binaries that employ the different conventions), it is usually
       necessary to verify the value of the arch field.

       It is strongly recommended to use a whitelisting approach whenever possible because such an approach is more robust
       and  simple.   A blacklist will have to be updated whenever a potentially dangerous system call is added (or a dan‐
       gerous flag or option if those are blacklisted), and it is often possible to alter the representation  of  a  value
       without altering its meaning, leading to a blacklist bypass.  See also Caveats below.

       The  arch  field  is  not  unique  for  all  calling  conventions.   The  x86-64  ABI  and  the  x32  ABI  both use
       AUDIT_ARCH_X86_64 as arch, and they run on the same processors.  Instead, the mask __X32_SYSCALL_BIT is used on the
       system call number to tell the two ABIs apart.

       This  means that in order to create a seccomp-based blacklist for system calls performed through the x86-64 ABI, it
       is necessary to not only check that arch equals AUDIT_ARCH_X86_64, but also to explicitly reject all  system  calls
       that contain __X32_SYSCALL_BIT in nr.

       The  instruction_pointer  field  provides the address of the machine-language instruction that performed the system
       call.  This might be useful in conjunction with the use of /proc/[pid]/maps to perform checks based on which region
       (mapping) of the program made the system call.  (Probably, it is wise to lock down the mmap(2) and mprotect(2) sys‐
       tem calls to prevent the program from subverting such checks.)

       When checking values from args against a blacklist, keep in mind that arguments are often silently truncated before
       being  processed, but after the seccomp check.  For example, this happens if the i386 ABI is used on an x86-64 ker‐
       nel: although the kernel will normally not look beyond the 32 lowest bits of the arguments, the values of the  full
       64-bit  registers will be present in the seccomp data.  A less surprising example is that if the x86-64 ABI is used
       to perform a system call that takes an argument of type int, the more-significant half of the argument register  is
       ignored by the system call, but visible in the seccomp data.

       A seccomp filter returns a 32-bit value consisting of two parts: the most significant 16 bits (corresponding to the
       mask defined by the constant SECCOMP_RET_ACTION_FULL) contain one of the "action" values listed  below;  the  least
       significant 16-bits (defined by the constant SECCOMP_RET_DATA) are "data" to be associated with this return value.

       If  multiple  filters  exist, they are all executed, in reverse order of their addition to the filter tree—that is,
       the most recently installed filter is executed first.  (Note that all filters will be called even  if  one  of  the
       earlier  filters returns SECCOMP_RET_KILL.  This is done to simplify the kernel code and to provide a tiny speed-up
       in the execution of sets of filters by avoiding a check for this uncommon case.)  The return value for the  evalua‐
       tion of a given system call is the first-seen action value of highest precedence (along with its accompanying data)
       returned by execution of all of the filters.

       In decreasing order of precedence, the action values that may be returned by a seccomp filter are:

       SECCOMP_RET_KILL_PROCESS (since Linux 4.14)
              This value results in immediate termination of the process, with a core dump.  The system call is  not  exe‐
              cuted.   By  contrast  with  SECCOMP_RET_KILL_THREAD  below, all threads in the thread group are terminated.
              (For a discussion of thread groups, see the description of the CLONE_THREAD flag in clone(2).)

              The process terminates as though killed by a SIGSYS signal.  Even if a signal handler  has  been  registered
              for SIGSYS, the handler will be ignored in this case and the process always terminates.  To a parent process
              that is waiting on this process (using waitpid(2) or similar), the returned wstatus will indicate  that  its
              child was terminated as though by a SIGSYS signal.

       SECCOMP_RET_KILL_THREAD (or SECCOMP_RET_KILL)
              This value results in immediate termination of the thread that made the system call.  The system call is not
              executed.  Other threads in the same thread group will continue to execute.

              The thread terminates as though killed by a SIGSYS signal.  See SECCOMP_RET_KILL_PROCESS above.

              Before Linux 4.11, any process terminated in this way would not trigger a coredump (even  though  SIGSYS  is
              documented  in  signal(7)  as having a default action of termination with a core dump).  Since Linux 4.11, a
              single-threaded process will dump core if terminated in this way.

              With the addition of SECCOMP_RET_KILL_PROCESS in Linux 4.14, SECCOMP_RET_KILL_THREAD was added as a  synonym
              for SECCOMP_RET_KILL, in order to more clearly distinguish the two actions.

       SECCOMP_RET_TRAP
              This  value  results  in  the kernel sending a thread-directed SIGSYS signal to the triggering thread.  (The
              system call is not executed.)  Various fields will be set in  the  siginfo_t  structure  (see  sigaction(2))
              associated with signal:

              *  si_signo will contain SIGSYS.

              *  si_call_addr will show the address of the system call instruction.

              *  si_syscall and si_arch will indicate which system call was attempted.

              *  si_code will contain SYS_SECCOMP.

              *  si_errno will contain the SECCOMP_RET_DATA portion of the filter return value.

              The  program counter will be as though the system call happened (i.e., the program counter will not point to
              the system call instruction).  The return value register will contain an  architecture-dependent  value;  if
              resuming  execution,  set  it to something appropriate for the system call.  (The architecture dependency is
              because replacing it with ENOSYS could overwrite some useful information.)

       SECCOMP_RET_ERRNO
              This value results in the SECCOMP_RET_DATA portion of the filter's return value being passed to  user  space
              as the errno value without executing the system call.

       SECCOMP_RET_TRACE
              When  returned, this value will cause the kernel to attempt to notify a ptrace(2)-based tracer prior to exe‐
              cuting the system call.  If there is no tracer present, the system call is not executed and returns a  fail‐
              ure status with errno set to ENOSYS.

              A  tracer will be notified if it requests PTRACE_O_TRACESECCOMP using ptrace(PTRACE_SETOPTIONS).  The tracer
              will be notified of a PTRACE_EVENT_SECCOMP and the SECCOMP_RET_DATA portion of  the  filter's  return  value
              will be available to the tracer via PTRACE_GETEVENTMSG.

              The tracer can skip the system call by changing the system call number to -1.  Alternatively, the tracer can
              change the system call requested by changing the system call to a valid system call number.  If  the  tracer
              asks  to  skip the system call, then the system call will appear to return the value that the tracer puts in
              the return value register.

              Before kernel 4.8, the seccomp check will not be run again after the tracer is notified.  (This means  that,
              on older kernels, seccomp-based sandboxes must not allow use of ptrace(2)—even of other sandboxed processes—
              without extreme care; ptracers can use this mechanism to escape from the seccomp sandbox.)

       SECCOMP_RET_LOG (since Linux 4.14)
              This value results in the system call being executed after the filter return action is logged.  An  adminis‐
              trator may override the logging of this action via the /proc/sys/kernel/seccomp/actions_logged file.

       SECCOMP_RET_ALLOW
              This value results in the system call being executed.

       If  an  action  value  other  than  one of the above is specified, then the filter action is treated as either SEC‐
       COMP_RET_KILL_PROCESS (since Linux 4.14) or SECCOMP_RET_KILL_THREAD (in Linux 4.13 and earlier).

   /proc interfaces
       The files in the directory /proc/sys/kernel/seccomp provide additional seccomp information and configuration:

       actions_avail (since Linux 4.14)
              A read-only ordered list of seccomp filter return actions in string form.  The ordering, from left-to-right,
              is  in  decreasing  order  of precedence.  The list represents the set of seccomp filter return actions sup‐
              ported by the kernel.

       actions_logged (since Linux 4.14)
              A read-write ordered list of seccomp filter return actions that are allowed to be  logged.   Writes  to  the
              file  do  not  need  to  be  in  ordered form but reads from the file will be ordered in the same way as the
              actions_avail file.

              It is important to note that the value of actions_logged does not prevent certain filter return actions from
              being  logged  when  the  audit  subsystem is configured to audit a task.  If the action is not found in the
              actions_logged file, the final decision on whether to audit the action for that task is ultimately  left  up
              to the audit subsystem to decide for all filter return actions other than SECCOMP_RET_ALLOW.

              The "allow" string is not accepted in the actions_logged file as it is not possible to log SECCOMP_RET_ALLOW
              actions.  Attempting to write "allow" to the file will fail with the error EINVAL.

   Audit logging of seccomp actions
       Since Linux 4.14, the kernel provides the facility to log the actions returned by seccomp filters in the audit log.
       The  kernel  makes the decision to log an action based on the action type,  whether or not the action is present in
       the actions_logged file, and whether kernel auditing is enabled (e.g., via the kernel boot  option  audit=1).   The
       rules are as follows:

       *  If the action is SECCOMP_RET_ALLOW, the action is not logged.

       *  Otherwise,  if the action is either SECCOMP_RET_KILL_PROCESS or SECCOMP_RET_KILL_THREAD, and that action appears
          in the actions_logged file, the action is logged.

       *  Otherwise, if the filter has requested logging (the SECCOMP_FILTER_FLAG_LOG flag) and the action appears in  the
          actions_logged file, the action is logged.

       *  Otherwise, if kernel auditing is enabled and the process is being audited (autrace(8)), the action is logged.

       *  Otherwise, the action is not logged.

RETURN VALUE
       On  success,  seccomp()  returns 0.  On error, if SECCOMP_FILTER_FLAG_TSYNC was used, the return value is the ID of
       the thread that caused the synchronization failure.  (This ID is a  kernel  thread  ID  of  the  type  returned  by
       clone(2) and gettid(2).)  On other errors, -1 is returned, and errno is set to indicate the cause of the error.

ERRORS
       seccomp() can fail for the following reasons:

       EACCESS
              The  caller  did  not  have  the CAP_SYS_ADMIN capability in its user namespace, or had not set no_new_privs
              before using SECCOMP_SET_MODE_FILTER.

       EFAULT args was not a valid address.

       EINVAL operation is unknown or is not supported by this kernel version or configuration.

       EINVAL The specified flags are invalid for the given operation.

       EINVAL operation included BPF_ABS, but the specified offset was not  aligned  to  a  32-bit  boundary  or  exceeded
              sizeof(struct seccomp_data).

       EINVAL A secure computing mode has already been set, and operation differs from the existing setting.

       EINVAL operation  specified SECCOMP_SET_MODE_FILTER, but the filter program pointed to by args was not valid or the
              length of the filter program was zero or exceeded BPF_MAXINSNS (4096) instructions.

       ENOMEM Out of memory.

       ENOMEM The total length of all filter programs attached to  the  calling  thread  would  exceed  MAX_INSNS_PER_PATH
              (32768)  instructions.   Note  that for the purposes of calculating this limit, each already existing filter
              program incurs an overhead penalty of 4 instructions.

       EOPNOTSUPP
              operation specified SECCOMP_GET_ACTION_AVAIL, but the kernel does not support the filter return action spec‐
              ified by args.

       ESRCH  Another thread caused a failure during thread sync, but its ID could not be determined.

VERSIONS
       The seccomp() system call first appeared in Linux 3.17.

CONFORMING TO
       The seccomp() system call is a nonstandard Linux extension.

NOTES
       Rather  than  hand-coding  seccomp  filters  as shown in the example below, you may prefer to employ the libseccomp
       library, which provides a front-end for generating seccomp filters.

       The Seccomp field of the /proc/[pid]/status file provides a method of viewing the seccomp mode of  a  process;  see
       proc(5).

       seccomp()  provides  a  superset of the functionality provided by the prctl(2) PR_SET_SECCOMP operation (which does
       not support flags).

       Since Linux 4.4, the ptrace(2) PTRACE_SECCOMP_GET_FILTER operation can be used to dump a process's seccomp filters.

   Architecture support for seccomp BPF
       Architecture support for seccomp BPF filtering is available on the following architectures:

       *  x86-64, i386, x32 (since Linux 3.5)
       *  ARM (since Linux 3.8)
       *  s390 (since Linux 3.8)
       *  MIPS (since Linux 3.16)
       *  ARM-64 (since Linux 3.19)
       *  PowerPC (since Linux 4.3)
       *  Tile (since Linux 4.3)
       *  PA-RISC (since Linux 4.6)

   Caveats
       There are various subtleties to consider when applying seccomp filters to a program, including the following:

       *  Some traditional system calls have user-space implementations in the vdso(7)  on  many  architectures.   Notable
          examples  include  clock_gettime(2), gettimeofday(2), and time(2).  On such architectures, seccomp filtering for
          these system calls will have no effect.  (However, there are cases where the vdso(7)  implementations  may  fall
          back to invoking the true system call, in which case seccomp filters would see the system call.)

       *  Seccomp  filtering is based on system call numbers.  However, applications typically do not directly invoke sys‐
          tem calls, but instead call wrapper functions in the C library which in turn invoke the  system  calls.   Conse‐
          quently, one must be aware of the following:

          ·  The glibc wrappers for some traditional system calls may actually employ system calls with different names in
             the kernel.  For example, the exit(2) wrapper function actually employs the exit_group(2)  system  call,  and
             the fork(2) wrapper function actually calls clone(2).

          ·  The  behavior of wrapper functions may vary across architectures, according to the range of system calls pro‐
             vided on those architectures.  In other words, the same wrapper function may invoke different system calls on
             different architectures.

          ·  Finally, the behavior of wrapper functions can change across glibc versions.  For example, in older versions,
             the glibc wrapper function for open(2) invoked the system call of the same name, but starting in glibc  2.26,
             the implementation switched to calling openat(2) on all architectures.

       The  consequence  of  the  above points is that it may be necessary to filter for a system call other than might be
       expected.  Various manual pages in Section 2 provide helpful details about the differences  between  wrapper  func‐
       tions and the underlying system calls in subsections entitled C library/kernel differences.

       Furthermore,  note that the application of seccomp filters even risks causing bugs in an application, when the fil‐
       ters cause unexpected failures for legitimate operations that the application might need to perform.  Such bugs may
       not easily be discovered when testing the seccomp filters if the bugs occur in rarely used application code paths.

   Seccomp-specific BPF details
       Note the following BPF details specific to seccomp filters:

       *  The BPF_H and BPF_B size modifiers are not supported: all operations must load and store (4-byte) words (BPF_W).

       *  To access the contents of the seccomp_data buffer, use the BPF_ABS addressing mode modifier.

       *  The  BPF_LEN  addressing  mode  modifier  yields  an  immediate mode operand whose value is the size of the sec‐
          comp_data buffer.

EXAMPLE
       The program below accepts four or more arguments.  The first three arguments are a system call  number,  a  numeric
       architecture identifier, and an error number.  The program uses these values to construct a BPF filter that is used
       at run time to perform the following checks:

       [1] If the program is not running on the specified architecture, the BPF filter causes system calls  to  fail  with
           the error ENOSYS.

       [2] If  the program attempts to execute the system call with the specified number, the BPF filter causes the system
           call to fail, with errno being set to the specified error number.

       The remaining command-line arguments specify the pathname and additional arguments of a program  that  the  example
       program should attempt to execute using execv(3) (a library function that employs the execve(2) system call).  Some
       example runs of the program are shown below.

       First, we display the architecture that we are running on (x86-64) and then construct a shell function  that  looks
       up system call numbers on this architecture:

           $ uname -m
           x86_64
           $ syscall_nr() {
               cat /usr/src/linux/arch/x86/syscalls/syscall_64.tbl | \
               awk '$2 != "x32" && $3 == "'$1'" { print $1 }'
           }

       When the BPF filter rejects a system call (case [2] above), it causes the system call to fail with the error number
       specified on the command line.  In the experiments shown here, we'll use error number 99:

           $ errno 99
           EADDRNOTAVAIL 99 Cannot assign requested address

       In the following example, we attempt to run the command whoami(1), but the BPF filter rejects the execve(2)  system
       call, so that the command is not even executed:

           $ syscall_nr execve
           59
           $ ./a.out
           Usage: ./a.out <syscall_nr> <arch> <errno> <prog> [<args>]
           Hint for <arch>: AUDIT_ARCH_I386: 0x40000003
                            AUDIT_ARCH_X86_64: 0xC000003E
           $ ./a.out 59 0xC000003E 99 /bin/whoami
           execv: Cannot assign requested address

       In the next example, the BPF filter rejects the write(2) system call, so that, although it is successfully started,
       the whoami(1) command is not able to write output:

           $ syscall_nr write
           1
           $ ./a.out 1 0xC000003E 99 /bin/whoami

       In the final example, the BPF filter rejects a system call that is not used by the whoami(1) command, so it is able
       to successfully execute and produce output:

           $ syscall_nr preadv
           295
           $ ./a.out 295 0xC000003E 99 /bin/whoami
           cecilia

   Program source
       #include <errno.h>
       #include <stddef.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <linux/audit.h>
       #include <linux/filter.h>
       #include <linux/seccomp.h>
       #include <sys/prctl.h>

       #define X32_SYSCALL_BIT 0x40000000

       static int
       install_filter(int syscall_nr, int t_arch, int f_errno)
       {
           unsigned int upper_nr_limit = 0xffffffff;

           /* Assume that AUDIT_ARCH_X86_64 means the normal x86-64 ABI
              (in the x32 ABI, all system calls have bit 30 set in the
              'nr' field, meaning the numbers are >= X32_SYSCALL_BIT) */
           if (t_arch == AUDIT_ARCH_X86_64)
               upper_nr_limit = X32_SYSCALL_BIT - 1;

           struct sock_filter filter[] = {
               /* [0] Load architecture from 'seccomp_data' buffer into
                      accumulator */
               BPF_STMT(BPF_LD | BPF_W | BPF_ABS,
                        (offsetof(struct seccomp_data, arch))),

               /* [1] Jump forward 5 instructions if architecture does not
                      match 't_arch' */
               BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, 0, 5),

               /* [2] Load system call number from 'seccomp_data' buffer into
                      accumulator */
               BPF_STMT(BPF_LD | BPF_W | BPF_ABS,
                        (offsetof(struct seccomp_data, nr))),

               /* [3] Check ABI - only needed for x86-64 in blacklist use
                      cases.  Use BPF_JGT instead of checking against the bit
                      mask to avoid having to reload the syscall number. */
               BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, upper_nr_limit, 3, 0),

               /* [4] Jump forward 1 instruction if system call number
                      does not match 'syscall_nr' */
               BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, 0, 1),

               /* [5] Matching architecture and system call: don't execute
                   the system call, and return 'f_errno' in 'errno' */
               BPF_STMT(BPF_RET | BPF_K,
                        SECCOMP_RET_ERRNO | (f_errno & SECCOMP_RET_DATA)),

               /* [6] Destination of system call number mismatch: allow other
                      system calls */
               BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),

               /* [7] Destination of architecture mismatch: kill task */
               BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL),
           };

           struct sock_fprog prog = {
               .len = (unsigned short) (sizeof(filter) / sizeof(filter[0])),
               .filter = filter,
           };

           if (seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog)) {
               perror("seccomp");
               return 1;
           }

           return 0;
       }

       int
       main(int argc, char **argv)
       {
           if (argc < 5) {
               fprintf(stderr, "Usage: "
                       "%s <syscall_nr> <arch> <errno> <prog> [<args>]\n"
                       "Hint for <arch>: AUDIT_ARCH_I386: 0x%X\n"
                       "                 AUDIT_ARCH_X86_64: 0x%X\n"
                       "\n", argv[0], AUDIT_ARCH_I386, AUDIT_ARCH_X86_64);
               exit(EXIT_FAILURE);
           }

           if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
               perror("prctl");
               exit(EXIT_FAILURE);
           }

           if (install_filter(strtol(argv[1], NULL, 0),
                              strtol(argv[2], NULL, 0),
                              strtol(argv[3], NULL, 0)))
               exit(EXIT_FAILURE);

           execv(argv[4], &argv[4]);
           perror("execv");
           exit(EXIT_FAILURE);
       }

SEE ALSO
       strace(1), bpf(2), prctl(2), ptrace(2), sigaction(2), proc(5), signal(7), socket(7)

       Various  pages from the libseccomp library, including: scmp_sys_resolver(1), seccomp_init(3), seccomp_load(3), sec‐
       comp_rule_add(3), and seccomp_export_bpf(3).

       The kernel source files Documentation/networking/filter.txt and Documentation/userspace-api/seccomp_filter.rst  (or
       Documentation/prctl/seccomp_filter.txt before Linux 4.13).

       McCanne,  S.  and Jacobson, V. (1992) The BSD Packet Filter: A New Architecture for User-level Packet Capture, Pro‐
       ceedings of the USENIX Winter 1993 Conference ⟨http://www.tcpdump.org/papers/bpf-usenix93.pdf⟩

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-02-02                                              SECCOMP(2)
</pre>
<pre zoom>
<span xsmall>2 sendfile64</span>
SENDFILE(2)                                      Linux Programmer's Manual                                     SENDFILE(2)

NAME
       sendfile - transfer data between file descriptors

SYNOPSIS
       #include <sys/sendfile.h>

       ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);

DESCRIPTION
       sendfile()  copies  data  between one file descriptor and another.  Because this copying is done within the kernel,
       sendfile() is more efficient than the combination of read(2) and write(2), which would require transferring data to
       and from user space.

       in_fd should be a file descriptor opened for reading and out_fd should be a descriptor opened for writing.

       If  offset is not NULL, then it points to a variable holding the file offset from which sendfile() will start read‐
       ing data from in_fd.  When sendfile() returns, this variable will be set to the offset of the  byte  following  the
       last  byte  that was read.  If offset is not NULL, then sendfile() does not modify the file offset of in_fd; other‐
       wise the file offset is adjusted to reflect the number of bytes read from in_fd.

       If offset is NULL, then data will be read from in_fd starting at the file offset,  and  the  file  offset  will  be
       updated by the call.

       count is the number of bytes to copy between the file descriptors.

       The in_fd argument must correspond to a file which supports mmap(2)-like operations (i.e., it cannot be a socket).

       In  Linux kernels before 2.6.33, out_fd must refer to a socket.  Since Linux 2.6.33 it can be any file.  If it is a
       regular file, then sendfile() changes the file offset appropriately.

RETURN VALUE
       If the transfer was successful, the number of bytes written to out_fd is returned.  Note that a successful call  to
       sendfile()  may  write  fewer  bytes  than requested; the caller should be prepared to retry the call if there were
       unsent bytes.  See also NOTES.

       On error, -1 is returned, and errno is set appropriately.

ERRORS
       EAGAIN Nonblocking I/O has been selected using O_NONBLOCK and the write would block.

       EBADF  The input file was not opened for reading or the output file was not opened for writing.

       EFAULT Bad address.

       EINVAL Descriptor is not valid or locked, or an mmap(2)-like operation is not available for in_fd, or count is neg‐
              ative.

       EINVAL out_fd has the O_APPEND flag set.  This is not currently supported by sendfile().

       EIO    Unspecified error while reading from in_fd.

       ENOMEM Insufficient memory to read from in_fd.

       EOVERFLOW
              count is too large, the operation would result in exceeding the maximum size of either the input file or the
              output file.

       ESPIPE offset is not NULL but the input file is not seek(2)-able.

VERSIONS
       sendfile() first appeared in Linux 2.2.  The include file <sys/sendfile.h> is present since glibc 2.1.

CONFORMING TO
       Not specified in POSIX.1-2001, nor in other standards.

       Other UNIX systems implement sendfile() with different semantics and prototypes.  It should not be used in portable
       programs.

NOTES
       sendfile()  will  transfer  at most 0x7ffff000 (2,147,479,552) bytes, returning the number of bytes actually trans‐
       ferred.  (This is true on both 32-bit and 64-bit systems.)

       If you plan to use sendfile() for sending files to a TCP socket, but need to send some header data in front of  the
       file  contents,  you will find it useful to employ the TCP_CORK option, described in tcp(7), to minimize the number
       of packets and to tune performance.

       In Linux 2.4 and earlier, out_fd could also refer to a regular file; this possibility went away in the Linux  2.6.x
       kernel series, but was restored in Linux 2.6.33.

       The  original  Linux sendfile() system call was not designed to handle large file offsets.  Consequently, Linux 2.4
       added sendfile64(), with a wider type for the offset argument.  The glibc sendfile() wrapper function transparently
       deals with the kernel differences.

       Applications may wish to fall back to read(2)/write(2) in the case where sendfile() fails with EINVAL or ENOSYS.

       If  out_fd  refers  to a socket or pipe with zero-copy support, callers must ensure the transferred portions of the
       file referred to by in_fd remain unmodified until the reader on the other end of out_fd  has  consumed  the  trans‐
       ferred data.

       The  Linux-specific  splice(2)  call supports transferring data between arbitrary file descriptors provided one (or
       both) of them is a pipe.

SEE ALSO
       copy_file_range(2), mmap(2), open(2), socket(2), splice(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             SENDFILE(2)
</pre>
<pre zoom>
<span xsmall>2 madvise</span>
MADVISE(2)                                       Linux Programmer's Manual                                      MADVISE(2)

NAME
       madvise - give advice about use of memory

SYNOPSIS
       #include <sys/mman.h>

       int madvise(void *addr, size_t length, int advice);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       madvise():
           Since glibc 2.19:
               _DEFAULT_SOURCE
           Up to and including glibc 2.19:
               _BSD_SOURCE

DESCRIPTION
       The  madvise()  system call is used to give advice or directions to the kernel about the address range beginning at
       address addr and with size length bytes In most cases, the goal of such advice is to improve system or  application
       performance.

       Initially,  the  system  call  supported a set of "conventional" advice values, which are also available on several
       other implementations.  (Note, though, that madvise() is not specified in POSIX.)  Subsequently, a number of Linux-
       specific advice values have been added.

   Conventional advice values
       The  advice values listed below allow an application to tell the kernel how it expects to use some mapped or shared
       memory areas, so that the kernel can choose appropriate read-ahead and caching techniques.  These advice values  do
       not influence the semantics of the application (except in the case of MADV_DONTNEED), but may influence its perfor‐
       mance.  All of the advice values listed here have analogs in the POSIX-specified posix_madvise(3) function, and the
       values have the same meanings, with the exception of MADV_DONTNEED.

       The advice is indicated in the advice argument, which is one of the following:

       MADV_NORMAL
              No special treatment.  This is the default.

       MADV_RANDOM
              Expect page references in random order.  (Hence, read ahead may be less useful than normally.)

       MADV_SEQUENTIAL
              Expect  page  references  in  sequential  order.   (Hence, pages in the given range can be aggressively read
              ahead, and may be freed soon after they are accessed.)

       MADV_WILLNEED
              Expect access in the near future.  (Hence, it might be a good idea to read some pages ahead.)

       MADV_DONTNEED
              Do not expect access in the near future.  (For the time being, the application is finished  with  the  given
              range, so the kernel can free resources associated with it.)

              After  a  successful  MADV_DONTNEED  operation,  the  semantics of memory access in the specified region are
              changed: subsequent accesses of pages in the range will succeed, but will result in either repopulating  the
              memory contents from the up-to-date contents of the underlying mapped file (for shared file mappings, shared
              anonymous mappings, and shmem-based techniques such as System V shared  memory  segments)  or  zero-fill-on-
              demand pages for anonymous private mappings.

              Note  that,  when applied to shared mappings, MADV_DONTNEED might not lead to immediate freeing of the pages
              in the range.  The kernel is free to delay freeing the pages until an appropriate moment.  The resident  set
              size (RSS) of the calling process will be immediately reduced however.

              MADV_DONTNEED cannot be applied to locked pages, Huge TLB pages, or VM_PFNMAP pages.  (Pages marked with the
              kernel-internal VM_PFNMAP flag are special memory areas that are not managed by the virtual  memory  subsys‐
              tem.  Such pages are typically created by device drivers that map the pages into user space.)

   Linux-specific advice values
       The following Linux-specific advice values have no counterparts in the POSIX-specified posix_madvise(3), and may or
       may not have counterparts in the madvise() interface available on other implementations.  Note that some  of  these
       operations change the semantics of memory accesses.

       MADV_REMOVE (since Linux 2.6.16)
              Free  up  a given range of pages and its associated backing store.  This is equivalent to punching a hole in
              the corresponding byte range of the backing store (see fallocate(2)).  Subsequent accesses in the  specified
              address range will see bytes containing zero.

              The  specified  address  range  must  be  mapped shared and writable.  This flag cannot be applied to locked
              pages, Huge TLB pages, or VM_PFNMAP pages.

              In the initial implementation, only tmpfs(5) was supported MADV_REMOVE; but since Linux 3.5, any  filesystem
              which  supports  the fallocate(2) FALLOC_FL_PUNCH_HOLE mode also supports MADV_REMOVE.  Hugetlbfs fails with
              the error EINVAL and other filesystems fail with the error EOPNOTSUPP.

       MADV_DONTFORK (since Linux 2.6.16)
              Do not make the pages in this range available to the child after a fork(2).  This is useful to prevent copy-
              on-write semantics from changing the physical location of a page if the parent writes to it after a fork(2).
              (Such page relocations cause problems for hardware that DMAs into the page.)

       MADV_DOFORK (since Linux 2.6.16)
              Undo the effect of MADV_DONTFORK, restoring the default behavior, whereby  a  mapping  is  inherited  across
              fork(2).

       MADV_HWPOISON (since Linux 2.6.32)
              Poison  the  pages in the range specified by addr and length and handle subsequent references to those pages
              like a hardware memory corruption.  This operation is available only  for  privileged  (CAP_SYS_ADMIN)  pro‐
              cesses.  This operation may result in the calling process receiving a SIGBUS and the page being unmapped.

              This  feature  is intended for testing of memory error-handling code; it is available only if the kernel was
              configured with CONFIG_MEMORY_FAILURE.

       MADV_MERGEABLE (since Linux 2.6.32)
              Enable Kernel Samepage Merging (KSM) for the pages in the range specified by addr and  length.   The  kernel
              regularly  scans those areas of user memory that have been marked as mergeable, looking for pages with iden‐
              tical content.  These are replaced by a single write-protected page (which  is  automatically  copied  if  a
              process  later  wants  to  update  the  content  of the page).  KSM merges only private anonymous pages (see
              mmap(2)).

              The KSM feature is intended for applications that generate many instances of the same data  (e.g.,  virtual‐
              ization  systems such as KVM).  It can consume a lot of processing power; use with care.  See the Linux ker‐
              nel source file Documentation/vm/ksm.txt for more details.

              The MADV_MERGEABLE and MADV_UNMERGEABLE operations are available only if the kernel was configured with CON‐
              FIG_KSM.

       MADV_UNMERGEABLE (since Linux 2.6.32)
              Undo the effect of an earlier MADV_MERGEABLE operation on the specified address range; KSM unmerges whatever
              pages it had merged in the address range specified by addr and length.

       MADV_SOFT_OFFLINE (since Linux 2.6.33)
              Soft offline the pages in the range specified by addr and length.  The memory of each page in the  specified
              range  is  preserved (i.e., when next accessed, the same content will be visible, but in a new physical page
              frame), and the original page is offlined (i.e., no longer used, and taken out of normal memory management).
              The  effect  of the MADV_SOFT_OFFLINE operation is invisible to (i.e., does not change the semantics of) the
              calling process.

              This feature is intended for testing of memory error-handling code; it is available only if the  kernel  was
              configured with CONFIG_MEMORY_FAILURE.

       MADV_HUGEPAGE (since Linux 2.6.38)
              Enable  Transparent Huge Pages (THP) for pages in the range specified by addr and length.  Currently, Trans‐
              parent Huge Pages work only with private anonymous pages (see mmap(2)).  The kernel will regularly scan  the
              areas  marked  as  huge page candidates to replace them with huge pages.  The kernel will also allocate huge
              pages directly when the region is naturally aligned to the huge page size (see posix_memalign(2)).

              This feature is primarily aimed at applications that use large mappings of data and access large regions  of
              that memory at a time (e.g., virtualization systems such as QEMU).  It can very easily waste memory (e.g., a
              2 MB mapping that only ever accesses 1 byte will result in 2 MB of wired memory instead of one  4 KB  page).
              See the Linux kernel source file Documentation/vm/transhuge.txt for more details.

              The  MADV_HUGEPAGE  and MADV_NOHUGEPAGE operations are available only if the kernel was configured with CON‐
              FIG_TRANSPARENT_HUGEPAGE.

       MADV_NOHUGEPAGE (since Linux 2.6.38)
              Ensures that memory in the address range specified by addr and length will not be collapsed into huge pages.

       MADV_DONTDUMP (since Linux 3.4)
              Exclude from a core dump those pages in the range specified by addr and length.  This is useful in  applica‐
              tions  that  have  large  areas  of  memory  that  are known not to be useful in a core dump.  The effect of
              MADV_DONTDUMP takes precedence over the bit mask that is set via the /proc/[pid]/coredump_filter  file  (see
              core(5)).

       MADV_DODUMP (since Linux 3.4)
              Undo the effect of an earlier MADV_DONTDUMP.

       MADV_FREE (since Linux 4.5)
              The  application  no  longer requires the pages in the range specified by addr and len.  The kernel can thus
              free these pages, but the freeing could be delayed until memory pressure occurs.  For each of the pages that
              has  been  marked  to be freed but has not yet been freed, the free operation will be canceled if the caller
              writes into the page.  After a successful MADV_FREE operation, any stale data (i.e., dirty, unwritten pages)
              will be lost when the kernel frees the pages.  However, subsequent writes to pages in the range will succeed
              and then kernel cannot free those dirtied pages, so that the caller can always see just  written  data.   If
              there  is no subsequent write, the kernel can free the pages at any time.  Once pages in the range have been
              freed, the caller will see zero-fill-on-demand pages upon subsequent page references.

              The MADV_FREE operation can be applied only to private anonymous pages (see mmap(2)).  On a swapless system,
              freeing pages in a given range happens instantly, regardless of memory pressure.

       MADV_WIPEONFORK (since Linux 4.14)
              Present  the child process with zero-filled memory in this range after a fork(2).  This is useful in forking
              servers in order to ensure that sensitive per-process data (for example, PRNG seeds, cryptographic  secrets,
              and so on) is not handed to child processes.

              The MADV_WIPEONFORK operation can be applied only to private anonymous pages (see mmap(2)).

              Within  the  child created by fork(2), the MADV_WIPEONFORK setting remains in place on the specified address
              range.  This setting is cleared during execve(2).

       MADV_KEEPONFORK (since Linux 4.14)
              Undo the effect of an earlier MADV_WIPEONFORK.

RETURN VALUE
       On success, madvise() returns zero.  On error, it returns -1 and errno is set appropriately.

ERRORS
       EACCES advice is MADV_REMOVE, but the specified address range is not a shared writable mapping.

       EAGAIN A kernel resource was temporarily unavailable.

       EBADF  The map exists, but the area maps something that isn't a file.

       EINVAL addr is not page-aligned or length is negative.

       EINVAL advice is not a valid.

       EINVAL advice is MADV_DONTNEED or MADV_REMOVE and the specified address range includes locked, Huge TLB  pages,  or
              VM_PFNMAP pages.

       EINVAL advice is MADV_MERGEABLE or MADV_UNMERGEABLE, but the kernel was not configured with CONFIG_KSM.

       EINVAL advice  is MADV_FREE or MADV_WIPEONFORK but the specified address range includes file, Huge TLB, MAP_SHARED,
              or VM_PFNMAP ranges.

       EIO    (for MADV_WILLNEED) Paging in this area would exceed the process's maximum resident set size.

       ENOMEM (for MADV_WILLNEED) Not enough memory: paging in failed.

       ENOMEM Addresses in the specified range are not currently mapped, or are outside the address space of the process.

       EPERM  advice is MADV_HWPOISON, but the caller does not have the CAP_SYS_ADMIN capability.

VERSIONS
       Since Linux 3.18, support for this system call is optional, depending on the setting of the  CONFIG_ADVISE_SYSCALLS
       configuration option.

CONFORMING TO
       madvise()  is  not specified by any standards.  Versions of this system call, implementing a wide variety of advice
       values, exist on many other implementations.  Other implementations typically implement at least the  flags  listed
       above under Conventional advice flags, albeit with some variation in semantics.

       POSIX.1-2001 describes posix_madvise(3) with constants POSIX_MADV_NORMAL, POSIX_MADV_RANDOM, POSIX_MADV_SEQUENTIAL,
       POSIX_MADV_WILLNEED, and POSIX_MADV_DONTNEED, and so on, with behavior close to the similarly  named  flags  listed
       above.

NOTES
   Linux notes
       The  Linux  implementation  requires that the address addr be page-aligned, and allows length to be zero.  If there
       are some parts of the specified address range that are not mapped, the Linux version of madvise() ignores them  and
       applies the call to the rest (but returns ENOMEM from the system call, as it should).

SEE ALSO
       getrlimit(2), mincore(2), mmap(2), mprotect(2), msync(2), munmap(2), prctl(2), posix_madvise(3), core(5)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                              MADVISE(2)
</pre>
<pre zoom>
<span xsmall>2 inl_p</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 setgid32</span>
SETGID(2)                                        Linux Programmer's Manual                                       SETGID(2)

NAME
       setgid - set group identity

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int setgid(gid_t gid);

DESCRIPTION
       setgid() sets the effective group ID of the calling process.  If the calling process is privileged (more precisely:
       has the CAP_SETGID capability in its user namespace), the real GID and saved set-group-ID are also set.

       Under Linux, setgid() is implemented like the POSIX version with the _POSIX_SAVED_IDS feature.  This allows a  set-
       group-ID  program that is not set-user-ID-root to drop all of its group privileges, do some un-privileged work, and
       then reengage the original effective group ID in a secure manner.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EINVAL The group ID specified in gid is not valid in this user namespace.

       EPERM  The calling process is not privileged (does not have the CAP_SETGID capability), and gid does not match  the
              real group ID or saved set-group-ID of the calling process.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

NOTES
       The  original Linux setgid() system call supported only 16-bit group IDs.  Subsequently, Linux 2.4 added setgid32()
       supporting 32-bit IDs.  The glibc setgid() wrapper function transparently deals with the  variation  across  kernel
       versions.

   C library/kernel differences
       At  the  kernel level, user IDs and group IDs are a per-thread attribute.  However, POSIX requires that all threads
       in a process share the same credentials.  The NPTL threading implementation handles the POSIX requirements by  pro‐
       viding  wrapper  functions for the various system calls that change process UIDs and GIDs.  These wrapper functions
       (including the one for setgid()) employ a signal-based technique to ensure that when  one  thread  changes  creden‐
       tials, all of the other threads in the process also change their credentials.  For details, see nptl(7).

SEE ALSO
       getgid(2), setegid(2), setregid(2), capabilities(7), credentials(7), user_namespaces(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SETGID(2)
</pre>
<pre zoom>
<span xsmall>2 epoll_wait</span>
EPOLL_WAIT(2)                                    Linux Programmer's Manual                                   EPOLL_WAIT(2)

NAME
       epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor

SYNOPSIS
       #include <sys/epoll.h>

       int epoll_wait(int epfd, struct epoll_event *events,
                      int maxevents, int timeout);
       int epoll_pwait(int epfd, struct epoll_event *events,
                      int maxevents, int timeout,
                      const sigset_t *sigmask);

DESCRIPTION
       The  epoll_wait()  system  call  waits for events on the epoll(7) instance referred to by the file descriptor epfd.
       The memory area pointed to by events will contain the events that will be available for the  caller.   Up  to  max‐
       events are returned by epoll_wait().  The maxevents argument must be greater than zero.

       The  timeout  argument specifies the number of milliseconds that epoll_wait() will block.  Time is measured against
       the CLOCK_MONOTONIC clock.  The call will block until either:

       *  a file descriptor delivers an event;

       *  the call is interrupted by a signal handler; or

       *  the timeout expires.

       Note that the timeout interval will be rounded up to the system clock granularity,  and  kernel  scheduling  delays
       mean  that  the blocking interval may overrun by a small amount.  Specifying a timeout of -1 causes epoll_wait() to
       block indefinitely, while specifying a timeout equal to zero cause epoll_wait() to return immediately, even  if  no
       events are available.

       The struct epoll_event is defined as:

           typedef union epoll_data {
               void    *ptr;
               int      fd;
               uint32_t u32;
               uint64_t u64;
           } epoll_data_t;

           struct epoll_event {
               uint32_t     events;    /* Epoll events */
               epoll_data_t data;      /* User data variable */
           };

       The  data  field  of  each  returned  structure  contains the same data as was specified in the most recent call to
       epoll_ctl(2) (EPOLL_CTL_ADD, EPOLL_CTL_MOD) for the corresponding open file description.  The events field contains
       the returned event bit field.

   epoll_pwait()
       The relationship between epoll_wait() and epoll_pwait() is analogous to the relationship between select(2) and pse‐
       lect(2): like pselect(2), epoll_pwait() allows an application to safely wait until either a file descriptor becomes
       ready or until a signal is caught.

       The following epoll_pwait() call:

           ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);

       is equivalent to atomically executing the following calls:

           sigset_t origmask;

           pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);
           ready = epoll_wait(epfd, &events, maxevents, timeout);
           pthread_sigmask(SIG_SETMASK, &origmask, NULL);

       The sigmask argument may be specified as NULL, in which case epoll_pwait() is equivalent to epoll_wait().

RETURN VALUE
       When  successful,  epoll_wait()  returns  the number of file descriptors ready for the requested I/O, or zero if no
       file descriptor became ready during the requested timeout milliseconds.  When an error occurs, epoll_wait() returns
       -1 and errno is set appropriately.

ERRORS
       EBADF  epfd is not a valid file descriptor.

       EFAULT The memory area pointed to by events is not accessible with write permissions.

       EINTR  The  call  was interrupted by a signal handler before either (1) any of the requested events occurred or (2)
              the timeout expired; see signal(7).

       EINVAL epfd is not an epoll file descriptor, or maxevents is less than or equal to zero.

VERSIONS
       epoll_wait() was added to the kernel in version 2.6.  Library support is provided in glibc  starting  with  version
       2.3.2.

       epoll_pwait() was added to Linux in kernel 2.6.19.  Library support is provided in glibc starting with version 2.6.

CONFORMING TO
       epoll_wait() is Linux-specific.

NOTES
       While  one thread is blocked in a call to epoll_pwait(), it is possible for another thread to add a file descriptor
       to the waited-upon epoll instance.  If the new file descriptor becomes ready, it will cause the  epoll_wait()  call
       to unblock.

       For  a  discussion  of what may happen if a file descriptor in an epoll instance being monitored by epoll_wait() is
       closed in another thread, see select(2).

BUGS
       In kernels before 2.6.37, a timeout value larger than approximately LONG_MAX / HZ milliseconds  is  treated  as  -1
       (i.e.,  infinity).   Thus,  for  example, on a system where sizeof(long) is 4 and the kernel HZ value is 1000, this
       means that timeouts greater than 35.79 minutes are treated as infinity.

   C library/kernel differences
       The raw epoll_pwait() system call has a sixth argument, size_t sigsetsize, which specifies the size in bytes of the
       sigmask  argument.   The  glibc  epoll_pwait()  wrapper function specifies this argument as a fixed value (equal to
       sizeof(sigset_t)).

SEE ALSO
       epoll_create(2), epoll_ctl(2), epoll(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           EPOLL_WAIT(2)
</pre>
<pre zoom>
<span xsmall>2 vm86</span>
VM86(2)                                          Linux Programmer's Manual                                         VM86(2)

NAME
       vm86old, vm86 - enter virtual 8086 mode

SYNOPSIS
       #include <sys/vm86.h>

       int vm86old(struct vm86_struct *info);

       int vm86(unsigned long fn, struct vm86plus_struct *v86);

DESCRIPTION
       The  system  call  vm86() was introduced in Linux 0.97p2.  In Linux 2.1.15 and 2.0.28, it was renamed to vm86old(),
       and a new vm86() was introduced.  The definition of struct vm86_struct was changed in 1.1.8 and 1.1.9.

       These calls cause the process to enter VM86 mode (virtual-8086 in Intel literature), and are used by dosemu.

       VM86 mode is an emulation of real mode within a protected mode task.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT This return value is specific to i386 and indicates a problem with getting user-space data.

       ENOSYS This return value indicates the call is not implemented on the present architecture.

       EPERM  Saved kernel stack exists.  (This is a kernel sanity check; the saved stack should exist  only  within  vm86
              mode itself.)

CONFORMING TO
       This call is specific to Linux on 32-bit Intel processors, and should not be used in programs intended to be porta‐
       ble.

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2009-02-20                                                 VM86(2)
</pre>
<pre zoom>
<span xsmall>2 outw</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 rtas</span>
RTAS(2)                                             System Calls Manual                                            RTAS(2)

NAME
       rtas - Allows userspace to call RTAS (Run Time Abstraction Services)

SYNOPSIS
       int ppc_rtas (struct rtas_args *uargs);

DESCRIPTION
       ppc_rtas  enables  userspace  manipulation of the RunTime Abstraction Services (RTAS). RTAS provides for a portable
       method of access and setting system information. For example, you could gather information on various  system  sen‐
       sors  and  set poweron values. RTAS is accessed via the /proc entry called "rtas". Manipulations on RTAS are imple‐
       mented via command line arguments on /proc/rtas.  The values for uargs vary greatly.  For more information, see the
       view/arch/ppcKconfig file.

RETURN VALUE
       rtas returns 0 on success; otherwise it returns one of the errors listed in the "Errors" section.

ERRORS
       -EPERM User does not have CAP_SYS_ADMIN capabilities.

       -EFAULT
              Problem copying uargs values to/from user space.

       -EINVAL
              Either number of uargs passed in too large or size of uargs array too large.

AUTHOR
       Niki Rahimi.

                                                                                                                   RTAS(2)
</pre>
<pre zoom>
<span xsmall>2 killpg</span>
KILLPG(3)                                        Linux Programmer's Manual                                       KILLPG(3)

NAME
       killpg - send signal to a process group

SYNOPSIS
       #include <signal.h>

       int killpg(int pgrp, int sig);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       killpg():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.19: */ _DEFAULT_SOURCE
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       killpg() sends the signal sig to the process group pgrp.  See signal(7) for a list of signals.

       If  pgrp is 0, killpg() sends the signal to the calling process's process group.  (POSIX says: if pgrp is less than
       or equal to 1, the behavior is undefined.)

       For the permissions required to send a signal to another process, see kill(2).

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EINVAL sig is not a valid signal number.

       EPERM  The process does not have permission to send the signal to any of the target processes.   For  the  required
              permissions, see kill(2).

       ESRCH  No process can be found in the process group specified by pgrp.

       ESRCH  The process group was given as 0 but the sending process does not have a process group.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (killpg() first appeared in 4BSD).

NOTES
       There  are  various differences between the permission checking in BSD-type systems and System V-type systems.  See
       the POSIX rationale for kill().  A difference not mentioned by POSIX concerns the return value EPERM: BSD documents
       that  no  signal is sent and EPERM returned when the permission check failed for at least one target process, while
       POSIX documents EPERM only when the permission check failed for all target processes.

   C library/kernel differences
       On Linux, killpg() is implemented as a library function that makes the call kill(-pgrp, sig).

SEE ALSO
       getpgrp(2), kill(2), signal(2), capabilities(7), credentials(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               KILLPG(3)
</pre>
<pre zoom>
<span xsmall>2 sigsuspend</span>
SIGSUSPEND(2)                                    Linux Programmer's Manual                                   SIGSUSPEND(2)

NAME
       sigsuspend, rt_sigsuspend - wait for a signal

SYNOPSIS
       #include <signal.h>

       int sigsuspend(const sigset_t *mask);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       sigsuspend(): _POSIX_C_SOURCE

DESCRIPTION
       sigsuspend()  temporarily replaces the signal mask of the calling process with the mask given by mask and then sus‐
       pends the process until delivery of a signal whose action is to invoke a signal handler or to terminate a process.

       If the signal terminates the process, then sigsuspend() does not return.  If the signal  is  caught,  then  sigsus‐
       pend()  returns  after  the signal handler returns, and the signal mask is restored to the state before the call to
       sigsuspend().

       It is not possible to block SIGKILL or SIGSTOP; specifying these signals in mask, has no effect  on  the  process's
       signal mask.

RETURN VALUE
       sigsuspend() always returns -1, with errno set to indicate the error (normally, EINTR).

ERRORS
       EFAULT mask points to memory which is not a valid part of the process address space.

       EINTR  The call was interrupted by a signal; signal(7).

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       Normally,  sigsuspend()  is used in conjunction with sigprocmask(2) in order to prevent delivery of a signal during
       the execution of a critical code section.  The caller first blocks the signals with sigprocmask(2).  When the crit‐
       ical  code  has  completed, the caller then waits for the signals by calling sigsuspend() with the signal mask that
       was returned by sigprocmask(2) (in the oldset argument).

       See sigsetops(3) for details on manipulating signal sets.

   C library/kernel differences
       The original Linux system call was named sigsuspend().  However, with the addition of real-time  signals  in  Linux
       2.2,  the  fixed-size,  32-bit  sigset_t  type supported by that system call was no longer fit for purpose.  Conse‐
       quently, a new system call, rt_sigsuspend(), was added to support an enlarged sigset_t type.  The new  system  call
       takes  a  second  argument,  size_t  sigsetsize, which specifies the size in bytes of the signal set in mask.  This
       argument is currently required to have the value sizeof(sigset_t) (or the error EINVAL results).  The glibc sigsus‐
       pend() wrapper function hides these details from us, transparently calling rt_sigsuspend() when the kernel provides
       it.

SEE ALSO
       kill(2), pause(2), sigaction(2), signal(2), sigprocmask(2), sigwaitinfo(2), sigsetops(3), sigwait(3), signal(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           SIGSUSPEND(2)
</pre>
<pre zoom>
<span xsmall>2 uname</span>
UNAME(2)                                         Linux Programmer's Manual                                        UNAME(2)

NAME
       uname - get name and information about current kernel

SYNOPSIS
       #include <sys/utsname.h>

       int uname(struct utsname *buf);

DESCRIPTION
       uname()  returns  system  information  in  the  structure  pointed  to  by  buf.   The utsname struct is defined in
       <sys/utsname.h>:

           struct utsname {
               char sysname[];    /* Operating system name (e.g., "Linux") */
               char nodename[];   /* Name within "some implementation-defined
                                     network" */
               char release[];    /* Operating system release (e.g., "2.6.28") */
               char version[];    /* Operating system version */
               char machine[];    /* Hardware identifier */
           #ifdef _GNU_SOURCE
               char domainname[]; /* NIS or YP domain name */
           #endif
           };

       The length of the arrays in a struct utsname is unspecified (see NOTES); the fields are terminated by a  null  byte
       ('\0').

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT buf is not valid.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.  There is no uname() call in 4.3BSD.

       The domainname member (the NIS or YP domain name) is a GNU extension.

NOTES
       This is a system call, and the operating system presumably knows its name, release and version.  It also knows what
       hardware it runs on.  So, four of the fields of the struct are meaningful.  On the other hand, the  field  nodename
       is  meaningless:  it gives the name of the present machine in some undefined network, but typically machines are in
       more than one network and have several names.  Moreover, the kernel has no way of knowing about such things, so  it
       has to be told what to answer here.  The same holds for the additional domainname field.

       To  this end, Linux uses the system calls sethostname(2) and setdomainname(2).  Note that there is no standard that
       says that the hostname set by sethostname(2) is the same string as the nodename field of  the  struct  returned  by
       uname()  (indeed,  some  systems allow a 256-byte hostname and an 8-byte nodename), but this is true on Linux.  The
       same holds for setdomainname(2) and the domainname field.

       The length of the fields in the struct varies.  Some operating systems or libraries use a hardcoded 9 or 33  or  65
       or  257.   Other  systems use SYS_NMLN or _SYS_NMLN or UTSLEN or _UTSNAME_LENGTH.  Clearly, it is a bad idea to use
       any of these constants; just use sizeof(...).  Often 257 is chosen in order to have room for an internet hostname.

       Part of the utsname information is also accessible  via  /proc/sys/kernel/{ostype,  hostname,  osrelease,  version,
       domainname}.

   C library/kernel differences
       Over  time,  increases  in  the  size  of  the  utsname structure have led to three successive versions of uname():
       sys_olduname() (slot __NR_oldolduname), sys_uname() (slot __NR_olduname),  and  sys_newuname()  (slot  __NR_uname).
       The  first  one  used  length  9 for all fields; the second used 65; the third also uses 65 but adds the domainname
       field.  The glibc uname() wrapper function hides these details from applications, invoking the most recent  version
       of the system call provided by the kernel.

SEE ALSO
       uname(1), getdomainname(2), gethostname(2), namespaces(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                UNAME(2)
</pre>
<pre zoom>
<span xsmall>2 setresgid</span>
SETRESUID(2)                                     Linux Programmer's Manual                                    SETRESUID(2)

NAME
       setresuid, setresgid - set real, effective and saved user or group ID

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <unistd.h>

       int setresuid(uid_t ruid, uid_t euid, uid_t suid);
       int setresgid(gid_t rgid, gid_t egid, gid_t sgid);

DESCRIPTION
       setresuid() sets the real user ID, the effective user ID, and the saved set-user-ID of the calling process.

       An  unprivileged process may change its real UID, effective UID, and saved set-user-ID, each to one of: the current
       real UID, the current effective UID or the current saved set-user-ID.

       A privileged process (on Linux, one having the CAP_SETUID capability) may set its  real  UID,  effective  UID,  and
       saved set-user-ID to arbitrary values.

       If one of the arguments equals -1, the corresponding value is not changed.

       Regardless  of  what  changes are made to the real UID, effective UID, and saved set-user-ID, the filesystem UID is
       always set to the same value as the (possibly new) effective UID.

       Completely analogously, setresgid() sets the real GID, effective GID, and saved set-group-ID of the calling process
       (and  always  modifies  the  filesystem  GID  to  be the same as the effective GID), with the same restrictions for
       unprivileged processes.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

       Note: there are cases where setresuid() can fail even when the caller is UID 0; it is a  grave  security  error  to
       omit checking for a failure return from setresuid().

ERRORS
       EAGAIN The call would change the caller's real UID (i.e., ruid does not match the caller's real UID), but there was
              a temporary failure allocating the necessary kernel data structures.

       EAGAIN ruid does not match the caller's real UID and this call would bring the number of processes belonging to the
              real user ID ruid over the caller's RLIMIT_NPROC resource limit.  Since Linux 3.1, this error case no longer
              occurs (but robust applications should check for this error); see the description of EAGAIN in execve(2).

       EINVAL One or more of the target user or group IDs is not valid in this user namespace.

       EPERM  The calling process is not privileged (did not have the necessary capability  in  its  user  namespace)  and
              tried  to  change  the  IDs  to values that are not permitted.  For setresuid(), the necessary capability is
              CAP_SETUID; for setresgid(), it is CAP_SETGID.

VERSIONS
       These calls are available under Linux since Linux 2.1.44.

CONFORMING TO
       These calls are nonstandard; they also appear on HP-UX and some of the BSDs.

NOTES
       Under HP-UX and FreeBSD, the prototype is found in <unistd.h>.  Under Linux, the prototype  is  provided  by  glibc
       since version 2.3.2.

       The  original  Linux  setresuid()  and  setresgid()  system calls supported only 16-bit user and group IDs.  Subse‐
       quently, Linux 2.4 added setresuid32() and setresgid32(), supporting 32-bit IDs.  The glibc setresuid() and setres‐
       gid() wrapper functions transparently deal with the variations across kernel versions.

   C library/kernel differences
       At  the  kernel level, user IDs and group IDs are a per-thread attribute.  However, POSIX requires that all threads
       in a process share the same credentials.  The NPTL threading implementation handles the POSIX requirements by  pro‐
       viding  wrapper  functions for the various system calls that change process UIDs and GIDs.  These wrapper functions
       (including those for setresuid() and setresgid()) employ a signal-based technique to ensure that  when  one  thread
       changes  credentials,  all  of  the  other  threads in the process also change their credentials.  For details, see
       nptl(7).

SEE ALSO
       getresuid(2),  getuid(2),  setfsgid(2),  setfsuid(2),  setreuid(2),  setuid(2),  capabilities(7),   credentials(7),
       user_namespaces(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            SETRESUID(2)
</pre>
<pre zoom>
<span xsmall>2 restart_syscall</span>
RESTART_SYSCALL(2)                               Linux Programmer's Manual                              RESTART_SYSCALL(2)

NAME
       restart_syscall - restart a system call after interruption by a stop signal

SYNOPSIS
       int restart_syscall(void);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       The  restart_syscall()  system  call  is used to restart certain system calls after a process that was stopped by a
       signal (e.g., SIGSTOP or SIGTSTP) is later resumed after receiving a SIGCONT signal.  This system call is  designed
       only for internal use by the kernel.

       restart_syscall()  is  used  for restarting only those system calls that, when restarted, should adjust their time-
       related parameters—namely poll(2) (since Linux 2.6.24), nanosleep(2) (since Linux 2.6),  clock_nanosleep(2)  (since
       Linux 2.6), and futex(2), when employed with the FUTEX_WAIT (since Linux 2.6.22) and FUTEX_WAIT_BITSET (since Linux
       2.6.31) operations.  restart_syscall() restarts the interrupted system call with a time argument that  is  suitably
       adjusted  to  account  for the time that has already elapsed (including the time where the process was stopped by a
       signal).  Without the restart_syscall() mechanism, restarting these system calls would  not  correctly  deduct  the
       already elapsed time when the process continued execution.

RETURN VALUE
       The return value of restart_syscall() is the return value of whatever system call is being restarted.

ERRORS
       errno is set as per the errors for whatever system call is being restarted by restart_syscall().

VERSIONS
       The restart_syscall() system call is present since Linux 2.6.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       There  is no glibc wrapper for this system call, because it is intended for use only by the kernel and should never
       be called by applications.

       The kernel uses restart_syscall() to ensure that when a system call is restarted after a process has  been  stopped
       by  a  signal  and  then  resumed  by SIGCONT, then the time that the process spent in the stopped state is counted
       against the timeout interval specified in the original system call.  In the case of system calls that take a  time‐
       out   argument  and  automatically  restart  after  a  stop  signal  plus  SIGCONT,  but  which  do  not  have  the
       restart_syscall() mechanism built in, then, after the process resumes execution, the time that the process spent in
       the stop state is not counted against the timeout value.  Notable examples of system calls that suffer this problem
       are ppoll(2), select(2), and pselect(2).

       From user space, the operation of restart_syscall() is largely invisible: to the process that made the system  call
       that is restarted, it appears as though that system call executed and returned in the usual fashion.

SEE ALSO
       sigaction(2), sigreturn(2), signal(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                      RESTART_SYSCALL(2)
</pre>
<pre zoom>
<span xsmall>2 outb</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 shutdown</span>
SHUTDOWN(2)                                      Linux Programmer's Manual                                     SHUTDOWN(2)

NAME
       shutdown - shut down part of a full-duplex connection

SYNOPSIS
       #include <sys/socket.h>

       int shutdown(int sockfd, int how);

DESCRIPTION
       The  shutdown() call causes all or part of a full-duplex connection on the socket associated with sockfd to be shut
       down.  If how is SHUT_RD, further receptions will be disallowed.  If how is SHUT_WR, further transmissions will  be
       disallowed.  If how is SHUT_RDWR, further receptions and transmissions will be disallowed.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EBADF  sockfd is not a valid file descriptor.

       EINVAL An invalid value was specified in how (but see BUGS).

       ENOTCONN
              The specified socket is not connected.

       ENOTSOCK
              The file descriptor sockfd does not refer to a socket.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.4BSD (shutdown() first appeared in 4.2BSD).

NOTES
       The  constants  SHUT_RD, SHUT_WR, SHUT_RDWR have the value 0, 1, 2, respectively, and are defined in <sys/socket.h>
       since glibc-2.1.91.

BUGS
       Checks for the validity of how are done in domain-specific code, and before Linux 3.7  not  all  domains  performed
       these  checks.   Most  notably, UNIX domain sockets simply ignored invalid values.  This problem was fixed for UNIX
       domain sockets in Linux 3.7.

SEE ALSO
       close(2), connect(2), socket(2), socket(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                             SHUTDOWN(2)
</pre>
<pre zoom>
<span xsmall>2 stat</span>
STAT(2)                                          Linux Programmer's Manual                                         STAT(2)

NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       int fstat(int fd, struct stat *statbuf);
       int lstat(const char *pathname, struct stat *statbuf);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
                   int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       lstat():
           /* glibc 2.19 and earlier */ _BSD_SOURCE
               || /* Since glibc 2.20 */ _DEFAULT_SOURCE
               || _XOPEN_SOURCE >= 500
               || /* Since glibc 2.10: */ _POSIX_C_SOURCE >= 200112L

       fstatat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  functions return information about a file, in the buffer pointed to by statbuf.  No permissions are required
       on the file itself, but—in the case of stat(), fstatat(), and lstat()—execute (search) permission  is  required  on
       all of the directories in pathname that lead to the file.

       stat()  and fstatat() retrieve information about the file pointed to by pathname; the differences for fstatat() are
       described below.

       lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information  about  the
       link itself, not the file that it refers to.

       fstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the
       file descriptor fd.

   The stat structure
       All of these system calls return a stat structure, which contains the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

       Note: the order of fields in the stat structure varies somewhat across architectures.  In addition, the  definition
       above  does  not  show the padding bytes that may be present between some fields on various architectures.  Consult
       the glibc and kernel source code if you need to know the details.

       Note: for performance and simplicity reasons, different fields in the stat structure may contain state  information
       from  different  moments  during the execution of the system call.  For example, if st_mode or st_uid is changed by
       another process by calling chmod(2) or chown(2), stat() might return the old st_mode together with the new  st_uid,
       or the old st_uid together with the new st_mode.

       The fields in the stat structure are as follows:

       st_dev This field describes the device on which this file resides.  (The major(3) and minor(3) macros may be useful
              to decompose the device ID in this field.)

       st_ino This field contains the file's inode number.

       st_mode
              This field contains the file type and mode.  See inode(7) for further information.

       st_nlink
              This field contains the number of hard links to the file.

       st_uid This field contains the user ID of the owner of the file.

       st_gid This field contains the ID of the group owner of the file.

       st_rdev
              This field describes the device that this file (inode) represents.

       st_size
              This field gives the size of the file (if it is a regular file or a symbolic link) in bytes.  The size of  a
              symbolic link is the length of the pathname it contains, without a terminating null byte.

       st_blksize
              This field gives the "preferred" block size for efficient filesystem I/O.

       st_blocks
              This  field  indicates  the number of blocks allocated to the file, in 512-byte units.  (This may be smaller
              than st_size/512 when the file has holes.)

       st_atime
              This is the file's last access timestamp.

       st_mtime
              This is the file's last modification timestamp.

       st_ctime
              This is the file's last status change timestamp.

       For further information on the above fields, see inode(7).

   fstatat()
       The fstatat() system call is a more general interface for  accessing  file  information  which  can  still  provide
       exactly the behavior of each of stat(), lstat(), and fstat().

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       stat() and lstat() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like stat() and lstat()).

       If pathname is absolute, then dirfd is ignored.

       flags can either be 0, or include one or more of the following flags ORed:

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2) O_PATH flag).  In this case, dirfd can refer to any type of file, not just a directory, and the
              behavior of fstatat() is similar to that of fstat().  If dirfd is AT_FDCWD, the call operates on the current
              working directory.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.

       AT_NO_AUTOMOUNT (since Linux 2.6.38)
              Don't  automount  the  terminal ("basename") component of pathname if it is a directory that is an automount
              point.  This allows the caller to gather attributes of an automount point (rather than the location it would
              mount).   Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand directory such as used
              for automounter indirect maps.  This flag can be used in tools that scan directories to  prevent  mass-auto‐
              mounting  of a directory of automount points.  The AT_NO_AUTOMOUNT flag has no effect if the mount point has
              already been mounted over.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.   Both
              stat() and lstat() act as though AT_NO_AUTOMOUNT was set.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a  symbolic link, do not dereference it: instead return information about the link itself,
              like lstat().  (By default, fstatat() dereferences symbolic links, like stat().)

       See openat(2) for an explanation of the need for fstatat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Search permission is denied for one of the directories in the path prefix of pathname.  (See also path_reso‐
              lution(7).)

       EBADF  fd is not a valid open file descriptor.

       EFAULT Bad address.

       ELOOP  Too many symbolic links encountered while traversing the path.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A  component  of pathname does not exist, or pathname is an empty string and AT_EMPTY_PATH was not specified
              in flags.

       ENOMEM Out of memory (i.e., kernel memory).

       ENOTDIR
              A component of the path prefix of pathname is not a directory.

       EOVERFLOW
              pathname or fd refers to a file whose size, inode number, or number of  blocks  cannot  be  represented  in,
              respectively,  the  types off_t, ino_t, or blkcnt_t.  This error can occur when, for example, an application
              compiled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 calls stat()  on  a  file  whose  size  exceeds
              (1<<31)-1 bytes.

       The following additional errors can occur for fstatat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fstatat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       stat(), fstat(), lstat(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.

       fstatat(): POSIX.1-2008.

       According  to  POSIX.1-2001, lstat() on a symbolic link need return valid information only in the st_size field and
       the file type of the st_mode field of the stat  structure.   POSIX.1-2008  tightens  the  specification,  requiring
       lstat() to return valid information in all fields except the mode bits in st_mode.

       Use of the st_blocks and st_blksize fields may be less portable.  (They were introduced in BSD.  The interpretation
       differs between systems, and possibly on a single system when NFS mounts are involved.)

NOTES
   Timestamp fields
       Older kernels and older standards did not support nanosecond timestamp fields.  Instead, there were three timestamp
       fields—st_atime, st_mtime, and st_ctime—typed as time_t that recorded timestamps with one-second precision.

       Since  kernel  2.5.48,  the stat structure supports nanosecond resolution for the three file timestamp fields.  The
       nanosecond components of each timestamp are available via names of the form st_atim.tv_nsec,  if  suitable  feature
       test macros are defined.  Nanosecond timestamps were standardized in POSIX.1-2008, and, starting with version 2.12,
       glibc exposes the nanosecond component names if _POSIX_C_SOURCE is defined with the value 200809L  or  greater,  or
       _XOPEN_SOURCE  is  defined  with  the value 700 or greater.  Up to and including glibc 2.19, the definitions of the
       nanoseconds components are also defined if _BSD_SOURCE or _SVID_SOURCE is defined.  If none of  the  aforementioned
       macros are defined, then the nanosecond values are exposed with names of the form st_atimensec.

   C library/kernel differences
       Over  time, increases in the size of the stat structure have led to three successive versions of stat(): sys_stat()
       (slot __NR_oldstat), sys_newstat() (slot __NR_stat), and sys_stat64() (slot __NR_stat64) on 32-bit  platforms  such
       as  i386.   The  first  two  versions were already present in Linux 1.0 (albeit with different names); the last was
       added in Linux 2.4.  Similar remarks apply for fstat() and lstat().

       The kernel-internal versions of the stat structure dealt with by the different versions are, respectively:

       __old_kernel_stat
              The original structure, with rather narrow fields, and no padding.

       stat   Larger st_ino field and padding added to various parts of the structure to allow for future expansion.

       stat64 Even larger st_ino field, larger st_uid and st_gid fields to accommodate the Linux-2.4 expansion of UIDs and
              GIDs  to  32 bits, and various other enlarged fields and further padding in the structure.  (Various padding
              bytes were eventually consumed in Linux 2.6, with the advent of 32-bit device IDs and nanosecond  components
              for the timestamp fields.)

       The  glibc  stat()  wrapper function hides these details from applications, invoking the most recent version of the
       system call provided by the kernel, and repacking the returned information if required for old binaries.

       On modern 64-bit systems, life is simpler: there is a single stat() system call and the kernel deals  with  a  stat
       structure that contains fields of a sufficient size.

       The  underlying  system call employed by the glibc fstatat() wrapper function is actually called fstatat64() or, on
       some architectures, newfstatat().

EXAMPLE
       The following program calls lstat() and displays selected fields in the returned stat structure.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/sysmacros.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           printf("ID of containing device:  [%lx,%lx]\n",
                (long) major(sb.st_dev), (long) minor(sb.st_dev));

           printf("File type:                ");

           switch (sb.st_mode & S_IFMT) {
           case S_IFBLK:  printf("block device\n");            break;
           case S_IFCHR:  printf("character device\n");        break;
           case S_IFDIR:  printf("directory\n");               break;
           case S_IFIFO:  printf("FIFO/pipe\n");               break;
           case S_IFLNK:  printf("symlink\n");                 break;
           case S_IFREG:  printf("regular file\n");            break;
           case S_IFSOCK: printf("socket\n");                  break;
           default:       printf("unknown?\n");                break;
           }

           printf("I-node number:            %ld\n", (long) sb.st_ino);

           printf("Mode:                     %lo (octal)\n",
                   (unsigned long) sb.st_mode);

           printf("Link count:               %ld\n", (long) sb.st_nlink);
           printf("Ownership:                UID=%ld   GID=%ld\n",
                   (long) sb.st_uid, (long) sb.st_gid);

           printf("Preferred I/O block size: %ld bytes\n",
                   (long) sb.st_blksize);
           printf("File size:                %lld bytes\n",
                   (long long) sb.st_size);
           printf("Blocks allocated:         %lld\n",
                   (long long) sb.st_blocks);

           printf("Last status change:       %s", ctime(&sb.st_ctime));
           printf("Last file access:         %s", ctime(&sb.st_atime));
           printf("Last file modification:   %s", ctime(&sb.st_mtime));

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ls(1), stat(1), access(2), chmod(2), chown(2), readlink(2), utime(2), capabilities(7), inode(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 STAT(2)
</pre>
<pre zoom>
<span xsmall>2 fstatat64</span>
STAT(2)                                          Linux Programmer's Manual                                         STAT(2)

NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       int fstat(int fd, struct stat *statbuf);
       int lstat(const char *pathname, struct stat *statbuf);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
                   int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       lstat():
           /* glibc 2.19 and earlier */ _BSD_SOURCE
               || /* Since glibc 2.20 */ _DEFAULT_SOURCE
               || _XOPEN_SOURCE >= 500
               || /* Since glibc 2.10: */ _POSIX_C_SOURCE >= 200112L

       fstatat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  functions return information about a file, in the buffer pointed to by statbuf.  No permissions are required
       on the file itself, but—in the case of stat(), fstatat(), and lstat()—execute (search) permission  is  required  on
       all of the directories in pathname that lead to the file.

       stat()  and fstatat() retrieve information about the file pointed to by pathname; the differences for fstatat() are
       described below.

       lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information  about  the
       link itself, not the file that it refers to.

       fstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the
       file descriptor fd.

   The stat structure
       All of these system calls return a stat structure, which contains the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

       Note: the order of fields in the stat structure varies somewhat across architectures.  In addition, the  definition
       above  does  not  show the padding bytes that may be present between some fields on various architectures.  Consult
       the glibc and kernel source code if you need to know the details.

       Note: for performance and simplicity reasons, different fields in the stat structure may contain state  information
       from  different  moments  during the execution of the system call.  For example, if st_mode or st_uid is changed by
       another process by calling chmod(2) or chown(2), stat() might return the old st_mode together with the new  st_uid,
       or the old st_uid together with the new st_mode.

       The fields in the stat structure are as follows:

       st_dev This field describes the device on which this file resides.  (The major(3) and minor(3) macros may be useful
              to decompose the device ID in this field.)

       st_ino This field contains the file's inode number.

       st_mode
              This field contains the file type and mode.  See inode(7) for further information.

       st_nlink
              This field contains the number of hard links to the file.

       st_uid This field contains the user ID of the owner of the file.

       st_gid This field contains the ID of the group owner of the file.

       st_rdev
              This field describes the device that this file (inode) represents.

       st_size
              This field gives the size of the file (if it is a regular file or a symbolic link) in bytes.  The size of  a
              symbolic link is the length of the pathname it contains, without a terminating null byte.

       st_blksize
              This field gives the "preferred" block size for efficient filesystem I/O.

       st_blocks
              This  field  indicates  the number of blocks allocated to the file, in 512-byte units.  (This may be smaller
              than st_size/512 when the file has holes.)

       st_atime
              This is the file's last access timestamp.

       st_mtime
              This is the file's last modification timestamp.

       st_ctime
              This is the file's last status change timestamp.

       For further information on the above fields, see inode(7).

   fstatat()
       The fstatat() system call is a more general interface for  accessing  file  information  which  can  still  provide
       exactly the behavior of each of stat(), lstat(), and fstat().

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       stat() and lstat() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like stat() and lstat()).

       If pathname is absolute, then dirfd is ignored.

       flags can either be 0, or include one or more of the following flags ORed:

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2) O_PATH flag).  In this case, dirfd can refer to any type of file, not just a directory, and the
              behavior of fstatat() is similar to that of fstat().  If dirfd is AT_FDCWD, the call operates on the current
              working directory.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.

       AT_NO_AUTOMOUNT (since Linux 2.6.38)
              Don't  automount  the  terminal ("basename") component of pathname if it is a directory that is an automount
              point.  This allows the caller to gather attributes of an automount point (rather than the location it would
              mount).   Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand directory such as used
              for automounter indirect maps.  This flag can be used in tools that scan directories to  prevent  mass-auto‐
              mounting  of a directory of automount points.  The AT_NO_AUTOMOUNT flag has no effect if the mount point has
              already been mounted over.  This flag is Linux-specific; define _GNU_SOURCE to obtain its definition.   Both
              stat() and lstat() act as though AT_NO_AUTOMOUNT was set.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a  symbolic link, do not dereference it: instead return information about the link itself,
              like lstat().  (By default, fstatat() dereferences symbolic links, like stat().)

       See openat(2) for an explanation of the need for fstatat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Search permission is denied for one of the directories in the path prefix of pathname.  (See also path_reso‐
              lution(7).)

       EBADF  fd is not a valid open file descriptor.

       EFAULT Bad address.

       ELOOP  Too many symbolic links encountered while traversing the path.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A  component  of pathname does not exist, or pathname is an empty string and AT_EMPTY_PATH was not specified
              in flags.

       ENOMEM Out of memory (i.e., kernel memory).

       ENOTDIR
              A component of the path prefix of pathname is not a directory.

       EOVERFLOW
              pathname or fd refers to a file whose size, inode number, or number of  blocks  cannot  be  represented  in,
              respectively,  the  types off_t, ino_t, or blkcnt_t.  This error can occur when, for example, an application
              compiled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 calls stat()  on  a  file  whose  size  exceeds
              (1<<31)-1 bytes.

       The following additional errors can occur for fstatat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fstatat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       stat(), fstat(), lstat(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.

       fstatat(): POSIX.1-2008.

       According  to  POSIX.1-2001, lstat() on a symbolic link need return valid information only in the st_size field and
       the file type of the st_mode field of the stat  structure.   POSIX.1-2008  tightens  the  specification,  requiring
       lstat() to return valid information in all fields except the mode bits in st_mode.

       Use of the st_blocks and st_blksize fields may be less portable.  (They were introduced in BSD.  The interpretation
       differs between systems, and possibly on a single system when NFS mounts are involved.)

NOTES
   Timestamp fields
       Older kernels and older standards did not support nanosecond timestamp fields.  Instead, there were three timestamp
       fields—st_atime, st_mtime, and st_ctime—typed as time_t that recorded timestamps with one-second precision.

       Since  kernel  2.5.48,  the stat structure supports nanosecond resolution for the three file timestamp fields.  The
       nanosecond components of each timestamp are available via names of the form st_atim.tv_nsec,  if  suitable  feature
       test macros are defined.  Nanosecond timestamps were standardized in POSIX.1-2008, and, starting with version 2.12,
       glibc exposes the nanosecond component names if _POSIX_C_SOURCE is defined with the value 200809L  or  greater,  or
       _XOPEN_SOURCE  is  defined  with  the value 700 or greater.  Up to and including glibc 2.19, the definitions of the
       nanoseconds components are also defined if _BSD_SOURCE or _SVID_SOURCE is defined.  If none of  the  aforementioned
       macros are defined, then the nanosecond values are exposed with names of the form st_atimensec.

   C library/kernel differences
       Over  time, increases in the size of the stat structure have led to three successive versions of stat(): sys_stat()
       (slot __NR_oldstat), sys_newstat() (slot __NR_stat), and sys_stat64() (slot __NR_stat64) on 32-bit  platforms  such
       as  i386.   The  first  two  versions were already present in Linux 1.0 (albeit with different names); the last was
       added in Linux 2.4.  Similar remarks apply for fstat() and lstat().

       The kernel-internal versions of the stat structure dealt with by the different versions are, respectively:

       __old_kernel_stat
              The original structure, with rather narrow fields, and no padding.

       stat   Larger st_ino field and padding added to various parts of the structure to allow for future expansion.

       stat64 Even larger st_ino field, larger st_uid and st_gid fields to accommodate the Linux-2.4 expansion of UIDs and
              GIDs  to  32 bits, and various other enlarged fields and further padding in the structure.  (Various padding
              bytes were eventually consumed in Linux 2.6, with the advent of 32-bit device IDs and nanosecond  components
              for the timestamp fields.)

       The  glibc  stat()  wrapper function hides these details from applications, invoking the most recent version of the
       system call provided by the kernel, and repacking the returned information if required for old binaries.

       On modern 64-bit systems, life is simpler: there is a single stat() system call and the kernel deals  with  a  stat
       structure that contains fields of a sufficient size.

       The  underlying  system call employed by the glibc fstatat() wrapper function is actually called fstatat64() or, on
       some architectures, newfstatat().

EXAMPLE
       The following program calls lstat() and displays selected fields in the returned stat structure.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/sysmacros.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           printf("ID of containing device:  [%lx,%lx]\n",
                (long) major(sb.st_dev), (long) minor(sb.st_dev));

           printf("File type:                ");

           switch (sb.st_mode & S_IFMT) {
           case S_IFBLK:  printf("block device\n");            break;
           case S_IFCHR:  printf("character device\n");        break;
           case S_IFDIR:  printf("directory\n");               break;
           case S_IFIFO:  printf("FIFO/pipe\n");               break;
           case S_IFLNK:  printf("symlink\n");                 break;
           case S_IFREG:  printf("regular file\n");            break;
           case S_IFSOCK: printf("socket\n");                  break;
           default:       printf("unknown?\n");                break;
           }

           printf("I-node number:            %ld\n", (long) sb.st_ino);

           printf("Mode:                     %lo (octal)\n",
                   (unsigned long) sb.st_mode);

           printf("Link count:               %ld\n", (long) sb.st_nlink);
           printf("Ownership:                UID=%ld   GID=%ld\n",
                   (long) sb.st_uid, (long) sb.st_gid);

           printf("Preferred I/O block size: %ld bytes\n",
                   (long) sb.st_blksize);
           printf("File size:                %lld bytes\n",
                   (long long) sb.st_size);
           printf("Blocks allocated:         %lld\n",
                   (long long) sb.st_blocks);

           printf("Last status change:       %s", ctime(&sb.st_ctime));
           printf("Last file access:         %s", ctime(&sb.st_atime));
           printf("Last file modification:   %s", ctime(&sb.st_mtime));

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ls(1), stat(1), access(2), chmod(2), chown(2), readlink(2), utime(2), capabilities(7), inode(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 STAT(2)
</pre>
<pre zoom>
<span xsmall>2 vfork</span>
VFORK(2)                                         Linux Programmer's Manual                                        VFORK(2)

NAME
       vfork - create a child process and block parent

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       pid_t vfork(void);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       vfork():
           Since glibc 2.12:
               (_XOPEN_SOURCE >= 500) && ! (_POSIX_C_SOURCE >= 200809L)
                   || /* Since glibc 2.19: */ _DEFAULT_SOURCE
                   || /* Glibc versions <= 2.19: */ _BSD_SOURCE
           Before glibc 2.12:
               _BSD_SOURCE || _XOPEN_SOURCE >= 500

DESCRIPTION
   Standard description
       (From  POSIX.1)  The  vfork() function has the same effect as fork(2), except that the behavior is undefined if the
       process created by vfork() either modifies any data other than a variable of type pid_t used to  store  the  return
       value  from  vfork(),  or returns from the function in which vfork() was called, or calls any other function before
       successfully calling _exit(2) or one of the exec(3) family of functions.

   Linux description
       vfork(), just like fork(2), creates a child process of the calling process.   For  details  and  return  value  and
       errors, see fork(2).

       vfork()  is  a special case of clone(2).  It is used to create new processes without copying the page tables of the
       parent process.  It may be useful in performance-sensitive applications where a child is created which then immedi‐
       ately issues an execve(2).

       vfork()  differs  from fork(2) in that the calling thread is suspended until the child terminates (either normally,
       by calling _exit(2), or abnormally, after delivery of a fatal signal), or it makes a call to execve(2).  Until that
       point,  the  child shares all memory with its parent, including the stack.  The child must not return from the cur‐
       rent function or call exit(3) (which would have the effect of calling  exit  handlers  established  by  the  parent
       process and flushing the parent's stdio(3) buffers), but may call _exit(2).

       As with fork(2), the child process created by vfork() inherits copies of various of the caller's process attributes
       (e.g., file descriptors, signal dispositions, and current working directory); the vfork() call differs only in  the
       treatment of the virtual address space, as described above.

       Signals sent to the parent arrive after the child releases the parent's memory (i.e., after the child terminates or
       calls execve(2)).

   Historic description
       Under Linux, fork(2) is implemented using copy-on-write pages, so the only penalty incurred by fork(2) is the  time
       and  memory  required  to  duplicate the parent's page tables, and to create a unique task structure for the child.
       However, in the bad old days a fork(2) would require making a complete copy of the caller's data space, often need‐
       lessly,  since  usually immediately afterward an exec(3) is done.  Thus, for greater efficiency, BSD introduced the
       vfork() system call, which did not fully copy the address space of the parent process, but  borrowed  the  parent's
       memory and thread of control until a call to execve(2) or an exit occurred.  The parent process was suspended while
       the child was using its resources.  The use of vfork() was tricky: for example, not modifying data  in  the  parent
       process depended on knowing which variables were held in a register.

CONFORMING TO
       4.3BSD; POSIX.1-2001 (but marked OBSOLETE).  POSIX.1-2008 removes the specification of vfork().

       The  requirements  put on vfork() by the standards are weaker than those put on fork(2), so an implementation where
       the two are synonymous is compliant.  In particular, the programmer cannot rely on  the  parent  remaining  blocked
       until  the  child  either  terminates  or calls execve(2), and cannot rely on any specific behavior with respect to
       shared memory.

NOTES
       Some consider the semantics of vfork() to be an architectural blemish, and the 4.2BSD man page stated: "This system
       call will be eliminated when proper system sharing mechanisms are implemented.  Users should not depend on the mem‐
       ory sharing semantics of vfork() as it will, in that case, be made synonymous to fork(2)."   However,  even  though
       modern  memory  management hardware has decreased the performance difference between fork(2) and vfork(), there are
       various reasons why Linux and other systems have retained vfork():

       *  Some performance-critical applications require the small performance advantage conferred by vfork().

       *  vfork() can be implemented on systems that lack a memory-management unit (MMU), but fork(2) can't be implemented
          on  such  systems.   (POSIX.1-2008 removed vfork() from the standard; the POSIX rationale for the posix_spawn(3)
          function notes that that function, which provides functionality equivalent to fork(2)+exec(3), is designed to be
          implementable on systems that lack an MMU.)

       *  On  systems  where memory is constrained, vfork() avoids the need to temporarily commit memory (see the descrip‐
          tion of /proc/sys/vm/overcommit_memory in proc(5)) in order to execute a new program.  (This can  be  especially
          beneficial  where  a large parent process wishes to execute a small helper program in a child process.)  By con‐
          trast, using fork(2) in this scenario requires either committing an amount of memory equal to the  size  of  the
          parent  process  (if strict overcommitting is in force) or overcommitting memory with the risk that a process is
          terminated by the out-of-memory (OOM) killer.

   Caveats
       The child process should take care not to modify the memory in unintended ways, since such changes will be seen  by
       the  parent  process once the child terminates or executes another program.  In this regard, signal handlers can be
       especially problematic: if a signal handler that is invoked in the child of vfork() changes memory,  those  changes
       may  result in an inconsistent process state from the perspective of the parent process (e.g., memory changes would
       be visible in the parent, but changes to the state of open file descriptors would not be visible).

       When vfork() is called in a multithreaded process, only the calling thread is suspended until the child  terminates
       or  executes  a  new program.  This means that the child is sharing an address space with other running code.  This
       can be dangerous if another thread in the parent process changes credentials (using setuid(2)  or  similar),  since
       there  are  now  two processes with different privilege levels running in the same address space.  As an example of
       the dangers, suppose that a multithreaded program running as  root  creates  a  child  using  vfork().   After  the
       vfork(),  a  thread  in the parent process drops the process to an unprivileged user in order to run some untrusted
       code (e.g., perhaps via plug-in opened with dlopen(3)).  In this  case,  attacks  are  possible  where  the  parent
       process uses mmap(2) to map in code that will be executed by the privileged child process.

   Linux notes
       Fork  handlers  established  using pthread_atfork(3) are not called when a multithreaded program employing the NPTL
       threading library calls vfork().  Fork handlers are called in this case in a program using the LinuxThreads thread‐
       ing library.  (See pthreads(7) for a description of Linux threading libraries.)

       A call to vfork() is equivalent to calling clone(2) with flags specified as:

            CLONE_VM | CLONE_VFORK | SIGCHLD

   History
       The  vfork()  system call appeared in 3.0BSD.  In 4.4BSD it was made synonymous to fork(2) but NetBSD introduced it
       again; see ⟨http://www.netbsd.org/Documentation/kernel/vfork.html⟩.  In Linux, it has been  equivalent  to  fork(2)
       until  2.2.0-pre6  or  so.   Since 2.2.0-pre9 (on i386, somewhat later on other architectures) it is an independent
       system call.  Support was added in glibc 2.0.112.

BUGS
       Details of the signal handling are obscure and differ between systems.  The BSD man page states: "To avoid a possi‐
       ble  deadlock  situation,  processes that are children in the middle of a vfork() are never sent SIGTTOU or SIGTTIN
       signals; rather, output or ioctls are allowed and input attempts result in an end-of-file indication."

SEE ALSO
       clone(2), execve(2), _exit(2), fork(2), unshare(2), wait(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                VFORK(2)
</pre>
<pre zoom>
<span xsmall>2 vmsplice</span>
VMSPLICE(2)                                      Linux Programmer's Manual                                     VMSPLICE(2)

NAME
       vmsplice - splice user pages into a pipe

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <fcntl.h>
       #include <sys/uio.h>

       ssize_t vmsplice(int fd, const struct iovec *iov,
                        unsigned long nr_segs, unsigned int flags);

DESCRIPTION
       The vmsplice() system call maps nr_segs ranges of user memory described by iov into a pipe.  The file descriptor fd
       must refer to a pipe.

       The pointer iov points to an array of iovec structures as defined in <sys/uio.h>:

           struct iovec {
               void  *iov_base;        /* Starting address */
               size_t iov_len;         /* Number of bytes */
           };

       The flags argument is a bit mask that is composed by ORing together zero or more of the following values:

       SPLICE_F_MOVE
              Unused for vmsplice(); see splice(2).

       SPLICE_F_NONBLOCK
              Do not block on I/O; see splice(2) for further details.

       SPLICE_F_MORE
              Currently has no effect for vmsplice(), but may be implemented in the future; see splice(2).

       SPLICE_F_GIFT
              The user pages are a gift to the kernel.  The application may not modify this  memory  ever,  otherwise  the
              page  cache  and  on-disk  data  may  differ.  Gifting pages to the kernel means that a subsequent splice(2)
              SPLICE_F_MOVE can successfully move the pages; if this flag is not specified, then  a  subsequent  splice(2)
              SPLICE_F_MOVE must copy the pages.  Data must also be properly page aligned, both in memory and length.

RETURN VALUE
       Upon  successful  completion, vmsplice() returns the number of bytes transferred to the pipe.  On error, vmsplice()
       returns -1 and errno is set to indicate the error.

ERRORS
       EAGAIN SPLICE_F_NONBLOCK was specified in flags, and the operation would block.

       EBADF  fd either not valid, or doesn't refer to a pipe.

       EINVAL nr_segs is greater than IOV_MAX; or memory not aligned if SPLICE_F_GIFT set.

       ENOMEM Out of memory.

VERSIONS
       The vmsplice() system call first appeared in Linux 2.6.17; library support was added to glibc in version 2.5.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       vmsplice() follows the other vectorized read/write type functions when it comes to limitations  on  the  number  of
       segments being passed in.  This limit is IOV_MAX as defined in <limits.h>.  Currently, this limit is 1024.

SEE ALSO
       splice(2), tee(2), pipe(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             VMSPLICE(2)
</pre>
<pre zoom>
<span xsmall>2 geteuid</span>
GETUID(2)                                        Linux Programmer's Manual                                       GETUID(2)

NAME
       getuid, geteuid - get user identity

SYNOPSIS
       #include <unistd.h>
       #include <sys/types.h>

       uid_t getuid(void);
       uid_t geteuid(void);

DESCRIPTION
       getuid() returns the real user ID of the calling process.

       geteuid() returns the effective user ID of the calling process.

ERRORS
       These functions are always successful.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD.

NOTES
   History
       In UNIX V6 the getuid() call returned (euid << 8) + uid.  UNIX V7 introduced separate calls getuid() and geteuid().

       The  original  Linux  getuid()  and geteuid() system calls supported only 16-bit user IDs.  Subsequently, Linux 2.4
       added getuid32() and geteuid32(), supporting 32-bit IDs.  The glibc getuid() and geteuid() wrapper functions trans‐
       parently deal with the variations across kernel versions.

SEE ALSO
       getresuid(2), setreuid(2), setuid(2), credentials(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               GETUID(2)
</pre>
<pre zoom>
<span xsmall>2 putpmsg</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 mlock</span>
MLOCK(2)                                         Linux Programmer's Manual                                        MLOCK(2)

NAME
       mlock, mlock2, munlock, mlockall, munlockall - lock and unlock memory

SYNOPSIS
       #include <sys/mman.h>

       int mlock(const void *addr, size_t len);
       int mlock2(const void *addr, size_t len, int flags);
       int munlock(const void *addr, size_t len);

       int mlockall(int flags);
       int munlockall(void);

DESCRIPTION
       mlock(),  mlock2(),  and  mlockall() lock part or all of the calling process's virtual address space into RAM, pre‐
       venting that memory from being paged to the swap area.

       munlock() and munlockall() perform the converse operation, unlocking part or all of the calling  process's  virtual
       address  space, so that pages in the specified virtual address range may once more to be swapped out if required by
       the kernel memory manager.

       Memory locking and unlocking are performed in units of whole pages.

   mlock(), mlock2(), and munlock()
       mlock() locks pages in the address range starting at addr and continuing for len bytes.  All pages that  contain  a
       part  of  the  specified address range are guaranteed to be resident in RAM when the call returns successfully; the
       pages are guaranteed to stay in RAM until later unlocked.

       mlock2() also locks pages in the specified range starting at addr and continuing for len bytes.  However, the state
       of  the  pages  contained  in  that range after the call returns successfully will depend on the value in the flags
       argument.

       The flags argument can be either 0 or the following constant:

       MLOCK_ONFAULT
              Lock pages that are currently resident and mark the entire range so that  the  remaining  nonresident  pages
              locked when they are populated by a page fault.

       If flags is 0, mlock2() behaves exactly the same as mlock().

       munlock()  unlocks  pages in the address range starting at addr and continuing for len bytes.  After this call, all
       pages that contain a part of the specified memory range can be moved to external swap space again by the kernel.

   mlockall() and munlockall()
       mlockall() locks all pages mapped into the address space of the calling process.  This includes the  pages  of  the
       code, data and stack segment, as well as shared libraries, user space kernel data, shared memory, and memory-mapped
       files.  All mapped pages are guaranteed to be resident in RAM when the call returns  successfully;  the  pages  are
       guaranteed to stay in RAM until later unlocked.

       The flags argument is constructed as the bitwise OR of one or more of the following constants:

       MCL_CURRENT Lock all pages which are currently mapped into the address space of the process.

       MCL_FUTURE  Lock  all  pages  which  will become mapped into the address space of the process in the future.  These
                   could be, for instance, new pages required by a growing heap and stack as  well  as  new  memory-mapped
                   files or shared memory regions.

       MCL_ONFAULT (since Linux 4.4)
                   Used  together  with  MCL_CURRENT,  MCL_FUTURE, or both.  Mark all current (with MCL_CURRENT) or future
                   (with MCL_FUTURE) mappings to lock pages when they are faulted in.  When  used  with  MCL_CURRENT,  all
                   present  pages  are  locked,  but  mlockall()  will  not  fault  in  non-present pages.  When used with
                   MCL_FUTURE, all future mappings will be marked to lock pages when they are faulted in,  but  they  will
                   not  be  populated  by  the  lock  when  the  mapping is created.  MCL_ONFAULT must be used with either
                   MCL_CURRENT or MCL_FUTURE or both.

       If MCL_FUTURE has been specified, then a later system call (e.g., mmap(2), sbrk(2),  malloc(3)),  may  fail  if  it
       would  cause  the  number  of locked bytes to exceed the permitted maximum (see below).  In the same circumstances,
       stack growth may likewise fail: the kernel will deny stack expansion and deliver a SIGSEGV signal to the process.

       munlockall() unlocks all pages mapped into the address space of the calling process.

RETURN VALUE
       On success, these system calls return 0.  On error, -1 is returned, errno is set appropriately, and no changes  are
       made to any locks in the address space of the process.

ERRORS
       ENOMEM (Linux  2.6.9 and later) the caller had a nonzero RLIMIT_MEMLOCK soft resource limit, but tried to lock more
              memory than the limit permitted.  This limit is not enforced if the process is privileged (CAP_IPC_LOCK).

       ENOMEM (Linux 2.4 and earlier) the calling process tried to lock more than half of RAM.

       EPERM  The caller is not privileged, but needs privilege (CAP_IPC_LOCK) to perform the requested operation.

       For mlock(), mlock2(), and munlock():

       EAGAIN Some or all of the specified address range could not be locked.

       EINVAL The result of the addition addr+len was less than addr (e.g., the addition may have  resulted  in  an  over‐
              flow).

       EINVAL (Not on Linux) addr was not a multiple of the page size.

       ENOMEM Some of the specified address range does not correspond to mapped pages in the address space of the process.

       ENOMEM Locking  or  unlocking a region would result in the total number of mappings with distinct attributes (e.g.,
              locked versus unlocked) exceeding the allowed maximum.  (For example, unlocking a range in the middle  of  a
              currently  locked  mapping  would  result in three mappings: two locked mappings at each end and an unlocked
              mapping in the middle.)

       For mlock2():

       EINVAL Unknown flags were specified.

       For mlockall():

       EINVAL Unknown flags were specified or MCL_ONFAULT was specified without either MCL_FUTURE or MCL_CURRENT.

       For munlockall():

       EPERM  (Linux 2.6.8 and earlier) The caller was not privileged (CAP_IPC_LOCK).

VERSIONS
       mlock2() is available since Linux 4.4; glibc support was added in version 2.27.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

       mlock2 () is Linux specific.

AVAILABILITY
       On POSIX systems on which mlock() and munlock() are available, _POSIX_MEMLOCK_RANGE is defined  in  <unistd.h>  and
       the number of bytes in a page can be determined from the constant PAGESIZE (if defined) in <limits.h> or by calling
       sysconf(_SC_PAGESIZE).

       On POSIX systems on which mlockall() and munlockall() are available, _POSIX_MEMLOCK is defined in <unistd.h>  to  a
       value greater than 0.  (See also sysconf(3).)

NOTES
       Memory locking has two main applications: real-time algorithms and high-security data processing.  Real-time appli‐
       cations require deterministic timing, and, like scheduling, paging is one major cause of unexpected program  execu‐
       tion  delays.  Real-time applications will usually also switch to a real-time scheduler with sched_setscheduler(2).
       Cryptographic security software often handles critical bytes like passwords or secret keys as data structures.   As
       a  result  of  paging,  these secrets could be transferred onto a persistent swap store medium, where they might be
       accessible to the enemy long after the security software has erased the secrets in RAM  and  terminated.   (But  be
       aware  that  the  suspend  mode on laptops and some desktop computers will save a copy of the system's RAM to disk,
       regardless of memory locks.)

       Real-time processes that are using mlockall() to prevent delays on page faults should reserve enough  locked  stack
       pages  before  entering the time-critical section, so that no page fault can be caused by function calls.  This can
       be achieved by calling a function that allocates a sufficiently large automatic variable (an array) and  writes  to
       the  memory  occupied by this array in order to touch these stack pages.  This way, enough pages will be mapped for
       the stack and can be locked into RAM.  The dummy writes ensure that not even copy-on-write page faults can occur in
       the critical section.

       Memory  locks  are  not inherited by a child created via fork(2) and are automatically removed (unlocked) during an
       execve(2) or when the process terminates.  The mlockall() MCL_FUTURE and MCL_FUTURE | MCL_ONFAULT settings are  not
       inherited by a child created via fork(2) and are cleared during an execve(2).

       Note  that fork(2) will prepare the address space for a copy-on-write operation.  The consequence is that any write
       access that follows will cause a page fault that in turn may cause high latencies for a real-time process.   There‐
       fore,  it  is  crucial  not to invoke fork(2) after an mlockall() or mlock() operation—not even from a thread which
       runs at a low priority within a process which also has a thread running at elevated priority.

       The memory lock on an address range is automatically removed if the address range is unmapped via munmap(2).

       Memory locks do not stack, that is, pages which have been locked several times by calls to  mlock(),  mlock2(),  or
       mlockall()  will  be  unlocked by a single call to munlock() for the corresponding range or by munlockall().  Pages
       which are mapped to several locations or by several processes stay locked into RAM as long as they  are  locked  at
       least at one location or by at least one process.

       If a call to mlockall() which uses the MCL_FUTURE flag is followed by another call that does not specify this flag,
       the changes made by the MCL_FUTURE call will be lost.

       The mlock2() MLOCK_ONFAULT flag and the mlockall() MCL_ONFAULT flag allow efficient memory locking for applications
       that  deal  with  large  mappings where only a (small) portion of pages in the mapping are touched.  In such cases,
       locking all of the pages in a mapping would incur a significant penalty for memory locking.

   Linux notes
       Under Linux, mlock(), mlock2(), and munlock() automatically round addr down to the nearest page boundary.  However,
       the  POSIX.1  specification of mlock() and munlock() allows an implementation to require that addr is page aligned,
       so portable applications should ensure this.

       The VmLck field of the Linux-specific /proc/[pid]/status file shows how many kilobytes of memory the  process  with
       ID PID has locked using mlock(), mlock2(), mlockall(), and mmap(2) MAP_LOCKED.

   Limits and permissions
       In Linux 2.6.8 and earlier, a process must be privileged (CAP_IPC_LOCK) in order to lock memory and the RLIMIT_MEM‐
       LOCK soft resource limit defines a limit on how much memory the process may lock.

       Since Linux 2.6.9, no limits are placed on the amount of  memory  that  a  privileged  process  can  lock  and  the
       RLIMIT_MEMLOCK soft resource limit instead defines a limit on how much memory an unprivileged process may lock.

BUGS
       In Linux 4.8 and earlier, a bug in the kernel's accounting of locked memory for unprivileged processes (i.e., with‐
       out CAP_IPC_LOCK) meant that if the region specified by addr and len overlapped an existing lock, then the  already
       locked  bytes in the overlapping region were counted twice when checking against the limit.  Such double accounting
       could incorrectly calculate a "total locked memory" value for the process that exceeded the  RLIMIT_MEMLOCK  limit,
       with the result that mlock() and mlock2() would fail on requests that should have succeeded.  This bug was fixed in
       Linux 4.9

       In the 2.4 series Linux kernels up to and including 2.4.17, a bug caused  the  mlockall()  MCL_FUTURE  flag  to  be
       inherited across a fork(2).  This was rectified in kernel 2.4.18.

       Since  kernel  2.6.9,  if  a  privileged  process  calls mlockall(MCL_FUTURE) and later drops privileges (loses the
       CAP_IPC_LOCK capability by, for example, setting its effective UID to a  nonzero  value),  then  subsequent  memory
       allocations (e.g., mmap(2), brk(2)) will fail if the RLIMIT_MEMLOCK resource limit is encountered.

SEE ALSO
       mincore(2), mmap(2), setrlimit(2), shmctl(2), sysconf(3), proc(5), capabilities(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-02-02                                                MLOCK(2)
</pre>
<pre zoom>
<span xsmall>2 bind</span>
BIND(2)                                          Linux Programmer's Manual                                         BIND(2)

NAME
       bind - bind a name to a socket

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>

       int bind(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen);

DESCRIPTION
       When  a socket is created with socket(2), it exists in a name space (address family) but has no address assigned to
       it.  bind() assigns the address specified by addr to the socket referred to by the file descriptor sockfd.  addrlen
       specifies the size, in bytes, of the address structure pointed to by addr.  Traditionally, this operation is called
       “assigning a name to a socket”.

       It is normally necessary to assign a local address using bind() before a SOCK_STREAM socket may receive connections
       (see accept(2)).

       The rules used in name binding vary between address families.  Consult the manual entries in Section 7 for detailed
       information.  For AF_INET, see ip(7); for AF_INET6, see ipv6(7); for AF_UNIX, see unix(7);  for  AF_APPLETALK,  see
       ddp(7); for AF_PACKET, see packet(7); for AF_X25, see x25(7); and for AF_NETLINK, see netlink(7).

       The  actual  structure  passed  for the addr argument will depend on the address family.  The sockaddr structure is
       defined as something like:

           struct sockaddr {
               sa_family_t sa_family;
               char        sa_data[14];
           }

       The only purpose of this structure is to cast the structure pointer passed in addr in order to avoid compiler warn‐
       ings.  See EXAMPLE below.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES The address is protected, and the user is not the superuser.

       EADDRINUSE
              The given address is already in use.

       EADDRINUSE
              (Internet  domain  sockets) The port number was specified as zero in the socket address structure, but, upon
              attempting to bind to an ephemeral port, it was determined that all port numbers in the ephemeral port range
              are currently in use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range ip(7).

       EBADF  sockfd is not a valid file descriptor.

       EINVAL The socket is already bound to an address.

       EINVAL addrlen is wrong, or addr is not a valid address for this socket's domain.

       ENOTSOCK
              The file descriptor sockfd does not refer to a socket.

       The following errors are specific to UNIX domain (AF_UNIX) sockets:

       EACCES Search permission is denied on a component of the path prefix.  (See also path_resolution(7).)

       EADDRNOTAVAIL
              A nonexistent interface was requested or the requested address was not local.

       EFAULT addr points outside the user's accessible address space.

       ELOOP  Too many symbolic links were encountered in resolving addr.

       ENAMETOOLONG
              addr is too long.

       ENOENT A component in the directory prefix of the socket pathname does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of the path prefix is not a directory.

       EROFS  The socket inode would reside on a read-only filesystem.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (bind() first appeared in 4.2BSD).

NOTES
       POSIX.1  does  not require the inclusion of <sys/types.h>, and this header file is not required on Linux.  However,
       some historical (BSD) implementations required this header file, and portable applications  are  probably  wise  to
       include it.

       For background on the socklen_t type, see accept(2).

BUGS
       The transparent proxy options are not described.

EXAMPLE
       An example of the use of bind() with Internet domain sockets can be found in getaddrinfo(3).

       The following example shows how to bind a stream socket in the UNIX (AF_UNIX) domain, and accept connections:

       #include <sys/socket.h>
       #include <sys/un.h>
       #include <stdlib.h>
       #include <stdio.h>
       #include <string.h>

       #define MY_SOCK_PATH "/somepath"
       #define LISTEN_BACKLOG 50

       #define handle_error(msg) \
           do { perror(msg); exit(EXIT_FAILURE); } while (0)

       int
       main(int argc, char *argv[])
       {
           int sfd, cfd;
           struct sockaddr_un my_addr, peer_addr;
           socklen_t peer_addr_size;

           sfd = socket(AF_UNIX, SOCK_STREAM, 0);
           if (sfd == -1)
               handle_error("socket");

           memset(&my_addr, 0, sizeof(struct sockaddr_un));
                               /* Clear structure */
           my_addr.sun_family = AF_UNIX;
           strncpy(my_addr.sun_path, MY_SOCK_PATH,
                   sizeof(my_addr.sun_path) - 1);

           if (bind(sfd, (struct sockaddr *) &my_addr,
                   sizeof(struct sockaddr_un)) == -1)
               handle_error("bind");

           if (listen(sfd, LISTEN_BACKLOG) == -1)
               handle_error("listen");

           /* Now we can accept incoming connections one
              at a time using accept(2) */

           peer_addr_size = sizeof(struct sockaddr_un);
           cfd = accept(sfd, (struct sockaddr *) &peer_addr,
                        &peer_addr_size);
           if (cfd == -1)
               handle_error("accept");

           /* Code to deal with incoming connection(s)... */

           /* When no longer required, the socket pathname, MY_SOCK_PATH
              should be deleted using unlink(2) or remove(3) */
       }

SEE ALSO
       accept(2),  connect(2),  getsockname(2),  listen(2),  socket(2),  getaddrinfo(3),  getifaddrs(3),  ip(7),  ipv6(7),
       path_resolution(7), socket(7), unix(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2016-12-12                                                 BIND(2)
</pre>
<pre zoom>
<span xsmall>2 getrandom</span>
GETRANDOM(2)                                     Linux Programmer's Manual                                    GETRANDOM(2)

NAME
       getrandom - obtain a series of random bytes

SYNOPSIS
       #include <sys/random.h>

       ssize_t getrandom(void *buf, size_t buflen, unsigned int flags);

DESCRIPTION
       The  getrandom() system call fills the buffer pointed to by buf with up to buflen random bytes.  These bytes can be
       used to seed user-space random number generators or for cryptographic purposes.

       By default, getrandom() draws entropy from the urandom source (i.e., the same source as the  /dev/urandom  device).
       This behavior can be changed via the flags argument.

       If  the urandom source has been initialized, reads of up to 256 bytes will always return as many bytes as requested
       and will not be interrupted by signals.  No such guarantees apply for larger buffer sizes.   For  example,  if  the
       call is interrupted by a signal handler, it may return a partially filled buffer, or fail with the error EINTR.

       If  the urandom source has not yet been initialized, then getrandom() will block, unless GRND_NONBLOCK is specified
       in flags.

       The flags argument is a bit mask that can contain zero or more of the following values ORed together:

       GRND_RANDOM
              If this bit is set, then random bytes are drawn from the  random  source  (i.e.,  the  same  source  as  the
              /dev/random  device)  instead of the urandom source.  The random source is limited based on the entropy that
              can be obtained from environmental noise.  If the number of available bytes in the  random  source  is  less
              than  requested  in buflen, the call returns just the available random bytes.  If no random bytes are avail‐
              able, the behavior depends on the presence of GRND_NONBLOCK in the flags argument.

       GRND_NONBLOCK
              By default, when reading from the random source, getrandom() blocks if no random bytes  are  available,  and
              when  reading  from  the urandom source, it blocks if the entropy pool has not yet been initialized.  If the
              GRND_NONBLOCK flag is set, then getrandom() does not block in these cases, but instead  immediately  returns
              -1 with errno set to EAGAIN.

RETURN VALUE
       On  success, getrandom() returns the number of bytes that were copied to the buffer buf.  This may be less than the
       number of bytes requested via buflen if either GRND_RANDOM was specified in  flags  and  insufficient  entropy  was
       present in the random source or the system call was interrupted by a signal.

       On error, -1 is returned, and errno is set appropriately.

ERRORS
       EAGAIN The  requested  entropy  was not available, and getrandom() would have blocked if the GRND_NONBLOCK flag was
              not set.

       EFAULT The address referred to by buf is outside the accessible address space.

       EINTR  The call was interrupted by a signal handler; see the description of how interrupted read(2) calls on "slow"
              devices are handled with and without the SA_RESTART flag in the signal(7) man page.

       EINVAL An invalid flag was specified in flags.

       ENOSYS The  glibc  wrapper  function  for getrandom() determined that the underlying kernel does not implement this
              system call.

VERSIONS
       getrandom() was introduced in version 3.17 of the Linux kernel.  Support was added to glibc in version 2.25.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       For an overview and comparison of the various interfaces that can be used to obtain randomness, see random(7).

       Unlike /dev/random and /dev/urandom, getrandom() does not involve the use of pathnames or file descriptors.   Thus,
       getrandom()  can be useful in cases where chroot(2) makes /dev pathnames invisible, and where an application (e.g.,
       a daemon during start-up) closes a file descriptor for one of these files that was opened by a library.

   Maximum number of bytes returned
       As of Linux 3.19 the following limits apply:

       *  When reading from the urandom source, a maximum of 33554431 bytes is returned by a single call to getrandom() on
          systems where int has a size of 32 bits.

       *  When reading from the random source, a maximum of 512 bytes is returned.

   Interruption by a signal handler
       When  reading  from  the urandom source (GRND_RANDOM is not set), getrandom() will block until the entropy pool has
       been initialized (unless the GRND_NONBLOCK flag was specified).  If a request is made to read  a  large  number  of
       bytes  (more  than  256),  getrandom() will block until those bytes have been generated and transferred from kernel
       memory to buf.  When reading from the random source (GRND_RANDOM is set), getrandom() will block until some  random
       bytes become available (unless the GRND_NONBLOCK flag was specified).

       The  behavior  when a call to getrandom() that is blocked while reading from the urandom source is interrupted by a
       signal handler depends on the initialization state of the entropy buffer and on the request size, buflen.   If  the
       entropy is not yet initialized, then the call fails with the EINTR error.  If the entropy pool has been initialized
       and the request size is large (buflen > 256), the call either succeeds, returning a  partially  filled  buffer,  or
       fails  with  the  error  EINTR.   If  the  entropy  pool  has  been  initialized  and  the  request  size  is small
       (buflen <= 256), then getrandom() will not fail with EINTR.  Instead, it will return all of  the  bytes  that  have
       been requested.

       When reading from the random source, blocking requests of any size can be interrupted by a signal handler (the call
       fails with the error EINTR).

       Using getrandom() to read small buffers (<= 256 bytes) from the urandom source is the preferred mode of usage.

       The special treatment of small values of buflen was designed for compatibility with OpenBSD's getentropy(3),  which
       is nowadays supported by glibc.

       The  user of getrandom() must always check the return value, to determine whether either an error occurred or fewer
       bytes than requested were returned.  In the case where GRND_RANDOM is not specified and  buflen  is  less  than  or
       equal to 256, a return of fewer bytes than requested should never happen, but the careful programmer will check for
       this anyway!

BUGS
       As of Linux 3.19, the following bug exists:

       *  Depending on CPU load, getrandom() does not react to interrupts before reading all bytes requested.

SEE ALSO
       getentropy(3), random(4), urandom(4), random(7), signal(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                            GETRANDOM(2)
</pre>
<pre zoom>
<span xsmall>2 timer_gettime</span>
TIMER_SETTIME(2)                                 Linux Programmer's Manual                                TIMER_SETTIME(2)

NAME
       timer_settime, timer_gettime - arm/disarm and fetch state of POSIX per-process timer

SYNOPSIS
       #include <time.h>

       int timer_settime(timer_t timerid, int flags,
                         const struct itimerspec *new_value,
                         struct itimerspec *old_value);
       int timer_gettime(timer_t timerid, struct itimerspec *curr_value);

       Link with -lrt.

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       timer_settime(), timer_gettime(): _POSIX_C_SOURCE >= 199309L

DESCRIPTION
       timer_settime()  arms  or disarms the timer identified by timerid.  The new_value argument is pointer to an itimer‐
       spec structure that specifies the new initial value and the new interval for the timer.  The  itimerspec  structure
       is defined as follows:

           struct timespec {
               time_t tv_sec;                /* Seconds */
               long   tv_nsec;               /* Nanoseconds */
           };

           struct itimerspec {
               struct timespec it_interval;  /* Timer interval */
               struct timespec it_value;     /* Initial expiration */
           };

       Each of the substructures of the itimerspec structure is a timespec structure that allows a time value to be speci‐
       fied in seconds and nanoseconds.  These time values are measured according to the clock that was specified when the
       timer was created by timer_create(2).

       If  new_value->it_value  specifies  a  nonzero  value (i.e., either subfield is nonzero), then timer_settime() arms
       (starts) the timer, setting it to initially expire at the given time.  (If the timer was already  armed,  then  the
       previous settings are overwritten.)  If new_value->it_value specifies a zero value (i.e., both subfields are zero),
       then the timer is disarmed.

       The new_value->it_interval field specifies the period of the timer, in seconds and nanoseconds.  If this  field  is
       nonzero,  then  each  time  that  an  armed  timer  expires,  the  timer  is  reloaded  from the value specified in
       new_value->it_interval.  If new_value->it_interval specifies a zero value, then the timer expires just once, at the
       time specified by it_value.

       By  default,  the  initial  expiration time specified in new_value->it_value is interpreted relative to the current
       time on the timer's clock at the time of the call.  This can be modified by specifying TIMER_ABSTIME in  flags,  in
       which  case  new_value->it_value is interpreted as an absolute value as measured on the timer's clock; that is, the
       timer will expire when the clock value reaches the value specified by new_value->it_value.  If the specified  abso‐
       lute  time  has already passed, then the timer expires immediately, and the overrun count (see timer_getoverrun(2))
       will be set correctly.

       If the value of the CLOCK_REALTIME clock is adjusted while an absolute timer based on that clock is armed, then the
       expiration  of the timer will be appropriately adjusted.  Adjustments to the CLOCK_REALTIME clock have no effect on
       relative timers based on that clock.

       If old_value is not NULL, then it points to a buffer that is used to return the previous interval of the timer  (in
       old_value->it_interval)  and  the  amount  of  time  until  the  timer  would  previously  have  next  expired  (in
       old_value->it_value).

       timer_gettime() returns the time until next expiration, and the interval, for the timer specified  by  timerid,  in
       the  buffer  pointed  to  by  curr_value.   The  time  remaining  until  the  next  timer expiration is returned in
       curr_value->it_value; this is always a relative value, regardless of whether the TIMER_ABSTIME flag was  used  when
       arming  the  timer.   If  the value returned in curr_value->it_value is zero, then the timer is currently disarmed.
       The timer interval is returned in curr_value->it_interval.  If the value  returned  in  curr_value->it_interval  is
       zero, then this is a "one-shot" timer.

RETURN VALUE
       On  success,  timer_settime() and timer_gettime() return 0.  On error, -1 is returned, and errno is set to indicate
       the error.

ERRORS
       These functions may fail with the following errors:

       EFAULT new_value, old_value, or curr_value is not a valid pointer.

       EINVAL timerid is invalid.

       timer_settime() may fail with the following errors:

       EINVAL new_value.it_value is negative; or new_value.it_value.tv_nsec is negative or greater than 999,999,999.

VERSIONS
       These system calls are available since Linux 2.6.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

EXAMPLE
       See timer_create(2).

SEE ALSO
       timer_create(2), timer_getoverrun(2), time(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        TIMER_SETTIME(2)
</pre>
<pre zoom>
<span xsmall>2 unlink</span>
UNLINK(2)                                        Linux Programmer's Manual                                       UNLINK(2)

NAME
       unlink, unlinkat - delete a name and possibly the file it refers to

SYNOPSIS
       #include <unistd.h>

       int unlink(const char *pathname);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <unistd.h>

       int unlinkat(int dirfd, const char *pathname, int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       unlinkat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       unlink()  deletes  a  name from the filesystem.  If that name was the last link to a file and no processes have the
       file open, the file is deleted and the space it was using is made available for reuse.

       If the name was the last link to a file but any processes still have the file open, the file will remain  in  exis‐
       tence until the last file descriptor referring to it is closed.

       If the name referred to a symbolic link, the link is removed.

       If  the  name referred to a socket, FIFO, or device, the name for it is removed but processes which have the object
       open may continue to use it.

   unlinkat()
       The unlinkat() system call operates in exactly the same way as either unlink() or rmdir(2) (depending on whether or
       not flags includes the AT_REMOVEDIR flag) except for the differences described here.

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       unlink() and rmdir(2) for a relative pathname).

       If the pathname given in pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted
       relative to the current working directory of the calling process (like unlink() and rmdir(2)).

       If the pathname given in pathname is absolute, then dirfd is ignored.

       flags is a bit mask that can either be specified as 0, or by ORing together flag values that control the  operation
       of unlinkat().  Currently, only one such flag is defined:

       AT_REMOVEDIR
              By  default, unlinkat() performs the equivalent of unlink() on pathname.  If the AT_REMOVEDIR flag is speci‐
              fied, then performs the equivalent of rmdir(2) on pathname.

       See openat(2) for an explanation of the need for unlinkat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Write access to the directory containing pathname is not allowed for the process's effective UID, or one  of
              the directories in pathname did not allow search permission.  (See also path_resolution(7).)

       EBUSY  The file pathname cannot be unlinked because it is being used by the system or another process; for example,
              it is a mount point or the NFS client software created it to represent  an  active  but  otherwise  nameless
              inode ("NFS silly renamed").

       EFAULT pathname points outside your accessible address space.

       EIO    An I/O error occurred.

       EISDIR pathname refers to a directory.  (This is the non-POSIX value returned by Linux since 2.1.132.)

       ELOOP  Too many symbolic links were encountered in translating pathname.

       ENAMETOOLONG
              pathname was too long.

       ENOENT A component in pathname does not exist or is a dangling symbolic link, or pathname is empty.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component used as a directory in pathname is not, in fact, a directory.

       EPERM  The system does not allow unlinking of directories, or unlinking of directories requires privileges that the
              calling process doesn't have.  (This is the POSIX prescribed error return; as  noted  above,  Linux  returns
              EISDIR for this case.)

       EPERM (Linux only)
              The filesystem does not allow unlinking of files.

       EPERM or EACCES
              The  directory  containing pathname has the sticky bit (S_ISVTX) set and the process's effective UID is nei‐
              ther the UID of the file to be deleted nor that of the directory containing it, and the process is not priv‐
              ileged (Linux: does not have the CAP_FOWNER capability).

       EPERM  The file to be unlinked is marked immutable or append-only.  (See ioctl_iflags(2).)

       EROFS  pathname refers to a file on a read-only filesystem.

       The  same  errors  that  occur  for  unlink() and rmdir(2) can also occur for unlinkat().  The following additional
       errors can occur for unlinkat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL An invalid flag value was specified in flags.

       EISDIR pathname refers to a directory, and AT_REMOVEDIR was not specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       unlinkat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       unlink(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       unlinkat(): POSIX.1-2008.

NOTES
   Glibc notes
       On older kernels where unlinkat() is unavailable, the glibc wrapper function falls back to the use of  unlink()  or
       rmdir(2).   When  pathname  is  a  relative  pathname,  glibc  constructs  a pathname based on the symbolic link in
       /proc/self/fd that corresponds to the dirfd argument.

BUGS
       Infelicities in the protocol underlying NFS can cause the unexpected disappearance of files which are  still  being
       used.

SEE ALSO
       rm(1),  unlink(1),  chmod(2),  link(2),  mknod(2), open(2), rename(2), rmdir(2), mkfifo(3), remove(3), path_resolu‐
       tion(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               UNLINK(2)
</pre>
<pre zoom>
<span xsmall>2 gethostname</span>
GETHOSTNAME(2)                                   Linux Programmer's Manual                                  GETHOSTNAME(2)

NAME
       gethostname, sethostname - get/set hostname

SYNOPSIS
       #include <unistd.h>

       int gethostname(char *name, size_t len);
       int sethostname(const char *name, size_t len);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       gethostname():
           Since glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE >= 500
           || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200112L
       sethostname():
           Since glibc 2.21:
               _DEFAULT_SOURCE
           In glibc 2.19 and 2.20:
               _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE < 500)
           Up to and including glibc 2.19:
               _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE < 500)

DESCRIPTION
       These system calls are used to access or to change the hostname of the current processor.

       sethostname()  sets  the  hostname  to the value given in the character array name.  The len argument specifies the
       number of bytes in name.  (Thus, name does not require a terminating null byte.)

       gethostname() returns the null-terminated hostname in the character array name, which has a length  of  len  bytes.
       If  the null-terminated hostname is too large to fit, then the name is truncated, and no error is returned (but see
       NOTES below).  POSIX.1 says that if such truncation occurs, then it is  unspecified  whether  the  returned  buffer
       includes a terminating null byte.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT name is an invalid address.

       EINVAL len is negative or, for sethostname(), len is larger than the maximum allowed size.

       ENAMETOOLONG
              (glibc  gethostname()) len is smaller than the actual size.  (Before version 2.1, glibc uses EINVAL for this
              case.)

       EPERM  For sethostname(), the caller did not have the CAP_SYS_ADMIN capability in  the  user  namespace  associated
              with its UTS namespace (see namespaces(7)).

CONFORMING TO
       SVr4, 4.4BSD  (these interfaces first appeared in 4.2BSD).  POSIX.1-2001 and POSIX.1-2008 specify gethostname() but
       not sethostname().

NOTES
       SUSv2 guarantees that "Host names are limited to 255 bytes".  POSIX.1 guarantees that "Host  names  (not  including
       the  terminating null byte) are limited to HOST_NAME_MAX bytes".  On Linux, HOST_NAME_MAX is defined with the value
       64, which has been the limit since Linux 1.0 (earlier kernels imposed a limit of 8 bytes).

   C library/kernel differences
       The GNU C library does not employ the gethostname() system call; instead, it implements gethostname() as a  library
       function  that  calls  uname(2) and copies up to len bytes from the returned nodename field into name.  Having per‐
       formed the copy, the function then checks if the length of the nodename was greater than or equal to len, and if it
       is,  then  the  function  returns  -1  with errno set to ENAMETOOLONG; in this case, a terminating null byte is not
       included in the returned name.

       Versions of glibc before 2.2 handle the case where the length of the nodename was greater than or equal to len dif‐
       ferently: nothing is copied into name and the function returns -1 with errno set to ENAMETOOLONG.

SEE ALSO
       hostname(1), getdomainname(2), setdomainname(2), uname(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                          GETHOSTNAME(2)
</pre>
<pre zoom>
<span xsmall>2 mq_timedreceive</span>
MQ_RECEIVE(3)                                    Linux Programmer's Manual                                   MQ_RECEIVE(3)

NAME
       mq_receive, mq_timedreceive - receive a message from a message queue

SYNOPSIS
       #include <mqueue.h>

       ssize_t mq_receive(mqd_t mqdes, char *msg_ptr,
                          size_t msg_len, unsigned int *msg_prio);

       #include <time.h>
       #include <mqueue.h>

       ssize_t mq_timedreceive(mqd_t mqdes, char *msg_ptr,
                          size_t msg_len, unsigned int *msg_prio,
                          const struct timespec *abs_timeout);

       Link with -lrt.

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       mq_timedreceive():
           _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       mq_receive() removes the oldest message with the highest priority from the message queue referred to by the message
       queue descriptor mqdes, and places it in the buffer pointed to by msg_ptr.  The msg_len argument specifies the size
       of  the  buffer  pointed to by msg_ptr; this must be greater than or equal to the mq_msgsize attribute of the queue
       (see mq_getattr(3)).  If msg_prio is not NULL, then the buffer to which it points is used to  return  the  priority
       associated with the received message.

       If  the  queue  is  empty,  then, by default, mq_receive() blocks until a message becomes available, or the call is
       interrupted by a signal handler.  If the O_NONBLOCK flag is enabled for the message  queue  description,  then  the
       call instead fails immediately with the error EAGAIN.

       mq_timedreceive()  behaves just like mq_receive(), except that if the queue is empty and the O_NONBLOCK flag is not
       enabled for the message queue description, then abs_timeout points to a structure which specifies how long the call
       will  block.   This  value  is  an absolute timeout in seconds and nanoseconds since the Epoch, 1970-01-01 00:00:00
       +0000 (UTC), specified in the following structure:

           struct timespec {
               time_t tv_sec;        /* seconds */
               long   tv_nsec;       /* nanoseconds */
           };

       If no message is available, and the timeout has already expired by the time of the call, mq_timedreceive()  returns
       immediately.

RETURN VALUE
       On  success, mq_receive() and mq_timedreceive() return the number of bytes in the received message; on error, -1 is
       returned, with errno set to indicate the error.

ERRORS
       EAGAIN The queue was empty, and the O_NONBLOCK flag was set for the message queue description referred to by mqdes.

       EBADF  The descriptor specified in mqdes was invalid or not opened for reading.

       EINTR  The call was interrupted by a signal handler; see signal(7).

       EINVAL The call would have blocked, and abs_timeout was invalid, either because  tv_sec  was  less  than  zero,  or
              because tv_nsec was less than zero or greater than 1000 million.

       EMSGSIZE
              msg_len was less than the mq_msgsize attribute of the message queue.

       ETIMEDOUT
              The call timed out before a message could be transferred.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌────────────────────────────────┬───────────────┬─────────┐
       │Interface                       │ Attribute     │ Value   │
       ├────────────────────────────────┼───────────────┼─────────┤
       │mq_receive(), mq_timedreceive() │ Thread safety │ MT-Safe │
       └────────────────────────────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       On  Linux, mq_timedreceive() is a system call, and mq_receive() is a library function layered on top of that system
       call.

SEE ALSO
       mq_close(3), mq_getattr(3), mq_notify(3), mq_open(3), mq_send(3), mq_unlink(3), mq_overview(7), time(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           MQ_RECEIVE(3)
</pre>
<pre zoom>
<span xsmall>2 pwrite</span>
PREAD(2)                                         Linux Programmer's Manual                                        PREAD(2)

NAME
       pread, pwrite - read from or write to a file descriptor at a given offset

SYNOPSIS
       #include <unistd.h>

       ssize_t pread(int fd, void *buf, size_t count, off_t offset);

       ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pread(), pwrite():
           _XOPEN_SOURCE >= 500
           || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L

DESCRIPTION
       pread() reads up to count bytes from file descriptor fd at offset offset (from the start of the file) into the buf‐
       fer starting at buf.  The file offset is not changed.

       pwrite() writes up to count bytes from the buffer starting at buf to the file descriptor fd at offset offset.   The
       file offset is not changed.

       The file referenced by fd must be capable of seeking.

RETURN VALUE
       On  success, pread() returns the number of bytes read (a return of zero indicates end of file) and pwrite() returns
       the number of bytes written.

       Note that is not an error for a successful call to transfer fewer bytes than requested (see read(2) and write(2)).

       On error, -1 is returned and errno is set to indicate the cause of the error.

ERRORS
       pread() can fail and set errno to any error specified for read(2) or lseek(2).  pwrite() can fail and set errno  to
       any error specified for write(2) or lseek(2).

VERSIONS
       The  pread()  and  pwrite() system calls were added to Linux in version 2.1.60; the entries in the i386 system call
       table were added in 2.1.69.  C library support (including emulation using lseek(2) on  older  kernels  without  the
       system calls) was added in glibc 2.1.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       The  pread()  and  pwrite()  system calls are especially useful in multithreaded applications.  They allow multiple
       threads to perform I/O on the same file descriptor without being affected by changes to the file  offset  by  other
       threads.

   C library/kernel differences
       On  Linux,  the  underlying  system calls were renamed in kernel 2.6: pread() became pread64(), and pwrite() became
       pwrite64().  The system call numbers remained the same.  The glibc pread() and pwrite() wrapper functions transpar‐
       ently deal with the change.

       On  some  32-bit  architectures,  the calling signature for these system calls differ, for the reasons described in
       syscall(2).

BUGS
       POSIX requires that opening a file with the O_APPEND flag should have no effect on the location at  which  pwrite()
       writes  data.   However, on Linux, if a file is opened with O_APPEND, pwrite() appends data to the end of the file,
       regardless of the value of offset.

SEE ALSO
       lseek(2), read(2), readv(2), write(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                PREAD(2)
</pre>
<pre zoom>
<span xsmall>2 acct</span>
ACCT(2)                                          Linux Programmer's Manual                                         ACCT(2)

NAME
       acct - switch process accounting on or off

SYNOPSIS
       #include <unistd.h>

       int acct(const char *filename);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       acct():
           Since glibc 2.21:
               _DEFAULT_SOURCE
           In glibc 2.19 and 2.20:
               _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE < 500)
           Up to and including glibc 2.19:
               _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE < 500)

DESCRIPTION
       The  acct() system call enables or disables process accounting.  If called with the name of an existing file as its
       argument, accounting is turned on, and records for each terminating process are appended to filename as  it  termi‐
       nates.  An argument of NULL causes accounting to be turned off.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Write permission is denied for the specified file, or search permission is denied for one of the directories
              in the path prefix of filename (see also path_resolution(7)), or filename is not a regular file.

       EFAULT filename points outside your accessible address space.

       EIO    Error writing to the file filename.

       EISDIR filename is a directory.

       ELOOP  Too many symbolic links were encountered in resolving filename.

       ENAMETOOLONG
              filename was too long.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENOENT The specified file does not exist.

       ENOMEM Out of memory.

       ENOSYS BSD process accounting has not been enabled when the operating system kernel was compiled.  The kernel  con‐
              figuration parameter controlling this feature is CONFIG_BSD_PROCESS_ACCT.

       ENOTDIR
              A component used as a directory in filename is not in fact a directory.

       EPERM  The  calling  process  has insufficient privilege to enable process accounting.  On Linux, the CAP_SYS_PACCT
              capability is required.

       EROFS  filename refers to a file on a read-only filesystem.

       EUSERS There are no more free file structures or we ran out of memory.

CONFORMING TO
       SVr4, 4.3BSD (but not POSIX).

NOTES
       No accounting is produced for programs running when a system crash occurs.  In particular, nonterminating processes
       are never accounted for.

       The structure of the records written to the accounting file is described in acct(5).

SEE ALSO
       acct(5)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2016-03-15                                                 ACCT(2)
</pre>
<pre zoom>
<span xsmall>2 dup2</span>
DUP(2)                                           Linux Programmer's Manual                                          DUP(2)

NAME
       dup, dup2, dup3 - duplicate a file descriptor

SYNOPSIS
       #include <unistd.h>

       int dup(int oldfd);
       int dup2(int oldfd, int newfd);

       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <fcntl.h>              /* Obtain O_* constant definitions */
       #include <unistd.h>

       int dup3(int oldfd, int newfd, int flags);

DESCRIPTION
       The dup() system call creates a copy of the file descriptor oldfd, using the lowest-numbered unused file descriptor
       for the new descriptor.

       After a successful return, the old and new file descriptors may be used interchangeably.  They refer  to  the  same
       open file description (see open(2)) and thus share file offset and file status flags; for example, if the file off‐
       set is modified by using lseek(2) on one of the file descriptors, the offset is also changed for the other.

       The two file descriptors do not share file descriptor flags  (the  close-on-exec  flag).   The  close-on-exec  flag
       (FD_CLOEXEC; see fcntl(2)) for the duplicate descriptor is off.

   dup2()
       The  dup2()  system  call  performs  the  same  task as dup(), but instead of using the lowest-numbered unused file
       descriptor, it uses the file descriptor number specified in newfd.  If the file  descriptor  newfd  was  previously
       open, it is silently closed before being reused.

       The  steps  of  closing and reusing the file descriptor newfd are performed atomically.  This is important, because
       trying to implement equivalent functionality using close(2) and dup() would be subject to race conditions,  whereby
       newfd  might be reused between the two steps.  Such reuse could happen because the main program is interrupted by a
       signal handler that allocates a file descriptor, or because a parallel thread allocates a file descriptor.

       Note the following points:

       *  If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.

       *  If oldfd is a valid file descriptor, and newfd has the same value  as  oldfd,  then  dup2()  does  nothing,  and
          returns newfd.

   dup3()
       dup3() is the same as dup2(), except that:

       *  The  caller  can  force  the close-on-exec flag to be set for the new file descriptor by specifying O_CLOEXEC in
          flags.  See the description of the same flag in open(2) for reasons why this may be useful.

       *  If oldfd equals newfd, then dup3() fails with the error EINVAL.

RETURN VALUE
       On success, these system calls return the new file descriptor.  On error, -1 is returned, and errno is  set  appro‐
       priately.

ERRORS
       EBADF  oldfd isn't an open file descriptor.

       EBADF  newfd  is  out  of  the  allowed  range  for  file descriptors (see the discussion of RLIMIT_NOFILE in getr‐
              limit(2)).

       EBUSY  (Linux only) This may be returned by dup2() or dup3() during a race condition with open(2) and dup().

       EINTR  The dup2() or dup3() call was interrupted by a signal; see signal(7).

       EINVAL (dup3()) flags contain an invalid value.

       EINVAL (dup3()) oldfd was equal to newfd.

       EMFILE The per-process limit on the number of open file  descriptors  has  been  reached  (see  the  discussion  of
              RLIMIT_NOFILE in getrlimit(2)).

VERSIONS
       dup3() was added to Linux in version 2.6.27; glibc support is available starting with version 2.9.

CONFORMING TO
       dup(), dup2(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

       dup3() is Linux-specific.

NOTES
       The  error  returned  by  dup2()  is different from that returned by fcntl(..., F_DUPFD, ...)  when newfd is out of
       range.  On some systems, dup2() also sometimes returns EINVAL like F_DUPFD.

       If newfd was open, any errors that would have been reported at close(2) time are lost.   If  this  is  of  concern,
       then—unless  the  program  is single-threaded and does not allocate file descriptors in signal handlers—the correct
       approach is not to close newfd before calling dup2(), because of the race condition described above.  Instead, code
       something like the following could be used:

           /* Obtain a duplicate of 'newfd' that can subsequently
              be used to check for close() errors; an EBADF error
              means that 'newfd' was not open. */

           tmpfd = dup(newfd);
           if (tmpfd == -1 && errno != EBADF) {
               /* Handle unexpected dup() error */
           }

           /* Atomically duplicate 'oldfd' on 'newfd' */

           if (dup2(oldfd, newfd) == -1) {
               /* Handle dup2() error */
           }

           /* Now check for close() errors on the file originally
              referred to by 'newfd' */

           if (tmpfd != -1) {
               if (close(tmpfd) == -1) {
                   /* Handle errors from close */
               }
           }

SEE ALSO
       close(2), fcntl(2), open(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                  DUP(2)
</pre>
<pre zoom>
<span xsmall>2 request_key</span>
REQUEST_KEY(2)                                  Linux Key Management Calls                                  REQUEST_KEY(2)

NAME
       request_key - request a key from the kernel's key management facility

SYNOPSIS
       #include <sys/types.h>
       #include <keyutils.h>

       key_serial_t request_key(const char *type, const char *description,
                                const char *callout_info,
                                key_serial_t dest_keyring);

       No glibc wrapper is provided for this system call; see NOTES.

DESCRIPTION
       request_key()  attempts  to  find  a  key  of  the  given type with a description (name) that matches the specified
       description.  If such a key could not be found, then the key is optionally created.  If the key is  found  or  cre‐
       ated,  request_key()  attaches it to the keyring whose ID is specified in dest_keyring and returns the key's serial
       number.

       request_key() first recursively searches for a matching key in all of the keyrings attached to the calling process.
       The  keyrings  are  searched  in  the  order:  thread-specific  keyring, process-specific keyring, and then session
       keyring.

       If request_key() is called from a program invoked by request_key() on behalf of some other process  to  generate  a
       key,  then  the keyrings of that other process will be searched next, using that other process's user ID, group ID,
       supplementary group IDs, and security context to determine access.

       The search of the keyring tree is breadth-first: the keys in each keyring searched are checked for a  match  before
       any  child  keyrings  are  recursed  into.  Only keys for which the caller has search permission be found, and only
       keyrings for which the caller has search permission may be searched.

       If the key is not found and callout is NULL, then the call fails with the error ENOKEY.

       If the key is not found and callout is not NULL, then the kernel attempts to invoke a user-space program to instan‐
       tiate the key.  The details are given below.

       The  dest_keyring serial number may be that of a valid keyring for which the caller has write permission, or it may
       be one of the following special keyring IDs:

       KEY_SPEC_THREAD_KEYRING
              This specifies the caller's thread-specific keyring (see thread-keyring(7)).

       KEY_SPEC_PROCESS_KEYRING
              This specifies the caller's process-specific keyring (see process-keyring(7)).

       KEY_SPEC_SESSION_KEYRING
              This specifies the caller's session-specific keyring (see session-keyring(7)).

       KEY_SPEC_USER_KEYRING
              This specifies the caller's UID-specific keyring (see user-keyring(7)).

       KEY_SPEC_USER_SESSION_KEYRING
              This specifies the caller's UID-session keyring (see user-session-keyring(7)).

       When the dest_keyring is specified as 0 and no key construction has been performed, then no additional  linking  is
       done.

       Otherwise,  if dest_keyring is 0 and a new key is constructed, the new key will be linked to the "default" keyring.
       More precisely, when the kernel tries to determine to which keyring the newly constructed key should be linked,  it
       tries  the following keyrings, beginning with the keyring set via the keyctl(2) KEYCTL_SET_REQKEY_KEYRING operation
       and continuing in the order shown below until it finds the first keyring that exists:

       ·  The requestor keyring (KEY_REQKEY_DEFL_REQUESTOR_KEYRING, since Linux 2.6.29).

       ·  The thread-specific keyring (KEY_REQKEY_DEFL_THREAD_KEYRING; see thread-keyring(7)).

       ·  The process-specific keyring (KEY_REQKEY_DEFL_PROCESS_KEYRING; see process-keyring(7)).

       ·  The session-specific keyring (KEY_REQKEY_DEFL_SESSION_KEYRING; see session-keyring(7)).

       ·  The  session  keyring  for  the  process's  user  ID  (KEY_REQKEY_DEFL_USER_SESSION_KEYRING;  see  user-session-
          keyring(7)).  This keyring is expected to always exist.

       ·  The  UID-specific keyring (KEY_REQKEY_DEFL_USER_KEYRING; see user-keyring(7)).  This keyring is also expected to
          always exist.

       If   the   keyctl(2)    KEYCTL_SET_REQKEY_KEYRING    operation    specifies    KEY_REQKEY_DEFL_DEFAULT    (or    no
       KEYCTL_SET_REQKEY_KEYRING  operation is performed), then the kernel looks for a keyring starting from the beginning
       of the list.

   Requesting user-space instantiation of a key
       If the kernel cannot find a key matching type and description, and callout is not NULL, then the kernel attempts to
       invoke  a user-space program to instantiate a key with the given type and description.  In this case, the following
       steps are performed:

       a)  The kernel creates an uninstantiated key, U, with the requested type and description.

       b)  The kernel creates an authorization key, V, that refers to the key U and records the facts that the  caller  of
           request_key() is:

           (1) the context in which the key U should be instantiated and secured, and

           (2) the context from which associated key requests may be satisfied.

           The authorization key is constructed as follows:

           *  The key type is ".request_key_auth".

           *  The key's UID and GID are the same as the corresponding filesystem IDs of the requesting process.

           *  The  key  grants  view, read, and search permissions to the key possessor as well as view permission for the
              key user.

           *  The description (name) of the key is the hexadecimal string representing the ID of the key  that  is  to  be
              instantiated in the requesting program.

           *  The payload of the key is taken from the data specified in callout_info.

           *  Internally, the kernel also records the PID of the process that called request_key().

       c)  The  kernel  creates  a  process  that  executes a user-space service such as request-key(8) with a new session
           keyring that contains a link to the authorization key, V.

           This program is supplied with the following command-line arguments:

           [0] The string "/sbin/request-key".

           [1] The string "create" (indicating that a key is to be created).

           [2] The ID of the key that is to be instantiated.

           [3] The filesystem UID of the caller of request_key().

           [4] The filesystem GID of the caller of request_key().

           [5] The ID of the thread keyring of the caller of request_key().  This may be zero if that keyring hasn't  been
               created.

           [6] The ID of the process keyring of the caller of request_key().  This may be zero if that keyring hasn't been
               created.

           [7] The ID of the session keyring of the caller of request_key().

           Note: each of the command-line arguments that is a key ID is encoded in decimal (unlike the key  IDs  shown  in
           /proc/keys, which are shown as hexadecimal values).

       d)  The program spawned in the previous step:

           *  Assumes  the authority to instantiate the key U using the keyctl(2) KEYCTL_ASSUME_AUTHORITY operation (typi‐
              cally via the keyctl_assume_authority(3) function).

           *  Obtains the callout data from the payload of the authorization key V (using the keyctl(2) KEYCTL_READ opera‐
              tion (or, more commonly, the keyctl_read(3) function) with a key ID value of KEY_SPEC_REQKEY_AUTH_KEY).

           *  Instantiates the key (or execs another program that performs that task), specifying the payload and destina‐
              tion keyring.  (The destination keyring that the requestor  specified  when  calling  request_key()  can  be
              accessed  using  the  special  key  ID  KEY_SPEC_REQUESTOR_KEYRING.)   Instantiation  is performed using the
              keyctl(2) KEYCTL_INSTANTIATE operation (or, more commonly, the  keyctl_instantiate(3)  function).   At  this
              point, the request_key() call completes, and the requesting program can continue execution.

       If  these steps are unsuccessful, then an ENOKEY error will be returned to the caller of request_key() and a tempo‐
       rary, negatively instantiated key will be installed in the keyring specified by  dest_keyring.   This  will  expire
       after  a  few seconds, but will cause subsequent calls to request_key() to fail until it does.  The purpose of this
       negatively instantiated key is to prevent (possibly different) processes making  repeated  requests  (that  require
       expensive request-key(8) upcalls) for a key that can't (at the moment) be positively instantiated.

       Once  the  key has been instantiated, the authorization key (KEY_SPEC_REQKEY_AUTH_KEY) is revoked, and the destina‐
       tion keyring (KEY_SPEC_REQUESTOR_KEYRING) is no longer accessible from the request-key(8) program.

       If a key is created, then—regardless of whether it is a valid key or a negatively instantiated key—it will displace
       any other key with the same type and description from the keyring specified in dest_keyring.

RETURN VALUE
       On  success,  request_key() returns the serial number of the key it found or caused to be created.  On error, -1 is
       returned and errno is set to indicate the cause of the error.

ERRORS
       EACCES The keyring wasn't available for modification by the user.

       EDQUOT The key quota for this user would be exceeded by creating this key or linking it to the keyring.

       EFAULT One of type, description, or callout_info points outside the process's accessible address space.

       EINTR  The request was interrupted by a signal; see signal(7).

       EINVAL The size of the string (including the terminating null byte) specified in type or description  exceeded  the
              limit (32 bytes and 4096 bytes respectively).

       EINVAL The  size  of the string (including the terminating null byte) specified in callout_info exceeded the system
              page size.

       EKEYEXPIRED
              An expired key was found, but no replacement could be obtained.

       EKEYREJECTED
              The attempt to generate a new key was rejected.

       EKEYREVOKED
              A revoked key was found, but no replacement could be obtained.

       ENOKEY No matching key was found.

       ENOMEM Insufficient memory to create a key.

       EPERM  The type argument started with a period ('.').

VERSIONS
       This system call first appeared in Linux 2.6.10.  The ability to instantiate keys upon request was added  in  Linux
       2.6.13.

CONFORMING TO
       This system call is a nonstandard Linux extension.

NOTES
       No  wrapper  for  this  system  call is provided in glibc.  A wrapper is provided in the libkeyutils package.  When
       employing the wrapper in that library, link with -lkeyutils.

EXAMPLE
       The program below demonstrates the use of request_key().  The type, description, and callout_info arguments for the
       system  call  are  taken  from  the  values supplied in the command-line arguments.  The call specifies the session
       keyring as the target keyring.

       In order to demonstrate this program, we first create a suitable entry in the file /etc/request-key.conf.

           $ sudo sh
           # echo 'create user mtk:* *   /bin/keyctl instantiate %k %c %S' \
                     > /etc/request-key.conf
           # exit

       This entry specifies that when a new "user" key with the prefix "mtk:" must be instantiated, that  task  should  be
       performed  via  the keyctl(1) command's instantiate operation.  The arguments supplied to the instantiate operation
       are: the ID of the uninstantiated key (%k); the callout data supplied to the request_key() call (%c); and the  ses‐
       sion  keyring  (%S)  of  the requestor (i.e., the caller of request_key()).  See request-key.conf(5) for details of
       these % specifiers.

       Then we run the program and check the contents of /proc/keys to verify that the requested key  has  been  instanti‐
       ated:

           $ ./t_request_key user mtk:key1 "Payload data"
           $ grep '2dddaf50' /proc/keys
           2dddaf50 I--Q---  1 perm 3f010000  1000  1000 user  mtk:key1: 12

       For another example of the use of this program, see keyctl(2).

   Program source

       /* t_request_key.c */

       #include <sys/types.h>
       #include <keyutils.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>

       int
       main(int argc, char *argv[])
       {
           key_serial_t key;

           if (argc != 4) {
               fprintf(stderr, "Usage: %s type description callout-data\n",
                       argv[0]);
               exit(EXIT_FAILURE);
           }

           key = request_key(argv[1], argv[2], argv[3],
                             KEY_SPEC_SESSION_KEYRING);
           if (key == -1) {
               perror("request_key");
               exit(EXIT_FAILURE);
           }

           printf("Key ID is %lx\n", (long) key);

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       keyctl(1), add_key(2), keyctl(2), keyctl(3), capabilities(7), keyrings(7), keyutils(7), persistent-keyring(7),
       process-keyring(7), session-keyring(7), thread-keyring(7), user-keyring(7), user-session-keyring(7), request-key(8)

       The kernel source files Documentation/security/keys/core.rst and Documentation/keys/request-key.rst (or, before
       Linux 4.13, in the files Documentation/security/keys.txt and Documentation/security/keys-request-key.txt).

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                          REQUEST_KEY(2)
</pre>
<pre zoom>
<span xsmall>2 getdtablesize</span>
GETDTABLESIZE(3)                                 Linux Programmer's Manual                                GETDTABLESIZE(3)

NAME
       getdtablesize - get file descriptor table size

SYNOPSIS
       #include <unistd.h>

       int getdtablesize(void);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       getdtablesize():
           Since glibc 2.12:
               /* Glibc since 2.19: */ _DEFAULT_SOURCE
                   || /* Glibc versions <= 2.19: */ _BSD_SOURCE
                   || ! (_POSIX_C_SOURCE >= 200112L)
           Before glibc 2.12:
               _BSD_SOURCE || _XOPEN_SOURCE >= 500

DESCRIPTION
       getdtablesize()  returns  the  maximum  number of files a process can have open, one more than the largest possible
       value for a file descriptor.

RETURN VALUE
       The current limit on the number of open files per process.

ERRORS
       On Linux, getdtablesize() can return any of the errors described for getrlimit(2); see NOTES below.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌────────────────┬───────────────┬─────────┐
       │Interface       │ Attribute     │ Value   │
       ├────────────────┼───────────────┼─────────┤
       │getdtablesize() │ Thread safety │ MT-Safe │
       └────────────────┴───────────────┴─────────┘
CONFORMING TO
       SVr4, 4.4BSD (the getdtablesize() function first appeared in 4.2BSD).  It is not  specified  in  POSIX.1;  portable
       applications should employ sysconf(_SC_OPEN_MAX) instead of this call.

NOTES
       getdtablesize()  is  implemented  as a libc library function.  The glibc version calls getrlimit(2) and returns the
       current RLIMIT_NOFILE limit, or OPEN_MAX when that fails.

SEE ALSO
       close(2), dup(2), getrlimit(2), open(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2016-03-15                                        GETDTABLESIZE(3)
</pre>
<pre zoom>
<span xsmall>2 posix_fadvise</span>
POSIX_FADVISE(2)                                 Linux Programmer's Manual                                POSIX_FADVISE(2)

NAME
       posix_fadvise - predeclare an access pattern for file data

SYNOPSIS
       #include <fcntl.h>

       int posix_fadvise(int fd, off_t offset, off_t len, int advice);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       posix_fadvise():
           _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       Programs  can use posix_fadvise() to announce an intention to access file data in a specific pattern in the future,
       thus allowing the kernel to perform appropriate optimizations.

       The advice applies to a (not necessarily existent) region starting at offset and extending for len bytes (or  until
       the  end  of the file if len is 0) within the file referred to by fd.  The advice is not binding; it merely consti‐
       tutes an expectation on behalf of the application.

       Permissible values for advice include:

       POSIX_FADV_NORMAL
              Indicates that the application has no advice to give about its access pattern for the specified data.  If no
              advice is given for an open file, this is the default assumption.

       POSIX_FADV_SEQUENTIAL
              The  application  expects  to  access the specified data sequentially (with lower offsets read before higher
              ones).

       POSIX_FADV_RANDOM
              The specified data will be accessed in random order.

       POSIX_FADV_NOREUSE
              The specified data will be accessed only once.

              In kernels before 2.6.18, POSIX_FADV_NOREUSE had the same semantics as POSIX_FADV_WILLNEED.  This was proba‐
              bly a bug; since kernel 2.6.18, this flag is a no-op.

       POSIX_FADV_WILLNEED
              The specified data will be accessed in the near future.

              POSIX_FADV_WILLNEED initiates a nonblocking read of the specified region into the page cache.  The amount of
              data read may be decreased by the kernel depending on virtual memory load.  (A few megabytes will usually be
              fully satisfied, and more is rarely useful.)

       POSIX_FADV_DONTNEED
              The specified data will not be accessed in the near future.

              POSIX_FADV_DONTNEED attempts to free cached pages associated with the specified region.  This is useful, for
              example, while streaming large files.  A program may periodically request the kernel  to  free  cached  data
              that has already been used, so that more useful cached pages are not discarded instead.

              Requests  to  discard  partial  pages  are  ignored.   It is preferable to preserve needed data than discard
              unneeded data.  If the application requires that data be considered for discarding, then offset and len must
              be page-aligned.

              The  implementation  may  attempt to write back dirty pages in the specified region, but this is not guaran‐
              teed.  Any unwritten dirty pages will not be freed.  If the application wishes to ensure  that  dirty  pages
              will be released, it should call fsync(2) or fdatasync(2) first.

RETURN VALUE
       On success, zero is returned.  On error, an error number is returned.

ERRORS
       EBADF  The fd argument was not a valid file descriptor.

       EINVAL An invalid value was specified for advice.

       ESPIPE The specified file descriptor refers to a pipe or FIFO.  (ESPIPE is the error specified by POSIX, but before
              kernel version 2.6.16, Linux returned EINVAL in this case.)

VERSIONS
       Kernel support first appeared in Linux 2.5.60; the underlying system call is called fadvise64().   Library  support
       has been provided since glibc version 2.2, via the wrapper function posix_fadvise().

       Since  Linux  3.18,  support  for  the  underlying  system  call  is optional, depending on the setting of the CON‐
       FIG_ADVISE_SYSCALLS configuration option.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.  Note that the  type  of  the  len  argument  was  changed  from  size_t  to  off_t  in
       POSIX.1-2003 TC1.

NOTES
       Under   Linux,  POSIX_FADV_NORMAL  sets  the  readahead  window  to  the  default  size  for  the  backing  device;
       POSIX_FADV_SEQUENTIAL doubles this size, and POSIX_FADV_RANDOM disables file  readahead  entirely.   These  changes
       affect  the  entire  file,  not  just  the specified region (but other open file handles to the same file are unaf‐
       fected).

       The contents of the kernel buffer cache can be cleared via  the  /proc/sys/vm/drop_caches  interface  described  in
       proc(5).

       One  can  obtain a snapshot of which pages of a file are resident in the buffer cache by opening a file, mapping it
       with mmap(2), and then applying mincore(2) to the mapping.

   C library/kernel differences
       The name of the wrapper function in the C library is posix_fadvise().  The underlying system call  is  called  fad‐
       vise64() (or, on some architectures, fadvise64_64()).

   Architecture-specific variants
       Some  architectures require 64-bit arguments to be aligned in a suitable pair of registers (see syscall(2) for fur‐
       ther detail).  On such architectures, the call signature of posix_fadvise() shown in the  SYNOPSIS  would  force  a
       register to be wasted as padding between the fd and offset arguments.  Therefore, these architectures define a ver‐
       sion of the system call that orders the arguments suitably, but is otherwise exactly the same as posix_fadvise().

       For example, since Linux 2.6.14, ARM has the following system call:

           long arm_fadvise64_64(int fd, int advice,
                                 loff_t offset, loff_t len);

       These architecture-specific details are generally hidden from applications by  the  glibc  posix_fadvise()  wrapper
       function, which invokes the appropriate architecture-specific system call.

BUGS
       In  kernels  before  2.6.6,  if len was specified as 0, then this was interpreted literally as "zero bytes", rather
       than as meaning "all bytes through to the end of the file".

SEE ALSO
       fincore(1), mincore(2), readahead(2), sync_file_range(2), posix_fallocate(3), posix_madvise(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        POSIX_FADVISE(2)
</pre>
<pre zoom>
<span xsmall>2 signal</span>
SIGNAL(2)                                        Linux Programmer's Manual                                       SIGNAL(2)

NAME
       signal - ANSI C signal handling

SYNOPSIS
       #include <signal.h>

       typedef void (*sighandler_t)(int);

       sighandler_t signal(int signum, sighandler_t handler);

DESCRIPTION
       The behavior of signal() varies across UNIX versions, and has also varied historically across different versions of
       Linux.  Avoid its use: use sigaction(2) instead.  See Portability below.

       signal() sets the disposition of the signal signum to handler, which is either SIG_IGN, SIG_DFL, or the address  of
       a programmer-defined function (a "signal handler").

       If the signal signum is delivered to the process, then one of the following happens:

       *  If the disposition is set to SIG_IGN, then the signal is ignored.

       *  If the disposition is set to SIG_DFL, then the default action associated with the signal (see signal(7)) occurs.

       *  If the disposition is set to a function, then first either the disposition is reset to SIG_DFL, or the signal is
          blocked (see Portability below), and then handler is called with argument signum.  If invocation of the  handler
          caused the signal to be blocked, then the signal is unblocked upon return from the handler.

       The signals SIGKILL and SIGSTOP cannot be caught or ignored.

RETURN VALUE
       signal() returns the previous value of the signal handler, or SIG_ERR on error.  In the event of an error, errno is
       set to indicate the cause.

ERRORS
       EINVAL signum is invalid.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, C89, C99.

NOTES
       The effects of signal() in a multithreaded process are unspecified.

       According to POSIX, the behavior of a process is undefined after it ignores a SIGFPE,  SIGILL,  or  SIGSEGV  signal
       that  was  not generated by kill(2) or raise(3).  Integer division by zero has undefined result.  On some architec‐
       tures it will generate a SIGFPE signal.  (Also dividing the most negative  integer  by  -1  may  generate  SIGFPE.)
       Ignoring this signal might lead to an endless loop.

       See sigaction(2) for details on what happens when the disposition SIGCHLD is set to SIG_IGN.

       See  signal-safety(7)  for a list of the async-signal-safe functions that can be safely called from inside a signal
       handler.

       The use of sighandler_t is a GNU extension, exposed if _GNU_SOURCE is defined; glibc also defines (the BSD-derived)
       sig_t if _BSD_SOURCE (glibc 2.19 and earlier) or _DEFAULT_SOURCE (glibc 2.19 and later) is defined.  Without use of
       such a type, the declaration of signal() is the somewhat harder to read:

           void ( *signal(int signum, void (*handler)(int)) ) (int);

   Portability
       The only portable use of signal() is to set a signal's disposition to SIG_DFL or SIG_IGN.  The semantics when using
       signal()  to establish a signal handler vary across systems (and POSIX.1 explicitly permits this variation); do not
       use it for this purpose.

       POSIX.1 solved the portability mess by specifying sigaction(2), which provides explicit control  of  the  semantics
       when a signal handler is invoked; use that interface instead of signal().

       In  the  original UNIX systems, when a handler that was established using signal() was invoked by the delivery of a
       signal, the disposition of the signal would be reset to SIG_DFL, and the system did not block delivery  of  further
       instances of the signal.  This is equivalent to calling sigaction(2) with the following flags:

           sa.sa_flags = SA_RESETHAND | SA_NODEFER;

       System V  also  provides  these  semantics  for signal().  This was bad because the signal might be delivered again
       before the handler had a chance to reestablish itself.  Furthermore, rapid deliveries  of  the  same  signal  could
       result in recursive invocations of the handler.

       BSD  improved  on  this  situation, but unfortunately also changed the semantics of the existing signal() interface
       while doing so.  On BSD, when a signal handler is invoked,  the  signal  disposition  is  not  reset,  and  further
       instances  of  the  signal  are  blocked from being delivered while the handler is executing.  Furthermore, certain
       blocking system calls are automatically restarted if interrupted by a signal  handler  (see  signal(7)).   The  BSD
       semantics are equivalent to calling sigaction(2) with the following flags:

           sa.sa_flags = SA_RESTART;

       The situation on Linux is as follows:

       * The kernel's signal() system call provides System V semantics.

       * By default, in glibc 2 and later, the signal() wrapper function does not invoke the kernel system call.  Instead,
         it calls sigaction(2) using flags that supply BSD semantics.  This default behavior is  provided  as  long  as  a
         suitable  feature  test  macro is defined: _BSD_SOURCE on glibc 2.19 and earlier or _DEFAULT_SOURCE in glibc 2.19
         and later.  (By default, these macros are defined; see feature_test_macros(7) for details.)  If  such  a  feature
         test macro is not defined, then signal() provides System V semantics.

SEE ALSO
       kill(1),  alarm(2),  kill(2),  pause(2),  sigaction(2),  signalfd(2), sigpending(2), sigprocmask(2), sigsuspend(2),
       bsd_signal(3), killpg(3), raise(3), siginterrupt(3), sigqueue(3),  sigsetops(3),  sigvec(3),  sysv_signal(3),  sig‐
       nal(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SIGNAL(2)
</pre>
<pre zoom>
<span xsmall>2 sched_setparam</span>
SCHED_SETPARAM(2)                                Linux Programmer's Manual                               SCHED_SETPARAM(2)

NAME
       sched_setparam, sched_getparam - set and get scheduling parameters

SYNOPSIS
       #include <sched.h>

       int sched_setparam(pid_t pid, const struct sched_param *param);

       int sched_getparam(pid_t pid, struct sched_param *param);

       struct sched_param {
           ...
           int sched_priority;
           ...
       };

DESCRIPTION
       sched_setparam() sets the scheduling parameters associated with the scheduling policy for the process identified by
       pid.  If pid is zero, then the parameters of the calling process are set.  The interpretation of the argument param
       depends  on the scheduling policy of the process identified by pid.  See sched(7) for a description of the schedul‐
       ing policies supported under Linux.

       sched_getparam() retrieves the scheduling parameters for the process identified by pid.  If pid is zero,  then  the
       parameters of the calling process are retrieved.

       sched_setparam() checks the validity of param for the scheduling policy of the thread.  The value param->sched_pri‐
       ority must lie within the range given by sched_get_priority_min(2) and sched_get_priority_max(2).

       For a discussion of the privileges and resource limits related to scheduling priority and policy, see sched(7).

       POSIX systems on which sched_setparam() and sched_getparam() are  available  define  _POSIX_PRIORITY_SCHEDULING  in
       <unistd.h>.

RETURN VALUE
       On  success,  sched_setparam() and sched_getparam() return 0.  On error, -1 is returned, and errno is set appropri‐
       ately.

ERRORS
       EINVAL Invalid arguments: param is NULL or pid is negative

       EINVAL (sched_setparam()) The argument param does not make sense for the current scheduling policy.

       EPERM  (sched_setparam()) The calling process does not have  appropriate  privileges  (Linux:  does  not  have  the
              CAP_SYS_NICE capability).

       ESRCH  The process whose ID is pid could not be found.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       Scheduling parameters are in fact per-thread attributes on Linux; see sched(7).

SEE ALSO
       getpriority(2), nice(2), sched_get_priority_max(2), sched_get_priority_min(2), sched_getaffinity(2),
       sched_getscheduler(2), sched_setaffinity(2), sched_setattr(2), sched_setscheduler(2), setpriority(2),
       capabilities(7), sched(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                       SCHED_SETPARAM(2)
</pre>
<pre zoom>
<span xsmall>2 chown32</span>
CHOWN(2)                                         Linux Programmer's Manual                                        CHOWN(2)

NAME
       chown, fchown, lchown, fchownat - change ownership of a file

SYNOPSIS
       #include <unistd.h>

       int chown(const char *pathname, uid_t owner, gid_t group);
       int fchown(int fd, uid_t owner, gid_t group);
       int lchown(const char *pathname, uid_t owner, gid_t group);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <unistd.h>

       int fchownat(int dirfd, const char *pathname,
                    uid_t owner, gid_t group, int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       fchown(), lchown():
           /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
               || _XOPEN_SOURCE >= 500
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE
       fchownat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  system  calls change the owner and group of a file.  The chown(), fchown(), and lchown() system calls differ
       only in how the file is specified:

       * chown() changes the ownership of the file specified by pathname, which is dereferenced if it is a symbolic link.

       * fchown() changes the ownership of the file referred to by the open file descriptor fd.

       * lchown() is like chown(), but does not dereference symbolic links.

       Only a privileged process (Linux: one with the CAP_CHOWN capability) may change the owner of a file.  The owner  of
       a file may change the group of the file to any group of which that owner is a member.  A privileged process (Linux:
       with CAP_CHOWN) may change the group arbitrarily.

       If the owner or group is specified as -1, then that ID is not changed.

       When the owner or group of an executable file is changed by an unprivileged user, the S_ISUID and S_ISGID mode bits
       are cleared.  POSIX does not specify whether this also should happen when root does the chown(); the Linux behavior
       depends on the kernel version, and since Linux 2.2.13, root is treated like other users.  In case of  a  non-group-
       executable  file  (i.e., one for which the S_IXGRP bit is not set) the S_ISGID bit indicates mandatory locking, and
       is not cleared by a chown().

       When the owner or group of an executable file is changed (by any user),  all  capability  sets  for  the  file  are
       cleared.

   fchownat()
       The fchownat() system call operates in exactly the same way as chown(), except for the differences described here.

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       chown() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like chown()).

       If pathname is absolute, then dirfd is ignored.

       The flags argument is a bit mask created by ORing together 0 or more of the following values;

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2)  O_PATH  flag).   In  this case, dirfd can refer to any type of file, not just a directory.  If
              dirfd is AT_FDCWD, the call operates on the current working directory.  This flag is Linux-specific;  define
              _GNU_SOURCE to obtain its definition.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a symbolic link, do not dereference it: instead operate on the link itself, like lchown().
              (By default, fchownat() dereferences symbolic links, like chown().)

       See openat(2) for an explanation of the need for fchownat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       Depending on the filesystem, errors other than those listed below can be returned.

       The more general errors for chown() are listed below.

       EACCES Search permission is denied on a component of the path prefix.  (See also path_resolution(7).)

       EFAULT pathname points outside your accessible address space.

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ENAMETOOLONG
              pathname is too long.

       ENOENT The file does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of the path prefix is not a directory.

       EPERM  The calling process did not have the required permissions (see above) to change owner and/or group.

       EPERM  The file is marked immutable or append-only.  (See ioctl_iflags(2).)

       EROFS  The named file resides on a read-only filesystem.

       The general errors for fchown() are listed below:

       EBADF  fd is not a valid open file descriptor.

       EIO    A low-level I/O error occurred while modifying the inode.

       ENOENT See above.

       EPERM  See above.

       EROFS  See above.

       The same errors that occur for chown() can also occur for fchownat().  The following additional  errors  can  occur
       for fchownat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fchownat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       chown(), fchown(), lchown(): 4.4BSD, SVr4, POSIX.1-2001, POSIX.1-2008.

       The 4.4BSD version can be used only by the superuser (that is, ordinary users cannot give away files).

       fchownat(): POSIX.1-2008.

NOTES
   Ownership of new files
       When  a  new  file  is created (by, for example, open(2) or mkdir(2)), its owner is made the same as the filesystem
       user ID of the creating process.  The group of the file depends on a  range  of  factors,  including  the  type  of
       filesystem,  the  options  used to mount the filesystem, and whether or not the set-group-ID mode bit is enabled on
       the parent directory.  If the filesystem supports the -o grpid (or, synonymously -o bsdgroups) and -o nogrpid  (or,
       synonymously -o sysvgroups) mount(8) options, then the rules are as follows:

       * If  the  filesystem is mounted with -o grpid, then the group of a new file is made the same as that of the parent
         directory.

       * If the filesystem is mounted with -o nogrpid and the set-group-ID bit is disabled on the parent  directory,  then
         the group of a new file is made the same as the process's filesystem GID.

       * If  the  filesystem  is mounted with -o nogrpid and the set-group-ID bit is enabled on the parent directory, then
         the group of a new file is made the same as that of the parent directory.

       As at Linux 4.12, the -o grpid and -o nogrpid mount options are supported by ext2, ext3, ext4, and  XFS.   Filesys‐
       tems that don't support these mount options follow the -o nogrpid rules.

   Glibc notes
       On  older  kernels where fchownat() is unavailable, the glibc wrapper function falls back to the use of chown() and
       lchown().  When pathname is a relative pathname, glibc  constructs  a  pathname  based  on  the  symbolic  link  in
       /proc/self/fd that corresponds to the dirfd argument.

   NFS
       The  chown()  semantics are deliberately violated on NFS filesystems which have UID mapping enabled.  Additionally,
       the semantics of all system calls which access the file contents are violated, because chown() may cause  immediate
       access  revocation on already open files.  Client side caching may lead to a delay between the time where ownership
       have been changed to allow access for a user and the time where the file can actually be accessed by  the  user  on
       other clients.

   Historical details
       The  original  Linux chown(), fchown(), and lchown() system calls supported only 16-bit user and group IDs.  Subse‐
       quently, Linux 2.4 added chown32(),  fchown32(),  and  lchown32(),  supporting  32-bit  IDs.   The  glibc  chown(),
       fchown(), and lchown() wrapper functions transparently deal with the variations across kernel versions.

       In  versions  of  Linux  prior  to 2.1.81 (and distinct from 2.1.46), chown() did not follow symbolic links.  Since
       Linux 2.1.81, chown() does follow symbolic links, and there is a new system call lchown() that does not follow sym‐
       bolic  links.   Since Linux 2.1.86, this new call (that has the same semantics as the old chown()) has got the same
       syscall number, and chown() got the newly introduced number.

EXAMPLE
       The following program changes the ownership of the file named in its second  command-line  argument  to  the  value
       specified  in its first command-line argument.  The new owner can be specified either as a numeric user ID, or as a
       username (which is converted to a user ID by using getpwnam(3) to perform a lookup in the system password file).

   Program source
       #include <pwd.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>

       int
       main(int argc, char *argv[])
       {
           uid_t uid;
           struct passwd *pwd;
           char *endptr;

           if (argc != 3 || argv[1][0] == '\0') {
               fprintf(stderr, "%s <owner> <file>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           uid = strtol(argv[1], &endptr, 10);  /* Allow a numeric string */

           if (*endptr != '\0') {         /* Was not pure numeric string */
               pwd = getpwnam(argv[1]);   /* Try getting UID for username */
               if (pwd == NULL) {
                   perror("getpwnam");
                   exit(EXIT_FAILURE);
               }

               uid = pwd->pw_uid;
           }

           if (chown(argv[2], uid, -1) == -1) {
               perror("chown");
               exit(EXIT_FAILURE);
           }

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       chgrp(1), chown(1), chmod(2), flock(2), path_resolution(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                CHOWN(2)
</pre>
<pre zoom>
<span xsmall>2 msgsnd</span>
MSGOP(2)                                         Linux Programmer's Manual                                        MSGOP(2)

NAME
       msgrcv, msgsnd - System V message queue operations

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);

       ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
                      int msgflg);

DESCRIPTION
       The  msgsnd()  and  msgrcv() system calls are used, respectively, to send messages to, and receive messages from, a
       System V message queue.  The calling process must have write permission on the message queue in  order  to  send  a
       message, and read permission to receive a message.

       The msgp argument is a pointer to a caller-defined structure of the following general form:

           struct msgbuf {
               long mtype;       /* message type, must be > 0 */
               char mtext[1];    /* message data */
           };

       The  mtext  field  is  an array (or other structure) whose size is specified by msgsz, a nonnegative integer value.
       Messages of zero length (i.e., no mtext field) are permitted.  The mtype field must have a strictly positive  inte‐
       ger  value.  This value can be used by the receiving process for message selection (see the description of msgrcv()
       below).

   msgsnd()
       The msgsnd() system call appends a copy of the message pointed to by msgp to the message queue whose identifier  is
       specified by msqid.

       If  sufficient  space  is available in the queue, msgsnd() succeeds immediately.  The queue capacity is governed by
       the msg_qbytes field in the associated data structure for the message queue.  During queue creation this  field  is
       initialized  to  MSGMNB bytes, but this limit can be modified using msgctl(2).  A message queue is considered to be
       full if either of the following conditions is true:

       * Adding a new message to the queue would cause the total number of bytes in the queue to exceed the queue's  maxi‐
         mum size (the msg_qbytes field).

       * Adding  another  message to the queue would cause the total number of messages in the queue to exceed the queue's
         maximum size (the msg_qbytes field).  This check is necessary to prevent an unlimited number of zero-length  mes‐
         sages being placed on the queue.  Although such messages contain no data, they nevertheless consume (locked) ker‐
         nel memory.

       If insufficient space is available in the queue, then the default behavior of msgsnd()  is  to  block  until  space
       becomes available.  If IPC_NOWAIT is specified in msgflg, then the call instead fails with the error EAGAIN.

       A blocked msgsnd() call may also fail if:

       * the queue is removed, in which case the system call fails with errno set to EIDRM; or

       * a  signal  is  caught,  in  which case the system call fails with errno set to EINTR;see signal(7).  (msgsnd() is
         never automatically restarted after being interrupted by a signal handler,  regardless  of  the  setting  of  the
         SA_RESTART flag when establishing a signal handler.)

       Upon successful completion the message queue data structure is updated as follows:

              msg_lspid is set to the process ID of the calling process.

              msg_qnum is incremented by 1.

              msg_stime is set to the current time.

   msgrcv()
       The msgrcv() system call removes a message from the queue specified by msqid and places it in the buffer pointed to
       by msgp.

       The argument msgsz specifies the maximum size in bytes for the member mtext of the structure pointed to by the msgp
       argument.   If  the message text has length greater than msgsz, then the behavior depends on whether MSG_NOERROR is
       specified in msgflg.  If MSG_NOERROR is specified, then the message text will be truncated (and the truncated  part
       will  be  lost); if MSG_NOERROR is not specified, then the message isn't removed from the queue and the system call
       fails returning -1 with errno set to E2BIG.

       Unless MSG_COPY is specified in msgflg (see below), the msgtyp argument specifies the type of message requested, as
       follows:

       * If msgtyp is 0, then the first message in the queue is read.

       * If  msgtyp  is  greater than 0, then the first message in the queue of type msgtyp is read, unless MSG_EXCEPT was
         specified in msgflg, in which case the first message in the queue of type not equal to msgtyp will be read.

       * If msgtyp is less than 0, then the first message in the queue with the lowest type less  than  or  equal  to  the
         absolute value of msgtyp will be read.

       The msgflg argument is a bit mask constructed by ORing together zero or more of the following flags:

       IPC_NOWAIT
              Return  immediately  if  no message of the requested type is in the queue.  The system call fails with errno
              set to ENOMSG.

       MSG_COPY (since Linux 3.8)
              Nondestructively fetch a copy of the message at the ordinal position in the queue specified by msgtyp  (mes‐
              sages are considered to be numbered starting at 0).

              This  flag  must  be  specified in conjunction with IPC_NOWAIT, with the result that, if there is no message
              available at the given position, the call fails immediately with the error ENOMSG.  Because they  alter  the
              meaning of msgtyp in orthogonal ways, MSG_COPY and MSG_EXCEPT may not both be specified in msgflg.

              The  MSG_COPY  flag was added for the implementation of the kernel checkpoint-restore facility and is avail‐
              able only if the kernel was built with the CONFIG_CHECKPOINT_RESTORE option.

       MSG_EXCEPT
              Used with msgtyp greater than 0 to read the first message in the queue with message type that  differs  from
              msgtyp.

       MSG_NOERROR
              To truncate the message text if longer than msgsz bytes.

       If  no  message of the requested type is available and IPC_NOWAIT isn't specified in msgflg, the calling process is
       blocked until one of the following conditions occurs:

       * A message of the desired type is placed in the queue.

       * The message queue is removed from the system.  In this case, the system call fails with errno set to EIDRM.

       * The calling process catches a signal.  In this case, the system call fails with errno set to EINTR.  (msgrcv() is
         never  automatically  restarted  after  being  interrupted  by a signal handler, regardless of the setting of the
         SA_RESTART flag when establishing a signal handler.)

       Upon successful completion the message queue data structure is updated as follows:

              msg_lrpid is set to the process ID of the calling process.

              msg_qnum is decremented by 1.

              msg_rtime is set to the current time.

RETURN VALUE
       On failure both functions return -1 with errno indicating the error, otherwise  msgsnd()  returns  0  and  msgrcv()
       returns the number of bytes actually copied into the mtext array.

ERRORS
       When msgsnd() fails, errno will be set to one among the following values:

       EACCES The calling process does not have write permission on the message queue, and does not have the CAP_IPC_OWNER
              capability.

       EAGAIN The message can't be sent due to the msg_qbytes limit for the queue and IPC_NOWAIT was specified in msgflg.

       EFAULT The address pointed to by msgp isn't accessible.

       EIDRM  The message queue was removed.

       EINTR  Sleeping on a full message queue condition, the process caught a signal.

       EINVAL Invalid msqid value, or nonpositive mtype value, or invalid msgsz value (less than 0  or  greater  than  the
              system value MSGMAX).

       ENOMEM The system does not have enough memory to make a copy of the message pointed to by msgp.

       When msgrcv() fails, errno will be set to one among the following values:

       E2BIG  The message text length is greater than msgsz and MSG_NOERROR isn't specified in msgflg.

       EACCES The  calling process does not have read permission on the message queue, and does not have the CAP_IPC_OWNER
              capability in the user namespace that governs its IPC namespace.

       EFAULT The address pointed to by msgp isn't accessible.

       EIDRM  While the process was sleeping to receive a message, the message queue was removed.

       EINTR  While the process was sleeping to receive a message, the process caught a signal; see signal(7).

       EINVAL msqid was invalid, or msgsz was less than 0.

       EINVAL (since Linux 3.14)
              msgflg specified MSG_COPY, but not IPC_NOWAIT.

       EINVAL (since Linux 3.14)
              msgflg specified both MSG_COPY and MSG_EXCEPT.

       ENOMSG IPC_NOWAIT was specified in msgflg and no message of the requested type existed on the message queue.

       ENOMSG IPC_NOWAIT and MSG_COPY were specified in msgflg and the queue contains less than msgtyp messages.

       ENOSYS (since Linux 3.8)
              MSG_COPY was specified in msgflg, and this kernel was configured without CONFIG_CHECKPOINT_RESTORE.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

       The MSG_EXCEPT and MSG_COPY flags are Linux-specific; their definitions can be obtained by defining the _GNU_SOURCE
       feature test macro.

NOTES
       The  inclusion  of <sys/types.h> and <sys/ipc.h> isn't required on Linux or by any version of POSIX.  However, some
       old implementations required the inclusion of these header files, and the SVID  also  documented  their  inclusion.
       Applications intended to be portable to such old systems may need to include these header files.

       The  msgp  argument is declared as struct msgbuf * in glibc 2.0 and 2.1.  It is declared as void * in glibc 2.2 and
       later, as required by SUSv2 and SUSv3.

       The following limits on message queue resources affect the msgsnd() call:

       MSGMAX Maximum size of a message text, in bytes (default value: 8192 bytes).  On Linux, this limit can be read  and
              modified via /proc/sys/kernel/msgmax.

       MSGMNB Maximum  number  of  bytes that can be held in a message queue (default value: 16384 bytes).  On Linux, this
              limit can be read and modified via /proc/sys/kernel/msgmnb.  A privileged process (Linux: a process with the
              CAP_SYS_RESOURCE  capability)  can  increase  the  size of a message queue beyond MSGMNB using the msgctl(2)
              IPC_SET operation.

       The implementation has no intrinsic system-wide limits on the number of message headers (MSGTQL) and the number  of
       bytes in the message pool (MSGPOOL).

BUGS
       In  Linux  3.13 and earlier, if msgrcv() was called with the MSG_COPY flag, but without IPC_NOWAIT, and the message
       queue contained less than msgtyp messages, then the call would block until the  next  message  is  written  to  the
       queue.   At  that point, the call would return a copy of the message, regardless of whether that message was at the
       ordinal position msgtyp.  This bug is fixed in Linux 3.14.

       Specifying both MSG_COPY and MSC_EXCEPT in msgflg is a logical error (since these flags impose different  interpre‐
       tations  on  msgtyp).   In  Linux 3.13 and earlier, this error was not diagnosed by msgrcv().  This bug is fixed in
       Linux 3.14.

EXAMPLE
       The program below demonstrates the use of msgsnd() and msgrcv().

       The example program is first run with the -s option to send a message and then run again  with  the  -r  option  to
       receive a message.

       The following shell session shows a sample run of the program:

           $ ./a.out -s
           sent: a message at Wed Mar  4 16:25:45 2015

           $ ./a.out -r
           message received: a message at Wed Mar  4 16:25:45 2015

   Program source

       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>
       #include <time.h>
       #include <unistd.h>
       #include <errno.h>
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       struct msgbuf {
           long mtype;
           char mtext[80];
       };

       static void
       usage(char *prog_name, char *msg)
       {
           if (msg != NULL)
               fputs(msg, stderr);

           fprintf(stderr, "Usage: %s [options]\n", prog_name);
           fprintf(stderr, "Options are:\n");
           fprintf(stderr, "-s        send message using msgsnd()\n");
           fprintf(stderr, "-r        read message using msgrcv()\n");
           fprintf(stderr, "-t        message type (default is 1)\n");
           fprintf(stderr, "-k        message queue key (default is 1234)\n");
           exit(EXIT_FAILURE);
       }

       static void
       send_msg(int qid, int msgtype)
       {
           struct msgbuf msg;
           time_t t;

           msg.mtype = msgtype;

           time(&t);
           snprintf(msg.mtext, sizeof(msg.mtext), "a message at %s",
                   ctime(&t));

           if (msgsnd(qid, (void *) &msg, sizeof(msg.mtext),
                       IPC_NOWAIT) == -1) {
               perror("msgsnd error");
               exit(EXIT_FAILURE);
           }
           printf("sent: %s\n", msg.mtext);
       }

       static void
       get_msg(int qid, int msgtype)
       {
           struct msgbuf msg;

           if (msgrcv(qid, (void *) &msg, sizeof(msg.mtext), msgtype,
                      MSG_NOERROR | IPC_NOWAIT) == -1) {
               if (errno != ENOMSG) {
                   perror("msgrcv");
                   exit(EXIT_FAILURE);
               }
               printf("No message available for msgrcv()\n");
           } else
               printf("message received: %s\n", msg.mtext);
       }

       int
       main(int argc, char *argv[])
       {
           int qid, opt;
           int mode = 0;               /* 1 = send, 2 = receive */
           int msgtype = 1;
           int msgkey = 1234;

           while ((opt = getopt(argc, argv, "srt:k:")) != -1) {
               switch (opt) {
               case 's':
                   mode = 1;
                   break;
               case 'r':
                   mode = 2;
                   break;
               case 't':
                   msgtype = atoi(optarg);
                   if (msgtype <= 0)
                       usage(argv[0], "-t option must be greater than 0\n");
                   break;
               case 'k':
                   msgkey = atoi(optarg);
                   break;
               default:
                   usage(argv[0], "Unrecognized option\n");
               }
           }

           if (mode == 0)
               usage(argv[0], "must use either -s or -r option\n");

           qid = msgget(msgkey, IPC_CREAT | 0666);

           if (qid == -1) {
               perror("msgget");
               exit(EXIT_FAILURE);
           }

           if (mode == 2)
               get_msg(qid, msgtype);
           else
               send_msg(qid, msgtype);

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       msgctl(2), msgget(2), capabilities(7), mq_overview(7), svipc(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                MSGOP(2)
</pre>
<pre zoom>
<span xsmall>2 clone</span>
CLONE(2)                                         Linux Programmer's Manual                                        CLONE(2)

NAME
       clone, __clone2 - create a child process

SYNOPSIS
       /* Prototype for the glibc wrapper function */

       #define _GNU_SOURCE
       #include <sched.h>

       int clone(int (*fn)(void *), void *child_stack,
                 int flags, void *arg, ...
                 /* pid_t *ptid, void *newtls, pid_t *ctid */ );

       /* For the prototype of the raw system call, see NOTES */

DESCRIPTION
       clone() creates a new process, in a manner similar to fork(2).

       This  page  describes  both the glibc clone() wrapper function and the underlying system call on which it is based.
       The main text describes the wrapper function; the differences for the raw system call are described toward the  end
       of this page.

       Unlike  fork(2), clone() allows the child process to share parts of its execution context with the calling process,
       such as the virtual address space, the table of file descriptors, and the table of signal handlers.  (Note that  on
       this  manual  page,  "calling  process"  normally  corresponds  to  "parent  process".   But see the description of
       CLONE_PARENT below.)

       One use of clone() is to implement threads: multiple flows of control in a  program  that  run  concurrently  in  a
       shared address space.

       When  the  child  process is created with clone(), it commences execution by calling the function pointed to by the
       argument fn.  (This differs from fork(2), where execution continues in the child from  the  point  of  the  fork(2)
       call.)  The arg argument is passed as the argument of the function fn.

       When the fn(arg) function returns, the child process terminates.  The integer returned by fn is the exit status for
       the child process.  The child process may also terminate explicitly by calling exit(2) or after receiving  a  fatal
       signal.

       The  child_stack argument specifies the location of the stack used by the child process.  Since the child and call‐
       ing process may share memory, it is not possible for the child process to execute in the same stack as the  calling
       process.   The  calling  process  must therefore set up memory space for the child stack and pass a pointer to this
       space to clone().  Stacks grow downward on all processors  that  run  Linux  (except  the  HP  PA  processors),  so
       child_stack usually points to the topmost address of the memory space set up for the child stack.

       The  low  byte  of  flags contains the number of the termination signal sent to the parent when the child dies.  If
       this signal is specified as anything other than SIGCHLD, then  the  parent  process  must  specify  the  __WALL  or
       __WCLONE  options  when  waiting for the child with wait(2).  If no signal is specified, then the parent process is
       not signaled when the child terminates.

       flags may also be bitwise-ORed with zero or more of the following constants, in order to  specify  what  is  shared
       between the calling process and the child process:

       CLONE_CHILD_CLEARTID (since Linux 2.5.49)
              Clear  (zero) the child thread ID at the location ctid in child memory when the child exits, and do a wakeup
              on the futex at that address.  The address involved may be changed by the  set_tid_address(2)  system  call.
              This is used by threading libraries.

       CLONE_CHILD_SETTID (since Linux 2.5.49)
              Store  the child thread ID at the location ctid in the child's memory.  The store operation completes before
              clone() returns control to user space.

       CLONE_FILES (since Linux 2.0)
              If CLONE_FILES is set, the calling process and the child process share the same file descriptor table.   Any
              file  descriptor  created by the calling process or by the child process is also valid in the other process.
              Similarly, if one of the processes closes a file descriptor, or changes  its  associated  flags  (using  the
              fcntl(2) F_SETFD operation), the other process is also affected.  If a process sharing a file descriptor ta‐
              ble calls execve(2), its file descriptor table is duplicated (unshared).

              If CLONE_FILES is not set, the child process inherits a copy of all file descriptors opened in  the  calling
              process  at  the time of clone().  Subsequent operations that open or close file descriptors, or change file
              descriptor flags, performed by either the calling process or the child  process  do  not  affect  the  other
              process.   Note,  however,  that  the  duplicated  file descriptors in the child refer to the same open file
              descriptions as the corresponding file descriptors in the calling process, and thus share file  offsets  and
              file status flags (see open(2)).

       CLONE_FS (since Linux 2.0)
              If  CLONE_FS  is set, the caller and the child process share the same filesystem information.  This includes
              the root of the filesystem, the current working directory, and the umask.  Any call to chroot(2),  chdir(2),
              or umask(2) performed by the calling process or the child process also affects the other process.

              If  CLONE_FS  is  not  set,  the  child process works on a copy of the filesystem information of the calling
              process at the time of the clone() call.  Calls to chroot(2), chdir(2), or umask(2) performed later  by  one
              of the processes do not affect the other process.

       CLONE_IO (since Linux 2.6.25)
              If  CLONE_IO  is  set, then the new process shares an I/O context with the calling process.  If this flag is
              not set, then (as with fork(2)) the new process has its own I/O context.

              The I/O context is the I/O scope of the disk scheduler (i.e., what the I/O scheduler uses to model  schedul‐
              ing of a process's I/O).  If processes share the same I/O context, they are treated as one by the I/O sched‐
              uler.  As a consequence, they get to share disk time.  For some I/O schedulers, if two  processes  share  an
              I/O  context,  they  will  be  allowed to interleave their disk access.  If several threads are doing I/O on
              behalf of the same process (aio_read(3), for instance), they should employ CLONE_IO to get better  I/O  per‐
              formance.

              If the kernel is not configured with the CONFIG_BLOCK option, this flag is a no-op.

       CLONE_NEWCGROUP (since Linux 4.6)
              Create  the  process in a new cgroup namespace.  If this flag is not set, then (as with fork(2)) the process
              is created in the same cgroup namespaces as the calling process.  This flag is intended for the  implementa‐
              tion of containers.

              For further information on cgroup namespaces, see cgroup_namespaces(7).

              Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWCGROUP.

       CLONE_NEWIPC (since Linux 2.6.19)
              If  CLONE_NEWIPC  is set, then create the process in a new IPC namespace.  If this flag is not set, then (as
              with fork(2)), the process is created in the same IPC namespace  as  the  calling  process.   This  flag  is
              intended for the implementation of containers.

              An  IPC  namespace provides an isolated view of System V IPC objects (see svipc(7)) and (since Linux 2.6.30)
              POSIX message queues (see mq_overview(7)).  The common characteristic of these IPC mechanisms  is  that  IPC
              objects are identified by mechanisms other than filesystem pathnames.

              Objects  created  in an IPC namespace are visible to all other processes that are members of that namespace,
              but are not visible to processes in other IPC namespaces.

              When an IPC namespace is destroyed (i.e., when the last process that is a member  of  the  namespace  termi‐
              nates), all IPC objects in the namespace are automatically destroyed.

              Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWIPC.  This flag can't be specified in conjunc‐
              tion with CLONE_SYSVSEM.

              For further information on IPC namespaces, see namespaces(7).

       CLONE_NEWNET (since Linux 2.6.24)
              (The implementation of this flag was completed only by about kernel version 2.6.29.)

              If CLONE_NEWNET is set, then create the process in a new network namespace.  If this flag is not  set,  then
              (as with fork(2)) the process is created in the same network namespace as the calling process.  This flag is
              intended for the implementation of containers.

              A network namespace provides an isolated view of the networking stack (network device interfaces,  IPv4  and
              IPv6  protocol  stacks, IP routing tables, firewall rules, the /proc/net and /sys/class/net directory trees,
              sockets, etc.).  A physical network device can live in exactly one network  namespace.   A  virtual  network
              (veth(4))  device  pair  provides a pipe-like abstraction that can be used to create tunnels between network
              namespaces, and can be used to create a bridge to a physical network device in another namespace.

              When a network namespace is freed (i.e., when the last process in the namespace  terminates),  its  physical
              network  devices  are  moved  back to the initial network namespace (not to the parent of the process).  For
              further information on network namespaces, see namespaces(7).

              Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWNET.

       CLONE_NEWNS (since Linux 2.4.19)
              If CLONE_NEWNS is set, the cloned child is started in a new mount namespace, initialized with a copy of  the
              namespace of the parent.  If CLONE_NEWNS is not set, the child lives in the same mount namespace as the par‐
              ent.

              Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWNS.  It  is  not  permitted  to  specify  both
              CLONE_NEWNS and CLONE_FS in the same clone() call.

              For further information on mount namespaces, see namespaces(7) and mount_namespaces(7).

       CLONE_NEWPID (since Linux 2.6.24)
              If  CLONE_NEWPID  is set, then create the process in a new PID namespace.  If this flag is not set, then (as
              with fork(2)) the process is created in the same PID  namespace  as  the  calling  process.   This  flag  is
              intended for the implementation of containers.

              For further information on PID namespaces, see namespaces(7) and pid_namespaces(7).

              Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWPID.  This flag can't be specified in conjunc‐
              tion with CLONE_THREAD or CLONE_PARENT.

       CLONE_NEWUSER
              (This flag first became meaningful for clone() in Linux 2.6.23, the current clone() semantics were merged in
              Linux 3.5, and the final pieces to make the user namespaces completely usable were merged in Linux 3.8.)

              If CLONE_NEWUSER is set, then create the process in a new user namespace.  If this flag is not set, then (as
              with fork(2)) the process is created in the same user namespace as the calling process.

              Before Linux 3.8, use of CLONE_NEWUSER required that the  caller  have  three  capabilities:  CAP_SYS_ADMIN,
              CAP_SETUID, and CAP_SETGID.  Starting with Linux 3.8, no privileges are needed to create a user namespace.

              This  flag  can't  be  specified  in  conjunction  with CLONE_THREAD or CLONE_PARENT.  For security reasons,
              CLONE_NEWUSER cannot be specified in conjunction with CLONE_FS.

              For further information on user namespaces, see namespaces(7) and user_namespaces(7).

       CLONE_NEWUTS (since Linux 2.6.19)
              If CLONE_NEWUTS is set, then create the process in a new UTS namespace, whose identifiers are initialized by
              duplicating  the  identifiers  from the UTS namespace of the calling process.  If this flag is not set, then
              (as with fork(2)) the process is created in the same UTS namespace as the calling  process.   This  flag  is
              intended for the implementation of containers.

              A  UTS  namespace is the set of identifiers returned by uname(2); among these, the domain name and the host‐
              name can be modified by setdomainname(2) and sethostname(2), respectively.  Changes made to the  identifiers
              in  a  UTS  namespace  are visible to all other processes in the same namespace, but are not visible to pro‐
              cesses in other UTS namespaces.

              Only a privileged process (CAP_SYS_ADMIN) can employ CLONE_NEWUTS.

              For further information on UTS namespaces, see namespaces(7).

       CLONE_PARENT (since Linux 2.3.12)
              If CLONE_PARENT is set, then the parent of the new child (as returned by getppid(2)) will  be  the  same  as
              that of the calling process.

              If CLONE_PARENT is not set, then (as with fork(2)) the child's parent is the calling process.

              Note  that it is the parent process, as returned by getppid(2), which is signaled when the child terminates,
              so that if CLONE_PARENT is set, then the parent of the calling process,  rather  than  the  calling  process
              itself, will be signaled.

       CLONE_PARENT_SETTID (since Linux 2.5.49)
              Store  the child thread ID at the location ptid in the parent's memory.  (In Linux 2.5.32-2.5.48 there was a
              flag CLONE_SETTID that did this.)  The store operation completes before  clone()  returns  control  to  user
              space.

       CLONE_PID (Linux 2.0 to 2.5.15)
              If  CLONE_PID is set, the child process is created with the same process ID as the calling process.  This is
              good for hacking the system, but otherwise of not much use.  From Linux 2.3.21 onward, this  flag  could  be
              specified  only by the system boot process (PID 0).  The flag disappeared completely from the kernel sources
              in Linux 2.5.16.  Since then, the kernel silently ignores this bit if it is specified in flags.

       CLONE_PTRACE (since Linux 2.2)
              If CLONE_PTRACE is specified, and the calling process is being  traced,  then  trace  the  child  also  (see
              ptrace(2)).

       CLONE_SETTLS (since Linux 2.5.32)
              The TLS (Thread Local Storage) descriptor is set to newtls.

              The  interpretation  of newtls and the resulting effect is architecture dependent.  On x86, newtls is inter‐
              preted as a struct user_desc * (see set_thread_area(2)).  On x86-64 it is the new value to be  set  for  the
              %fs  base  register  (see the ARCH_SET_FS argument to arch_prctl(2)).  On architectures with a dedicated TLS
              register, it is the new value of that register.

       CLONE_SIGHAND (since Linux 2.0)
              If CLONE_SIGHAND is set, the calling process and the child process share the same table of signal  handlers.
              If  the calling process or child process calls sigaction(2) to change the behavior associated with a signal,
              the behavior is changed in the other process as well.  However, the  calling  process  and  child  processes
              still  have distinct signal masks and sets of pending signals.  So, one of them may block or unblock signals
              using sigprocmask(2) without affecting the other process.

              If CLONE_SIGHAND is not set, the child process inherits a copy of the signal handlers of the calling process
              at the time clone() is called.  Calls to sigaction(2) performed later by one of the processes have no effect
              on the other process.

              Since Linux 2.6.0-test6, flags must also include CLONE_VM if CLONE_SIGHAND is specified

       CLONE_STOPPED (since Linux 2.6.0-test2)
              If CLONE_STOPPED is set, then the child is initially stopped (as though it was sent a SIGSTOP  signal),  and
              must be resumed by sending it a SIGCONT signal.

              This  flag was deprecated from Linux 2.6.25 onward, and was removed altogether in Linux 2.6.38.  Since then,
              the kernel silently ignores it without error.  Starting with Linux 4.6, the same  bit  was  reused  for  the
              CLONE_NEWCGROUP flag.

       CLONE_SYSVSEM (since Linux 2.5.10)
              If  CLONE_SYSVSEM  is  set, then the child and the calling process share a single list of System V semaphore
              adjustment (semadj) values (see semop(2)).  In this case, the shared list accumulates semadj  values  across
              all  processes  sharing the list, and semaphore adjustments are performed only when the last process that is
              sharing the list terminates (or ceases sharing the list using unshare(2)).  If this flag is  not  set,  then
              the child has a separate semadj list that is initially empty.

       CLONE_THREAD (since Linux 2.4.0-test8)
              If  CLONE_THREAD  is  set, the child is placed in the same thread group as the calling process.  To make the
              remainder of the discussion of CLONE_THREAD more readable, the term "thread" is used to refer  to  the  pro‐
              cesses within a thread group.

              Thread groups were a feature added in Linux 2.4 to support the POSIX threads notion of a set of threads that
              share a single PID.  Internally, this shared PID is the so-called thread group  identifier  (TGID)  for  the
              thread group.  Since Linux 2.4, calls to getpid(2) return the TGID of the caller.

              The  threads  within  a  group  can  be distinguished by their (system-wide) unique thread IDs (TID).  A new
              thread's TID is available as the function result returned to the caller of clone(), and a thread can  obtain
              its own TID using gettid(2).

              When a call is made to clone() without specifying CLONE_THREAD, then the resulting thread is placed in a new
              thread group whose TGID is the same as the thread's TID.  This thread is the leader of the new thread group.

              A new thread created with CLONE_THREAD has the same parent process as the  caller  of  clone()  (i.e.,  like
              CLONE_PARENT),  so  that calls to getppid(2) return the same value for all of the threads in a thread group.
              When a CLONE_THREAD thread terminates, the thread that created it using clone() is not sent  a  SIGCHLD  (or
              other  termination)  signal;  nor can the status of such a thread be obtained using wait(2).  (The thread is
              said to be detached.)

              After all of the threads in a thread group terminate the parent process  of  the  thread  group  is  sent  a
              SIGCHLD (or other termination) signal.

              If  any of the threads in a thread group performs an execve(2), then all threads other than the thread group
              leader are terminated, and the new program is executed in the thread group leader.

              If one of the threads in a thread group creates a child using fork(2), then any  thread  in  the  group  can
              wait(2) for that child.

              Since Linux 2.5.35, flags must also include CLONE_SIGHAND if CLONE_THREAD is specified (and note that, since
              Linux 2.6.0-test6, CLONE_SIGHAND also requires CLONE_VM to be included).

              Signals may be sent to a thread group as a whole (i.e., a TGID) using  kill(2),  or  to  a  specific  thread
              (i.e., TID) using tgkill(2).

              Signal  dispositions  and actions are process-wide: if an unhandled signal is delivered to a thread, then it
              will affect (terminate, stop, continue, be ignored in) all members of the thread group.

              Each thread has its own signal mask, as set by sigprocmask(2), but signals can be pending  either:  for  the
              whole process (i.e., deliverable to any member of the thread group), when sent with kill(2); or for an indi‐
              vidual thread, when sent with tgkill(2).  A call to sigpending(2) returns a signal set that is the union  of
              the signals pending for the whole process and the signals that are pending for the calling thread.

              If  kill(2) is used to send a signal to a thread group, and the thread group has installed a handler for the
              signal, then the handler will be invoked in exactly one, arbitrarily selected member  of  the  thread  group
              that has not blocked the signal.  If multiple threads in a group are waiting to accept the same signal using
              sigwaitinfo(2), the kernel will arbitrarily select one of these threads  to  receive  a  signal  sent  using
              kill(2).

       CLONE_UNTRACED (since Linux 2.5.46)
              If CLONE_UNTRACED is specified, then a tracing process cannot force CLONE_PTRACE on this child process.

       CLONE_VFORK (since Linux 2.2)
              If  CLONE_VFORK  is set, the execution of the calling process is suspended until the child releases its vir‐
              tual memory resources via a call to execve(2) or _exit(2) (as with vfork(2)).

              If CLONE_VFORK is not set, then both the calling process and the child are schedulable after the  call,  and
              an application should not rely on execution occurring in any particular order.

       CLONE_VM (since Linux 2.0)
              If  CLONE_VM is set, the calling process and the child process run in the same memory space.  In particular,
              memory writes performed by the calling process or by the  child  process  are  also  visible  in  the  other
              process.   Moreover,  any  memory  mapping  or unmapping performed with mmap(2) or munmap(2) by the child or
              calling process also affects the other process.

              If CLONE_VM is not set, the child process runs in a separate copy of the memory space of the calling process
              at  the time of clone().  Memory writes or file mappings/unmappings performed by one of the processes do not
              affect the other, as with fork(2).

NOTES
       Note that the glibc clone() wrapper function makes some changes in the memory pointed to  by  child_stack  (changes
       required  to set the stack up correctly for the child) before invoking the clone() system call.  So, in cases where
       clone() is used to recursively create children, do not use the buffer employed for the parent's stack as the  stack
       of the child.

   C library/kernel differences
       The  raw  clone() system call corresponds more closely to fork(2) in that execution in the child continues from the
       point of the call.  As such, the fn and arg arguments of the clone() wrapper function are omitted.

       Another difference for the raw clone() system call is that the child_stack argument may be NULL, in which case  the
       child  uses a duplicate of the parent's stack.  (Copy-on-write semantics ensure that the child gets separate copies
       of stack pages when either process modifies the stack.)  In this case, for correct operation, the  CLONE_VM  option
       should not be specified.  (If the child shares the parent's memory because of the use of the CLONE_VM flag, then no
       copy-on-write duplication occurs and chaos is likely to result.)

       The order of the arguments also differs in the raw system call, and there are variations in  the  arguments  across
       architectures, as detailed in the following paragraphs.

       The raw system call interface on x86-64 and some other architectures (including sh, tile, and alpha) is:

           long clone(unsigned long flags, void *child_stack,
                      int *ptid, int *ctid,
                      unsigned long newtls);

       On  x86-32,  and  several other common architectures (including score, ARM, ARM 64, PA-RISC, arc, Power PC, xtensa,
       and MIPS), the order of the last two arguments is reversed:

           long clone(unsigned long flags, void *child_stack,
                     int *ptid, unsigned long newtls,
                     int *ctid);

       On the cris and s390 architectures, the order of the first two arguments is reversed:

           long clone(void *child_stack, unsigned long flags,
                      int *ptid, int *ctid,
                      unsigned long newtls);

       On the microblaze architecture, an additional argument is supplied:

           long clone(unsigned long flags, void *child_stack,
                      int stack_size,         /* Size of stack */
                      int *ptid, int *ctid,
                      unsigned long newtls);

   blackfin, m68k, and sparc
       The argument-passing conventions on blackfin, m68k, and sparc are  different  from  the  descriptions  above.   For
       details, see the kernel (and glibc) source.

   ia64
       On ia64, a different interface is used:

       int __clone2(int (*fn)(void *),
                    void *child_stack_base, size_t stack_size,
                    int flags, void *arg, ...
                 /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ );

       The  prototype  shown above is for the glibc wrapper function; the raw system call interface has no fn or arg argu‐
       ment, and changes the order of the arguments so that flags is the first argument, and tls is the last argument.

       __clone2() operates in the same way as clone(), except that child_stack_base points to the lowest  address  of  the
       child's stack area, and stack_size specifies the size of the stack pointed to by child_stack_base.

   Linux 2.4 and earlier
       In Linux 2.4 and earlier, clone() does not take arguments ptid, tls, and ctid.

RETURN VALUE
       On  success, the thread ID of the child process is returned in the caller's thread of execution.  On failure, -1 is
       returned in the caller's context, no child process will be created, and errno will be set appropriately.

ERRORS
       EAGAIN Too many processes are already running; see fork(2).

       EINVAL CLONE_SIGHAND was specified, but CLONE_VM was not.  (Since Linux 2.6.0-test6.)

       EINVAL CLONE_THREAD was specified, but CLONE_SIGHAND was not.  (Since Linux 2.5.35.)

       EINVAL Both CLONE_FS and CLONE_NEWNS were specified in flags.

       EINVAL (since Linux 3.9)
              Both CLONE_NEWUSER and CLONE_FS were specified in flags.

       EINVAL Both CLONE_NEWIPC and CLONE_SYSVSEM were specified in flags.

       EINVAL One (or both) of CLONE_NEWPID or CLONE_NEWUSER and one (or both) of CLONE_THREAD or CLONE_PARENT were speci‐
              fied in flags.

       EINVAL Returned by the glibc clone() wrapper function when fn or child_stack is specified as NULL.

       EINVAL CLONE_NEWIPC  was  specified  in  flags,  but the kernel was not configured with the CONFIG_SYSVIPC and CON‐
              FIG_IPC_NS options.

       EINVAL CLONE_NEWNET was specified in flags, but the kernel was not configured with the CONFIG_NET_NS option.

       EINVAL CLONE_NEWPID was specified in flags, but the kernel was not configured with the CONFIG_PID_NS option.

       EINVAL CLONE_NEWUTS was specified in flags, but the kernel was not configured with the CONFIG_UTS option.

       EINVAL child_stack is not aligned to  a  suitable  boundary  for  this  architecture.   For  example,  on  aarch64,
              child_stack must be a multiple of 16.

       ENOMEM Cannot  allocate sufficient memory to allocate a task structure for the child, or to copy those parts of the
              caller's context that need to be copied.

       ENOSPC (since Linux 3.7)
              CLONE_NEWPID was specified in flags, but the limit on the nesting depth of PID namespaces  would  have  been
              exceeded; see pid_namespaces(7).

       ENOSPC (since Linux 4.9; beforehand EUSERS)
              CLONE_NEWUSER was specified in flags, and the call would cause the limit on the number of nested user names‐
              paces to be exceeded.  See user_namespaces(7).

              From Linux 3.11 to Linux 4.8, the error diagnosed in this case was EUSERS.

       ENOSPC (since Linux 4.9)
              One of the values in flags specified the creation of a new user namespace, but doing so  would  have  caused
              the  limit  defined  by  the  corresponding file in /proc/sys/user to be exceeded.  For further details, see
              namespaces(7).

       EPERM  CLONE_NEWCGROUP, CLONE_NEWIPC, CLONE_NEWNET, CLONE_NEWNS, CLONE_NEWPID, or CLONE_NEWUTS was specified by  an
              unprivileged process (process without CAP_SYS_ADMIN).

       EPERM  CLONE_PID was specified by a process other than process 0.  (This error occurs only on Linux 2.5.15 and ear‐
              lier.)

       EPERM  CLONE_NEWUSER was specified in flags, but either the effective user ID or the  effective  group  ID  of  the
              caller does not have a mapping in the parent namespace (see user_namespaces(7)).

       EPERM (since Linux 3.9)
              CLONE_NEWUSER  was  specified  in  flags  and the caller is in a chroot environment (i.e., the caller's root
              directory does not match the root directory of the mount namespace in which it resides).

       ERESTARTNOINTR (since Linux 2.6.17)
              System call was interrupted by a signal and will be restarted.  (This can be seen only during a trace.)

       EUSERS (Linux 3.11 to Linux 4.8)
              CLONE_NEWUSER was specified in flags, and the limit on  the  number  of  nested  user  namespaces  would  be
              exceeded.  See the discussion of the ENOSPC error above.

CONFORMING TO
       clone() is Linux-specific and should not be used in programs intended to be portable.

NOTES
       The kcmp(2) system call can be used to test whether two processes share various resources such as a file descriptor
       table, System V semaphore undo operations, or a virtual address space.

       Handlers registered using pthread_atfork(3) are not executed during a call to clone().

       In the Linux 2.4.x series, CLONE_THREAD generally does not make the parent of the new thread the same as the parent
       of  the calling process.  However, for kernel versions 2.4.7 to 2.4.18 the CLONE_THREAD flag implied the CLONE_PAR‐
       ENT flag (as in Linux 2.6.0 and later).

       For a while there was CLONE_DETACHED (introduced in 2.5.32): parent wants no child-exit signal.   In  Linux  2.6.2,
       the need to give this flag together with CLONE_THREAD disappeared.  This flag is still defined, but has no effect.

       On i386, clone() should not be called through vsyscall, but directly through int $0x80.

BUGS
       GNU  C  library  versions  2.3.4 up to and including 2.24 contained a wrapper function for getpid(2) that performed
       caching of PIDs.  This caching relied on support in the glibc wrapper for clone(), but limitations in the implemen‐
       tation  meant that the cache was not up to date in some circumstances.  In particular, if a signal was delivered to
       the child immediately after the clone() call, then a call to getpid(2) in a handler for the signal could return the
       PID of the calling process ("the parent"), if the clone wrapper had not yet had a chance to update the PID cache in
       the child.  (This discussion ignores the case where the child was created using CLONE_THREAD, when getpid(2) should
       return  the  same  value in the child and in the process that called clone(), since the caller and the child are in
       the same thread group.  The stale-cache problem also does not occur if the flags argument includes  CLONE_VM.)   To
       get the truth, it was sometimes necessary to use code such as the following:

           #include <syscall.h>

           pid_t mypid;

           mypid = syscall(SYS_getpid);

       Because  of  the  stale-cache  problem,  as  well as other problems noted in getpid(2), the PID caching feature was
       removed in glibc 2.25.

EXAMPLE
       The following program demonstrates the use of clone() to create a child process that executes  in  a  separate  UTS
       namespace.   The  child  changes  the hostname in its UTS namespace.  Both parent and child then display the system
       hostname, making it possible to see that the hostname differs in the UTS namespaces of the parent and  child.   For
       an example of the use of this program, see setns(2).

   Program source
       #define _GNU_SOURCE
       #include <sys/wait.h>
       #include <sys/utsname.h>
       #include <sched.h>
       #include <string.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>

       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       static int              /* Start function for cloned child */
       childFunc(void *arg)
       {
           struct utsname uts;

           /* Change hostname in UTS namespace of child */

           if (sethostname(arg, strlen(arg)) == -1)
               errExit("sethostname");

           /* Retrieve and display hostname */

           if (uname(&uts) == -1)
               errExit("uname");
           printf("uts.nodename in child:  %s\n", uts.nodename);

           /* Keep the namespace open for a while, by sleeping.
              This allows some experimentation--for example, another
              process might join the namespace. */

           sleep(200);

           return 0;           /* Child terminates now */
       }

       #define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */

       int
       main(int argc, char *argv[])
       {
           char *stack;                    /* Start of stack buffer */
           char *stackTop;                 /* End of stack buffer */
           pid_t pid;
           struct utsname uts;

           if (argc < 2) {
               fprintf(stderr, "Usage: %s <child-hostname>\n", argv[0]);
               exit(EXIT_SUCCESS);
           }

           /* Allocate stack for child */

           stack = malloc(STACK_SIZE);
           if (stack == NULL)
               errExit("malloc");
           stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */

           /* Create child that has its own UTS namespace;
              child commences execution in childFunc() */

           pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);
           if (pid == -1)
               errExit("clone");
           printf("clone() returned %ld\n", (long) pid);

           /* Parent falls through to here */

           sleep(1);           /* Give child time to change its hostname */

           /* Display hostname in parent's UTS namespace. This will be
              different from hostname in child's UTS namespace. */

           if (uname(&uts) == -1)
               errExit("uname");
           printf("uts.nodename in parent: %s\n", uts.nodename);

           if (waitpid(pid, NULL, 0) == -1)    /* Wait for child */
               errExit("waitpid");
           printf("child has terminated\n");

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       fork(2),  futex(2),  getpid(2),  gettid(2),  kcmp(2),  set_thread_area(2),  set_tid_address(2), setns(2), tkill(2),
       unshare(2), wait(2), capabilities(7), namespaces(7), pthreads(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                CLONE(2)
</pre>
<pre zoom>
<span xsmall>2 dup</span>
DUP(2)                                           Linux Programmer's Manual                                          DUP(2)

NAME
       dup, dup2, dup3 - duplicate a file descriptor

SYNOPSIS
       #include <unistd.h>

       int dup(int oldfd);
       int dup2(int oldfd, int newfd);

       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <fcntl.h>              /* Obtain O_* constant definitions */
       #include <unistd.h>

       int dup3(int oldfd, int newfd, int flags);

DESCRIPTION
       The dup() system call creates a copy of the file descriptor oldfd, using the lowest-numbered unused file descriptor
       for the new descriptor.

       After a successful return, the old and new file descriptors may be used interchangeably.  They refer  to  the  same
       open file description (see open(2)) and thus share file offset and file status flags; for example, if the file off‐
       set is modified by using lseek(2) on one of the file descriptors, the offset is also changed for the other.

       The two file descriptors do not share file descriptor flags  (the  close-on-exec  flag).   The  close-on-exec  flag
       (FD_CLOEXEC; see fcntl(2)) for the duplicate descriptor is off.

   dup2()
       The  dup2()  system  call  performs  the  same  task as dup(), but instead of using the lowest-numbered unused file
       descriptor, it uses the file descriptor number specified in newfd.  If the file  descriptor  newfd  was  previously
       open, it is silently closed before being reused.

       The  steps  of  closing and reusing the file descriptor newfd are performed atomically.  This is important, because
       trying to implement equivalent functionality using close(2) and dup() would be subject to race conditions,  whereby
       newfd  might be reused between the two steps.  Such reuse could happen because the main program is interrupted by a
       signal handler that allocates a file descriptor, or because a parallel thread allocates a file descriptor.

       Note the following points:

       *  If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.

       *  If oldfd is a valid file descriptor, and newfd has the same value  as  oldfd,  then  dup2()  does  nothing,  and
          returns newfd.

   dup3()
       dup3() is the same as dup2(), except that:

       *  The  caller  can  force  the close-on-exec flag to be set for the new file descriptor by specifying O_CLOEXEC in
          flags.  See the description of the same flag in open(2) for reasons why this may be useful.

       *  If oldfd equals newfd, then dup3() fails with the error EINVAL.

RETURN VALUE
       On success, these system calls return the new file descriptor.  On error, -1 is returned, and errno is  set  appro‐
       priately.

ERRORS
       EBADF  oldfd isn't an open file descriptor.

       EBADF  newfd  is  out  of  the  allowed  range  for  file descriptors (see the discussion of RLIMIT_NOFILE in getr‐
              limit(2)).

       EBUSY  (Linux only) This may be returned by dup2() or dup3() during a race condition with open(2) and dup().

       EINTR  The dup2() or dup3() call was interrupted by a signal; see signal(7).

       EINVAL (dup3()) flags contain an invalid value.

       EINVAL (dup3()) oldfd was equal to newfd.

       EMFILE The per-process limit on the number of open file  descriptors  has  been  reached  (see  the  discussion  of
              RLIMIT_NOFILE in getrlimit(2)).

VERSIONS
       dup3() was added to Linux in version 2.6.27; glibc support is available starting with version 2.9.

CONFORMING TO
       dup(), dup2(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

       dup3() is Linux-specific.

NOTES
       The  error  returned  by  dup2()  is different from that returned by fcntl(..., F_DUPFD, ...)  when newfd is out of
       range.  On some systems, dup2() also sometimes returns EINVAL like F_DUPFD.

       If newfd was open, any errors that would have been reported at close(2) time are lost.   If  this  is  of  concern,
       then—unless  the  program  is single-threaded and does not allocate file descriptors in signal handlers—the correct
       approach is not to close newfd before calling dup2(), because of the race condition described above.  Instead, code
       something like the following could be used:

           /* Obtain a duplicate of 'newfd' that can subsequently
              be used to check for close() errors; an EBADF error
              means that 'newfd' was not open. */

           tmpfd = dup(newfd);
           if (tmpfd == -1 && errno != EBADF) {
               /* Handle unexpected dup() error */
           }

           /* Atomically duplicate 'oldfd' on 'newfd' */

           if (dup2(oldfd, newfd) == -1) {
               /* Handle dup2() error */
           }

           /* Now check for close() errors on the file originally
              referred to by 'newfd' */

           if (tmpfd != -1) {
               if (close(tmpfd) == -1) {
                   /* Handle errors from close */
               }
           }

SEE ALSO
       close(2), fcntl(2), open(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                  DUP(2)
</pre>
<pre zoom>
<span xsmall>2 insb</span>
OUTB(2)                                          Linux Programmer's Manual                                         OUTB(2)

NAME
       outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, outb_p, outw_p, outl_p, inb_p, inw_p, inl_p
       - port I/O

SYNOPSIS
       #include <sys/io.h>

       unsigned char inb(unsigned short int port);
       unsigned char inb_p(unsigned short int port);
       unsigned short int inw(unsigned short int port);
       unsigned short int inw_p(unsigned short int port);
       unsigned int inl(unsigned short int port);
       unsigned int inl_p(unsigned short int port);

       void outb(unsigned char value, unsigned short int port);
       void outb_p(unsigned char value, unsigned short int port);
       void outw(unsigned short int value, unsigned short int port);
       void outw_p(unsigned short int value, unsigned short int port);
       void outl(unsigned int value, unsigned short int port);
       void outl_p(unsigned int value, unsigned short int port);

       void insb(unsigned short int port, void *addr,
                  unsigned long int count);
       void insw(unsigned short int port, void *addr,
                  unsigned long int count);
       void insl(unsigned short int port, void *addr,
                  unsigned long int count);
       void outsb(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsw(unsigned short int port, const void *addr,
                  unsigned long int count);
       void outsl(unsigned short int port, const void *addr,
                  unsigned long int count);

DESCRIPTION
       This family of functions is used to do low-level port input and output.  The out* functions do port output, the in*
       functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix
       functions pause until the I/O completes.

       They are primarily designed for internal kernel use, but can be used from user space.

       You must compile with -O or -O2 or similar.  The functions are defined as inline macros, and will  not  be  substi‐
       tuted in without optimization enabled, causing unresolved references at link time.

       You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O
       ports in question.  Failure to do this will cause the application to receive a segmentation fault.

CONFORMING TO
       outb() and friends are hardware-specific.  The value argument is passed first and the port argument is passed  sec‐
       ond, which is the opposite order from most DOS implementations.

SEE ALSO
       ioperm(2), iopl(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                 OUTB(2)
</pre>
<pre zoom>
<span xsmall>2 geteuid32</span>
GETUID(2)                                        Linux Programmer's Manual                                       GETUID(2)

NAME
       getuid, geteuid - get user identity

SYNOPSIS
       #include <unistd.h>
       #include <sys/types.h>

       uid_t getuid(void);
       uid_t geteuid(void);

DESCRIPTION
       getuid() returns the real user ID of the calling process.

       geteuid() returns the effective user ID of the calling process.

ERRORS
       These functions are always successful.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD.

NOTES
   History
       In UNIX V6 the getuid() call returned (euid << 8) + uid.  UNIX V7 introduced separate calls getuid() and geteuid().

       The  original  Linux  getuid()  and geteuid() system calls supported only 16-bit user IDs.  Subsequently, Linux 2.4
       added getuid32() and geteuid32(), supporting 32-bit IDs.  The glibc getuid() and geteuid() wrapper functions trans‐
       parently deal with the variations across kernel versions.

SEE ALSO
       getresuid(2), setreuid(2), setuid(2), credentials(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               GETUID(2)
</pre>
<pre zoom>
<span xsmall>2 lgetxattr</span>
GETXATTR(2)                                      Linux Programmer's Manual                                     GETXATTR(2)

NAME
       getxattr, lgetxattr, fgetxattr - retrieve an extended attribute value

SYNOPSIS
       #include <sys/types.h>
       #include <sys/xattr.h>

       ssize_t getxattr(const char *path, const char *name,
                        void *value, size_t size);
       ssize_t lgetxattr(const char *path, const char *name,
                        void *value, size_t size);
       ssize_t fgetxattr(int fd, const char *name,
                        void *value, size_t size);

DESCRIPTION
       Extended  attributes  are name:value pairs associated with inodes (files, directories, symbolic links, etc.).  They
       are extensions to the normal attributes which are associated with all inodes  in  the  system  (i.e.,  the  stat(2)
       data).  A complete overview of extended attributes concepts can be found in xattr(7).

       getxattr()  retrieves  the value of the extended attribute identified by name and associated with the given path in
       the filesystem.  The attribute value is placed in the buffer pointed to by value; size specifies the size  of  that
       buffer.  The return value of the call is the number of bytes placed in value.

       lgetxattr()  is  identical  to getxattr(), except in the case of a symbolic link, where the link itself is interro‐
       gated, not the file that it refers to.

       fgetxattr() is identical to getxattr(), only the open file referred to by fd (as returned by open(2))  is  interro‐
       gated in place of path.

       An  extended  attribute  name is a null-terminated string.  The name includes a namespace prefix; there may be sev‐
       eral, disjoint namespaces associated with an individual inode.  The value of an extended attribute is  a  chunk  of
       arbitrary textual or binary data that was assigned using setxattr(2).

       If  size is specified as zero, these calls return the current size of the named extended attribute (and leave value
       unchanged).  This can be used to determine the size of the buffer that should be supplied  in  a  subsequent  call.
       (But,  bear  in mind that there is a possibility that the attribute value may change between the two calls, so that
       it is still necessary to check the return status from the second call.)

RETURN VALUE
       On success, these calls return a nonnegative value which is the size (in bytes) of the  extended  attribute  value.
       On failure, -1 is returned and errno is set appropriately.

ERRORS
       E2BIG  The  size of the attribute value is larger than the maximum size allowed; the attribute cannot be retrieved.
              This can happen on filesystems that support very large attribute values such as NFSv4, for example.

       ENOATTR
              The named attribute does not exist, or the process has no access to this attribute.  (ENOATTR is defined  to
              be a synonym for ENODATA in <attr/xattr.h>.)

       ENOTSUP
              Extended attributes are not supported by the filesystem, or are disabled.

       ERANGE The size of the value buffer is too small to hold the result.

       In addition, the errors documented in stat(2) can also occur.

VERSIONS
       These system calls have been available on Linux since kernel 2.4; glibc support is provided since version 2.3.

CONFORMING TO
       These system calls are Linux-specific.

EXAMPLE
       See listxattr(2).

SEE ALSO
       getfattr(1), setfattr(1), listxattr(2), open(2), removexattr(2), setxattr(2), stat(2), symlink(7), xattr(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-03-13                                             GETXATTR(2)
</pre>
<pre zoom>
<span xsmall>2 setsid</span>
SETSID(2)                                        Linux Programmer's Manual                                       SETSID(2)

NAME
       setsid - creates a session and sets the process group ID

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       pid_t setsid(void);

DESCRIPTION
       setsid()  creates  a  new session if the calling process is not a process group leader.  The calling process is the
       leader of the new session (i.e., its session ID is made the same as its process  ID).   The  calling  process  also
       becomes the process group leader of a new process group in the session (i.e., its process group ID is made the same
       as its process ID).

       The calling process will be the only process in the new process group and in the new session.

       Initially, the new session has no controlling terminal.  For details of how a session acquires a controlling termi‐
       nal, see credentials(7).

RETURN VALUE
       On  success,  the (new) session ID of the calling process is returned.  On error, (pid_t) -1 is returned, and errno
       is set to indicate the error.

ERRORS
       EPERM  The process group ID of any process equals the PID of the calling process.  Thus,  in  particular,  setsid()
              fails if the calling process is already a process group leader.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

NOTES
       A child created via fork(2) inherits its parent's session ID.  The session ID is preserved across an execve(2).

       A process group leader is a process whose process group ID equals its PID.  Disallowing a process group leader from
       calling setsid() prevents the possibility that a process group leader places itself in a new  session  while  other
       processes  in  the  process  group remain in the original session; such a scenario would break the strict two-level
       hierarchy of sessions and process groups.  In order to be sure that setsid() will succeed, call  fork(2)  and  have
       the parent _exit(2), while the child (which by definition can't be a process group leader) calls setsid().

       If  a  session  has a controlling terminal, and the CLOCAL flag for that terminal is not set, and a terminal hangup
       occurs, then the session leader is sent a SIGHUP signal.

       If a process that is a session leader terminates, then a SIGHUP signal is sent to each process  in  the  foreground
       process group of the controlling terminal.

SEE ALSO
       setsid(1), getsid(2), setpgid(2), setpgrp(2), tcgetsid(3), credentials(7), sched(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SETSID(2)
</pre>
<pre zoom>
<span xsmall>2 memfd_create</span>
MEMFD_CREATE(2)                                  Linux Programmer's Manual                                 MEMFD_CREATE(2)

NAME
       memfd_create - create an anonymous file

SYNOPSIS
       #include <sys/memfd.h>

       int memfd_create(const char *name, unsigned int flags);

DESCRIPTION
       memfd_create()  creates an anonymous file and returns a file descriptor that refers to it.  The file behaves like a
       regular file, and so can be modified, truncated, memory-mapped, and so on.  However,  unlike  a  regular  file,  it
       lives  in RAM and has a volatile backing storage.  Once all references to the file are dropped, it is automatically
       released.  Anonymous memory is used for all backing pages of the file.  Therefore, files created by  memfd_create()
       have  the  same  semantics  as  other  anonymous  memory allocations such as those allocated using mmap(2) with the
       MAP_ANONYMOUS flag.

       The initial size of the file is set to 0.  Following the call, the file size  should  be  set  using  ftruncate(2).
       (Alternatively, the file may be populated by calls to write(2) or similar.)

       The  name  supplied in name is used as a filename and will be displayed as the target of the corresponding symbolic
       link in the directory /proc/self/fd/.  The displayed name is always prefixed with memfd: and serves only for debug‐
       ging  purposes.   Names  do not affect the behavior of the file descriptor, and as such multiple files can have the
       same name without any side effects.

       The following values may be bitwise ORed in flags to change the behavior of memfd_create():

       MFD_CLOEXEC
              Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.  See the description  of  the  O_CLOEXEC
              flag in open(2) for reasons why this may be useful.

       MFD_ALLOW_SEALING
              Allow  sealing operations on this file.  See the discussion of the F_ADD_SEALS and F_GET_SEALS operations in
              fcntl(2), and also NOTES, below.  The initial set of seals is empty.  If this flag is not set,  the  initial
              set of seals will be F_SEAL_SEAL, meaning that no other seals can be set on the file.

       MFD_HUGETLB (since Linux 4.14)
              The  anonymous  file  will  be  created  in the hugetlbfs filesystem using huge pages.  See the Linux kernel
              source file Documentation/vm/hugetlbpage.txt for more information about hugetlbfs.  The hugetlbfs filesystem
              does  not  support file-sealing operations.  Therefore, specifying both MFD_HUGETLB and MFD_ALLOW_SEALING in
              flags is disallowed.

       MFD_HUGE_2MB, MFD_HUGE_1GB, ...
              Used in conjunction with MFD_HUGETLB to select alternative hugetlb page  sizes  (respectively,  2 MB,  1 GB,
              ...)   on  systems  that  support  multiple  hugetlb  page sizes.  Definitions for known huge page sizes are
              included in the header file <sys/memfd.h>.

              For details on encoding huge page sizes not included in the header file, see the discussion of the similarly
              named constants in mmap(2).

       Unused bits in flags must be 0.

       As its return value, memfd_create() returns a new file descriptor that can be used to refer to the file.  This file
       descriptor is opened for both reading and writing (O_RDWR) and O_LARGEFILE is set for the file descriptor.

       With respect to fork(2) and execve(2), the usual semantics apply for the file descriptor created by memfd_create().
       A  copy of the file descriptor is inherited by the child produced by fork(2) and refers to the same file.  The file
       descriptor is preserved across execve(2), unless the close-on-exec flag has been set.

RETURN VALUE
       On success, memfd_create() returns a new file descriptor.  On error, -1 is returned and errno is  set  to  indicate
       the error.

ERRORS
       EFAULT The address in name points to invalid memory.

       EINVAL flags included unknown bits.

       EINVAL name was too long.  (The limit is 249 bytes, excluding the terminating null byte.)

       EINVAL Both MFD_HUGETLB and MFD_ALLOW_SEALING were specified in flags.

       EMFILE The per-process limit on the number of open file descriptors has been reached.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENOMEM There was insufficient memory to create a new anonymous file.

VERSIONS
       The memfd_create() system call first appeared in Linux 3.17; glibc support was added in version 2.27.

CONFORMING TO
       The memfd_create() system call is Linux-specific.

NOTES
       The  memfd_create() system call provides a simple alternative to manually mounting a tmpfs(5) filesystem and creat‐
       ing and opening a file in that filesystem.  The primary purpose of memfd_create() is to create files and associated
       file descriptors that are used with the file-sealing APIs provided by fcntl(2).

       The  memfd_create()  system  call also has uses without file sealing (which is why file-sealing is disabled, unless
       explicitly requested with the MFD_ALLOW_SEALING flag).  In particular, it can be used as an alternative to creating
       files  in  tmp or as an alternative to using the open(2) O_TMPFILE in cases where there is no intention to actually
       link the resulting file into the filesystem.

   File sealing
       In the absence of file sealing, processes that communicate via shared memory must either trust each other, or  take
       measures to deal with the possibility that an untrusted peer may manipulate the shared memory region in problematic
       ways.  For example, an untrusted peer might modify the contents of the shared memory at any  time,  or  shrink  the
       shared  memory  region.  The former possibility leaves the local process vulnerable to time-of-check-to-time-of-use
       race conditions (typically dealt with by copying data from the shared memory region before checking and using  it).
       The  latter  possibility  leaves the local process vulnerable to SIGBUS signals when an attempt is made to access a
       now-nonexistent location in the shared memory region.  (Dealing with this possibility necessitates  the  use  of  a
       handler for the SIGBUS signal.)

       Dealing  with  untrusted peers imposes extra complexity on code that employs shared memory.  Memory sealing enables
       that extra complexity to be eliminated, by allowing a process to operate secure in  the  knowledge  that  its  peer
       can't modify the shared memory in an undesired fashion.

       An example of the usage of the sealing mechanism is as follows:

       1. The  first process creates a tmpfs(5) file using memfd_create().  The call yields a file descriptor used in sub‐
          sequent steps.

       2. The first process sizes the file created in the previous step using ftruncate(2), maps  it  using  mmap(2),  and
          populates the shared memory with the desired data.

       3. The  first  process  uses the fcntl(2) F_ADD_SEALS operation to place one or more seals on the file, in order to
          restrict further modifications on the file.  (If placing the seal F_SEAL_WRITE, then it  will  be  necessary  to
          first unmap the shared writable mapping created in the previous step.)

       4. A  second process obtains a file descriptor for the tmpfs(5) file and maps it.  Among the possible ways in which
          this could happen are the following:

          *  The process that called memfd_create() could transfer the resulting file descriptor to the second process via
             a UNIX domain socket (see unix(7) and cmsg(3)).  The second process then maps the file using mmap(2).

          *  The  second  process  is created via fork(2) and thus automatically inherits the file descriptor and mapping.
             (Note that in this case and the next, there is a natural trust relationship between the two processes,  since
             they are running under the same user ID.  Therefore, file sealing would not normally be necessary.)

          *  The  second  process opens the file /proc/<pid>/fd/<fd>, where <pid> is the PID of the first process (the one
             that called memfd_create()), and <fd> is the number of the file descriptor returned by the call to memfd_cre‐
             ate() in that process.  The second process then maps the file using mmap(2).

       5. The  second  process  uses  the  fcntl(2)  F_GET_SEALS operation to retrieve the bit mask of seals that has been
          applied to the file.  This bit mask can be inspected in order to determine what kinds of restrictions have  been
          placed  on  file  modifications.   If  desired,  the second process can apply further seals to impose additional
          restrictions (so long as the F_SEAL_SEAL seal has not yet been applied).

EXAMPLE
       Below are shown two example programs that demonstrate the use of memfd_create() and the file sealing API.

       The first program, t_memfd_create.c, creates a tmpfs(5) file using memfd_create(), sets a size for the  file,  maps
       it  into  memory, and optionally places some seals on the file.  The program accepts up to three command-line argu‐
       ments, of which the first two are required.  The first argument is the name to associate with the file, the  second
       argument is the size to be set for the file, and the optional third argument is a string of characters that specify
       seals to be set on file.

       The second program, t_get_seals.c, can be used to open an existing file that was  created  via  memfd_create()  and
       inspect the set of seals that have been applied to that file.

       The  following  shell session demonstrates the use of these programs.  First we create a tmpfs(5) file and set some
       seals on it:

           $ ./t_memfd_create my_memfd_file 4096 sw &
           [1] 11775
           PID: 11775; fd: 3; /proc/11775/fd/3

       At this point, the t_memfd_create program continues to run in the background.  From another program, we can  obtain
       a file descriptor for the file created by memfd_create() by opening the /proc/[pid]/fd file that corresponds to the
       file descriptor opened by memfd_create().  Using that pathname, we inspect the content of the  /proc/[pid]/fd  sym‐
       bolic link, and use our t_get_seals program to view the seals that have been placed on the file:

           $ readlink /proc/11775/fd/3
           /memfd:my_memfd_file (deleted)
           $ ./t_get_seals /proc/11775/fd/3
           Existing seals: WRITE SHRINK

   Program source: t_memfd_create.c

       #include <sys/memfd.h>
       #include <fcntl.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <string.h>
       #include <stdio.h>

       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       int
       main(int argc, char *argv[])
       {
           int fd;
           unsigned int seals;
           char *addr;
           char *name, *seals_arg;
           ssize_t len;

           if (argc < 3) {
               fprintf(stderr, "%s name size [seals]\n", argv[0]);
               fprintf(stderr, "\t'seals' can contain any of the "
                       "following characters:\n");
               fprintf(stderr, "\t\tg - F_SEAL_GROW\n");
               fprintf(stderr, "\t\ts - F_SEAL_SHRINK\n");
               fprintf(stderr, "\t\tw - F_SEAL_WRITE\n");
               fprintf(stderr, "\t\tS - F_SEAL_SEAL\n");
               exit(EXIT_FAILURE);
           }

           name = argv[1];
           len = atoi(argv[2]);
           seals_arg = argv[3];

           /* Create an anonymous file in tmpfs; allow seals to be
              placed on the file */

           fd = memfd_create(name, MFD_ALLOW_SEALING);
           if (fd == -1)
               errExit("memfd_create");

           /* Size the file as specified on the command line */

           if (ftruncate(fd, len) == -1)
               errExit("truncate");

           printf("PID: %ld; fd: %d; /proc/%ld/fd/%d\n",
                   (long) getpid(), fd, (long) getpid(), fd);

           /* Code to map the file and populate the mapping with data
              omitted */

           /* If a 'seals' command-line argument was supplied, set some
              seals on the file */

           if (seals_arg != NULL) {
               seals = 0;

               if (strchr(seals_arg, 'g') != NULL)
                   seals |= F_SEAL_GROW;
               if (strchr(seals_arg, 's') != NULL)
                   seals |= F_SEAL_SHRINK;
               if (strchr(seals_arg, 'w') != NULL)
                   seals |= F_SEAL_WRITE;
               if (strchr(seals_arg, 'S') != NULL)
                   seals |= F_SEAL_SEAL;

               if (fcntl(fd, F_ADD_SEALS, seals) == -1)
                   errExit("fcntl");
           }

           /* Keep running, so that the file created by memfd_create()
              continues to exist */

           pause();

           exit(EXIT_SUCCESS);
       }

   Program source: t_get_seals.c

       #include <sys/memfd.h>
       #include <fcntl.h>
       #include <unistd.h>
       #include <stdlib.h>
       #include <string.h>
       #include <stdio.h>

       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       int
       main(int argc, char *argv[])
       {
           int fd;
           unsigned int seals;

           if (argc != 2) {
               fprintf(stderr, "%s /proc/PID/fd/FD\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           fd = open(argv[1], O_RDWR);
           if (fd == -1)
               errExit("open");

           seals = fcntl(fd, F_GET_SEALS);
           if (seals == -1)
               errExit("fcntl");

           printf("Existing seals:");
           if (seals & F_SEAL_SEAL)
               printf(" SEAL");
           if (seals & F_SEAL_GROW)
               printf(" GROW");
           if (seals & F_SEAL_WRITE)
               printf(" WRITE");
           if (seals & F_SEAL_SHRINK)
               printf(" SHRINK");
           printf("\n");

           /* Code to map the file and access the contents of the
              resulting mapping omitted */

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       fcntl(2), ftruncate(2), mmap(2), shmget(2), shm_open(3)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-02-02                                         MEMFD_CREATE(2)
</pre>
<pre zoom>
<span xsmall>2 waitid</span>
WAIT(2)                                          Linux Programmer's Manual                                         WAIT(2)

NAME
       wait, waitpid, waitid - wait for process to change state

SYNOPSIS
       #include <sys/types.h>
       #include <sys/wait.h>

       pid_t wait(int *wstatus);

       pid_t waitpid(pid_t pid, int *wstatus, int options);

       int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
                       /* This is the glibc and POSIX interface; see
                          NOTES for information on the raw system call. */

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       waitid():
           Since glibc 2.26: _XOPEN_SOURCE >= 500 ||
               _POSIX_C_SOURCE >= 200809L
           Glibc 2.25 and earlier:
               _XOPEN_SOURCE
                   || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
                   || /* Glibc versions <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       All of these system calls are used to wait for state changes in a child of the calling process, and obtain informa‐
       tion about the child whose state has changed.  A state change is considered to be: the child terminated; the  child
       was  stopped  by  a  signal; or the child was resumed by a signal.  In the case of a terminated child, performing a
       wait allows the system to release the resources associated with the child; if a wait is  not  performed,  then  the
       terminated child remains in a "zombie" state (see NOTES below).

       If  a  child  has already changed state, then these calls return immediately.  Otherwise, they block until either a
       child changes state or a signal handler interrupts the call (assuming  that  system  calls  are  not  automatically
       restarted  using  the  SA_RESTART  flag  of  sigaction(2)).  In the remainder of this page, a child whose state has
       changed and which has not yet been waited upon by one of these system calls is termed waitable.

   wait() and waitpid()
       The wait() system call suspends execution of the calling thread until one of its  children  terminates.   The  call
       wait(&wstatus) is equivalent to:

           waitpid(-1, &wstatus, 0);

       The  waitpid()  system  call  suspends  execution of the calling thread until a child specified by pid argument has
       changed state.  By default, waitpid() waits only for terminated children, but this behavior is modifiable  via  the
       options argument, as described below.

       The value of pid can be:

       < -1   meaning wait for any child process whose process group ID is equal to the absolute value of pid.

       -1     meaning wait for any child process.

       0      meaning wait for any child process whose process group ID is equal to that of the calling process.

       > 0    meaning wait for the child whose process ID is equal to the value of pid.

       The value of options is an OR of zero or more of the following constants:

       WNOHANG     return immediately if no child has exited.

       WUNTRACED   also  return  if  a child has stopped (but not traced via ptrace(2)).  Status for traced children which
                   have stopped is provided even if this option is not specified.

       WCONTINUED (since Linux 2.6.10)
                   also return if a stopped child has been resumed by delivery of SIGCONT.

       (For Linux-only options, see below.)

       If wstatus is not NULL, wait() and waitpid() store status information in the int to which it points.  This  integer
       can  be  inspected with the following macros (which take the integer itself as an argument, not a pointer to it, as
       is done in wait() and waitpid()!):

       WIFEXITED(wstatus)
              returns true if the child terminated normally, that is, by calling exit(3) or _exit(2), or by returning from
              main().

       WEXITSTATUS(wstatus)
              returns  the exit status of the child.  This consists of the least significant 8 bits of the status argument
              that the child specified in a call to exit(3) or _exit(2) or as the  argument  for  a  return  statement  in
              main().  This macro should be employed only if WIFEXITED returned true.

       WIFSIGNALED(wstatus)
              returns true if the child process was terminated by a signal.

       WTERMSIG(wstatus)
              returns  the number of the signal that caused the child process to terminate.  This macro should be employed
              only if WIFSIGNALED returned true.

       WCOREDUMP(wstatus)
              returns true if the child produced a core dump.  This macro should be employed only if WIFSIGNALED  returned
              true.

              This  macro  is  not specified in POSIX.1-2001 and is not available on some UNIX implementations (e.g., AIX,
              SunOS).  Therefore, enclose its use inside #ifdef WCOREDUMP ... #endif.

       WIFSTOPPED(wstatus)
              returns true if the child process was stopped by delivery of a signal; this is possible only if the call was
              done using WUNTRACED or when the child is being traced (see ptrace(2)).

       WSTOPSIG(wstatus)
              returns the number of the signal which caused the child to stop.  This macro should be employed only if WIF‐
              STOPPED returned true.

       WIFCONTINUED(wstatus)
              (since Linux 2.6.10) returns true if the child process was resumed by delivery of SIGCONT.

   waitid()
       The waitid() system call (available since Linux 2.6.9) provides more precise control over which child state changes
       to wait for.

       The idtype and id arguments select the child(ren) to wait for, as follows:

       idtype == P_PID
              Wait for the child whose process ID matches id.

       idtype == P_PGID
              Wait for any child whose process group ID matches id.

       idtype == P_ALL
              Wait for any child; id is ignored.

       The child state changes to wait for are specified by ORing one or more of the following flags in options:

       WEXITED     Wait for children that have terminated.

       WSTOPPED    Wait for children that have been stopped by delivery of a signal.

       WCONTINUED  Wait for (previously stopped) children that have been resumed by delivery of SIGCONT.

       The following flags may additionally be ORed in options:

       WNOHANG     As for waitpid().

       WNOWAIT     Leave  the  child in a waitable state; a later wait call can be used to again retrieve the child status
                   information.

       Upon successful return, waitid() fills in the following fields of the siginfo_t structure pointed to by infop:

       si_pid      The process ID of the child.

       si_uid      The real user ID of the child.  (This field is not set on most other implementations.)

       si_signo    Always set to SIGCHLD.

       si_status   Either the exit status of the child, as given to _exit(2) (or exit(3)), or the signal that  caused  the
                   child  to  terminate,  stop,  or continue.  The si_code field can be used to determine how to interpret
                   this field.

       si_code     Set to one of: CLD_EXITED (child called _exit(2)); CLD_KILLED  (child  killed  by  signal);  CLD_DUMPED
                   (child  killed  by signal, and dumped core); CLD_STOPPED (child stopped by signal); CLD_TRAPPED (traced
                   child has trapped); or CLD_CONTINUED (child continued by SIGCONT).

       If WNOHANG was specified in options and there were no children in a waitable state, then waitid() returns 0 immedi‐
       ately  and  the  state of the siginfo_t structure pointed to by infop depends on the implementation.  To (portably)
       distinguish this case from that where a child was in a waitable state, zero out the si_pid field  before  the  call
       and check for a nonzero value in this field after the call returns.

       POSIX.1-2008  Technical  Corrigendum  1  (2013)  adds the requirement that when WNOHANG is specified in options and
       there were no children in a waitable state, then waitid() should zero out the si_pid and  si_signo  fields  of  the
       structure.  On Linux and other implementations that adhere to this requirement, it is not necessary to zero out the
       si_pid field before calling waitid().  However, not all implementations follow the POSIX.1  specification  on  this
       point.

RETURN VALUE
       wait(): on success, returns the process ID of the terminated child; on error, -1 is returned.

       waitpid():  on  success,  returns the process ID of the child whose state has changed; if WNOHANG was specified and
       one or more child(ren) specified by pid exist, but have not yet changed state, then 0 is returned.  On error, -1 is
       returned.

       waitid(): returns 0 on success or if WNOHANG was specified and no child(ren) specified by id has yet changed state;
       on error, -1 is returned.

       Each of these calls sets errno to an appropriate value in the case of an error.

ERRORS
       ECHILD (for wait()) The calling process does not have any unwaited-for children.

       ECHILD (for waitpid() or waitid()) The process specified by pid (waitpid()) or idtype and id  (waitid())  does  not
              exist  or  is  not  a  child of the calling process.  (This can happen for one's own child if the action for
              SIGCHLD is set to SIG_IGN.  See also the Linux Notes section about threads.)

       EINTR  WNOHANG was not set and an unblocked signal or a SIGCHLD was caught; see signal(7).

       EINVAL The options argument was invalid.

CONFORMING TO
       SVr4, 4.3BSD, POSIX.1-2001.

NOTES
       A child that terminates, but has not been waited for becomes a "zombie".  The kernel maintains  a  minimal  set  of
       information  about  the  zombie process (PID, termination status, resource usage information) in order to allow the
       parent to later perform a wait to obtain information about the child.  As long as a zombie is not removed from  the
       system via a wait, it will consume a slot in the kernel process table, and if this table fills, it will not be pos‐
       sible to create further processes.  If a parent process terminates, then its "zombie" children (if any) are adopted
       by  init(1),  (or  by  the nearest "subreaper" process as defined through the use of the prctl(2) PR_SET_CHILD_SUB‐
       REAPER operation); init(1) automatically performs a wait to remove the zombies.

       POSIX.1-2001 specifies that if the disposition of SIGCHLD is set to SIG_IGN or the SA_NOCLDWAIT  flag  is  set  for
       SIGCHLD  (see  sigaction(2)),  then children that terminate do not become zombies and a call to wait() or waitpid()
       will block until all children have terminated, and then fail with errno set to ECHILD.  (The original  POSIX  stan‐
       dard left the behavior of setting SIGCHLD to SIG_IGN unspecified.  Note that even though the default disposition of
       SIGCHLD is "ignore", explicitly setting the disposition to SIG_IGN results in different treatment of zombie process
       children.)

       Linux  2.6 conforms to the POSIX requirements.  However, Linux 2.4 (and earlier) does not: if a wait() or waitpid()
       call is made while SIGCHLD is being ignored, the call behaves just as though SIGCHLD were not being  ignored,  that
       is, the call blocks until the next child terminates and then returns the process ID and status of that child.

   Linux notes
       In  the  Linux  kernel, a kernel-scheduled thread is not a distinct construct from a process.  Instead, a thread is
       simply a process that is created using the Linux-unique clone(2) system call; other routines such as  the  portable
       pthread_create(3)  call  are  implemented  using clone(2).  Before Linux 2.4, a thread was just a special case of a
       process, and as a consequence one thread could not wait on the children of another thread,  even  when  the  latter
       belongs  to the same thread group.  However, POSIX prescribes such functionality, and since Linux 2.4 a thread can,
       and by default will, wait on children of other threads in the same thread group.

       The following Linux-specific options are for use with children created using clone(2); they can also,  since  Linux
       4.7, be used with waitid():

       __WCLONE
              Wait  for  "clone" children only.  If omitted, then wait for "non-clone" children only.  (A "clone" child is
              one which delivers no signal, or a signal other than SIGCHLD to its parent upon termination.)   This  option
              is ignored if __WALL is also specified.

       __WALL (since Linux 2.4)
              Wait for all children, regardless of type ("clone" or "non-clone").

       __WNOTHREAD (since Linux 2.4)
              Do not wait for children of other threads in the same thread group.  This was the default before Linux 2.4.

       Since Linux 4.7, the __WALL flag is automatically implied if the child is being ptraced.

   C library/kernel differences
       wait() is actually a library function that (in glibc) is implemented as a call to wait4(2).

       On  some  architectures,  there is no waitpid() system call; instead, this interface is implemented via a C library
       wrapper function that calls wait4(2).

       The raw waitid() system call takes a fifth argument, of type struct rusage *.  If this argument is  non-NULL,  then
       it  is used to return resource usage information about the child, in the same manner as wait4(2).  See getrusage(2)
       for details.

BUGS
       According to POSIX.1-2008, an application calling waitid() must ensure that infop points to a  siginfo_t  structure
       (i.e.,  that  it is a non-null pointer).  On Linux, if infop is NULL, waitid() succeeds, and returns the process ID
       of the waited-for child.  Applications should avoid relying on this inconsistent, nonstandard, and unnecessary fea‐
       ture.

EXAMPLE
       The  following  program demonstrates the use of fork(2) and waitpid().  The program creates a child process.  If no
       command-line argument is supplied to the program, then the child suspends its execution using  pause(2),  to  allow
       the  user  to  send  signals to the child.  Otherwise, if a command-line argument is supplied, then the child exits
       immediately, using the integer supplied on the command line as the exit status.  The parent process executes a loop
       that monitors the child using waitpid(), and uses the W*() macros described above to analyze the wait status value.

       The following shell session demonstrates the use of the program:

           $ ./a.out &
           Child PID is 32360
           [1] 32359
           $ kill -STOP 32360
           stopped by signal 19
           $ kill -CONT 32360
           continued
           $ kill -TERM 32360
           killed by signal 15
           [1]+  Done                    ./a.out
           $

   Program source

       #include <sys/wait.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <stdio.h>

       int
       main(int argc, char *argv[])
       {
           pid_t cpid, w;
           int wstatus;

           cpid = fork();
           if (cpid == -1) {
               perror("fork");
               exit(EXIT_FAILURE);
           }

           if (cpid == 0) {            /* Code executed by child */
               printf("Child PID is %ld\n", (long) getpid());
               if (argc == 1)
                   pause();                    /* Wait for signals */
               _exit(atoi(argv[1]));

           } else {                    /* Code executed by parent */
               do {
                   w = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);
                   if (w == -1) {
                       perror("waitpid");
                       exit(EXIT_FAILURE);
                   }

                   if (WIFEXITED(wstatus)) {
                       printf("exited, status=%d\n", WEXITSTATUS(wstatus));
                   } else if (WIFSIGNALED(wstatus)) {
                       printf("killed by signal %d\n", WTERMSIG(wstatus));
                   } else if (WIFSTOPPED(wstatus)) {
                       printf("stopped by signal %d\n", WSTOPSIG(wstatus));
                   } else if (WIFCONTINUED(wstatus)) {
                       printf("continued\n");
                   }
               } while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));
               exit(EXIT_SUCCESS);
           }
       }

SEE ALSO
       _exit(2),  clone(2),  fork(2),  kill(2),  ptrace(2),  sigaction(2), signal(2), wait4(2), pthread_create(3), creden‐
       tials(7), signal(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                                 WAIT(2)
</pre>
<pre zoom>
<span xsmall>2 bpf</span>
BPF(2)                                           Linux Programmer's Manual                                          BPF(2)

NAME
       bpf - perform a command on an extended BPF map or program

SYNOPSIS
       #include <linux/bpf.h>

       int bpf(int cmd, union bpf_attr *attr, unsigned int size);

DESCRIPTION
       The bpf() system call performs a range of operations related to extended Berkeley Packet Filters.  Extended BPF (or
       eBPF) is similar to the original ("classic") BPF (cBPF) used to filter network packets.  For  both  cBPF  and  eBPF
       programs, the kernel statically analyzes the programs before loading them, in order to ensure that they cannot harm
       the running system.

       eBPF extends cBPF in multiple ways, including the ability to call a fixed set of in-kernel  helper  functions  (via
       the BPF_CALL opcode extension provided by eBPF) and access shared data structures such as eBPF maps.

   Extended BPF Design/Architecture
       eBPF  maps  are  a generic data structure for storage of different data types.  Data types are generally treated as
       binary blobs, so a user just specifies the size of the key and the size of the  value  at  map-creation  time.   In
       other words, a key/value for a given map can have an arbitrary structure.

       A  user process can create multiple maps (with key/value-pairs being opaque bytes of data) and access them via file
       descriptors.  Different eBPF programs can access the same maps in parallel.  It's up to the user process  and  eBPF
       program to decide what they store inside maps.

       There's  one special map type, called a program array.  This type of map stores file descriptors referring to other
       eBPF programs.  When a lookup in the map is performed, the program flow is redirected in-place to the beginning  of
       another  eBPF  program  and does not return back to the calling program.  The level of nesting has a fixed limit of
       32, so that infinite loops cannot be crafted.  At run time, the program file descriptors stored in the map  can  be
       modified,  so  program  functionality can be altered based on specific requirements.  All programs referred to in a
       program-array map must have been previously loaded into the kernel via bpf().  If a map lookup fails,  the  current
       program continues its execution.  See BPF_MAP_TYPE_PROG_ARRAY below for further details.

       Generally, eBPF programs are loaded by the user process and automatically unloaded when the process exits.  In some
       cases, for example, tc-bpf(8), the program will continue to stay alive inside the kernel  even  after  the  process
       that loaded the program exits.  In that case, the tc subsystem holds a reference to the eBPF program after the file
       descriptor has been closed by the user-space program.  Thus, whether a specific program continues  to  live  inside
       the kernel depends on how it is further attached to a given kernel subsystem after it was loaded via bpf().

       Each  eBPF program is a set of instructions that is safe to run until its completion.  An in-kernel verifier stati‐
       cally determines that the eBPF program terminates and is safe to execute.  During verification, the  kernel  incre‐
       ments  reference counts for each of the maps that the eBPF program uses, so that the attached maps can't be removed
       until the program is unloaded.

       eBPF programs can be attached to different events.  These events can be the arrival  of  network  packets,  tracing
       events,  classification events by network queueing  disciplines (for eBPF programs attached to a tc(8) classifier),
       and other types that may be added in the future.  A new event triggers execution of the  eBPF  program,  which  may
       store information about the event in eBPF maps.  Beyond storing data, eBPF programs may call a fixed set of in-ker‐
       nel helper functions.

       The same eBPF program can be attached to multiple events and different eBPF programs can access the same map:

           tracing     tracing    tracing    packet      packet     packet
           event A     event B    event C    on eth0     on eth1    on eth2
            |             |         |          |           |          ^
            |             |         |          |           v          |
            --> tracing <--     tracing      socket    tc ingress   tc egress
                 prog_1          prog_2      prog_3    classifier    action
                 |  |              |           |         prog_4      prog_5
              |---  -----|  |------|          map_3        |           |
            map_1       map_2                              --| map_4 |--

   Arguments
       The operation to be performed by the bpf() system call is determined by the cmd argument.  Each operation takes  an
       accompanying  argument,  provided  via  attr, which is a pointer to a union of type bpf_attr (see below).  The size
       argument is the size of the union pointed to by attr.

       The value provided in cmd is one of the following:

       BPF_MAP_CREATE
              Create a map and return a file descriptor that refers to the map.  The close-on-exec  file  descriptor  flag
              (see fcntl(2)) is automatically enabled for the new file descriptor.

       BPF_MAP_LOOKUP_ELEM
              Look up an element by key in a specified map and return its value.

       BPF_MAP_UPDATE_ELEM
              Create or update an element (key/value pair) in a specified map.

       BPF_MAP_DELETE_ELEM
              Look up and delete an element by key in a specified map.

       BPF_MAP_GET_NEXT_KEY
              Look up an element by key in a specified map and return the key of the next element.

       BPF_PROG_LOAD
              Verify and load an eBPF program, returning a new file descriptor associated with the program.  The close-on-
              exec file descriptor flag (see fcntl(2)) is automatically enabled for the new file descriptor.

              The bpf_attr union consists of various anonymous structures that are used by different bpf() commands:

           union bpf_attr {
               struct {    /* Used by BPF_MAP_CREATE */
                   __u32         map_type;
                   __u32         key_size;    /* size of key in bytes */
                   __u32         value_size;  /* size of value in bytes */
                   __u32         max_entries; /* maximum number of entries
                                                 in a map */
               };

               struct {    /* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY
                              commands */
                   __u32         map_fd;
                   __aligned_u64 key;
                   union {
                       __aligned_u64 value;
                       __aligned_u64 next_key;
                   };
                   __u64         flags;
               };

               struct {    /* Used by BPF_PROG_LOAD */
                   __u32         prog_type;
                   __u32         insn_cnt;
                   __aligned_u64 insns;      /* 'const struct bpf_insn *' */
                   __aligned_u64 license;    /* 'const char *' */
                   __u32         log_level;  /* verbosity level of verifier */
                   __u32         log_size;   /* size of user buffer */
                   __aligned_u64 log_buf;    /* user supplied 'char *'
                                                buffer */
                   __u32         kern_version;
                                             /* checked when prog_type=kprobe
                                                (since Linux 4.1) */
               };
           } __attribute__((aligned(8)));

   eBPF maps
       Maps are a generic data structure for storage of different types of data.  They allow sharing of data between  eBPF
       kernel programs, and also between kernel and user-space applications.

       Each map type has the following attributes:

       *  type

       *  maximum number of elements

       *  key size in bytes

       *  value size in bytes

       The  following  wrapper functions demonstrate how various bpf() commands can be used to access the maps.  The func‐
       tions use the cmd argument to invoke different operations.

       BPF_MAP_CREATE
              The BPF_MAP_CREATE command creates a new map, returning a new file descriptor that refers to the map.

                  int
                  bpf_create_map(enum bpf_map_type map_type,
                                 unsigned int key_size,
                                 unsigned int value_size,
                                 unsigned int max_entries)
                  {
                      union bpf_attr attr = {
                          .map_type    = map_type,
                          .key_size    = key_size,
                          .value_size  = value_size,
                          .max_entries = max_entries
                      };

                      return bpf(BPF_MAP_CREATE, &attr, sizeof(attr));
                  }

              The new map has the type specified by map_type, and attributes as specified  in  key_size,  value_size,  and
              max_entries.   On  success, this operation returns a file descriptor.  On error, -1 is returned and errno is
              set to EINVAL, EPERM, or ENOMEM.

              The key_size and value_size attributes will be used by the verifier during program loading to check that the
              program  is calling bpf_map_*_elem() helper functions with a correctly initialized key and to check that the
              program doesn't access the map element value beyond the specified value_size.  For example, when  a  map  is
              created with a key_size of 8 and the eBPF program calls

                  bpf_map_lookup_elem(map_fd, fp - 4)

              the program will be rejected, since the in-kernel helper function

                  bpf_map_lookup_elem(map_fd, void *key)

              expects  to  read  8  bytes  from the location pointed to by key, but the fp - 4 (where fp is the top of the
              stack) starting address will cause out-of-bounds stack access.

              Similarly, when a map is created with a value_size of 1 and the eBPF program contains

                  value = bpf_map_lookup_elem(...);
                  *(u32 *) value = 1;

              the program will be rejected, since it accesses the value pointer beyond the  specified  1  byte  value_size
              limit.

              Currently, the following values are supported for map_type:

                  enum bpf_map_type {
                      BPF_MAP_TYPE_UNSPEC,  /* Reserve 0 as invalid map type */
                      BPF_MAP_TYPE_HASH,
                      BPF_MAP_TYPE_ARRAY,
                      BPF_MAP_TYPE_PROG_ARRAY,
                      BPF_MAP_TYPE_PERF_EVENT_ARRAY,
                      BPF_MAP_TYPE_PERCPU_HASH,
                      BPF_MAP_TYPE_PERCPU_ARRAY,
                      BPF_MAP_TYPE_STACK_TRACE,
                      BPF_MAP_TYPE_CGROUP_ARRAY,
                      BPF_MAP_TYPE_LRU_HASH,
                      BPF_MAP_TYPE_LRU_PERCPU_HASH,
                      BPF_MAP_TYPE_LPM_TRIE,
                      BPF_MAP_TYPE_ARRAY_OF_MAPS,
                      BPF_MAP_TYPE_HASH_OF_MAPS,
                      BPF_MAP_TYPE_DEVMAP,
                      BPF_MAP_TYPE_SOCKMAP,
                      BPF_MAP_TYPE_CPUMAP,
                  };

              map_type  selects  one of the available map implementations in the kernel.  For all map types, eBPF programs
              access maps with the same bpf_map_lookup_elem() and bpf_map_update_elem() helper functions.  Further details
              of the various map types are given below.

       BPF_MAP_LOOKUP_ELEM
              The  BPF_MAP_LOOKUP_ELEM  command  looks  up  an element with a given key in the map referred to by the file
              descriptor fd.

                  int
                  bpf_lookup_elem(int fd, const void *key, void *value)
                  {
                      union bpf_attr attr = {
                          .map_fd = fd,
                          .key    = ptr_to_u64(key),
                          .value  = ptr_to_u64(value),
                      };

                      return bpf(BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
                  }

              If an element is found, the operation returns zero and stores the element's value  into  value,  which  must
              point to a buffer of value_size bytes.

              If no element is found, the operation returns -1 and sets errno to ENOENT.

       BPF_MAP_UPDATE_ELEM
              The  BPF_MAP_UPDATE_ELEM command creates or updates an element with a given key/value in the map referred to
              by the file descriptor fd.

                  int
                  bpf_update_elem(int fd, const void *key, const void *value,
                                  uint64_t flags)
                  {
                      union bpf_attr attr = {
                          .map_fd = fd,
                          .key    = ptr_to_u64(key),
                          .value  = ptr_to_u64(value),
                          .flags  = flags,
                      };

                      return bpf(BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
                  }

              The flags argument should be specified as one of the following:

              BPF_ANY
                     Create a new element or update an existing element.

              BPF_NOEXIST
                     Create a new element only if it did not exist.

              BPF_EXIST
                     Update an existing element.

              On success, the operation returns zero.  On error, -1 is returned and errno is set to EINVAL, EPERM, ENOMEM,
              or E2BIG.  E2BIG indicates that the number of elements in the map reached the max_entries limit specified at
              map creation time.  EEXIST will be returned if flags specifies BPF_NOEXIST and the element with key  already
              exists  in  the  map.  ENOENT will be returned if flags specifies BPF_EXIST and the element with key doesn't
              exist in the map.

       BPF_MAP_DELETE_ELEM
              The BPF_MAP_DELETE_ELEM command deleted the element whose key is key from the map referred to  by  the  file
              descriptor fd.

                  int
                  bpf_delete_elem(int fd, const void *key)
                  {
                      union bpf_attr attr = {
                          .map_fd = fd,
                          .key    = ptr_to_u64(key),
                      };

                      return bpf(BPF_MAP_DELETE_ELEM, &attr, sizeof(attr));
                  }

              On success, zero is returned.  If the element is not found, -1 is returned and errno is set to ENOENT.

       BPF_MAP_GET_NEXT_KEY
              The BPF_MAP_GET_NEXT_KEY command looks up an element by key in the map referred to by the file descriptor fd
              and sets the next_key pointer to the key of the next element.

                  int
                  bpf_get_next_key(int fd, const void *key, void *next_key)
                  {
                      union bpf_attr attr = {
                          .map_fd   = fd,
                          .key      = ptr_to_u64(key),
                          .next_key = ptr_to_u64(next_key),
                      };

                      return bpf(BPF_MAP_GET_NEXT_KEY, &attr, sizeof(attr));
                  }

              If key is found, the operation returns zero and sets the next_key pointer to the key of  the  next  element.
              If  key  is not found, the operation returns zero and sets the next_key pointer to the key of the first ele‐
              ment.  If key is the last element, -1 is returned and errno is set to ENOENT.  Other possible  errno  values
              are ENOMEM, EFAULT, EPERM, and EINVAL.  This method can be used to iterate over all elements in the map.

       close(map_fd)
              Delete  the  map  referred to by the file descriptor map_fd.  When the user-space program that created a map
              exits, all maps will be deleted automatically (but see NOTES).

   eBPF map types
       The following map types are supported:

       BPF_MAP_TYPE_HASH
              Hash-table maps have the following characteristics:

              *  Maps are created and destroyed by user-space programs.  Both user-space and  eBPF  programs  can  perform
                 lookup, update, and delete operations.

              *  The kernel takes care of allocating and freeing key/value pairs.

              *  The  map_update_elem()  helper  will  fail  to  insert new element when the max_entries limit is reached.
                 (This ensures that eBPF programs cannot exhaust memory.)

              *  map_update_elem() replaces existing elements atomically.

              Hash-table maps are optimized for speed of lookup.

       BPF_MAP_TYPE_ARRAY
              Array maps have the following characteristics:

              *  Optimized for fastest possible lookup.  In the future the verifier/JIT compiler  may  recognize  lookup()
                 operations  that employ a constant key and optimize it into constant pointer.  It is possible to optimize
                 a non-constant key into direct pointer arithmetic as well, since pointers and value_size are constant for
                 the  life  of  the  eBPF  program.  In other words, array_map_lookup_elem() may be 'inlined' by the veri‐
                 fier/JIT compiler while preserving concurrent access to this map from user space.

              *  All array elements pre-allocated and zero initialized at init time

              *  The key is an array index, and must be exactly four bytes.

              *  map_delete_elem() fails with the error EINVAL, since elements cannot be deleted.

              *  map_update_elem() replaces elements in a nonatomic fashion; for atomic updates, a hash-table  map  should
                 be  used instead.  There is however one special case that can also be used with arrays: the atomic built-
                 in __sync_fetch_and_add() can be used on 32 and 64 bit atomic counters.  For example, it can  be  applied
                 on  the whole value itself if it represents a single counter, or in case of a structure containing multi‐
                 ple counters, it could be used on individual counters.  This is quite often useful  for  aggregation  and
                 accounting of events.

              Among the uses for array maps are the following:

              *  As "global" eBPF variables: an array of 1 element whose key is (index) 0 and where the value is a collec‐
                 tion of 'global' variables which eBPF programs can use to keep state between events.

              *  Aggregation of tracing events into a fixed set of buckets.

              *  Accounting of networking events, for example, number of packets and packet sizes.

       BPF_MAP_TYPE_PROG_ARRAY (since Linux 4.2)
              A program array map is a special kind of array map whose map values contain only file descriptors  referring
              to  other  eBPF  programs.   Thus, both the key_size and value_size must be exactly four bytes.  This map is
              used in conjunction with the bpf_tail_call() helper.

              This means that an eBPF program with a program array map attached to it can call from kernel side into

                  void bpf_tail_call(void *context, void *prog_map,
                                     unsigned int index);

              and therefore replace its own program flow with the one from the program at the given program array slot, if
              present.   This  can  be  regarded as kind of a jump table to a different eBPF program.  The invoked program
              will then reuse the same stack.  When a jump into the new program has been performed, it won't return to the
              old program anymore.

              If  no eBPF program is found at the given index of the program array (because the map slot doesn't contain a
              valid program file descriptor, the specified lookup index/key is out of bounds, or the limit  of  32  nested
              calls  has  been  exceed),  execution  continues with the current eBPF program.  This can be used as a fall-
              through for default cases.

              A program array map is useful, for example, in tracing or networking, to handle individual system  calls  or
              protocols  in their own subprograms and use their identifiers as an individual map index.  This approach may
              result in performance benefits, and also makes it possible to overcome the maximum instruction  limit  of  a
              single  eBPF program.  In dynamic environments, a user-space daemon might atomically replace individual sub‐
              programs at run-time with newer versions to alter overall program behavior, for instance, if global policies
              change.

   eBPF programs
       The  BPF_PROG_LOAD command is used to load an eBPF program into the kernel.  The return value for this command is a
       new file descriptor associated with this eBPF program.

           char bpf_log_buf[LOG_BUF_SIZE];

           int
           bpf_prog_load(enum bpf_prog_type type,
                         const struct bpf_insn *insns, int insn_cnt,
                         const char *license)
           {
               union bpf_attr attr = {
                   .prog_type = type,
                   .insns     = ptr_to_u64(insns),
                   .insn_cnt  = insn_cnt,
                   .license   = ptr_to_u64(license),
                   .log_buf   = ptr_to_u64(bpf_log_buf),
                   .log_size  = LOG_BUF_SIZE,
                   .log_level = 1,
               };

               return bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
           }

       prog_type is one of the available program types:

                  enum bpf_prog_type {
                      BPF_PROG_TYPE_UNSPEC,        /* Reserve 0 as invalid
                                                      program type */
                      BPF_PROG_TYPE_SOCKET_FILTER,
                      BPF_PROG_TYPE_KPROBE,
                      BPF_PROG_TYPE_SCHED_CLS,
                      BPF_PROG_TYPE_SCHED_ACT,
                  };

       For further details of eBPF program types, see below.

       The remaining fields of bpf_attr are set as follows:

       *  insns is an array of struct bpf_insn instructions.

       *  insn_cnt is the number of instructions in the program referred to by insns.

       *  license is a license string, which must be GPL compatible  to  call  helper  functions  marked  gpl_only.   (The
          licensing  rules  are the same as for kernel modules, so that also dual licenses, such as "Dual BSD/GPL", may be
          used.)

       *  log_buf is a pointer to a caller-allocated buffer in which the in-kernel verifier  can  store  the  verification
          log.   This  log is a multi-line string that can be checked by the program author in order to understand how the
          verifier came to the conclusion that the eBPF program is unsafe.  The format of the output  can  change  at  any
          time as the verifier evolves.

       *  log_size  size  of the buffer pointed to by log_buf.  If the size of the buffer is not large enough to store all
          verifier messages, -1 is returned and errno is set to ENOSPC.

       *  log_level verbosity level of the verifier.  A value of zero means that the verifier will not provide a  log;  in
          this case, log_buf must be a NULL pointer, and log_size must be zero.

       Applying close(2) to the file descriptor returned by BPF_PROG_LOAD will unload the eBPF program (but see NOTES).

       Maps  are  accessible  from eBPF programs and are used to exchange data between eBPF programs and between eBPF pro‐
       grams and user-space programs.  For example, eBPF programs can process various events (like  kprobe,  packets)  and
       store their data into a map, and user-space programs can then fetch data from the map.  Conversely, user-space pro‐
       grams can use a map as a configuration mechanism, populating the map with values checked by the eBPF program, which
       then modifies its behavior on the fly according to those values.

   eBPF program types
       The  eBPF program type (prog_type) determines the subset of kernel helper functions that the program may call.  The
       program type also determines the program input (context)—the format of struct bpf_context (which is the  data  blob
       passed into the eBPF program as the first argument).

       For  example,  a tracing program does not have the exact same subset of helper functions as a socket filter program
       (though they may have some helpers in common).  Similarly, the input (context) for a tracing program is  a  set  of
       register values, while for a socket filter it is a network packet.

       The set of functions available to eBPF programs of a given type may increase in the future.

       The following program types are supported:

       BPF_PROG_TYPE_SOCKET_FILTER (since Linux 3.19)
              Currently, the set of functions for BPF_PROG_TYPE_SOCKET_FILTER is:

                  bpf_map_lookup_elem(map_fd, void *key)
                                      /* look up key in a map_fd */
                  bpf_map_update_elem(map_fd, void *key, void *value)
                                      /* update key/value */
                  bpf_map_delete_elem(map_fd, void *key)
                                      /* delete key in a map_fd */

              The bpf_context argument is a pointer to a struct __sk_buff.

       BPF_PROG_TYPE_KPROBE (since Linux 4.1)
              [To be documented]

       BPF_PROG_TYPE_SCHED_CLS (since Linux 4.1)
              [To be documented]

       BPF_PROG_TYPE_SCHED_ACT (since Linux 4.1)
              [To be documented]

   Events
       Once a program is loaded, it can be attached to an event.  Various kernel subsystems have different ways to do so.

       Since  Linux 3.19, the following call will attach the program prog_fd to the socket sockfd, which was created by an
       earlier call to socket(2):

           setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_BPF,
                      &prog_fd, sizeof(prog_fd));

       Since Linux 4.1, the following call may be used to attach the eBPF program  referred  to  by  the  file  descriptor
       prog_fd to a perf event file descriptor, event_fd, that was created by a previous call to perf_event_open(2):

           ioctl(event_fd, PERF_EVENT_IOC_SET_BPF, prog_fd);

EXAMPLES
       /* bpf+sockets example:
        * 1. create array map of 256 elements
        * 2. load program that counts number of packets received
        *    r0 = skb->data[ETH_HLEN + offsetof(struct iphdr, protocol)]
        *    map[r0]++
        * 3. attach prog_fd to raw socket via setsockopt()
        * 4. print number of received TCP/UDP packets every second
        */
       int
       main(int argc, char **argv)
       {
           int sock, map_fd, prog_fd, key;
           long long value = 0, tcp_cnt, udp_cnt;

           map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(key),
                                   sizeof(value), 256);
           if (map_fd < 0) {
               printf("failed to create map '%s'\n", strerror(errno));
               /* likely not run as root */
               return 1;
           }

           struct bpf_insn prog[] = {
               BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),        /* r6 = r1 */
               BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol)),
                                       /* r0 = ip->proto */
               BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),
                                       /* *(u32 *)(fp - 4) = r0 */
               BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /* r2 = fp */
               BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /* r2 = r2 - 4 */
               BPF_LD_MAP_FD(BPF_REG_1, map_fd),           /* r1 = map_fd */
               BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),
                                       /* r0 = map_lookup(r1, r2) */
               BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),
                                       /* if (r0 == 0) goto pc+2 */
               BPF_MOV64_IMM(BPF_REG_1, 1),                /* r1 = 1 */
               BPF_XADD(BPF_DW, BPF_REG_0, BPF_REG_1, 0, 0),
                                       /* lock *(u64 *) r0 += r1 */
               BPF_MOV64_IMM(BPF_REG_0, 0),                /* r0 = 0 */
               BPF_EXIT_INSN(),                            /* return r0 */
           };

           prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog,
                                   sizeof(prog), "GPL");

           sock = open_raw_sock("lo");

           assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &prog_fd,
                             sizeof(prog_fd)) == 0);

           for (;;) {
               key = IPPROTO_TCP;
               assert(bpf_lookup_elem(map_fd, &key, &tcp_cnt) == 0);
               key = IPPROTO_UDP;
               assert(bpf_lookup_elem(map_fd, &key, &udp_cnt) == 0);
               printf("TCP %lld UDP %lld packets\n", tcp_cnt, udp_cnt);
               sleep(1);
           }

           return 0;
       }

       Some complete working code can be found in the samples/bpf directory in the kernel source tree.

RETURN VALUE
       For a successful call, the return value depends on the operation:

       BPF_MAP_CREATE
              The new file descriptor associated with the eBPF map.

       BPF_PROG_LOAD
              The new file descriptor associated with the eBPF program.

       All other commands
              Zero.

       On error, -1 is returned, and errno is set appropriately.

ERRORS
       E2BIG  The eBPF program is too large or a map reached the max_entries limit (maximum number of elements).

       EACCES For  BPF_PROG_LOAD, even though all program instructions are valid, the program has been rejected because it
              was deemed unsafe.  This may be because it may have accessed a disallowed memory region or an  uninitialized
              stack/register  or because the function constraints don't match the actual types or because there was a mis‐
              aligned memory access.  In this case, it is recommended to call bpf() again with log_level = 1  and  examine
              log_buf for the specific reason provided by the verifier.

       EBADF  fd is not an open file descriptor.

       EFAULT One of the pointers (key or value or log_buf or insns) is outside the accessible address space.

       EINVAL The value specified in cmd is not recognized by this kernel.

       EINVAL For BPF_MAP_CREATE, either map_type or attributes are invalid.

       EINVAL For  BPF_MAP_*_ELEM commands, some of the fields of union bpf_attr that are not used by this command are not
              set to zero.

       EINVAL For BPF_PROG_LOAD, indicates an attempt to load an invalid program.  eBPF programs can be deemed invalid due
              to  unrecognized  instructions,  the  use of reserved fields, jumps out of range, infinite loops or calls of
              unknown functions.

       ENOENT For BPF_MAP_LOOKUP_ELEM or BPF_MAP_DELETE_ELEM, indicates that the element with the given key was not found.

       ENOMEM Cannot allocate sufficient memory.

       EPERM  The call was made without sufficient privilege (without the CAP_SYS_ADMIN capability).

VERSIONS
       The bpf() system call first appeared in Linux 3.18.

CONFORMING TO
       The bpf() system call is Linux-specific.

NOTES
       In the current implementation, all bpf() commands require the caller to have the CAP_SYS_ADMIN capability.

       eBPF objects (maps and programs) can be shared between processes.  For example, after fork(2), the  child  inherits
       file  descriptors  referring to the same eBPF objects.  In addition, file descriptors referring to eBPF objects can
       be transferred over UNIX domain sockets.  File descriptors referring to eBPF objects can be duplicated in the usual
       way,  using  dup(2)  and similar calls.  An eBPF object is deallocated only after all file descriptors referring to
       the object have been closed.

       eBPF programs can be written in a restricted C that is compiled (using the  clang  compiler)  into  eBPF  bytecode.
       Various features are omitted from this restricted C, such as loops, global variables, variadic functions, floating-
       point  numbers,  and  passing  structures  as  function  arguments.   Some  examples  can  be  found  in  the  sam‐
       ples/bpf/*_kern.c files in the kernel source tree.

       The kernel contains a just-in-time (JIT) compiler that translates eBPF bytecode into native machine code for better
       performance.  In kernels before Linux 4.15, the JIT compiler is disabled by default, but its operation can be  con‐
       trolled by writing one of the following integer strings to the file /proc/sys/net/core/bpf_jit_enable:

       0  Disable JIT compilation (default).

       1  Normal compilation.

       2  Debugging mode.  The generated opcodes are dumped in hexadecimal into the kernel log.  These opcodes can then be
          disassembled using the program tools/net/bpf_jit_disasm.c provided in the kernel source tree.

       Since Linux 4.15, the kernel may configured with the CONFIG_BPF_JIT_ALWAYS_ON option.  In this case, the  JIT  com‐
       piler  is  always enabled, and the bpf_jit_enable is initialized to 1 and is immutable.  (This kernel configuration
       option was provided as a mitigation for one of the Spectre attacks against the BPF interpreter.)

       The JIT compiler for eBPF is currently available for the following architectures:

       *  x86-64 (since Linux 3.18);
       *  ARM-64 (since Linux 3.18);
       *  s390 (since Linux 4.1);
       *  PowerPC 64 (since Linux 4.8);
       *  SPARC 64 (since Linux 4.12);
       *  MIPS (since Linux 4.13);
       *  ARM32 (since Linux 4.14).

SEE ALSO
       seccomp(2), socket(7), tc(8), tc-bpf(8)

       Both classic and extended BPF are explained in the kernel source file Documentation/networking/filter.txt.

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-02-02                                                  BPF(2)
</pre>
<pre zoom>
<span xsmall>2 fstatfs64</span>
STATFS(2)                                        Linux Programmer's Manual                                       STATFS(2)

NAME
       statfs, fstatfs - get filesystem statistics

SYNOPSIS
       #include <sys/vfs.h>    /* or <sys/statfs.h> */

       int statfs(const char *path, struct statfs *buf);
       int fstatfs(int fd, struct statfs *buf);

DESCRIPTION
       The  statfs()  system call returns information about a mounted filesystem.  path is the pathname of any file within
       the mounted filesystem.  buf is a pointer to a statfs structure defined approximately as follows:

           struct statfs {
               __fsword_t f_type;    /* Type of filesystem (see below) */
               __fsword_t f_bsize;   /* Optimal transfer block size */
               fsblkcnt_t f_blocks;  /* Total data blocks in filesystem */
               fsblkcnt_t f_bfree;   /* Free blocks in filesystem */
               fsblkcnt_t f_bavail;  /* Free blocks available to
                                        unprivileged user */
               fsfilcnt_t f_files;   /* Total file nodes in filesystem */
               fsfilcnt_t f_ffree;   /* Free file nodes in filesystem */
               fsid_t     f_fsid;    /* Filesystem ID */
               __fsword_t f_namelen; /* Maximum length of filenames */
               __fsword_t f_frsize;  /* Fragment size (since Linux 2.6) */
               __fsword_t f_flags;   /* Mount flags of filesystem
                                        (since Linux 2.6.36) */
               __fsword_t f_spare[xxx];
                               /* Padding bytes reserved for future use */
           };

       The following filesystem types may appear in f_type:

           ADFS_SUPER_MAGIC      0xadf5
           AFFS_SUPER_MAGIC      0xadff
           AFS_SUPER_MAGIC       0x5346414f
           ANON_INODE_FS_MAGIC   0x09041934 /* Anonymous inode FS (for
                                               pseudofiles that have no name;
                                               e.g., epoll, signalfd, bpf) */
           AUTOFS_SUPER_MAGIC    0x0187
           BDEVFS_MAGIC          0x62646576
           BEFS_SUPER_MAGIC      0x42465331
           BFS_MAGIC             0x1badface
           BINFMTFS_MAGIC        0x42494e4d
           BPF_FS_MAGIC          0xcafe4a11
           BTRFS_SUPER_MAGIC     0x9123683e
           BTRFS_TEST_MAGIC      0x73727279
           CGROUP_SUPER_MAGIC    0x27e0eb   /* Cgroup pseudo FS */
           CGROUP2_SUPER_MAGIC   0x63677270 /* Cgroup v2 pseudo FS */
           CIFS_MAGIC_NUMBER     0xff534d42
           CODA_SUPER_MAGIC      0x73757245
           COH_SUPER_MAGIC       0x012ff7b7
           CRAMFS_MAGIC          0x28cd3d45
           DEBUGFS_MAGIC         0x64626720
           DEVFS_SUPER_MAGIC     0x1373     /* Linux 2.6.17 and earlier */
           DEVPTS_SUPER_MAGIC    0x1cd1
           ECRYPTFS_SUPER_MAGIC  0xf15f
           EFIVARFS_MAGIC        0xde5e81e4
           EFS_SUPER_MAGIC       0x00414a53
           EXT_SUPER_MAGIC       0x137d     /* Linux 2.0 and earlier */
           EXT2_OLD_SUPER_MAGIC  0xef51
           EXT2_SUPER_MAGIC      0xef53
           EXT3_SUPER_MAGIC      0xef53
           EXT4_SUPER_MAGIC      0xef53
           F2FS_SUPER_MAGIC      0xf2f52010
           FUSE_SUPER_MAGIC      0x65735546
           FUTEXFS_SUPER_MAGIC   0xbad1dea  /* Unused */
           HFS_SUPER_MAGIC       0x4244
           HOSTFS_SUPER_MAGIC    0x00c0ffee
           HPFS_SUPER_MAGIC      0xf995e849
           HUGETLBFS_MAGIC       0x958458f6
           ISOFS_SUPER_MAGIC     0x9660
           JFFS2_SUPER_MAGIC     0x72b6
           JFS_SUPER_MAGIC       0x3153464a
           MINIX_SUPER_MAGIC     0x137f     /* original minix FS */
           MINIX_SUPER_MAGIC2    0x138f     /* 30 char minix FS */
           MINIX2_SUPER_MAGIC    0x2468     /* minix V2 FS */
           MINIX2_SUPER_MAGIC2   0x2478     /* minix V2 FS, 30 char names */
           MINIX3_SUPER_MAGIC    0x4d5a     /* minix V3 FS, 60 char names */
           MQUEUE_MAGIC          0x19800202 /* POSIX message queue FS */
           MSDOS_SUPER_MAGIC     0x4d44
           MTD_INODE_FS_MAGIC    0x11307854
           NCP_SUPER_MAGIC       0x564c
           NFS_SUPER_MAGIC       0x6969
           NILFS_SUPER_MAGIC     0x3434
           NSFS_MAGIC            0x6e736673
           NTFS_SB_MAGIC         0x5346544e
           OCFS2_SUPER_MAGIC     0x7461636f
           OPENPROM_SUPER_MAGIC  0x9fa1
           OVERLAYFS_SUPER_MAGIC 0x794c7630
           PIPEFS_MAGIC          0x50495045
           PROC_SUPER_MAGIC      0x9fa0     /* /proc FS */
           PSTOREFS_MAGIC        0x6165676c
           QNX4_SUPER_MAGIC      0x002f
           QNX6_SUPER_MAGIC      0x68191122
           RAMFS_MAGIC           0x858458f6
           REISERFS_SUPER_MAGIC  0x52654973
           ROMFS_MAGIC           0x7275
           SECURITYFS_MAGIC      0x73636673
           SELINUX_MAGIC         0xf97cff8c
           SMACK_MAGIC           0x43415d53
           SMB_SUPER_MAGIC       0x517b
           SOCKFS_MAGIC          0x534f434b
           SQUASHFS_MAGIC        0x73717368
           SYSFS_MAGIC           0x62656572
           SYSV2_SUPER_MAGIC     0x012ff7b6
           SYSV4_SUPER_MAGIC     0x012ff7b5
           TMPFS_MAGIC           0x01021994
           TRACEFS_MAGIC         0x74726163
           UDF_SUPER_MAGIC       0x15013346
           UFS_MAGIC             0x00011954
           USBDEVICE_SUPER_MAGIC 0x9fa2
           V9FS_MAGIC            0x01021997
           VXFS_SUPER_MAGIC      0xa501fcf5
           XENFS_SUPER_MAGIC     0xabba1974
           XENIX_SUPER_MAGIC     0x012ff7b4
           XFS_SUPER_MAGIC       0x58465342
           _XIAFS_SUPER_MAGIC    0x012fd16d /* Linux 2.0 and earlier */

       Most of these MAGIC constants are defined in /usr/include/linux/magic.h, and some are hardcoded in kernel sources.

       The f_flags field is a bit mask indicating mount options for the filesystem.  It contains zero or more of the  fol‐
       lowing bits:

       ST_MANDLOCK
              Mandatory locking is permitted on the filesystem (see fcntl(2)).

       ST_NOATIME
              Do not update access times; see mount(2).

       ST_NODEV
              Disallow access to device special files on this filesystem.

       ST_NODIRATIME
              Do not update directory access times; see mount(2).

       ST_NOEXEC
              Execution of programs is disallowed on this filesystem.

       ST_NOSUID
              The set-user-ID and set-group-ID bits are ignored by exec(3) for executable files on this filesystem

       ST_RDONLY
              This filesystem is mounted read-only.

       ST_RELATIME
              Update atime relative to mtime/ctime; see mount(2).

       ST_SYNCHRONOUS
              Writes are synched to the filesystem immediately (see the description of O_SYNC in open(2)).

       Nobody knows what f_fsid is supposed to contain (but see below).

       Fields that are undefined for a particular filesystem are set to 0.

       fstatfs() returns the same information about an open file referenced by descriptor fd.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES (statfs())  Search  permission is denied for a component of the path prefix of path.  (See also path_resolu‐
              tion(7).)

       EBADF  (fstatfs()) fd is not a valid open file descriptor.

       EFAULT buf or path points to an invalid address.

       EINTR  The call was interrupted by a signal; see signal(7).

       EIO    An I/O error occurred while reading from the filesystem.

       ELOOP  (statfs()) Too many symbolic links were encountered in translating path.

       ENAMETOOLONG
              (statfs()) path is too long.

       ENOENT (statfs()) The file referred to by path does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOSYS The filesystem does not support this call.

       ENOTDIR
              (statfs()) A component of the path prefix of path is not a directory.

       EOVERFLOW
              Some values were too large to be represented in the returned struct.

CONFORMING TO
       Linux-specific.  The Linux statfs() was inspired by the 4.4BSD one (but they do not use the same structure).

NOTES
       The __fsword_t type used for various fields in the statfs structure  definition  is  a  glibc  internal  type,  not
       intended  for  public use.  This leaves the programmer in a bit of a conundrum when trying to copy or compare these
       fields to local variables in a program.  Using unsigned int for such variables suffices on most systems.

       The original Linux statfs() and fstatfs() system calls were not designed with extremely large file sizes  in  mind.
       Subsequently,  Linux  2.6  added new statfs64() and fstatfs64() system calls that employ a new structure, statfs64.
       The new structure contains the same fields as the original statfs structure, but the sizes of  various  fields  are
       increased,  to accommodate large file sizes.  The glibc statfs() and fstatfs() wrapper functions transparently deal
       with the kernel differences.

       Some systems have only <sys/vfs.h>, other systems also have <sys/statfs.h>, where the former includes  the  latter.
       So it seems including the former is the best choice.

       LSB has deprecated the library calls statfs() and fstatfs() and tells us to use statvfs(2) and fstatvfs(2) instead.

   The f_fsid field
       Solaris,  Irix  and  POSIX have a system call statvfs(2) that returns a struct statvfs (defined in <sys/statvfs.h>)
       containing an unsigned long f_fsid.  Linux, SunOS, HP-UX, 4.4BSD have a system call statfs() that returns a  struct
       statfs (defined in <sys/vfs.h>) containing a fsid_t f_fsid, where fsid_t is defined as struct { int val[2]; }.  The
       same holds for FreeBSD, except that it uses the include file <sys/mount.h>.

       The general idea is that f_fsid contains some random stuff such that the pair (f_fsid,ino)  uniquely  determines  a
       file.   Some  operating  systems  use  (a  variation  on) the device number, or the device number combined with the
       filesystem type.  Several operating systems restrict giving out the f_fsid field to the superuser only (and zero it
       for unprivileged users), because this field is used in the filehandle of the filesystem when NFS-exported, and giv‐
       ing it out is a security concern.

       Under some operating systems, the fsid can be used as the second argument to the sysfs(2) system call.

BUGS
       From Linux 2.6.38 up to and including Linux 3.1, fstatfs() failed with the error ENOSYS for file  descriptors  cre‐
       ated by pipe(2).

SEE ALSO
       stat(2), statvfs(3), path_resolution(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               STATFS(2)
</pre>
<pre zoom>
<span xsmall>2 splice</span>
SPLICE(2)                                        Linux Programmer's Manual                                       SPLICE(2)

NAME
       splice - splice data to/from a pipe

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <fcntl.h>

       ssize_t splice(int fd_in, loff_t *off_in, int fd_out,
                      loff_t *off_out, size_t len, unsigned int flags);

DESCRIPTION
       splice()  moves  data  between  two  file descriptors without copying between kernel address space and user address
       space.  It transfers up to len bytes of data from the file descriptor fd_in to the file  descriptor  fd_out,  where
       one of the file descriptors must refer to a pipe.

       The following semantics apply for fd_in and off_in:

       *  If fd_in refers to a pipe, then off_in must be NULL.

       *  If fd_in does not refer to a pipe and off_in is NULL, then bytes are read from fd_in starting from the file off‐
          set, and the file offset is adjusted appropriately.

       *  If fd_in does not refer to a pipe and off_in is not NULL, then off_in must point to a buffer which specifies the
          starting offset from which bytes will be read from fd_in; in this case, the file offset of fd_in is not changed.

       Analogous statements apply for fd_out and off_out.

       The flags argument is a bit mask that is composed by ORing together zero or more of the following values:

       SPLICE_F_MOVE
              Attempt  to  move pages instead of copying.  This is only a hint to the kernel: pages may still be copied if
              the kernel cannot move the pages from the pipe, or if the pipe buffers don't refer to full pages.  The  ini‐
              tial  implementation  of this flag was buggy: therefore starting in Linux 2.6.21 it is a no-op (but is still
              permitted in a splice() call); in the future, a correct implementation may be restored.

       SPLICE_F_NONBLOCK
              Do not block on I/O.  This makes the splice pipe operations nonblocking, but splice() may nevertheless block
              because the file descriptors that are spliced to/from may block (unless they have the O_NONBLOCK flag set).

       SPLICE_F_MORE
              More  data will be coming in a subsequent splice.  This is a helpful hint when the fd_out refers to a socket
              (see also the description of MSG_MORE in send(2), and the description of TCP_CORK in tcp(7)).

       SPLICE_F_GIFT
              Unused for splice(); see vmsplice(2).

RETURN VALUE
       Upon successful completion, splice() returns the number of bytes spliced to or from the pipe.

       A return value of 0 means end of input.  If fd_in refers to a pipe, then this means  that  there  was  no  data  to
       transfer, and it would not make sense to block because there are no writers connected to the write end of the pipe.

       On error, splice() returns -1 and errno is set to indicate the error.

ERRORS
       EAGAIN SPLICE_F_NONBLOCK was specified in flags, and the operation would block.

       EBADF  One or both file descriptors are not valid, or do not have proper read-write mode.

       EINVAL The target filesystem doesn't support splicing.

       EINVAL The target file is opened in append mode.

       EINVAL Neither of the file descriptors refers to a pipe.

       EINVAL An offset was given for nonseekable device (e.g., a pipe).

       EINVAL fd_in and fd_out refer to the same pipe.

       ENOMEM Out of memory.

       ESPIPE Either off_in or off_out was not NULL, but the corresponding file descriptor refers to a pipe.

VERSIONS
       The splice() system call first appeared in Linux 2.6.17; library support was added to glibc in version 2.5.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       The  three  system  calls  splice(), vmsplice(2), and tee(2), provide user-space programs with full control over an
       arbitrary kernel buffer, implemented within the kernel using the same type of buffer that is used for a  pipe.   In
       overview, these system calls perform the following tasks:

       splice()    moves  data  from  the  buffer  to  an  arbitrary file descriptor, or vice versa, or from one buffer to
                   another.

       tee(2)      "copies" the data from one buffer to another.

       vmsplice(2) "copies" data from user space into the buffer.

       Though we talk of copying, actual copies are generally avoided.  The kernel does this by implementing a pipe buffer
       as a set of reference-counted pointers to pages of kernel memory.  The kernel creates "copies" of pages in a buffer
       by creating new pointers (for the output buffer) referring to the pages, and increasing the  reference  counts  for
       the pages: only pointers are copied, not the pages of the buffer.

       In  Linux  2.6.30 and earlier, exactly one of fd_in and fd_out was required to be a pipe.  Since Linux 2.6.31, both
       arguments may refer to pipes.

EXAMPLE
       See tee(2).

SEE ALSO
       copy_file_range(2), sendfile(2), tee(2), vmsplice(2), pipe(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               SPLICE(2)
</pre>
<pre zoom>
<span xsmall>2 subpage_prot</span>
SUBPAGE_PROT(2)                                  Linux Programmer's Manual                                 SUBPAGE_PROT(2)

NAME
       subpage_prot - define a subpage protection for an address range

SYNOPSIS
       long subpage_prot(unsigned long addr, unsigned long len,
                         uint32_t *map);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       The PowerPC-specific subpage_prot() system call provides the facility to control the access permissions on individ‐
       ual 4 kB subpages on systems configured with a page size of 64 kB.

       The protection map is applied to the memory pages in the region starting at addr  and  continuing  for  len  bytes.
       Both of these arguments must be aligned to a 64-kB boundary.

       The  protection  map  is specified in the buffer pointed to by map.  The map has 2 bits per 4 kB subpage; thus each
       32-bit word specifies the protections of 16 4 kB subpages inside a 64 kB page  (so,  the  number  of  32-bit  words
       pointed to by map should equate to the number of 64-kB pages specified by len).  Each 2-bit field in the protection
       map is either 0 to allow any access, 1 to prevent writes, or 2 or 3 to prevent all accesses.

RETURN VALUE
       On success, subpage_prot() returns 0.  Otherwise, one of the error codes specified below is returned.

ERRORS
       EFAULT The buffer referred to by map is not accessible.

       EINVAL The addr or len arguments are incorrect.  Both of these arguments must be aligned to a multiple of the  sys‐
              tem  page  size,  and  they  must  not refer to a region outside of the address space of the process or to a
              region that consists of huge pages.

       ENOMEM Out of memory.

VERSIONS
       This system call is provided on the PowerPC architecture since Linux 2.6.25.  The system call is provided  only  if
       the kernel is configured with CONFIG_PPC_64K_PAGES.  No library support is provided.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       Glibc does not provide a wrapper for this system call; call it using syscall(2).

       Normal  page  protections  (at  the 64-kB page level) also apply; the subpage protection mechanism is an additional
       constraint, so putting 0 in a 2-bit field won't allow writes to a page that is otherwise write-protected.

   Rationale
       This system call is provided to assist writing emulators that operate using 64-kB pages on PowerPC  systems.   When
       emulating systems such as x86, which uses a smaller page size, the emulator can no longer use the memory-management
       unit (MMU) and normal system calls for controlling page protections.  (The emulator could emulate the MMU by check‐
       ing and possibly remapping the address for each memory access in software, but that is slow.)  The idea is that the
       emulator supplies an array of protection masks to apply to a specified range of virtual addresses.  These masks are
       applied  at  the  level where hardware page-table entries (PTEs) are inserted into the hardware page table based on
       the Linux PTEs, so the Linux PTEs are not affected.  Implicit in this is that the regions of the address space that
       are  protected  are switched to use 4-kB hardware pages rather than 64-kB hardware pages (on machines with hardware
       64-kB page support).

SEE ALSO
       mprotect(2), syscall(2)

       Documentation/vm/hugetlbpage.txt in the Linux kernel source tree

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                         SUBPAGE_PROT(2)
</pre>
<pre zoom>
<span xsmall>2 readlinkat</span>
READLINK(2)                                      Linux Programmer's Manual                                     READLINK(2)

NAME
       readlink, readlinkat - read value of a symbolic link

SYNOPSIS
       #include <unistd.h>

       ssize_t readlink(const char *pathname, char *buf, size_t bufsiz);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <unistd.h>

       ssize_t readlinkat(int dirfd, const char *pathname,
                          char *buf, size_t bufsiz);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       readlink():
           _XOPEN_SOURCE >= 500 || _POSIX_C_SOURCE >= 200112L
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

       readlinkat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       readlink()  places the contents of the symbolic link pathname in the buffer buf, which has size bufsiz.  readlink()
       does not append a null byte to buf.  It will (silently) truncate the contents (to a length of  bufsiz  characters),
       in case the buffer is too small to hold all of the contents.

   readlinkat()
       The  readlinkat()  system call operates in exactly the same way as readlink(), except for the differences described
       here.

       If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by  the
       file  descriptor dirfd (rather than relative to the current working directory of the calling process, as is done by
       readlink() for a relative pathname).

       If pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the  cur‐
       rent working directory of the calling process (like readlink()).

       If pathname is absolute, then dirfd is ignored.

       Since  Linux 2.6.39, pathname can be an empty string, in which case the call operates on the symbolic link referred
       to by dirfd (which should have been obtained using open(2) with the O_PATH and O_NOFOLLOW flags).

       See openat(2) for an explanation of the need for readlinkat().

RETURN VALUE
       On success, these calls return the number of bytes placed in buf.  (If the returned value equals bufsiz, then trun‐
       cation may have occurred.)  On error, -1 is returned and errno is set to indicate the error.

ERRORS
       EACCES Search permission is denied for a component of the path prefix.  (See also path_resolution(7).)

       EFAULT buf extends outside the process's allocated address space.

       EINVAL bufsiz is not positive.

       EINVAL The named file (i.e., the final filename component of pathname) is not a symbolic link.

       EIO    An I/O error occurred while reading from the filesystem.

       ELOOP  Too many symbolic links were encountered in translating the pathname.

       ENAMETOOLONG
              A pathname, or a component of a pathname, was too long.

       ENOENT The named file does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of the path prefix is not a directory.

       The following additional errors can occur for readlinkat():

       EBADF  dirfd is not a valid file descriptor.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       readlinkat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       readlink(): 4.4BSD (readlink() first appeared in 4.2BSD), POSIX.1-2001, POSIX.1-2008.

       readlinkat(): POSIX.1-2008.

NOTES
       In  versions  of glibc up to and including glibc 2.4, the return type of readlink() was declared as int.  Nowadays,
       the return type is declared as ssize_t, as (newly) required in POSIX.1-2001.

       Using a statically sized buffer might not provide enough room for the symbolic link contents.   The  required  size
       for  the  buffer  can be obtained from the stat.st_size value returned by a call to lstat(2) on the link.  However,
       the number of bytes written by readlink() and readlinkat() should be checked to make sure that the size of the sym‐
       bolic  link  did not increase between the calls.  Dynamically allocating the buffer for readlink() and readlinkat()
       also addresses a common portability problem when using PATH_MAX for the buffer size, as this constant is not  guar‐
       anteed to be defined per POSIX if the system does not have such limit.

   Glibc notes
       On older kernels where readlinkat() is unavailable, the glibc wrapper function falls back to the use of readlink().
       When pathname is a relative pathname, glibc constructs a pathname based on the symbolic link in /proc/self/fd  that
       corresponds to the dirfd argument.

EXAMPLE
       The  following  program  allocates  the  buffer  needed  by readlink() dynamically from the information provided by
       lstat(2), falling back to a buffer of size PATH_MAX in cases where lstat(2) reports a size of zero.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <limits.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;
           char *buf;
           ssize_t nbytes, bufsiz;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           /* Add one to the link size, so that we can determine whether
              the buffer returned by readlink() was truncated. */

           bufsiz = sb.st_size + 1;

           /* Some magic symlinks under (for example) /proc and /sys
              report 'st_size' as zero. In that case, take PATH_MAX as
              a "good enough" estimate. */

           if (sb.st_size == 0)
               bufsiz = PATH_MAX;

           buf = malloc(bufsiz);
           if (buf == NULL) {
               perror("malloc");
               exit(EXIT_FAILURE);
           }

           nbytes = readlink(argv[1], buf, bufsiz);
           if (nbytes == -1) {
               perror("readlink");
               exit(EXIT_FAILURE);
           }

           printf("'%s' points to '%.*s'\n", argv[1], (int) nbytes, buf);

           /* If the return value was equal to the buffer size, then the
              the link target was larger than expected (perhaps because the
              target was changed between the call to lstat() and the call to
              readlink()). Warn the user that the returned target may have
              been truncated. */

           if (nbytes == bufsiz)
               printf("(Returned buffer may have been truncated)\n");

           free(buf);
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       readlink(1), lstat(2), stat(2), symlink(2), realpath(3), path_resolution(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             READLINK(2)
</pre>
<pre zoom>
<span xsmall>2 prlimit</span>
GETRLIMIT(2)                                     Linux Programmer's Manual                                    GETRLIMIT(2)

NAME
       getrlimit, setrlimit, prlimit - get/set resource limits

SYNOPSIS
       #include <sys/time.h>
       #include <sys/resource.h>

       int getrlimit(int resource, struct rlimit *rlim);
       int setrlimit(int resource, const struct rlimit *rlim);

       int prlimit(pid_t pid, int resource, const struct rlimit *new_limit,
                   struct rlimit *old_limit);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       prlimit(): _GNU_SOURCE

DESCRIPTION
       The  getrlimit() and setrlimit() system calls get and set resource limits respectively.  Each resource has an asso‐
       ciated soft and hard limit, as defined by the rlimit structure:

           struct rlimit {
               rlim_t rlim_cur;  /* Soft limit */
               rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
           };

       The soft limit is the value that the kernel enforces for the corresponding resource.  The  hard  limit  acts  as  a
       ceiling  for  the soft limit: an unprivileged process may set only its soft limit to a value in the range from 0 up
       to the hard limit, and (irreversibly) lower its hard limit.  A  privileged  process  (under  Linux:  one  with  the
       CAP_SYS_RESOURCE capability in the initial user namespace) may make arbitrary changes to either limit value.

       The  value  RLIM_INFINITY  denotes no limit on a resource (both in the structure returned by getrlimit() and in the
       structure passed to setrlimit()).

       The resource argument must be one of:

       RLIMIT_AS
              This is the maximum size of the process's virtual memory (address space).  The limit is specified in  bytes,
              and  is  rounded  down to the system page size.  This limit affects calls to brk(2), mmap(2), and mremap(2),
              which fail with the error ENOMEM upon exceeding this limit.  In addition, automatic  stack  expansion  fails
              (and  generates  a  SIGSEGV that kills the process if no alternate stack has been made available via sigalt‐
              stack(2)).  Since the value is a long, on machines with a 32-bit long either this limit is at most 2 GiB, or
              this resource is unlimited.

       RLIMIT_CORE
              This  is  the  maximum size of a core file (see core(5)) in bytes that the process may dump.  When 0 no core
              dump files are created.  When nonzero, larger dumps are truncated to this size.

       RLIMIT_CPU
              This is a limit, in seconds, on the amount of CPU time that the  process  can  consume.   When  the  process
              reaches the soft limit, it is sent a SIGXCPU signal.  The default action for this signal is to terminate the
              process.  However, the signal can be caught, and the handler can return control to the main program.  If the
              process  continues  to  consume  CPU  time,  it will be sent SIGXCPU once per second until the hard limit is
              reached, at which time it is sent SIGKILL.  (This latter point describes  Linux  behavior.   Implementations
              vary in how they treat processes which continue to consume CPU time after reaching the soft limit.  Portable
              applications that need to catch this signal should perform an orderly  termination  upon  first  receipt  of
              SIGXCPU.)

       RLIMIT_DATA
              This  is  the  maximum  size of the process's data segment (initialized data, uninitialized data, and heap).
              The limit is specified in bytes, and is rounded down to the system page size.  This limit affects  calls  to
              brk(2),  sbrk(2), and (since Linux 4.7) mmap(2), which fail with the error ENOMEM upon encountering the soft
              limit of this resource.

       RLIMIT_FSIZE
              This is the maximum size in bytes of files that the process may create.  Attempts to extend  a  file  beyond
              this  limit  result  in  delivery  of a SIGXFSZ signal.  By default, this signal terminates a process, but a
              process can catch this signal instead, in which case the relevant system call (e.g., write(2),  truncate(2))
              fails with the error EFBIG.

       RLIMIT_LOCKS (early Linux 2.4 only)
              This  is  a  limit on the combined number of flock(2) locks and fcntl(2) leases that this process may estab‐
              lish.

       RLIMIT_MEMLOCK
              This is the maximum number of bytes of memory that may be locked into RAM.  This limit is in effect  rounded
              down  to  the  nearest  multiple of the system page size.  This limit affects mlock(2), mlockall(2), and the
              mmap(2) MAP_LOCKED operation.  Since Linux 2.6.9, it also affects the shmctl(2) SHM_LOCK operation, where it
              sets  a  maximum on the total bytes in shared memory segments (see shmget(2)) that may be locked by the real
              user ID of the calling process.  The shmctl(2) SHM_LOCK locks are accounted for  separately  from  the  per-
              process  memory locks established by mlock(2), mlockall(2), and mmap(2) MAP_LOCKED; a process can lock bytes
              up to this limit in each of these two categories.

              In Linux kernels before 2.6.9, this limit controlled the amount of memory that could be locked by  a  privi‐
              leged  process.   Since  Linux 2.6.9, no limits are placed on the amount of memory that a privileged process
              may lock, and this limit instead governs the amount of memory that an unprivileged process may lock.

       RLIMIT_MSGQUEUE (since Linux 2.6.8)
              This is a limit on the number of bytes that can be allocated for POSIX message queues for the real  user  ID
              of  the  calling  process.  This limit is enforced for mq_open(3).  Each message queue that the user creates
              counts (until it is removed) against this limit according to the formula:

                  Since Linux 3.5:

                      bytes = attr.mq_maxmsg * sizeof(struct msg_msg) +
                              min(attr.mq_maxmsg, MQ_PRIO_MAX) *
                                    sizeof(struct posix_msg_tree_node)+
                                              /* For overhead */
                              attr.mq_maxmsg * attr.mq_msgsize;
                                              /* For message data */

                  Linux 3.4 and earlier:

                      bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +
                                              /* For overhead */
                              attr.mq_maxmsg * attr.mq_msgsize;
                                              /* For message data */

              where attr is the mq_attr structure specified as the fourth argument to  mq_open(3),  and  the  msg_msg  and
              posix_msg_tree_node structures are kernel-internal structures.

              The  "overhead" addend in the formula accounts for overhead bytes required by the implementation and ensures
              that the user cannot create an unlimited number of zero-length messages  (such  messages  nevertheless  each
              consume some system memory for bookkeeping overhead).

       RLIMIT_NICE (since Linux 2.6.12, but see BUGS below)
              This  specifies  a  ceiling to which the process's nice value can be raised using setpriority(2) or nice(2).
              The actual ceiling for the nice value is calculated as 20 - rlim_cur.  The useful range for  this  limit  is
              thus  from  1  (corresponding  to  a  nice  value of 19) to 40 (corresponding to a nice value of -20).  This
              unusual choice of range was necessary because negative numbers cannot be specified as resource limit values,
              since  they  typically  have special meanings.  For example, RLIM_INFINITY typically is the same as -1.  For
              more detail on the nice value, see sched(7).

       RLIMIT_NOFILE
              This specifies a value one greater than the maximum file descriptor  number  that  can  be  opened  by  this
              process.  Attempts (open(2), pipe(2), dup(2), etc.)  to exceed this limit yield the error EMFILE.  (Histori‐
              cally, this limit was named RLIMIT_OFILE on BSD.)

              Since Linux 4.5, this limit also defines the maximum number of file descriptors that an unprivileged process
              (one  without  the  CAP_SYS_RESOURCE  capability)  may  have "in flight" to other processes, by being passed
              across UNIX domain sockets.  This limit applies to the sendmsg(2) system call.   For  further  details,  see
              unix(7).

       RLIMIT_NPROC
              This  is a limit on the number of extant process (or, more precisely on Linux, threads) for the real user ID
              of the calling process.  So long as the current number of processes belonging to this process's real user ID
              is greater than or equal to this limit, fork(2) fails with the error EAGAIN.

              The  RLIMIT_NPROC  limit  is  not  enforced  for  processes  that  have  either  the  CAP_SYS_ADMIN  or  the
              CAP_SYS_RESOURCE capability.

       RLIMIT_RSS
              This is a limit (in bytes) on the process's resident set (the number of  virtual  pages  resident  in  RAM).
              This  limit  has  effect  only in Linux 2.4.x, x < 30, and there affects only calls to madvise(2) specifying
              MADV_WILLNEED.

       RLIMIT_RTPRIO (since Linux 2.6.12, but see BUGS)
              This specifies a ceiling on the real-time priority that may be set for this  process  using  sched_setsched‐
              uler(2) and sched_setparam(2).

              For further details on real-time scheduling policies, see sched(7)

       RLIMIT_RTTIME (since Linux 2.6.25)
              This  is  a  limit  (in  microseconds)  on the amount of CPU time that a process scheduled under a real-time
              scheduling policy may consume without making a blocking system call.  For the purpose of  this  limit,  each
              time  a  process makes a blocking system call, the count of its consumed CPU time is reset to zero.  The CPU
              time count is not reset if the process continues trying to use the CPU but  is  preempted,  its  time  slice
              expires, or it calls sched_yield(2).

              Upon  reaching the soft limit, the process is sent a SIGXCPU signal.  If the process catches or ignores this
              signal and continues consuming CPU time, then SIGXCPU will be generated once  each  second  until  the  hard
              limit is reached, at which point the process is sent a SIGKILL signal.

              The intended use of this limit is to stop a runaway real-time process from locking up the system.

              For further details on real-time scheduling policies, see sched(7)

       RLIMIT_SIGPENDING (since Linux 2.6.8)
              This  is  a  limit  on the number of signals that may be queued for the real user ID of the calling process.
              Both standard and real-time signals are counted for the purpose of checking this limit.  However, the  limit
              is  enforced  only for sigqueue(3); it is always possible to use kill(2) to queue one instance of any of the
              signals that are not already queued to the process.

       RLIMIT_STACK
              This is the maximum size of the process stack, in bytes.  Upon reaching this limit, a SIGSEGV signal is gen‐
              erated.  To handle this signal, a process must employ an alternate signal stack (sigaltstack(2)).

              Since Linux 2.6.23, this limit also determines the amount of space used for the process's command-line argu‐
              ments and environment variables; for details, see execve(2).

   prlimit()
       The Linux-specific prlimit() system call combines and extends the functionality of setrlimit() and getrlimit().  It
       can be used to both set and get the resource limits of an arbitrary process.

       The resource argument has the same meaning as for setrlimit() and getrlimit().

       If the new_limit argument is a not NULL, then the rlimit structure to which it points is used to set new values for
       the soft and hard limits for resource.  If the old_limit argument  is  a  not  NULL,  then  a  successful  call  to
       prlimit() places the previous soft and hard limits for resource in the rlimit structure pointed to by old_limit.

       The  pid  argument  specifies  the  ID  of the process on which the call is to operate.  If pid is 0, then the call
       applies to the calling process.  To set or get the resources of a process other than itself, the caller  must  have
       the  CAP_SYS_RESOURCE  capability  in the user namespace of the process whose resource limits are being changed, or
       the real, effective, and saved set user IDs of the target process must match the real user ID of the caller and the
       real, effective, and saved set group IDs of the target process must match the real group ID of the caller.

RETURN VALUE
       On success, these system calls return 0.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT A pointer argument points to a location outside the accessible address space.

       EINVAL The  value  specified in resource is not valid; or, for setrlimit() or prlimit(): rlim->rlim_cur was greater
              than rlim->rlim_max.

       EPERM  An unprivileged process tried to raise the hard limit; the CAP_SYS_RESOURCE capability  is  required  to  do
              this.

       EPERM  The  caller tried to increase the hard RLIMIT_NOFILE limit above the maximum defined by /proc/sys/fs/nr_open
              (see proc(5))

       EPERM  (prlimit()) The calling process did not have permission to set limits for the process specified by pid.

       ESRCH  Could not find a process with the ID specified in pid.

VERSIONS
       The prlimit() system call is available since Linux 2.6.36.  Library support is available since glibc 2.13.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌────────────────────────────────────┬───────────────┬─────────┐
       │Interface                           │ Attribute     │ Value   │
       ├────────────────────────────────────┼───────────────┼─────────┤
       │getrlimit(), setrlimit(), prlimit() │ Thread safety │ MT-Safe │
       └────────────────────────────────────┴───────────────┴─────────┘

CONFORMING TO
       getrlimit(), setrlimit(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

       prlimit(): Linux-specific.

       RLIMIT_MEMLOCK and RLIMIT_NPROC derive from BSD and are not specified in POSIX.1; they are present on the BSDs  and
       Linux, but on few other implementations.  RLIMIT_RSS derives from BSD and is not specified in POSIX.1; it is never‐
       theless  present  on  most  implementations.   RLIMIT_MSGQUEUE,  RLIMIT_NICE,  RLIMIT_RTPRIO,  RLIMIT_RTTIME,   and
       RLIMIT_SIGPENDING are Linux-specific.

NOTES
       A  child  process  created via fork(2) inherits its parent's resource limits.  Resource limits are preserved across
       execve(2).

       Lowering the soft limit for a resource below the process's current consumption of that resource will  succeed  (but
       will prevent the process from further increasing its consumption of the resource).

       One  can  set  the  resource  limits of the shell using the built-in ulimit command (limit in csh(1)).  The shell's
       resource limits are inherited by the processes that it creates to execute commands.

       Since Linux 2.6.24, the resource limits of any process can be inspected via /proc/[pid]/limits; see proc(5).

       Ancient systems provided a vlimit() function with a similar purpose to setrlimit().   For  backward  compatibility,
       glibc also provides vlimit().  All new applications should be written using setrlimit().

   C library/kernel ABI differences
       Since version 2.13, the glibc getrlimit() and setrlimit() wrapper functions no longer invoke the corresponding sys‐
       tem calls, but instead employ prlimit(), for the reasons described in BUGS.

       The name of the glibc wrapper function is prlimit(); the underlying system call is prlimit64().

BUGS
       In older Linux kernels, the SIGXCPU and SIGKILL signals delivered when a process  encountered  the  soft  and  hard
       RLIMIT_CPU  limits  were  delivered  one  (CPU)  second later than they should have been.  This was fixed in kernel
       2.6.8.

       In 2.6.x kernels before 2.6.17, a RLIMIT_CPU limit of 0 is wrongly treated  as  "no  limit"  (like  RLIM_INFINITY).
       Since Linux 2.6.17, setting a limit of 0 does have an effect, but is actually treated as a limit of 1 second.

       A kernel bug means that RLIMIT_RTPRIO does not work in kernel 2.6.12; the problem is fixed in kernel 2.6.13.

       In  kernel  2.6.12,  there  was  an  off-by-one mismatch between the priority ranges returned by getpriority(2) and
       RLIMIT_NICE.  This had the effect that the actual ceiling for the nice value was calculated as 19 - rlim_cur.  This
       was fixed in kernel 2.6.13.

       Since  Linux  2.6.12, if a process reaches its soft RLIMIT_CPU limit and has a handler installed for SIGXCPU, then,
       in addition to invoking the signal handler, the kernel increases the soft  limit  by  one  second.   This  behavior
       repeats  if  the process continues to consume CPU time, until the hard limit is reached, at which point the process
       is killed.  Other implementations do not change the RLIMIT_CPU soft limit in this manner, and the Linux behavior is
       probably not standards conformant; portable applications should avoid relying on this Linux-specific behavior.  The
       Linux-specific RLIMIT_RTTIME limit exhibits the same behavior when the soft limit is encountered.

       Kernels before 2.4.22 did not diagnose the error EINVAL  for  setrlimit()  when  rlim->rlim_cur  was  greater  than
       rlim->rlim_max.

   Representation of "large" resource limit values on 32-bit platforms
       The  glibc  getrlimit()  and setrlimit() wrapper functions use a 64-bit rlim_t data type, even on 32-bit platforms.
       However, the rlim_t data type used in the getrlimit() and setrlimit() system calls is  a  (32-bit)  unsigned  long.
       Furthermore, in Linux versions before 2.6.36, the kernel represents resource limits on 32-bit platforms as unsigned
       long.  However, a 32-bit data type is not wide enough.  The most pertinent limit here is RLIMIT_FSIZE, which speci‐
       fies  the  maximum size to which a file can grow: to be useful, this limit must be represented using a type that is
       as wide as the type used to represent file offsets—that is, as wide as a 64-bit off_t (assuming a program  compiled
       with _FILE_OFFSET_BITS=64).

       To  work  around  this  kernel limitation, if a program tried to set a resource limit to a value larger than can be
       represented in a 32-bit unsigned long, then the glibc setrlimit() wrapper function  silently  converted  the  limit
       value to RLIM_INFINITY.  In other words, the requested resource limit setting was silently ignored.

       This problem was addressed in Linux 2.6.36 with two principal changes:

       *  the addition of a new kernel representation of resource limits that uses 64 bits, even on 32-bit platforms;

       *  the addition of the prlimit() system call, which employs 64-bit values for its resource limit arguments.

       Since  version  2.13,  glibc works around the limitations of the getrlimit() and setrlimit() system calls by imple‐
       menting setrlimit() and getrlimit() as wrapper functions that call prlimit().

EXAMPLE
       The program below demonstrates the use of prlimit().

       #define _GNU_SOURCE
       #define _FILE_OFFSET_BITS 64
       #include <stdio.h>
       #include <time.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <sys/resource.h>

       #define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

       int
       main(int argc, char *argv[])
       {
           struct rlimit old, new;
           struct rlimit *newp;
           pid_t pid;

           if (!(argc == 2 || argc == 4)) {
               fprintf(stderr, "Usage: %s <pid> [<new-soft-limit> "
                       "<new-hard-limit>]\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           pid = atoi(argv[1]);        /* PID of target process */

           newp = NULL;
           if (argc == 4) {
               new.rlim_cur = atoi(argv[2]);
               new.rlim_max = atoi(argv[3]);
               newp = &new;
           }

           /* Set CPU time limit of target process; retrieve and display
              previous limit */

           if (prlimit(pid, RLIMIT_CPU, newp, &old) == -1)
               errExit("prlimit-1");
           printf("Previous limits: soft=%lld; hard=%lld\n",
                   (long long) old.rlim_cur, (long long) old.rlim_max);

           /* Retrieve and display new CPU time limit */

           if (prlimit(pid, RLIMIT_CPU, NULL, &old) == -1)
               errExit("prlimit-2");
           printf("New limits: soft=%lld; hard=%lld\n",
                   (long long) old.rlim_cur, (long long) old.rlim_max);

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       prlimit(1), dup(2), fcntl(2), fork(2), getrusage(2), mlock(2), mmap(2), open(2), quotactl(2),  sbrk(2),  shmctl(2),
       malloc(3), sigqueue(3), ulimit(3), core(5), capabilities(7), cgroups(7), credentials(7), signal(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                            GETRLIMIT(2)
</pre>
<pre zoom>
<span xsmall>2 openat</span>
OPEN(2)                                          Linux Programmer's Manual                                         OPEN(2)

NAME
       open, openat, creat - open and possibly create a file

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>

       int open(const char *pathname, int flags);
       int open(const char *pathname, int flags, mode_t mode);

       int creat(const char *pathname, mode_t mode);

       int openat(int dirfd, const char *pathname, int flags);
       int openat(int dirfd, const char *pathname, int flags, mode_t mode);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       openat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       The  open() system call opens the file specified by pathname.  If the specified file does not exist, it may option‐
       ally (if O_CREAT is specified in flags) be created by open().

       The return value of open() is a file descriptor, a small, nonnegative integer that is  used  in  subsequent  system
       calls  (read(2),  write(2), lseek(2), fcntl(2), etc.) to refer to the open file.  The file descriptor returned by a
       successful call will be the lowest-numbered file descriptor not currently open for the process.

       By default, the new file descriptor is set to remain open across an execve(2) (i.e., the FD_CLOEXEC file descriptor
       flag  described in fcntl(2) is initially disabled); the O_CLOEXEC flag, described below, can be used to change this
       default.  The file offset is set to the beginning of the file (see lseek(2)).

       A call to open() creates a new open file description, an entry in the system-wide table of open  files.   The  open
       file  description  records the file offset and the file status flags (see below).  A file descriptor is a reference
       to an open file description; this reference is unaffected if pathname is subsequently removed or modified to  refer
       to a different file.  For further details on open file descriptions, see NOTES.

       The  argument  flags  must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR.  These request
       opening the file read-only, write-only, or read/write, respectively.

       In addition, zero or more file creation flags and file status flags can be bitwise-or'd in flags.   The  file  cre‐
       ation  flags  are  O_CLOEXEC, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_TMPFILE, and O_TRUNC.  The file
       status flags are all of the remaining flags listed below.  The distinction between these two  groups  of  flags  is
       that  the file creation flags affect the semantics of the open operation itself, while the file status flags affect
       the semantics of subsequent I/O operations.  The file status flags can be retrieved and (in some  cases)  modified;
       see fcntl(2) for details.

       The full list of file creation flags and file status flags is as follows:

       O_APPEND
              The  file  is  opened in append mode.  Before each write(2), the file offset is positioned at the end of the
              file, as if with lseek(2).  The modification of the file offset and the write operation are performed  as  a
              single atomic step.

              O_APPEND  may  lead to corrupted files on NFS filesystems if more than one process appends data to a file at
              once.  This is because NFS does not support appending to a file, so the client kernel has  to  simulate  it,
              which can't be done without a race condition.

       O_ASYNC
              Enable  signal-driven  I/O:  generate a signal (SIGIO by default, but this can be changed via fcntl(2)) when
              input or output becomes possible on this file descriptor.  This feature is  available  only  for  terminals,
              pseudoterminals,  sockets,  and  (since  Linux 2.6) pipes and FIFOs.  See fcntl(2) for further details.  See
              also BUGS, below.

       O_CLOEXEC (since Linux 2.6.23)
              Enable the close-on-exec flag for the new file descriptor.  Specifying this flag permits a program to  avoid
              additional fcntl(2) F_SETFD operations to set the FD_CLOEXEC flag.

              Note  that  the  use  of  this  flag  is  essential in some multithreaded programs, because using a separate
              fcntl(2) F_SETFD operation to set the FD_CLOEXEC flag does not suffice to avoid race  conditions  where  one
              thread opens a file descriptor and attempts to set its close-on-exec flag using fcntl(2) at the same time as
              another thread does a fork(2) plus execve(2).  Depending on the order of execution, the race may lead to the
              file descriptor returned by open() being unintentionally leaked to the program executed by the child process
              created by fork(2).  (This kind of race is in principle possible for any system call  that  creates  a  file
              descriptor  whose  close-on-exec flag should be set, and various other Linux system calls provide an equiva‐
              lent of the O_CLOEXEC flag to deal with this problem.)

       O_CREAT
              If pathname does not exist, create it as a regular file.

              The owner (user ID) of the new file is set to the effective user ID of the process.

              The group ownership (group ID) of the new file is set either to the effective group ID of the process  (Sys‐
              tem V semantics) or to the group ID of the parent directory (BSD semantics).  On Linux, the behavior depends
              on whether the set-group-ID mode bit is set on the parent directory: if that bit is set, then BSD  semantics
              apply;  otherwise,  System  V  semantics apply.  For some filesystems, the behavior also depends on the bsd‐
              groups and sysvgroups mount options described in mount(8)).

              The mode argument specifies the file mode bits be applied when a new file is created.  This argument must be
              supplied  when  O_CREAT  or  O_TMPFILE is specified in flags; if neither O_CREAT nor O_TMPFILE is specified,
              then mode is ignored.  The effective mode is modified by the process's  umask  in  the  usual  way:  in  the
              absence of a default ACL, the mode of the created file is (mode & ~umask).  Note that this mode applies only
              to future accesses of the newly created file; the open() call that creates a read-only file may well  return
              a read/write file descriptor.

              The following symbolic constants are provided for mode:

              S_IRWXU  00700 user (file owner) has read, write, and execute permission

              S_IRUSR  00400 user has read permission

              S_IWUSR  00200 user has write permission

              S_IXUSR  00100 user has execute permission

              S_IRWXG  00070 group has read, write, and execute permission

              S_IRGRP  00040 group has read permission

              S_IWGRP  00020 group has write permission

              S_IXGRP  00010 group has execute permission

              S_IRWXO  00007 others have read, write, and execute permission

              S_IROTH  00004 others have read permission

              S_IWOTH  00002 others have write permission

              S_IXOTH  00001 others have execute permission

              According to POSIX, the effect when other bits are set in mode is unspecified.  On Linux, the following bits
              are also honored in mode:

              S_ISUID  0004000 set-user-ID bit

              S_ISGID  0002000 set-group-ID bit (see inode(7)).

              S_ISVTX  0001000 sticky bit (see inode(7)).

       O_DIRECT (since Linux 2.4.10)
              Try to minimize cache effects of the I/O to and from this file.  In general this will  degrade  performance,
              but  it  is  useful in special situations, such as when applications do their own caching.  File I/O is done
              directly to/from user-space buffers.  The O_DIRECT flag on its own makes an effort  to  transfer  data  syn‐
              chronously,  but does not give the guarantees of the O_SYNC flag that data and necessary metadata are trans‐
              ferred.  To guarantee synchronous I/O, O_SYNC must be used in addition to O_DIRECT.   See  NOTES  below  for
              further discussion.

              A semantically similar (but deprecated) interface for block devices is described in raw(8).

       O_DIRECTORY
              If  pathname  is not a directory, cause the open to fail.  This flag was added in kernel version 2.1.126, to
              avoid denial-of-service problems if opendir(3) is called on a FIFO or tape device.

       O_DSYNC
              Write operations on the file will complete according to the requirements of synchronized I/O data  integrity
              completion.

              By  the time write(2) (and similar) return, the output data has been transferred to the underlying hardware,
              along with any file metadata that would be required to retrieve that data (i.e., as though each write(2) was
              followed by a call to fdatasync(2)).  See NOTES below.

       O_EXCL Ensure  that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname
              already exists, then open() fails with the error EEXIST.

              When these two flags are specified, symbolic links are not followed: if pathname is a  symbolic  link,  then
              open() fails regardless of where the symbolic link points.

              In  general,  the behavior of O_EXCL is undefined if it is used without O_CREAT.  There is one exception: on
              Linux 2.6 and later, O_EXCL can be used without O_CREAT if pathname refers to a block device.  If the  block
              device is in use by the system (e.g., mounted), open() fails with the error EBUSY.

              On  NFS,  O_EXCL  is  supported  only when using NFSv3 or later on kernel 2.6 or later.  In NFS environments
              where O_EXCL support is not provided, programs that rely on it for performing locking tasks will  contain  a
              race  condition.   Portable  programs that want to perform atomic file locking using a lockfile, and need to
              avoid reliance on NFS support for O_EXCL, can create a unique file on the same filesystem (e.g., incorporat‐
              ing  hostname  and  PID), and use link(2) to make a link to the lockfile.  If link(2) returns 0, the lock is
              successful.  Otherwise, use stat(2) on the unique file to check if its link count has  increased  to  2,  in
              which case the lock is also successful.

       O_LARGEFILE
              (LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be
              opened.  The _LARGEFILE64_SOURCE macro must be defined (before including  any  header  files)  in  order  to
              obtain  this definition.  Setting the _FILE_OFFSET_BITS feature test macro to 64 (rather than using O_LARGE‐
              FILE) is the preferred method of accessing large files on 32-bit systems (see feature_test_macros(7)).

       O_NOATIME (since Linux 2.6.8)
              Do not update the file last access time (st_atime in the inode) when the file is read(2).

              This flag can be employed only if one of the following conditions is true:

              *  The effective UID of the process matches the owner UID of the file.

              *  The calling process has the CAP_FOWNER capability in its user namespace and the owner UID of the file has
                 a mapping in the namespace.

              This  flag  is  intended  for use by indexing or backup programs, where its use can significantly reduce the
              amount of disk activity.  This flag may not be effective on all filesystems.  One example is NFS, where  the
              server maintains the access time.

       O_NOCTTY
              If  pathname  refers  to  a terminal device—see tty(4)—it will not become the process's controlling terminal
              even if the process does not have one.

       O_NOFOLLOW
              If pathname is a symbolic link, then the open fails, with the error ELOOP.  Symbolic links in earlier compo‐
              nents  of  the  pathname  will still be followed.  (Note that the ELOOP error that can occur in this case is
              indistinguishable from the case where an open fails because there are too many symbolic  links  found  while
              resolving components in the prefix part of the pathname.)

              This  flag  is  a  FreeBSD extension, which was added to Linux in version 2.1.126, and has subsequently been
              standardized in POSIX.1-2008.

              See also O_PATH below.

       O_NONBLOCK or O_NDELAY
              When possible, the file is opened in nonblocking mode.  Neither the open() nor any subsequent operations  on
              the file descriptor which is returned will cause the calling process to wait.

              Note  that  this  flag  has  no  effect  for  regular  files and block devices; that is, I/O operations will
              (briefly) block when device activity is required, regardless of whether O_NONBLOCK is set.  Since O_NONBLOCK
              semantics might eventually be implemented, applications should not depend upon blocking behavior when speci‐
              fying this flag for regular files and block devices.

              For the handling of FIFOs (named pipes), see also fifo(7).  For a discussion of the effect of O_NONBLOCK  in
              conjunction with mandatory file locks and with file leases, see fcntl(2).

       O_PATH (since Linux 2.6.39)
              Obtain  a  file  descriptor that can be used for two purposes: to indicate a location in the filesystem tree
              and to perform operations that act purely at the file descriptor level.  The file itself is not opened,  and
              other  file operations (e.g., read(2), write(2), fchmod(2), fchown(2), fgetxattr(2), ioctl(2), mmap(2)) fail
              with the error EBADF.

              The following operations can be performed on the resulting file descriptor:

              *  close(2).

              *  fchdir(2), if the file descriptor refers to a directory (since Linux 3.5).

              *  fstat(2) (since Linux 3.6).

              *  fstatfs(2) (since Linux 3.12).

              *  Duplicating the file descriptor (dup(2), fcntl(2) F_DUPFD, etc.).

              *  Getting and setting file descriptor flags (fcntl(2) F_GETFD and F_SETFD).

              *  Retrieving open file status flags using the fcntl(2) F_GETFL operation: the returned flags  will  include
                 the bit O_PATH.

              *  Passing  the  file descriptor as the dirfd argument of openat() and the other "*at()" system calls.  This
                 includes linkat(2) with AT_EMPTY_PATH (or via procfs using AT_SYMLINK_FOLLOW) even if the file is  not  a
                 directory.

              *  Passing the file descriptor to another process via a UNIX domain socket (see SCM_RIGHTS in unix(7)).

              When O_PATH is specified in flags, flag bits other than O_CLOEXEC, O_DIRECTORY, and O_NOFOLLOW are ignored.

              Opening  a  file  or  directory  with the O_PATH flag requires no permissions on the object itself (but does
              require execute permission on the directories in the path prefix).  Depending on the subsequent operation, a
              check  for  suitable  file  permissions may be performed (e.g., fchdir(2) requires execute permission on the
              directory referred to by its file descriptor argument).  By contrast, obtaining a reference to a  filesystem
              object  by  opening  it  with the O_RDONLY flag requires that the caller have read permission on the object,
              even when the subsequent operation (e.g., fchdir(2), fstat(2)) does  not  require  read  permission  on  the
              object.

              If  pathname  is  a  symbolic  link  and the O_NOFOLLOW flag is also specified, then the call returns a file
              descriptor referring to the symbolic link.  This file descriptor can be used as the dirfd argument in  calls
              to fchownat(2), fstatat(2), linkat(2), and readlinkat(2) with an empty pathname to have the calls operate on
              the symbolic link.

              If pathname refers to an automount point that has not yet been triggered, so no other filesystem is  mounted
              on  it,  then  the  call returns a file descriptor referring to the automount directory without triggering a
              mount.  fstatfs(2) can then be used to determine if it is, in fact, an untriggered automount point  (.f_type
              == AUTOFS_SUPER_MAGIC).

              One  use  of  O_PATH for regular files is to provide the equivalent of POSIX.1's O_EXEC functionality.  This
              permits us to open a file for which we have execute permission but not read  permission,  and  then  execute
              that file, with steps something like the following:

                  char buf[PATH_MAX];
                  fd = open("some_prog", O_PATH);
                  snprintf(buf, PATH_MAX, "/proc/self/fd/%d", fd);
                  execl(buf, "some_prog", (char *) NULL);

              An O_PATH file descriptor can also be passed as the argument of fexecve(3).

       O_SYNC Write  operations on the file will complete according to the requirements of synchronized I/O file integrity
              completion (by contrast with the synchronized I/O data integrity completion provided by O_DSYNC.)

              By the time write(2) (or similar) returns, the output data and associated file  metadata  have  been  trans‐
              ferred  to  the underlying hardware (i.e., as though each write(2) was followed by a call to fsync(2)).  See
              NOTES below.

       O_TMPFILE (since Linux 3.11)
              Create an unnamed temporary regular file.  The pathname argument specifies a  directory;  an  unnamed  inode
              will  be  created  in that directory's filesystem.  Anything written to the resulting file will be lost when
              the last file descriptor is closed, unless the file is given a name.

              O_TMPFILE must be specified with one of O_RDWR or O_WRONLY and, optionally, O_EXCL.  If O_EXCL is not speci‐
              fied,  then linkat(2) can be used to link the temporary file into the filesystem, making it permanent, using
              code like the following:

                  char path[PATH_MAX];
                  fd = open("/path/to/dir", O_TMPFILE | O_RDWR,
                                          S_IRUSR | S_IWUSR);

                  /* File I/O on 'fd'... */

                  snprintf(path, PATH_MAX,  "/proc/self/fd/%d", fd);
                  linkat(AT_FDCWD, path, AT_FDCWD, "/path/for/file",
                                          AT_SYMLINK_FOLLOW);

              In this case, the open() mode argument determines the file permission mode, as with O_CREAT.

              Specifying O_EXCL in conjunction with O_TMPFILE prevents  a  temporary  file  from  being  linked  into  the
              filesystem in the above manner.  (Note that the meaning of O_EXCL in this case is different from the meaning
              of O_EXCL otherwise.)

              There are two main use cases for O_TMPFILE:

              *  Improved tmpfile(3) functionality: race-free creation of  temporary  files  that  (1)  are  automatically
                 deleted  when  closed; (2) can never be reached via any pathname; (3) are not subject to symlink attacks;
                 and (4) do not require the caller to devise unique names.

              *  Creating a file that is initially invisible, which is then populated  with  data  and  adjusted  to  have
                 appropriate  filesystem  attributes  (fchown(2),  fchmod(2), fsetxattr(2), etc.)  before being atomically
                 linked into the filesystem in a fully formed state (using linkat(2) as described above).

              O_TMPFILE requires support by the underlying filesystem; only a subset of  Linux  filesystems  provide  that
              support.  In the initial implementation, support was provided in the ext2, ext3, ext4, UDF, Minix, and shmem
              filesystems.  Support for other filesystems has subsequently been added as follows: XFS (Linux 3.15);  Btrfs
              (Linux 3.16); F2FS (Linux 3.16); and ubifs (Linux 4.9)

       O_TRUNC
              If  the  file  already  exists  and is a regular file and the access mode allows writing (i.e., is O_RDWR or
              O_WRONLY) it will be truncated to length 0.  If the file is a FIFO or terminal device file, the O_TRUNC flag
              is ignored.  Otherwise, the effect of O_TRUNC is unspecified.

   creat()
       A call to creat() is equivalent to calling open() with flags equal to O_CREAT|O_WRONLY|O_TRUNC.

   openat()
       The openat() system call operates in exactly the same way as open(), except for the differences described here.

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       open() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like open()).

       If pathname is absolute, then dirfd is ignored.

RETURN VALUE
       open(), openat(), and creat() return the new file descriptor, or -1 if an error occurred (in which case,  errno  is
       set appropriately).

ERRORS
       open(), openat(), and creat() can fail with the following errors:

       EACCES The  requested  access to the file is not allowed, or search permission is denied for one of the directories
              in the path prefix of pathname, or the file did not exist yet and write access to the  parent  directory  is
              not allowed.  (See also path_resolution(7).)

       EDQUOT Where  O_CREAT  is  specified, the file does not exist, and the user's quota of disk blocks or inodes on the
              filesystem has been exhausted.

       EEXIST pathname already exists and O_CREAT and O_EXCL were used.

       EFAULT pathname points outside your accessible address space.

       EFBIG  See EOVERFLOW.

       EINTR  While blocked waiting to complete an open of a slow device (e.g., a FIFO; see fifo(7)), the call was  inter‐
              rupted by a signal handler; see signal(7).

       EINVAL The filesystem does not support the O_DIRECT flag.  See NOTES for more information.

       EINVAL Invalid value in flags.

       EINVAL O_TMPFILE was specified in flags, but neither O_WRONLY nor O_RDWR was specified.

       EINVAL O_CREAT  was  specified  in flags and the final component ("basename") of the new file's pathname is invalid
              (e.g., it contains characters not permitted by the underlying filesystem).

       EISDIR pathname refers to a directory and the access requested involved writing (that is,  O_WRONLY  or  O_RDWR  is
              set).

       EISDIR pathname  refers  to an existing directory, O_TMPFILE and one of O_WRONLY or O_RDWR were specified in flags,
              but this kernel version does not provide the O_TMPFILE functionality.

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ELOOP  pathname was a symbolic link, and flags specified O_NOFOLLOW but not O_PATH.

       EMFILE The per-process limit on the number of open file descriptors  has  been  reached  (see  the  description  of
              RLIMIT_NOFILE in getrlimit(2)).

       ENAMETOOLONG
              pathname was too long.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENODEV pathname  refers  to a device special file and no corresponding device exists.  (This is a Linux kernel bug;
              in this situation ENXIO must be returned.)

       ENOENT O_CREAT is not set and the named file does not exist.  Or, a directory component in pathname does not  exist
              or is a dangling symbolic link.

       ENOENT pathname refers to a nonexistent directory, O_TMPFILE and one of O_WRONLY or O_RDWR were specified in flags,
              but this kernel version does not provide the O_TMPFILE functionality.

       ENOMEM The named file is a FIFO, but memory for the FIFO buffer can't be allocated because the per-user hard  limit
              on memory allocation for pipes has been reached and the caller is not privileged; see pipe(7).

       ENOMEM Insufficient kernel memory was available.

       ENOSPC pathname was to be created but the device containing pathname has no room for the new file.

       ENOTDIR
              A  component  used as a directory in pathname is not, in fact, a directory, or O_DIRECTORY was specified and
              pathname was not a directory.

       ENXIO  O_NONBLOCK | O_WRONLY is set, the named file is a FIFO, and no process has the FIFO open for reading.

       ENXIO  The file is a device special file and no corresponding device exists.

       EOPNOTSUPP
              The filesystem containing pathname does not support O_TMPFILE.

       EOVERFLOW
              pathname refers to a regular file that is too large to be opened.  The usual scenario here is that an appli‐
              cation  compiled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 tried to open a file whose size exceeds
              (1<<31)-1 bytes; see also O_LARGEFILE above.  This is the error specified  by  POSIX.1;  in  kernels  before
              2.6.24, Linux gave the error EFBIG for this case.

       EPERM  The  O_NOATIME  flag  was  specified, but the effective user ID of the caller did not match the owner of the
              file and the caller was not privileged.

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       EROFS  pathname refers to a file on a read-only filesystem and write access was requested.

       ETXTBSY
              pathname refers to an executable image which is currently being executed and write access was requested.

       ETXTBSY
              pathname refers to a file that is currently in use as a swap file, and the O_TRUNC flag was specified.

       ETXTBSY
              pathname refers to a file that is currently being read by the kernel (e.g. for module/firmware loading), and
              write access was requested.

       EWOULDBLOCK
              The O_NONBLOCK flag was specified, and an incompatible lease was held on the file (see fcntl(2)).

       The following additional errors can occur for openat():

       EBADF  dirfd is not a valid file descriptor.

       ENOTDIR
              pathname is a relative pathname and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       openat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       open(), creat() SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       openat(): POSIX.1-2008.

       The  O_DIRECT,  O_NOATIME,  O_PATH,  and O_TMPFILE flags are Linux-specific.  One must define _GNU_SOURCE to obtain
       their definitions.

       The O_CLOEXEC, O_DIRECTORY, and  O_NOFOLLOW  flags  are  not  specified  in  POSIX.1-2001,  but  are  specified  in
       POSIX.1-2008.   Since  glibc 2.12, one can obtain their definitions by defining either _POSIX_C_SOURCE with a value
       greater than or equal to 200809L or _XOPEN_SOURCE with a value greater than or equal to 700.   In  glibc  2.11  and
       earlier, one obtains the definitions by defining _GNU_SOURCE.

       As  noted  in  feature_test_macros(7),  feature test macros such as _POSIX_C_SOURCE, _XOPEN_SOURCE, and _GNU_SOURCE
       must be defined before including any header files.

NOTES
       Under Linux, the O_NONBLOCK flag indicates that one wants to open but does not necessarily have  the  intention  to
       read or write.  This is typically used to open devices in order to get a file descriptor for use with ioctl(2).

       The  (undefined)  effect  of O_RDONLY | O_TRUNC varies among implementations.  On many systems the file is actually
       truncated.

       Note that open() can open device special files, but creat() cannot create them; use mknod(2) instead.

       If the file is newly created, its st_atime, st_ctime, st_mtime fields (respectively, time of last access,  time  of
       last  status  change,  and  time  of  last  modification;  see stat(2)) are set to the current time, and so are the
       st_ctime and st_mtime fields of the parent directory.  Otherwise, if the file is modified because  of  the  O_TRUNC
       flag, its st_ctime and st_mtime fields are set to the current time.

       The  files  in  the  /proc/[pid]/fd  directory show the open file descriptors of the process with the PID pid.  The
       files in the /proc/[pid]/fdinfo directory show even more information about these files  descriptors.   See  proc(5)
       for further details of both of these directories.

   Open file descriptions
       The  term  open  file description is the one used by POSIX to refer to the entries in the system-wide table of open
       files.  In other contexts, this object is variously also called an "open file object", a "file  handle",  an  "open
       file table entry", or—in kernel-developer parlance—a struct file.

       When a file descriptor is duplicated (using dup(2) or similar), the duplicate refers to the same open file descrip‐
       tion as the original file descriptor, and the two file descriptors consequently share the file offset and file sta‐
       tus  flags.  Such sharing can also occur between processes: a child process created via fork(2) inherits duplicates
       of its parent's file descriptors, and those duplicates refer to the same open file descriptions.

       Each open() of a file creates a new open file description; thus, there may be multiple open file descriptions  cor‐
       responding to a file inode.

       On  Linux, one can use the kcmp(2) KCMP_FILE operation to test whether two file descriptors (in the same process or
       in two different processes) refer to the same open file description.

   Synchronized I/O
       The POSIX.1-2008 "synchronized I/O" option specifies different variants of  synchronized  I/O,  and  specifies  the
       open()  flags  O_SYNC,  O_DSYNC, and O_RSYNC for controlling the behavior.  Regardless of whether an implementation
       supports this option, it must at least support the use of O_SYNC for regular files.

       Linux implements O_SYNC and O_DSYNC, but not O_RSYNC.  (Somewhat incorrectly, glibc defines  O_RSYNC  to  have  the
       same value as O_SYNC.)

       O_SYNC  provides synchronized I/O file integrity completion, meaning write operations will flush data and all asso‐
       ciated metadata to the underlying hardware.  O_DSYNC provides synchronized I/O data integrity  completion,  meaning
       write operations will flush data to the underlying hardware, but will only flush metadata updates that are required
       to allow a subsequent read operation to complete successfully.  Data integrity completion can reduce the number  of
       disk operations that are required for applications that don't need the guarantees of file integrity completion.

       To  understand  the  difference between the two types of completion, consider two pieces of file metadata: the file
       last modification timestamp (st_mtime) and the file length.  All write operations will update the last file modifi‐
       cation timestamp, but only writes that add data to the end of the file will change the file length.  The last modi‐
       fication timestamp is not needed to ensure that a read completes successfully,  but  the  file  length  is.   Thus,
       O_DSYNC  would  only guarantee to flush updates to the file length metadata (whereas O_SYNC would also always flush
       the last modification timestamp metadata).

       Before Linux 2.6.33, Linux implemented only the O_SYNC flag for open().  However, when  that  flag  was  specified,
       most  filesystems  actually provided the equivalent of synchronized I/O data integrity completion (i.e., O_SYNC was
       actually implemented as the equivalent of O_DSYNC).

       Since Linux 2.6.33, proper O_SYNC support is provided.  However, to ensure backward binary  compatibility,  O_DSYNC
       was defined with the same value as the historical O_SYNC, and O_SYNC was defined as a new (two-bit) flag value that
       includes the O_DSYNC flag value.  This ensures that applications compiled against new headers get at least  O_DSYNC
       semantics on pre-2.6.33 kernels.

   C library/kernel differences
       Since  version  2.26,  the glibc wrapper function for open() employs the openat() system call, rather than the ker‐
       nel's open() system call.  For certain architectures, this is also true in glibc versions before 2.26.

   NFS
       There are many infelicities in the protocol underlying NFS, affecting amongst others O_SYNC and O_NDELAY.

       On NFS filesystems with UID mapping enabled, open() may return a file descriptor but, for example, read(2) requests
       are denied with EACCES.  This is because the client performs open() by checking the permissions, but UID mapping is
       performed by the server upon read and write requests.

   FIFOs
       Opening the read or write end of a FIFO blocks until the other end is also opened (by another process  or  thread).
       See fifo(7) for further details.

   File access mode
       Unlike  the  other  values that can be specified in flags, the access mode values O_RDONLY, O_WRONLY, and O_RDWR do
       not specify individual bits.  Rather, they define the low order two bits of flags, and are defined respectively  as
       0,  1,  and 2.  In other words, the combination O_RDONLY | O_WRONLY is a logical error, and certainly does not have
       the same meaning as O_RDWR.

       Linux reserves the special, nonstandard access mode 3 (binary 11) in flags to mean: check for read and  write  per‐
       mission  on  the  file  and  return  a file descriptor that can't be used for reading or writing.  This nonstandard
       access mode is used by some Linux drivers to return a file descriptor that is to be used only  for  device-specific
       ioctl(2) operations.

   Rationale for openat() and other directory file descriptor APIs
       openat()  and  the  other  system calls and library functions that take a directory file descriptor argument (i.e.,
       execveat(2), faccessat(2), fanotify_mark(2), fchmodat(2), fchownat(2), fstatat(2), futimesat(2),  linkat(2),  mkdi‐
       rat(2),  mknodat(2), name_to_handle_at(2), readlinkat(2), renameat(2), statx(2), symlinkat(2), unlinkat(2), utimen‐
       sat(2), mkfifoat(3), and scandirat(3)) address two problems with the older interfaces that  preceded  them.   Here,
       the explanation is in terms of the openat() call, but the rationale is analogous for the other interfaces.

       First,  openat() allows an application to avoid race conditions that could occur when using open() to open files in
       directories other than the current working directory.  These race conditions result from the fact that some  compo‐
       nent  of  the  directory prefix given to open() could be changed in parallel with the call to open().  Suppose, for
       example, that we wish to create the file dir1/dir2/xxx.dep if the file dir1/dir2/xxx exists.  The problem  is  that
       between the existence check and the file-creation step, dir1 or dir2 (which might be symbolic links) could be modi‐
       fied to point to a different location.  Such races can be avoided by opening  a  file  descriptor  for  the  target
       directory,  and  then  specifying that file descriptor as the dirfd argument of (say) fstatat(2) and openat().  The
       use of the dirfd file descriptor also has other benefits:

       *  the file descriptor is a stable reference to the directory, even if the directory is renamed; and

       *  the open file descriptor prevents the underlying filesystem from being dismounted, just as when a process has  a
          current working directory on a filesystem.

       Second,  openat()  allows  the  implementation  of a per-thread "current working directory", via file descriptor(s)
       maintained by the application.   (This  functionality  can  also  be  obtained  by  tricks  based  on  the  use  of
       /proc/self/fd/dirfd, but less efficiently.)

   O_DIRECT
       The  O_DIRECT  flag  may impose alignment restrictions on the length and address of user-space buffers and the file
       offset of I/Os.  In Linux alignment restrictions vary  by  filesystem  and  kernel  version  and  might  be  absent
       entirely.   However  there  is  currently  no filesystem-independent interface for an application to discover these
       restrictions for a given file or filesystem.  Some filesystems provide their own interfaces for doing so, for exam‐
       ple the XFS_IOC_DIOINFO operation in xfsctl(3).

       Under  Linux 2.4, transfer sizes, and the alignment of the user buffer and the file offset must all be multiples of
       the logical block size of the filesystem.  Since Linux 2.6.0, alignment to the logical block size of the underlying
       storage  (typically  512  bytes)  suffices.   The logical block size can be determined using the ioctl(2) BLKSSZGET
       operation or from the shell using the command:

           blockdev --getss

       O_DIRECT I/Os should never be run concurrently with the fork(2) system call, if the memory buffer is a private map‐
       ping  (i.e.,  any mapping created with the mmap(2) MAP_PRIVATE flag; this includes memory allocated on the heap and
       statically allocated buffers).  Any such I/Os, whether submitted via an asynchronous I/O interface or from  another
       thread  in  the process, should be completed before fork(2) is called.  Failure to do so can result in data corrup‐
       tion and undefined behavior in parent and child processes.  This restriction does not apply when the memory  buffer
       for  the  O_DIRECT  I/Os was created using shmat(2) or mmap(2) with the MAP_SHARED flag.  Nor does this restriction
       apply when the memory buffer has been advised as MADV_DONTFORK with madvise(2), ensuring that it will not be avail‐
       able to the child after fork(2).

       The  O_DIRECT  flag  was introduced in SGI IRIX, where it has alignment restrictions similar to those of Linux 2.4.
       IRIX has also a fcntl(2) call to query appropriate alignments, and sizes.  FreeBSD 4.x introduced  a  flag  of  the
       same name, but without alignment restrictions.

       O_DIRECT  support  was  added  under  Linux in kernel version 2.4.10.  Older Linux kernels simply ignore this flag.
       Some filesystems may not implement the flag, in which case open() fails with the error EINVAL if it is used.

       Applications should avoid mixing O_DIRECT and normal I/O to the same  file,  and  especially  to  overlapping  byte
       regions in the same file.  Even when the filesystem correctly handles the coherency issues in this situation, over‐
       all I/O throughput is likely to be slower than using either mode alone.  Likewise, applications should avoid mixing
       mmap(2) of files with direct I/O to the same files.

       The behavior of O_DIRECT with NFS will differ from local filesystems.  Older kernels, or kernels configured in cer‐
       tain ways, may not support this combination.  The NFS protocol does not support passing the flag to the server,  so
       O_DIRECT  I/O  will  bypass the page cache only on the client; the server may still cache the I/O.  The client asks
       the server to make the I/O synchronous to preserve the synchronous semantics of O_DIRECT.  Some servers  will  per‐
       form poorly under these circumstances, especially if the I/O size is small.  Some servers may also be configured to
       lie to clients about the I/O having reached stable storage; this will avoid the performance penalty at some risk to
       data  integrity  in  the  event  of server power failure.  The Linux NFS client places no alignment restrictions on
       O_DIRECT I/O.

       In summary, O_DIRECT is a potentially powerful tool that should be used  with  caution.   It  is  recommended  that
       applications treat use of O_DIRECT as a performance option which is disabled by default.

              "The  thing  that has always disturbed me about O_DIRECT is that the whole interface is just stupid, and was
              probably designed by a deranged monkey on some serious mind-controlling substances."—Linus

BUGS
       Currently, it is not possible to enable signal-driven I/O by specifying O_ASYNC when calling open();  use  fcntl(2)
       to enable this flag.

       One  must  check for two different error codes, EISDIR and ENOENT, when trying to determine whether the kernel sup‐
       ports O_TMPFILE functionality.

       When both O_CREAT and O_DIRECTORY are specified in flags and the file specified by pathname does not exist,  open()
       will create a regular file (i.e., O_DIRECTORY is ignored).

SEE ALSO
       chmod(2),  chown(2),  close(2),  dup(2),  fcntl(2),  link(2),  lseek(2),  mknod(2), mmap(2), mount(2), open_by_han‐
       dle_at(2), read(2), socket(2),  stat(2),  umask(2),  unlink(2),  write(2),  fopen(3),  acl(5),  fifo(7),  inode(7),
       path_resolution(7), symlink(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-04-30                                                 OPEN(2)
</pre>
<pre zoom>
<span xsmall>2 phys</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 arm_fadvise64_64</span>
POSIX_FADVISE(2)                                 Linux Programmer's Manual                                POSIX_FADVISE(2)

NAME
       posix_fadvise - predeclare an access pattern for file data

SYNOPSIS
       #include <fcntl.h>

       int posix_fadvise(int fd, off_t offset, off_t len, int advice);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       posix_fadvise():
           _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       Programs  can use posix_fadvise() to announce an intention to access file data in a specific pattern in the future,
       thus allowing the kernel to perform appropriate optimizations.

       The advice applies to a (not necessarily existent) region starting at offset and extending for len bytes (or  until
       the  end  of the file if len is 0) within the file referred to by fd.  The advice is not binding; it merely consti‐
       tutes an expectation on behalf of the application.

       Permissible values for advice include:

       POSIX_FADV_NORMAL
              Indicates that the application has no advice to give about its access pattern for the specified data.  If no
              advice is given for an open file, this is the default assumption.

       POSIX_FADV_SEQUENTIAL
              The  application  expects  to  access the specified data sequentially (with lower offsets read before higher
              ones).

       POSIX_FADV_RANDOM
              The specified data will be accessed in random order.

       POSIX_FADV_NOREUSE
              The specified data will be accessed only once.

              In kernels before 2.6.18, POSIX_FADV_NOREUSE had the same semantics as POSIX_FADV_WILLNEED.  This was proba‐
              bly a bug; since kernel 2.6.18, this flag is a no-op.

       POSIX_FADV_WILLNEED
              The specified data will be accessed in the near future.

              POSIX_FADV_WILLNEED initiates a nonblocking read of the specified region into the page cache.  The amount of
              data read may be decreased by the kernel depending on virtual memory load.  (A few megabytes will usually be
              fully satisfied, and more is rarely useful.)

       POSIX_FADV_DONTNEED
              The specified data will not be accessed in the near future.

              POSIX_FADV_DONTNEED attempts to free cached pages associated with the specified region.  This is useful, for
              example, while streaming large files.  A program may periodically request the kernel  to  free  cached  data
              that has already been used, so that more useful cached pages are not discarded instead.

              Requests  to  discard  partial  pages  are  ignored.   It is preferable to preserve needed data than discard
              unneeded data.  If the application requires that data be considered for discarding, then offset and len must
              be page-aligned.

              The  implementation  may  attempt to write back dirty pages in the specified region, but this is not guaran‐
              teed.  Any unwritten dirty pages will not be freed.  If the application wishes to ensure  that  dirty  pages
              will be released, it should call fsync(2) or fdatasync(2) first.

RETURN VALUE
       On success, zero is returned.  On error, an error number is returned.

ERRORS
       EBADF  The fd argument was not a valid file descriptor.

       EINVAL An invalid value was specified for advice.

       ESPIPE The specified file descriptor refers to a pipe or FIFO.  (ESPIPE is the error specified by POSIX, but before
              kernel version 2.6.16, Linux returned EINVAL in this case.)

VERSIONS
       Kernel support first appeared in Linux 2.5.60; the underlying system call is called fadvise64().   Library  support
       has been provided since glibc version 2.2, via the wrapper function posix_fadvise().

       Since  Linux  3.18,  support  for  the  underlying  system  call  is optional, depending on the setting of the CON‐
       FIG_ADVISE_SYSCALLS configuration option.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.  Note that the  type  of  the  len  argument  was  changed  from  size_t  to  off_t  in
       POSIX.1-2003 TC1.

NOTES
       Under   Linux,  POSIX_FADV_NORMAL  sets  the  readahead  window  to  the  default  size  for  the  backing  device;
       POSIX_FADV_SEQUENTIAL doubles this size, and POSIX_FADV_RANDOM disables file  readahead  entirely.   These  changes
       affect  the  entire  file,  not  just  the specified region (but other open file handles to the same file are unaf‐
       fected).

       The contents of the kernel buffer cache can be cleared via  the  /proc/sys/vm/drop_caches  interface  described  in
       proc(5).

       One  can  obtain a snapshot of which pages of a file are resident in the buffer cache by opening a file, mapping it
       with mmap(2), and then applying mincore(2) to the mapping.

   C library/kernel differences
       The name of the wrapper function in the C library is posix_fadvise().  The underlying system call  is  called  fad‐
       vise64() (or, on some architectures, fadvise64_64()).

   Architecture-specific variants
       Some  architectures require 64-bit arguments to be aligned in a suitable pair of registers (see syscall(2) for fur‐
       ther detail).  On such architectures, the call signature of posix_fadvise() shown in the  SYNOPSIS  would  force  a
       register to be wasted as padding between the fd and offset arguments.  Therefore, these architectures define a ver‐
       sion of the system call that orders the arguments suitably, but is otherwise exactly the same as posix_fadvise().

       For example, since Linux 2.6.14, ARM has the following system call:

           long arm_fadvise64_64(int fd, int advice,
                                 loff_t offset, loff_t len);

       These architecture-specific details are generally hidden from applications by  the  glibc  posix_fadvise()  wrapper
       function, which invokes the appropriate architecture-specific system call.

BUGS
       In  kernels  before  2.6.6,  if len was specified as 0, then this was interpreted literally as "zero bytes", rather
       than as meaning "all bytes through to the end of the file".

SEE ALSO
       fincore(1), mincore(2), readahead(2), sync_file_range(2), posix_fallocate(3), posix_madvise(3)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        POSIX_FADVISE(2)
</pre>
<pre zoom>
<span xsmall>2 pause</span>
PAUSE(2)                                         Linux Programmer's Manual                                        PAUSE(2)

NAME
       pause - wait for signal

SYNOPSIS
       #include <unistd.h>

       int pause(void);

DESCRIPTION
       pause()  causes  the  calling  process  (or thread) to sleep until a signal is delivered that either terminates the
       process or causes the invocation of a signal-catching function.

RETURN VALUE
       pause() returns only when a signal was caught and the signal-catching function returned.   In  this  case,  pause()
       returns -1, and errno is set to EINTR.

ERRORS
       EINTR  a signal was caught and the signal-catching function returned.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

SEE ALSO
       kill(2), select(2), signal(2), sigsuspend(2)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2015-08-08                                                PAUSE(2)
</pre>
<pre zoom>
<span xsmall>2 fattach</span>
UNIMPLEMENTED(2)                                 Linux Programmer's Manual                                UNIMPLEMENTED(2)

NAME
       afs_syscall,  break,  fattach, fdetach, ftime, getmsg, getpmsg, gtty, isastream, lock, madvise1, mpx, prof, profil,
       putmsg, putpmsg, security, stty, tuxcall, ulimit, vserver - unimplemented system calls

SYNOPSIS
       Unimplemented system calls.

DESCRIPTION
       These system calls are not implemented in the Linux kernel.

RETURN VALUE
       These system calls always return -1 and set errno to ENOSYS.

NOTES
       Note that ftime(3), profil(3), and ulimit(3) are implemented as library functions.

       Some system calls, like alloc_hugepages(2), free_hugepages(2), ioperm(2), iopl(2), and vm86(2) exist only  on  cer‐
       tain architectures.

       Some  system  calls,  like ipc(2), create_module(2), init_module(2), and delete_module(2) exist only when the Linux
       kernel was built with support for them.

SEE ALSO
       syscalls(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                        UNIMPLEMENTED(2)
</pre>
<pre zoom>
<span xsmall>2 socketpair</span>
SOCKETPAIR(2)                                    Linux Programmer's Manual                                   SOCKETPAIR(2)

NAME
       socketpair - create a pair of connected sockets

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>

       int socketpair(int domain, int type, int protocol, int sv[2]);

DESCRIPTION
       The  socketpair() call creates an unnamed pair of connected sockets in the specified domain, of the specified type,
       and using the optionally specified protocol.  For further details of these arguments, see socket(2).

       The file descriptors used in referencing the new sockets are returned in sv[0] and  sv[1].   The  two  sockets  are
       indistinguishable.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

       On  Linux (and other systems), socketpair() does not modify sv on failure.  A requirement standardizing this behav‐
       ior was added in POSIX.1-2016.

ERRORS
       EAFNOSUPPORT
              The specified address family is not supported on this machine.

       EFAULT The address sv does not specify a valid part of the process address space.

       EMFILE The per-process limit on the number of open file descriptors has been reached.

       ENFILE The system-wide limit on the total number of open files has been reached.

       EOPNOTSUPP
              The specified protocol does not support creation of socket pairs.

       EPROTONOSUPPORT
              The specified protocol is not supported on this machine.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.4BSD.  socketpair() first appeared in 4.2BSD.  It is generally portable to/from  non-
       BSD systems supporting clones of the BSD socket layer (including System V variants).

NOTES
       On  Linux,  the  only supported domain for this call is AF_UNIX (or synonymously, AF_LOCAL).  (Most implementations
       have the same restriction.)

       Since Linux 2.6.27, socketpair() supports the SOCK_NONBLOCK  and  SOCK_CLOEXEC  flags  in  the  type  argument,  as
       described in socket(2).

       POSIX.1  does  not require the inclusion of <sys/types.h>, and this header file is not required on Linux.  However,
       some historical (BSD) implementations required this header file, and portable applications  are  probably  wise  to
       include it.

SEE ALSO
       pipe(2), read(2), socket(2), write(2), socket(7), unix(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                           SOCKETPAIR(2)
</pre>
<pre zoom>
<span xsmall>2 settimeofday</span>
GETTIMEOFDAY(2)                                  Linux Programmer's Manual                                 GETTIMEOFDAY(2)

NAME
       gettimeofday, settimeofday - get / set time

SYNOPSIS
       #include <sys/time.h>

       int gettimeofday(struct timeval *tv, struct timezone *tz);

       int settimeofday(const struct timeval *tv, const struct timezone *tz);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       settimeofday():
           Since glibc 2.19:
               _DEFAULT_SOURCE
           Glibc 2.19 and earlier:
               _BSD_SOURCE

DESCRIPTION
       The functions gettimeofday() and settimeofday() can get and set the time as well as a timezone.  The tv argument is
       a struct timeval (as specified in <sys/time.h>):

           struct timeval {
               time_t      tv_sec;     /* seconds */
               suseconds_t tv_usec;    /* microseconds */
           };

       and gives the number of seconds and microseconds since the Epoch (see time(2)).  The tz argument is a struct  time‐
       zone:

           struct timezone {
               int tz_minuteswest;     /* minutes west of Greenwich */
               int tz_dsttime;         /* type of DST correction */
           };

       If  either  tv  or  tz is NULL, the corresponding structure is not set or returned.  (However, compilation warnings
       will result if tv is NULL.)

       The use of the timezone structure is obsolete; the tz argument should normally be specified as  NULL.   (See  NOTES
       below.)

       Under  Linux,  there  are some peculiar "warp clock" semantics associated with the settimeofday() system call if on
       the very first call (after booting) that has a non-NULL tz argument, the tv argument is NULL and the tz_minuteswest
       field is nonzero.  (The tz_dsttime field should be zero for this case.)  In such a case it is assumed that the CMOS
       clock is on local time, and that it has to be incremented by this amount to get UTC system time.  No doubt it is  a
       bad idea to use this feature.

RETURN VALUE
       gettimeofday()  and  settimeofday()  return  0 for success, or -1 for failure (in which case errno is set appropri‐
       ately).

ERRORS
       EFAULT One of tv or tz pointed outside the accessible address space.

       EINVAL Timezone (or something else) is invalid.

       EPERM  The calling process has insufficient privilege to call settimeofday(); under Linux the CAP_SYS_TIME capabil‐
              ity is required.

CONFORMING TO
       SVr4,  4.3BSD.  POSIX.1-2001 describes gettimeofday() but not settimeofday().  POSIX.1-2008 marks gettimeofday() as
       obsolete, recommending the use of clock_gettime(2) instead.

NOTES
       The time returned by gettimeofday() is affected by discontinuous jumps in the system  time  (e.g.,  if  the  system
       administrator  manually  changes  the  system  time).  If you need a monotonically increasing clock, see clock_get‐
       time(2).

       Macros for operating on timeval structures are described in timeradd(3).

       Traditionally, the fields of struct timeval were of type long.

   C library/kernel differences
       On some architectures, an implementation of gettimeofday() is provided in the vdso(7).

   The tz_dsttime field
       On a non-Linux kernel, with glibc, the tz_dsttime field of struct timezone will be set to a nonzero value  by  get‐
       timeofday()  if  the  current  timezone has ever had or will have a daylight saving rule applied.  In this sense it
       exactly mirrors the meaning of daylight(3) for the current zone.  On Linux, with glibc, the setting of the  tz_dst‐
       time  field  of  struct  timezone  has never been used by settimeofday() or gettimeofday().  Thus, the following is
       purely of historical interest.

       On old systems, the field tz_dsttime contains a symbolic constant (values are given below) that indicates in  which
       part  of the year Daylight Saving Time is in force.  (Note: this value is constant throughout the year: it does not
       indicate that DST is in force, it just selects an algorithm.)  The daylight saving time algorithms defined  are  as
       follows:

           DST_NONE     /* not on DST */
           DST_USA      /* USA style DST */
           DST_AUST     /* Australian style DST */
           DST_WET      /* Western European DST */
           DST_MET      /* Middle European DST */
           DST_EET      /* Eastern European DST */
           DST_CAN      /* Canada */
           DST_GB       /* Great Britain and Eire */
           DST_RUM      /* Romania */
           DST_TUR      /* Turkey */
           DST_AUSTALT  /* Australian style with shift in 1986 */

       Of course it turned out that the period in which Daylight Saving Time is in force cannot be given by a simple algo‐
       rithm, one per country; indeed, this period is determined by unpredictable political decisions.  So this method  of
       representing timezones has been abandoned.

SEE ALSO
       date(1),  adjtimex(2),  clock_gettime(2),  time(2),  ctime(3),  ftime(3),  timeradd(3),  capabilities(7),  time(7),
       vdso(7), hwclock(8)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                         GETTIMEOFDAY(2)
</pre>
<pre zoom>
<span xsmall>2 shmdt</span>
SHMOP(2)                                         Linux Programmer's Manual                                        SHMOP(2)

NAME
       shmat, shmdt - System V shared memory operations

SYNOPSIS
       #include <sys/types.h>
       #include <sys/shm.h>

       void *shmat(int shmid, const void *shmaddr, int shmflg);

       int shmdt(const void *shmaddr);

DESCRIPTION
   shmat()
       shmat()  attaches  the  System V  shared  memory  segment  identified  by shmid to the address space of the calling
       process.  The attaching address is specified by shmaddr with one of the following criteria:

       *  If shmaddr is NULL, the system chooses a suitable (unused) page-aligned address to attach the segment.

       *  If shmaddr isn't NULL and SHM_RND is specified in shmflg, the attach occurs at  the  address  equal  to  shmaddr
          rounded down to the nearest multiple of SHMLBA.

       *  Otherwise, shmaddr must be a page-aligned address at which the attach occurs.

       In addition to SHM_RND, the following flags may be specified in the shmflg bit-mask argument:

       SHM_EXEC (Linux-specific; since Linux 2.6.9)
              Allow the contents of the segment to be executed.  The caller must have execute permission on the segment.

       SHM_RDONLY
              Attach  the  segment  for read-only access.  The process must have read permission for the segment.  If this
              flag is not specified, the segment is attached for read and write access, and the process must have read and
              write permission for the segment.  There is no notion of a write-only shared memory segment.

       SHM_REMAP (Linux-specific)
              This  flag specifies that the mapping of the segment should replace any existing mapping in the range start‐
              ing at shmaddr and continuing for the size of the segment.  (Normally, an EINVAL error  would  result  if  a
              mapping already exists in this address range.)  In this case, shmaddr must not be NULL.

       The  brk(2)  value of the calling process is not altered by the attach.  The segment will automatically be detached
       at process exit.  The same segment may be attached as a read and as a read-write one, and more than  once,  in  the
       process's address space.

       A  successful shmat() call updates the members of the shmid_ds structure (see shmctl(2)) associated with the shared
       memory segment as follows:

              shm_atime is set to the current time.

              shm_lpid is set to the process-ID of the calling process.

              shm_nattch is incremented by one.

   shmdt()
       shmdt() detaches the shared memory segment located at the address specified by shmaddr from the  address  space  of
       the  calling  process.   The  to-be-detached  segment  must  be  currently attached with shmaddr equal to the value
       returned by the attaching shmat() call.

       On a successful shmdt() call, the system updates the members of the shmid_ds structure associated with  the  shared
       memory segment as follows:

              shm_dtime is set to the current time.

              shm_lpid is set to the process-ID of the calling process.

              shm_nattch  is  decremented  by one.  If it becomes 0 and the segment is marked for deletion, the segment is
              deleted.

RETURN VALUE
       On success, shmat() returns the address of the attached shared memory segment; on error, (void *) -1  is  returned,
       and errno is set to indicate the cause of the error.

       On success, shmdt() returns 0; on error -1 is returned, and errno is set to indicate the cause of the error.

ERRORS
       When shmat() fails, errno is set to one of the following:

       EACCES The  calling process does not have the required permissions for the requested attach type, and does not have
              the CAP_IPC_OWNER capability in the user namespace that governs its IPC namespace.

       EIDRM  shmid points to a removed identifier.

       EINVAL Invalid shmid value, unaligned (i.e., not page-aligned and SHM_RND was not  specified)  or  invalid  shmaddr
              value, or can't attach segment at shmaddr, or SHM_REMAP was specified and shmaddr was NULL.

       ENOMEM Could not allocate memory for the descriptor or for the page tables.

       When shmdt() fails, errno is set as follows:

       EINVAL There is no shared memory segment attached at shmaddr; or, shmaddr is not aligned on a page boundary.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

       In SVID 3 (or perhaps earlier), the type of the shmaddr argument was changed from char * into const void *, and the
       returned type of shmat() from char * into void *.

NOTES
       After a fork(2), the child inherits the attached shared memory segments.

       After an execve(2), all attached shared memory segments are detached from the process.

       Upon _exit(2), all attached shared memory segments are detached from the process.

       Using shmat() with shmaddr equal to NULL is the preferred, portable way of attaching a shared memory  segment.   Be
       aware  that the shared memory segment attached in this way may be attached at different addresses in different pro‐
       cesses.  Therefore, any pointers maintained within the shared memory must be made relative (typically to the start‐
       ing address of the segment), rather than absolute.

       On  Linux,  it  is possible to attach a shared memory segment even if it is already marked to be deleted.  However,
       POSIX.1 does not specify this behavior and many other implementations do not support it.

       The following system parameter affects shmat():

       SHMLBA Segment low boundary address multiple.  When explicitly specifying an attach address in a call  to  shmat(),
              the  caller should ensure that the address is a multiple of this value.  This is necessary on some architec‐
              tures, in order either to ensure good CPU cache performance or to ensure that different attaches of the same
              segment  have  consistent  views  within the CPU cache.  SHMLBA is normally some multiple of the system page
              size.  (On many Linux architectures, SHMLBA is the same as the system page size.)

       The implementation places no intrinsic per-process limit on the number of shared memory segments (SHMSEG).

SEE ALSO
       brk(2), mmap(2), shmctl(2), shmget(2), capabilities(7), shm_overview(7), svipc(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                SHMOP(2)
</pre>
<pre zoom>
<span xsmall>2 capset</span>
CAPGET(2)                                        Linux Programmer's Manual                                       CAPGET(2)

NAME
       capget, capset - set/get capabilities of thread(s)

SYNOPSIS
       #include <sys/capability.h>

       int capget(cap_user_header_t hdrp, cap_user_data_t datap);

       int capset(cap_user_header_t hdrp, const cap_user_data_t datap);

DESCRIPTION
       Since  Linux 2.2, the power of the superuser (root) has been partitioned into a set of discrete capabilities.  Each
       thread has a set of effective capabilities identifying which capabilities (if any) it may currently exercise.  Each
       thread  also  has a set of inheritable capabilities that may be passed through an execve(2) call, and a set of per‐
       mitted capabilities that it can make effective or inheritable.

       These two system calls are the raw kernel interface for getting and setting  thread  capabilities.   Not  only  are
       these system calls specific to Linux, but the kernel API is likely to change and use of these system calls (in par‐
       ticular the format of the cap_user_*_t types) is subject to extension with each kernel revision, but  old  programs
       will keep working.

       The  portable  interfaces  are cap_set_proc(3) and cap_get_proc(3); if possible, you should use those interfaces in
       applications.  If you wish to use the Linux extensions in applications, you should use the easier-to-use interfaces
       capsetp(3) and capgetp(3).

   Current details
       Now that you have been warned, some current kernel details.  The structures are defined as follows.

           #define _LINUX_CAPABILITY_VERSION_1  0x19980330
           #define _LINUX_CAPABILITY_U32S_1     1

                   /* V2 added in Linux 2.6.25; deprecated */
           #define _LINUX_CAPABILITY_VERSION_2  0x20071026
           #define _LINUX_CAPABILITY_U32S_2     2

                   /* V3 added in Linux 2.6.26 */
           #define _LINUX_CAPABILITY_VERSION_3  0x20080522
           #define _LINUX_CAPABILITY_U32S_3     2

           typedef struct __user_cap_header_struct {
              __u32 version;
              int pid;
           } *cap_user_header_t;

           typedef struct __user_cap_data_struct {
              __u32 effective;
              __u32 permitted;
              __u32 inheritable;
           } *cap_user_data_t;

       The  effective,  permitted,  and  inheritable  fields are bit masks of the capabilities defined in capabilities(7).
       Note that the CAP_* values are bit indexes and need to be bit-shifted before ORing into the bit fields.  To  define
       the  structures  for  passing  to  the  system call, you have to use the struct __user_cap_header_struct and struct
       __user_cap_data_struct names because the typedefs are only pointers.

       Kernels prior to 2.6.25 prefer 32-bit capabilities with version _LINUX_CAPABILITY_VERSION_1.   Linux  2.6.25  added
       64-bit  capability  sets,  with  version _LINUX_CAPABILITY_VERSION_2.  There was, however, an API glitch, and Linux
       2.6.26 added _LINUX_CAPABILITY_VERSION_3 to fix the problem.

       Note that 64-bit capabilities use datap[0] and datap[1], whereas 32-bit capabilities use only datap[0].

       On kernels that support file capabilities (VFS capabilities support), these system calls  behave  slightly  differ‐
       ently.  This support was added as an option in Linux 2.6.24, and became fixed (nonoptional) in Linux 2.6.33.

       For  capget()  calls, one can probe the capabilities of any process by specifying its process ID with the hdrp->pid
       field value.

   With VFS capabilities support
       VFS capabilities employ a file extended attribute (see xattr(7)) to allow capabilities to be attached  to  executa‐
       bles.   This  privilege  model  obsoletes kernel support for one process asynchronously setting the capabilities of
       another.  That is, on kernels that have VFS capabilities support, when calling capset(), the only permitted  values
       for hdrp->pid are 0 or, equivalently, the value returned by gettid(2).

   Without VFS capabilities support
       On older kernels that do not provide VFS capabilities support capset() can, if the caller has the CAP_SETPCAP capa‐
       bility, be used to change not only the caller's own capabilities, but also the capabilities of other threads.   The
       call  operates on the capabilities of the thread specified by the pid field of hdrp when that is nonzero, or on the
       capabilities of the calling thread if pid is 0.  If pid refers to a single-threaded process, then pid can be speci‐
       fied as a traditional process ID; operating on a thread of a multithreaded process requires a thread ID of the type
       returned by gettid(2).  For capset(), pid can also be: -1, meaning perform the change on  all  threads  except  the
       caller  and  init(1);  or  a  value less than -1, in which case the change is applied to all members of the process
       group whose ID is -pid.

       For details on the data, see capabilities(7).

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

       The calls fail with the error EINVAL, and set  the  version  field  of  hdrp  to  the  kernel  preferred  value  of
       _LINUX_CAPABILITY_VERSION_?   when  an unsupported version value is specified.  In this way, one can probe what the
       current preferred capability revision is.

ERRORS
       EFAULT Bad memory address.  hdrp must not be NULL.  datap may be NULL only when the user is trying to determine the
              preferred capability version format supported by the kernel.

       EINVAL One of the arguments was invalid.

       EPERM  An  attempt  was  made  to add a capability to the Permitted set, or to set a capability in the Effective or
              Inheritable sets that is not in the Permitted set.

       EPERM  The caller attempted to use capset() to modify the capabilities of a thread other than  itself,  but  lacked
              sufficient  privilege.  For kernels supporting VFS capabilities, this is never permitted.  For kernels lack‐
              ing VFS support, the CAP_SETPCAP capability is required.  (A bug in kernels before 2.6.11  meant  that  this
              error  could also occur if a thread without this capability tried to change its own capabilities by specify‐
              ing the pid field as a nonzero value (i.e., the value returned by getpid(2)) instead of 0.)

       ESRCH  No such thread.

CONFORMING TO
       These system calls are Linux-specific.

NOTES
       The portable interface to the capability querying and setting functions is provided by the libcap  library  and  is
       available here:
       ⟨http://git.kernel.org/cgit/linux/kernel/git/morgan/libcap.git⟩

SEE ALSO
       clone(2), gettid(2), capabilities(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               CAPGET(2)
</pre>
<pre zoom>
<span xsmall>2 fcntl64</span>
FCNTL(2)                                         Linux Programmer's Manual                                        FCNTL(2)

NAME
       fcntl - manipulate file descriptor

SYNOPSIS
       #include <unistd.h>
       #include <fcntl.h>

       int fcntl(int fd, int cmd, ... /* arg */ );

DESCRIPTION
       fcntl() performs one of the operations described below on the open file descriptor fd.  The operation is determined
       by cmd.

       fcntl() can take an optional third argument.  Whether or not this argument is required is determined by  cmd.   The
       required  argument  type  is indicated in parentheses after each cmd name (in most cases, the required type is int,
       and we identify the argument using the name arg), or void is specified if the argument is not required.

       Certain of the operations below are supported only since a particular Linux kernel version.  The  preferred  method
       of checking whether the host kernel supports a particular operation is to invoke fcntl() with the desired cmd value
       and then test whether the call failed with EINVAL, indicating that the kernel does not recognize this value.

   Duplicating a file descriptor
       F_DUPFD (int)
              Duplicate the file descriptor fd using the lowest-numbered available file descriptor greater than  or  equal
              to arg.  This is different from dup2(2), which uses exactly the file descriptor specified.

              On success, the new file descriptor is returned.

              See dup(2) for further details.

       F_DUPFD_CLOEXEC (int; since Linux 2.6.24)
              As  for  F_DUPFD, but additionally set the close-on-exec flag for the duplicate file descriptor.  Specifying
              this flag permits a program to avoid an additional fcntl() F_SETFD operation to  set  the  FD_CLOEXEC  flag.
              For an explanation of why this flag is useful, see the description of O_CLOEXEC in open(2).

   File descriptor flags
       The  following  commands  manipulate the flags associated with a file descriptor.  Currently, only one such flag is
       defined: FD_CLOEXEC, the close-on-exec flag.  If the FD_CLOEXEC bit is set, the file descriptor will  automatically
       be  closed  during  a  successful  execve(2).   (If the execve(2) fails, the file descriptor is left open.)  If the
       FD_CLOEXEC bit is not set, the file descriptor will remain open across an execve(2).

       F_GETFD (void)
              Return (as the function result) the file descriptor flags; arg is ignored.

       F_SETFD (int)
              Set the file descriptor flags to the value specified by arg.

       In multithreaded programs, using fcntl() F_SETFD to set the close-on-exec flag at the same time as  another  thread
       performs a fork(2) plus execve(2) is vulnerable to a race condition that may unintentionally leak the file descrip‐
       tor to the program executed in the child process.  See the discussion of the O_CLOEXEC flag in open(2) for  details
       and a remedy to the problem.

   File status flags
       Each  open  file  description  has certain associated status flags, initialized by open(2) and possibly modified by
       fcntl().  Duplicated file descriptors (made with dup(2), fcntl(F_DUPFD), fork(2), etc.) refer to the same open file
       description, and thus share the same file status flags.

       The file status flags and their semantics are described in open(2).

       F_GETFL (void)
              Return (as the function result) the file access mode and the file status flags; arg is ignored.

       F_SETFL (int)
              Set  the file status flags to the value specified by arg.  File access mode (O_RDONLY, O_WRONLY, O_RDWR) and
              file creation flags (i.e., O_CREAT, O_EXCL, O_NOCTTY, O_TRUNC) in arg are ignored.  On Linux,  this  command
              can  change  only  the  O_APPEND, O_ASYNC, O_DIRECT, O_NOATIME, and O_NONBLOCK flags.  It is not possible to
              change the O_DSYNC and O_SYNC flags; see BUGS, below.

   Advisory record locking
       Linux implements traditional ("process-associated") UNIX record locks, as standardized by POSIX.  For a  Linux-spe‐
       cific alternative with better semantics, see the discussion of open file description locks below.

       F_SETLK, F_SETLKW, and F_GETLK are used to acquire, release, and test for the existence of record locks (also known
       as byte-range, file-segment, or file-region locks).  The third argument, lock, is a pointer to a structure that has
       at least the following fields (in unspecified order).

           struct flock {
               ...
               short l_type;    /* Type of lock: F_RDLCK,
                                   F_WRLCK, F_UNLCK */
               short l_whence;  /* How to interpret l_start:
                                   SEEK_SET, SEEK_CUR, SEEK_END */
               off_t l_start;   /* Starting offset for lock */
               off_t l_len;     /* Number of bytes to lock */
               pid_t l_pid;     /* PID of process blocking our lock
                                   (set by F_GETLK and F_OFD_GETLK) */
               ...
           };

       The  l_whence,  l_start, and l_len fields of this structure specify the range of bytes we wish to lock.  Bytes past
       the end of the file may be locked, but not bytes before the start of the file.

       l_start is the starting offset for the lock, and is interpreted relative to either:  the  start  of  the  file  (if
       l_whence  is  SEEK_SET);  the current file offset (if l_whence is SEEK_CUR); or the end of the file (if l_whence is
       SEEK_END).  In the final two cases, l_start can be a negative number provided the offset does not  lie  before  the
       start of the file.

       l_len  specifies  the number of bytes to be locked.  If l_len is positive, then the range to be locked covers bytes
       l_start up to and including l_start+l_len-1.  Specifying 0 for l_len has the special meaning: lock all bytes start‐
       ing  at  the  location  specified  by l_whence and l_start through to the end of file, no matter how large the file
       grows.

       POSIX.1-2001 allows (but does not require) an implementation to support a negative l_len value; if l_len  is  nega‐
       tive,  the  interval described by lock covers bytes l_start+l_len up to and including l_start-1.  This is supported
       by Linux since kernel versions 2.4.21 and 2.5.49.

       The l_type field can be used to place a read (F_RDLCK) or a write (F_WRLCK) lock on a file.   Any  number  of  pro‐
       cesses  may  hold a read lock (shared lock) on a file region, but only one process may hold a write lock (exclusive
       lock).  An exclusive lock excludes all other locks, both shared and exclusive.  A single process can hold only  one
       type of lock on a file region; if a new lock is applied to an already-locked region, then the existing lock is con‐
       verted to the new lock type.  (Such conversions may involve splitting, shrinking, or coalescing  with  an  existing
       lock if the byte range specified by the new lock does not precisely coincide with the range of the existing lock.)

       F_SETLK (struct flock *)
              Acquire  a  lock (when l_type is F_RDLCK or F_WRLCK) or release a lock (when l_type is F_UNLCK) on the bytes
              specified by the l_whence, l_start, and l_len fields of lock.  If a conflicting  lock  is  held  by  another
              process,  this call returns -1 and sets errno to EACCES or EAGAIN.  (The error returned in this case differs
              across implementations, so POSIX requires a portable application to check for both errors.)

       F_SETLKW (struct flock *)
              As for F_SETLK, but if a conflicting lock is held on the file, then wait for that lock to be released.  If a
              signal  is  caught  while  waiting, then the call is interrupted and (after the signal handler has returned)
              returns immediately (with return value -1 and errno set to EINTR; see signal(7)).

       F_GETLK (struct flock *)
              On input to this call, lock describes a lock we would like to place on the  file.   If  the  lock  could  be
              placed,  fcntl()  does not actually place it, but returns F_UNLCK in the l_type field of lock and leaves the
              other fields of the structure unchanged.

              If one or more incompatible locks would prevent this lock being placed, then fcntl() returns  details  about
              one of those locks in the l_type, l_whence, l_start, and l_len fields of lock.  If the conflicting lock is a
              traditional (process-associated) record lock, then the l_pid field is set to the PID of the process  holding
              that  lock.   If  the conflicting lock is an open file description lock, then l_pid is set to -1.  Note that
              the returned information may already be out of date by the time the caller inspects it.

       In order to place a read lock, fd must be open for reading.  In order to place a write lock, fd must  be  open  for
       writing.  To place both types of lock, open a file read-write.

       When  placing  locks  with  F_SETLKW,  the  kernel detects deadlocks, whereby two or more processes have their lock
       requests mutually blocked by locks held by the other processes.  For example, suppose process A holds a write  lock
       on  byte  100  of  a file, and process B holds a write lock on byte 200.  If each process then attempts to lock the
       byte already locked by the other process using F_SETLKW, then, without deadlock  detection,  both  processes  would
       remain  blocked  indefinitely.  When the kernel detects such deadlocks, it causes one of the blocking lock requests
       to immediately fail with the error EDEADLK; an application that encounters such an error should release some of its
       locks  to  allow other applications to proceed before attempting regain the locks that it requires.  Circular dead‐
       locks involving more than two processes are also detected.  Note, however, that there are limitations to  the  ker‐
       nel's deadlock-detection algorithm; see BUGS.

       As  well  as  being removed by an explicit F_UNLCK, record locks are automatically released when the process termi‐
       nates.

       Record locks are not inherited by a child created via fork(2), but are preserved across an execve(2).

       Because of the buffering performed by the stdio(3) library, the use of record locking with routines in that package
       should be avoided; use read(2) and write(2) instead.

       The  record locks described above are associated with the process (unlike the open file description locks described
       below).  This has some unfortunate consequences:

       *  If a process closes any file descriptor referring to a file, then all of the process's locks on  that  file  are
          released,  regardless  of the file descriptor(s) on which the locks were obtained.  This is bad: it means that a
          process can lose its locks on a file such as /etc/passwd or /etc/mtab when for some reason  a  library  function
          decides to open, read, and close the same file.

       *  The  threads  in  a  process  share  locks.  In other words, a multithreaded program can't use record locking to
          ensure that threads don't simultaneously access the same region of a file.

       Open file description locks solve both of these problems.

   Open file description locks (non-POSIX)
       Open file description locks are advisory byte-range locks whose operation is in most respects identical to the tra‐
       ditional  record  locks described above.  This lock type is Linux-specific, and available since Linux 3.15.  (There
       is a proposal with the Austin Group to include this lock type in the next revision of POSIX.1.)  For an explanation
       of open file descriptions, see open(2).

       The  principal difference between the two lock types is that whereas traditional record locks are associated with a
       process, open file description locks are associated with the open file description on which they are acquired, much
       like locks acquired with flock(2).  Consequently (and unlike traditional advisory record locks), open file descrip‐
       tion locks are inherited across fork(2) (and clone(2) with CLONE_FILES), and are only automatically released on the
       last close of the open file description, instead of being released on any close of the file.

       Conflicting  lock  combinations  (i.e.,  a read lock and a write lock or two write locks) where one lock is an open
       file description lock and the other is a traditional record lock conflict even when they are acquired by  the  same
       process on the same file descriptor.

       Open file description locks placed via the same open file description (i.e., via the same file descriptor, or via a
       duplicate of the file descriptor created by fork(2), dup(2), fcntl() F_DUPFD, and so on) are always compatible:  if
       a  new lock is placed on an already locked region, then the existing lock is converted to the new lock type.  (Such
       conversions may result in splitting, shrinking, or coalescing with an existing lock as discussed above.)

       On the other hand, open file description locks may conflict with each other when they are  acquired  via  different
       open  file  descriptions.  Thus, the threads in a multithreaded program can use open file description locks to syn‐
       chronize access to a file region by having each thread perform its own open(2) on the file and applying  locks  via
       the resulting file descriptor.

       As  with  traditional  advisory locks, the third argument to fcntl(), lock, is a pointer to an flock structure.  By
       contrast with traditional record locks, the l_pid field of that structure must be set to zero when using  the  com‐
       mands described below.

       The commands for working with open file description locks are analogous to those used with traditional locks:

       F_OFD_SETLK (struct flock *)
              Acquire  an  open file description lock (when l_type is F_RDLCK or F_WRLCK) or release an open file descrip‐
              tion lock (when l_type is F_UNLCK) on the bytes specified by the l_whence,  l_start,  and  l_len  fields  of
              lock.  If a conflicting lock is held by another process, this call returns -1 and sets errno to EAGAIN.

       F_OFD_SETLKW (struct flock *)
              As  for  F_OFD_SETLK, but if a conflicting lock is held on the file, then wait for that lock to be released.
              If a signal is caught while waiting, then the  call  is  interrupted  and  (after  the  signal  handler  has
              returned) returns immediately (with return value -1 and errno set to EINTR; see signal(7)).

       F_OFD_GETLK (struct flock *)
              On  input to this call, lock describes an open file description lock we would like to place on the file.  If
              the lock could be placed, fcntl() does not actually place it, but returns F_UNLCK in  the  l_type  field  of
              lock  and  leaves the other fields of the structure unchanged.  If one or more incompatible locks would pre‐
              vent this lock being placed, then details about one of these locks are returned via lock, as described above
              for F_GETLK.

       In the current implementation, no deadlock detection is performed for open file description locks.  (This contrasts
       with process-associated record locks, for which the kernel does perform deadlock detection.)

   Mandatory locking
       Warning: the Linux implementation of mandatory locking is unreliable.  See BUGS below.  Because of these bugs,  and
       the  fact  that  the  feature  is  believed  to be little used, since Linux 4.5, mandatory locking has been made an
       optional feature, governed by a configuration option (CONFIG_MANDATORY_FILE_LOCKING).   This  is  an  initial  step
       toward removing this feature completely.

       By  default,  both  traditional (process-associated) and open file description record locks are advisory.  Advisory
       locks are not enforced and are useful only between cooperating processes.

       Both lock types can also be mandatory.  Mandatory locks are enforced for all processes.  If a process tries to per‐
       form  an  incompatible access (e.g., read(2) or write(2)) on a file region that has an incompatible mandatory lock,
       then the result depends upon whether the O_NONBLOCK flag is enabled for its open file description.  If  the  O_NON‐
       BLOCK flag is not enabled, then the system call is blocked until the lock is removed or converted to a mode that is
       compatible with the access.  If the O_NONBLOCK flag is enabled, then the system call fails with the error EAGAIN.

       To make use of mandatory locks, mandatory locking must be enabled both on the filesystem that contains the file  to
       be  locked,  and  on  the  file itself.  Mandatory locking is enabled on a filesystem using the "-o mand" option to
       mount(8), or the MS_MANDLOCK flag for mount(2).  Mandatory locking is enabled on a file by disabling group  execute
       permission on the file and enabling the set-group-ID permission bit (see chmod(1) and chmod(2)).

       Mandatory  locking  is  not  specified  by  POSIX.  Some other systems also support mandatory locking, although the
       details of how to enable it vary across systems.

   Lost locks
       When an advisory lock is obtained on a networked filesystem such as NFS it is possible  that  the  lock  might  get
       lost.   This  may  happen  due to administrative action on the server, or due to a network partition (i.e., loss of
       network connectivity with the server) which lasts long enough for the server to assume that the client is no longer
       functioning.

       When  the  filesystem  determines  that a lock has been lost, future read(2) or write(2) requests may fail with the
       error EIO.  This error will persist until the lock is removed or the file descriptor is closed.  Since Linux  3.12,
       this happens at least for NFSv4 (including all minor versions).

       Some  versions  of  UNIX send a signal (SIGLOST) in this circumstance.  Linux does not define this signal, and does
       not provide any asynchronous notification of lost locks.

   Managing signals
       F_GETOWN, F_SETOWN, F_GETOWN_EX, F_SETOWN_EX, F_GETSIG and F_SETSIG are used to manage I/O availability signals:

       F_GETOWN (void)
              Return (as the function result) the process ID or process group currently receiving SIGIO and SIGURG signals
              for  events  on  file  descriptor  fd.   Process  IDs are returned as positive values; process group IDs are
              returned as negative values (but see BUGS below).  arg is ignored.

       F_SETOWN (int)
              Set the process ID or process group ID that will receive SIGIO and SIGURG signals for  events  on  the  file
              descriptor  fd.  The target process or process group ID is specified in arg.  A process ID is specified as a
              positive value; a process group ID is specified as a negative value.  Most  commonly,  the  calling  process
              specifies itself as the owner (that is, arg is specified as getpid(2)).

              As  well  as  setting  the  file  descriptor  owner,  one must also enable generation of signals on the file
              descriptor.  This is done by using the fcntl() F_SETFL command to set the O_ASYNC file status  flag  on  the
              file descriptor.  Subsequently, a SIGIO signal is sent whenever input or output becomes possible on the file
              descriptor.  The fcntl() F_SETSIG command can be used to obtain delivery of a signal other than SIGIO.

              Sending a signal to the owner process (group) specified by F_SETOWN  is  subject  to  the  same  permissions
              checks  as  are  described  for kill(2), where the sending process is the one that employs F_SETOWN (but see
              BUGS below).  If this permission check fails, then the signal is silently  discarded.   Note:  The  F_SETOWN
              operation  records  the  caller's credentials at the time of the fcntl() call, and it is these saved creden‐
              tials that are used for the permission checks.

              If the file descriptor fd refers to a socket, F_SETOWN also selects the recipient of SIGURG signals that are
              delivered  when  out-of-band  data arrives on that socket.  (SIGURG is sent in any situation where select(2)
              would report the socket as having an "exceptional condition".)

              The following was true in 2.6.x kernels up to and including kernel 2.6.11:

                     If a nonzero value is given to F_SETSIG in a multithreaded process running with a  threading  library
                     that  supports  thread  groups  (e.g., NPTL), then a positive value given to F_SETOWN has a different
                     meaning: instead of being a process ID identifying a whole process, it is a thread ID  identifying  a
                     specific  thread  within a process.  Consequently, it may be necessary to pass F_SETOWN the result of
                     gettid(2) instead of getpid(2) to get sensible results when F_SETSIG  is  used.   (In  current  Linux
                     threading  implementations, a main thread's thread ID is the same as its process ID.  This means that
                     a single-threaded program can equally use gettid(2) or getpid(2) in this scenario.)   Note,  however,
                     that  the  statements  in  this paragraph do not apply to the SIGURG signal generated for out-of-band
                     data on a socket: this signal is always sent to either a process or a process group, depending on the
                     value given to F_SETOWN.

              The  above  behavior  was  accidentally  dropped  in Linux 2.6.12, and won't be restored.  From Linux 2.6.32
              onward, use F_SETOWN_EX to target SIGIO and SIGURG signals at a particular thread.

       F_GETOWN_EX (struct f_owner_ex *) (since Linux 2.6.32)
              Return the current file descriptor owner settings as defined  by  a  previous  F_SETOWN_EX  operation.   The
              information is returned in the structure pointed to by arg, which has the following form:

                  struct f_owner_ex {
                      int   type;
                      pid_t pid;
                  };

              The  type  field  will have one of the values F_OWNER_TID, F_OWNER_PID, or F_OWNER_PGRP.  The pid field is a
              positive integer representing a thread ID, process ID, or  process  group  ID.   See  F_SETOWN_EX  for  more
              details.

       F_SETOWN_EX (struct f_owner_ex *) (since Linux 2.6.32)
              This operation performs a similar task to F_SETOWN.  It allows the caller to direct I/O availability signals
              to a specific thread, process, or process group.  The caller specifies the target of signals via arg,  which
              is  a  pointer  to a f_owner_ex structure.  The type field has one of the following values, which define how
              pid is interpreted:

              F_OWNER_TID
                     Send the signal to the thread whose thread ID (the value returned by a call to clone(2) or gettid(2))
                     is specified in pid.

              F_OWNER_PID
                     Send the signal to the process whose ID is specified in pid.

              F_OWNER_PGRP
                     Send the signal to the process group whose ID is specified in pid.  (Note that, unlike with F_SETOWN,
                     a process group ID is specified as a positive value here.)

       F_GETSIG (void)
              Return (as the function result) the signal sent when input or output becomes  possible.   A  value  of  zero
              means  SIGIO  is sent.  Any other value (including SIGIO) is the signal sent instead, and in this case addi‐
              tional info is available to the signal handler if installed with SA_SIGINFO.  arg is ignored.

       F_SETSIG (int)
              Set the signal sent when input or output becomes possible to the value given in arg.  A value of zero  means
              to  send  the default SIGIO signal.  Any other value (including SIGIO) is the signal to send instead, and in
              this case additional info is available to the signal handler if installed with SA_SIGINFO.

              By using F_SETSIG with a nonzero value, and setting SA_SIGINFO for the signal  handler  (see  sigaction(2)),
              extra  information about I/O events is passed to the handler in a siginfo_t structure.  If the si_code field
              indicates the source is SI_SIGIO, the si_fd field gives the file descriptor associated with the event.  Oth‐
              erwise,  there  is no indication which file descriptors are pending, and you should use the usual mechanisms
              (select(2), poll(2), read(2) with O_NONBLOCK set etc.) to determine which file descriptors are available for
              I/O.

              Note that the file descriptor provided in si_fd is the one that was specified during the F_SETSIG operation.
              This can lead to an unusual corner case.  If the file descriptor is duplicated (dup(2) or similar), and  the
              original  file descriptor is closed, then I/O events will continue to be generated, but the si_fd field will
              contain the number of the now closed file descriptor.

              By selecting a real time signal (value >= SIGRTMIN), multiple I/O events may be queued using the same signal
              numbers.   (Queuing  is dependent on available memory.)  Extra information is available if SA_SIGINFO is set
              for the signal handler, as above.

              Note that Linux imposes a limit on the number of real-time signals that may be  queued  to  a  process  (see
              getrlimit(2)  and  signal(7)) and if this limit is reached, then the kernel reverts to delivering SIGIO, and
              this signal is delivered to the entire process rather than to a specific thread.

       Using these mechanisms, a program can implement fully asynchronous I/O without using select(2) or poll(2)  most  of
       the time.

       The  use of O_ASYNC is specific to BSD and Linux.  The only use of F_GETOWN and F_SETOWN specified in POSIX.1 is in
       conjunction with the use of the SIGURG signal on sockets.  (POSIX does not specify the SIGIO signal.)  F_GETOWN_EX,
       F_SETOWN_EX,  F_GETSIG, and F_SETSIG are Linux-specific.  POSIX has asynchronous I/O and the aio_sigevent structure
       to achieve similar things; these are also available in Linux as part of the GNU C Library (Glibc).

   Leases
       F_SETLEASE and F_GETLEASE (Linux 2.4 onward) are used (respectively) to establish a new  lease,  and  retrieve  the
       current  lease, on the open file description referred to by the file descriptor fd.  A file lease provides a mecha‐
       nism whereby the process holding the lease (the "lease holder") is notified (via  delivery  of  a  signal)  when  a
       process (the "lease breaker") tries to open(2) or truncate(2) the file referred to by that file descriptor.

       F_SETLEASE (int)
              Set or remove a file lease according to which of the following values is specified in the integer arg:

              F_RDLCK
                     Take  out  a  read lease.  This will cause the calling process to be notified when the file is opened
                     for writing or is truncated.  A read lease can be placed only on a file  descriptor  that  is  opened
                     read-only.

              F_WRLCK
                     Take  out a write lease.  This will cause the caller to be notified when the file is opened for read‐
                     ing or writing or is truncated.  A write lease may be placed on a file only if  there  are  no  other
                     open file descriptors for the file.

              F_UNLCK
                     Remove our lease from the file.

       Leases  are  associated  with  an  open file description (see open(2)).  This means that duplicate file descriptors
       (created by, for example, fork(2) or dup(2)) refer to the same lease, and this lease may be  modified  or  released
       using  any of these descriptors.  Furthermore, the lease is released by either an explicit F_UNLCK operation on any
       of these duplicate file descriptors, or when all such file descriptors have been closed.

       Leases may be taken out only on regular files.  An unprivileged process may take out a lease only on a  file  whose
       UID (owner) matches the filesystem UID of the process.  A process with the CAP_LEASE capability may take out leases
       on arbitrary files.

       F_GETLEASE (void)
              Indicates what type of lease is associated with the file descriptor fd by returning either F_RDLCK, F_WRLCK,
              or F_UNLCK, indicating, respectively, a read lease , a write lease, or no lease.  arg is ignored.

       When a process (the "lease breaker") performs an open(2) or truncate(2) that conflicts with a lease established via
       F_SETLEASE, the system call is blocked by the kernel and the kernel notifies the lease holder by sending it a  sig‐
       nal  (SIGIO  by  default).   The lease holder should respond to receipt of this signal by doing whatever cleanup is
       required in preparation for the file to be accessed by another process (e.g., flushing  cached  buffers)  and  then
       either  remove  or  downgrade  its lease.  A lease is removed by performing an F_SETLEASE command specifying arg as
       F_UNLCK.  If the lease holder currently holds a write lease on the file, and the lease breaker is opening the  file
       for  reading,  then  it is sufficient for the lease holder to downgrade the lease to a read lease.  This is done by
       performing an F_SETLEASE command specifying arg as F_RDLCK.

       If the lease  holder  fails  to  downgrade  or  remove  the  lease  within  the  number  of  seconds  specified  in
       /proc/sys/fs/lease-break-time, then the kernel forcibly removes or downgrades the lease holder's lease.

       Once a lease break has been initiated, F_GETLEASE returns the target lease type (either F_RDLCK or F_UNLCK, depend‐
       ing on what would be compatible with the lease breaker) until the lease holder voluntarily  downgrades  or  removes
       the lease or the kernel forcibly does so after the lease break timer expires.

       Once  the  lease  has  been  voluntarily  or forcibly removed or downgraded, and assuming the lease breaker has not
       unblocked its system call, the kernel permits the lease breaker's system call to proceed.

       If the lease breaker's blocked open(2) or truncate(2) is interrupted by a signal  handler,  then  the  system  call
       fails  with the error EINTR, but the other steps still occur as described above.  If the lease breaker is killed by
       a signal while blocked in open(2) or truncate(2), then the other steps still occur  as  described  above.   If  the
       lease  breaker  specifies  the O_NONBLOCK flag when calling open(2), then the call immediately fails with the error
       EWOULDBLOCK, but the other steps still occur as described above.

       The default signal used to notify the lease holder is SIGIO, but this can be changed using the F_SETSIG command  to
       fcntl().   If  a  F_SETSIG  command is performed (even one specifying SIGIO), and the signal handler is established
       using SA_SIGINFO, then the handler will receive a siginfo_t structure as its second argument, and the  si_fd  field
       of this argument will hold the file descriptor of the leased file that has been accessed by another process.  (This
       is useful if the caller holds leases against multiple files.)

   File and directory change notification (dnotify)
       F_NOTIFY (int)
              (Linux 2.4 onward) Provide notification when the directory referred to by fd or any of  the  files  that  it
              contains is changed.  The events to be notified are specified in arg, which is a bit mask specified by ORing
              together zero or more of the following bits:

              DN_ACCESS   A file was accessed (read(2), pread(2), readv(2), and similar)
              DN_MODIFY   A file was modified (write(2), pwrite(2), writev(2), truncate(2), ftruncate(2), and similar).
              DN_CREATE   A file was created (open(2), creat(2), mknod(2), mkdir(2), link(2), symlink(2),  rename(2)  into
                          this directory).
              DN_DELETE   A file was unlinked (unlink(2), rename(2) to another directory, rmdir(2)).
              DN_RENAME   A file was renamed within this directory (rename(2)).
              DN_ATTRIB   The attributes of a file were changed (chown(2), chmod(2), utime(2), utimensat(2), and similar).

              (In  order  to obtain these definitions, the _GNU_SOURCE feature test macro must be defined before including
              any header files.)

              Directory notifications are normally "one-shot", and the application  must  reregister  to  receive  further
              notifications.   Alternatively,  if DN_MULTISHOT is included in arg, then notification will remain in effect
              until explicitly removed.

              A series of F_NOTIFY requests is cumulative, with the events in arg being added to  the  set  already  moni‐
              tored.  To disable notification of all events, make an F_NOTIFY call specifying arg as 0.

              Notification  occurs  via  delivery of a signal.  The default signal is SIGIO, but this can be changed using
              the F_SETSIG command to fcntl().  (Note that SIGIO is one of the nonqueuing standard signals;  switching  to
              the  use of a real-time signal means that multiple notifications can be queued to the process.)  In the lat‐
              ter case, the signal handler receives a siginfo_t structure as its  second  argument  (if  the  handler  was
              established  using SA_SIGINFO) and the si_fd field of this structure contains the file descriptor which gen‐
              erated the notification (useful when establishing notification on multiple directories).

              Especially when using DN_MULTISHOT, a real time signal should be used for  notification,  so  that  multiple
              notifications can be queued.

              NOTE:  New  applications  should use the inotify interface (available since kernel 2.6.13), which provides a
              much superior interface for obtaining notifications of filesystem events.  See inotify(7).

   Changing the capacity of a pipe
       F_SETPIPE_SZ (int; since Linux 2.6.35)
              Change the capacity of the pipe referred to by fd to be at least arg bytes.   An  unprivileged  process  can
              adjust   the  pipe  capacity  to  any  value  between  the  system  page  size  and  the  limit  defined  in
              /proc/sys/fs/pipe-max-size (see proc(5)).  Attempts to set  the  pipe  capacity  below  the  page  size  are
              silently  rounded  up  to the page size.  Attempts by an unprivileged process to set the pipe capacity above
              the limit in /proc/sys/fs/pipe-max-size yield the error EPERM; a privileged process  (CAP_SYS_RESOURCE)  can
              override the limit.

              When  allocating  the  buffer for the pipe, the kernel may use a capacity larger than arg, if that is conve‐
              nient for the implementation.  (In the current implementation, the allocation is the next  higher  power-of-
              two  page-size  multiple  of the requested size.)  The actual capacity (in bytes) that is set is returned as
              the function result.

              Attempting to set the pipe capacity smaller than the amount of buffer space currently  used  to  store  data
              produces the error EBUSY.

       F_GETPIPE_SZ (void; since Linux 2.6.35)
              Return (as the function result) the capacity of the pipe referred to by fd.

   File Sealing
       File  seals  limit  the set of allowed operations on a given file.  For each seal that is set on a file, a specific
       set of operations will fail with EPERM on this file from now on.  The file is said to be sealed.  The  default  set
       of  seals depends on the type of the underlying file and filesystem.  For an overview of file sealing, a discussion
       of its purpose, and some code examples, see memfd_create(2).

       Currently, file seals can be applied only to a file descriptor returned by memfd_create(2) (if the  MFD_ALLOW_SEAL‐
       ING was employed).  On other filesystems, all fcntl() operations that operate on seals will return EINVAL.

       Seals  are  a property of an inode.  Thus, all open file descriptors referring to the same inode share the same set
       of seals.  Furthermore, seals can never be removed, only added.

       F_ADD_SEALS (int; since Linux 3.17)
              Add the seals given in the bit-mask argument arg to the set of seals of the inode referred to  by  the  file
              descriptor  fd.  Seals cannot be removed again.  Once this call succeeds, the seals are enforced by the ker‐
              nel immediately.  If the current set of seals includes F_SEAL_SEAL (see  below),  then  this  call  will  be
              rejected  with EPERM.  Adding a seal that is already set is a no-op, in case F_SEAL_SEAL is not set already.
              In order to place a seal, the file descriptor fd must be writable.

       F_GET_SEALS (void; since Linux 3.17)
              Return (as the function result) the current set of seals of the inode referred to by fd.  If  no  seals  are
              set, 0 is returned.  If the file does not support sealing, -1 is returned and errno is set to EINVAL.

       The following seals are available:

       F_SEAL_SEAL
              If  this  seal  is set, any further call to fcntl() with F_ADD_SEALS fails with the error EPERM.  Therefore,
              this seal prevents any modifications to the set of seals itself.  If the initial set  of  seals  of  a  file
              includes F_SEAL_SEAL, then this effectively causes the set of seals to be constant and locked.

       F_SEAL_SHRINK
              If  this seal is set, the file in question cannot be reduced in size.  This affects open(2) with the O_TRUNC
              flag as well as truncate(2) and ftruncate(2).  Those calls fail with EPERM if you try to shrink the file  in
              question.  Increasing the file size is still possible.

       F_SEAL_GROW
              If this seal is set, the size of the file in question cannot be increased.  This affects write(2) beyond the
              end of the file, truncate(2), ftruncate(2), and fallocate(2).  These calls fail with EPERM if you  use  them
              to increase the file size.  If you keep the size or shrink it, those calls still work as expected.

       F_SEAL_WRITE
              If this seal is set, you cannot modify the contents of the file.  Note that shrinking or growing the size of
              the file is still possible and allowed.  Thus, this seal is normally used in combination  with  one  of  the
              other seals.  This seal affects write(2) and fallocate(2) (only in combination with the FALLOC_FL_PUNCH_HOLE
              flag).  Those calls fail with EPERM if this seal is set.  Furthermore, trying to create new shared, writable
              memory-mappings via mmap(2) will also fail with EPERM.

              Using  the  F_ADD_SEALS operation to set the F_SEAL_WRITE seal fails with EBUSY if any writable, shared map‐
              ping exists.  Such mappings must be unmapped before you can add this seal.  Furthermore, if  there  are  any
              asynchronous I/O operations (io_submit(2)) pending on the file, all outstanding writes will be discarded.

   File read/write hints
       Write  lifetime  hints  can  be used to inform the kernel about the relative expected lifetime of writes on a given
       inode or via a particular open file description.  (See open(2) for an explanation of open file  descriptions.)   In
       this context, the term "write lifetime" means the expected time the data will live on media, before being overwrit‐
       ten or erased.

       An application may use the different hint values specified below to separate writes into different  write  classes,
       so  that  multiple users or applications running on a single storage back-end can aggregate their I/O patterns in a
       consistent manner.  However, there are no functional semantics implied by these flags, and  different  I/O  classes
       can use the write lifetime hints in arbitrary ways, so long as the hints are used consistently.

       The following operations can be applied to the file descriptor, fd:

       F_GET_RW_HINT (uint64_t *; since Linux 4.13)
              Returns the value of the read/write hint associated with the underlying inode referred to by fd.

       F_SET_RW_HINT (uint64_t *; since Linux 4.13)
              Sets  the  read/write hint value associated with the underlying inode referred to by fd.  This hint persists
              until either it is explicitly modified or the underlying filesystem is unmounted.

       F_GET_FILE_RW_HINT (uint64_t *; since Linux 4.13)
              Returns the value of the read/write hint associated with the open file description referred to by fd.

       F_SET_FILE_RW_HINT (uint64_t *; since Linux 4.13)
              Sets the read/write hint value associated with the open file description referred to by fd.

       If an open file description has not been assigned a read/write hint, then it shall use the value  assigned  to  the
       inode, if any.

       The following read/write hints are valid since Linux 4.13:

       RWH_WRITE_LIFE_NOT_SET
              No specific hint has been set.  This is the default value.

       RWH_WRITE_LIFE_NONE
              No specific write lifetime is associated with this file or inode.

       RWH_WRITE_LIFE_SHORT
              Data written to this inode or via this open file description is expected to have a short lifetime.

       RWH_WRITE_LIFE_MEDIUM
              Data written to this inode or via this open file description is expected to have a lifetime longer than data
              written with RWH_WRITE_LIFE_SHORT.

       RWH_WRITE_LIFE_LONG
              Data written to this inode or via this open file description is expected to have a lifetime longer than data
              written with RWH_WRITE_LIFE_MEDIUM.

       RWH_WRITE_LIFE_EXTREME
              Data written to this inode or via this open file description is expected to have a lifetime longer than data
              written with RWH_WRITE_LIFE_LONG.

       All the write-specific hints are relative to each other, and no individual absolute meaning should be attributed to
       them.

RETURN VALUE
       For a successful call, the return value depends on the operation:

       F_DUPFD  The new file descriptor.

       F_GETFD  Value of file descriptor flags.

       F_GETFL  Value of file status flags.

       F_GETLEASE
                Type of lease held on file descriptor.

       F_GETOWN Value of file descriptor owner.

       F_GETSIG Value of signal sent when read or write becomes possible, or zero for traditional SIGIO behavior.

       F_GETPIPE_SZ, F_SETPIPE_SZ
                The pipe capacity.

       F_GET_SEALS
                A bit mask identifying the seals that have been set for the inode referred to by fd.

       All other commands
                Zero.

       On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES or EAGAIN
              Operation is prohibited by locks held by other processes.

       EAGAIN The operation is prohibited because the file has been memory-mapped by another process.

       EBADF  fd is not an open file descriptor

       EBADF  cmd is F_SETLK or F_SETLKW and the file descriptor open mode doesn't match with the type of lock requested.

       EBUSY  cmd  is  F_SETPIPE_SZ  and the new pipe capacity specified in arg is smaller than the amount of buffer space
              currently used to store data in the pipe.

       EBUSY  cmd is F_ADD_SEALS, arg includes F_SEAL_WRITE, and there exists a  writable,  shared  mapping  on  the  file
              referred to by fd.

       EDEADLK
              It was detected that the specified F_SETLKW command would cause a deadlock.

       EFAULT lock is outside your accessible address space.

       EINTR  cmd is F_SETLKW or F_OFD_SETLKW and the operation was interrupted by a signal; see signal(7).

       EINTR  cmd  is  F_GETLK, F_SETLK, F_OFD_GETLK, or F_OFD_SETLK, and the operation was interrupted by a signal before
              the lock was checked or acquired.  Most likely when locking a remote file (e.g., locking over NFS), but  can
              sometimes happen locally.

       EINVAL The value specified in cmd is not recognized by this kernel.

       EINVAL cmd is F_ADD_SEALS and arg includes an unrecognized sealing bit.

       EINVAL cmd is F_ADD_SEALS or F_GET_SEALS and the filesystem containing the inode referred to by fd does not support
              sealing.

       EINVAL cmd is F_DUPFD and arg is negative or is greater than the maximum allowable value  (see  the  discussion  of
              RLIMIT_NOFILE in getrlimit(2)).

       EINVAL cmd is F_SETSIG and arg is not an allowable signal number.

       EINVAL cmd is F_OFD_SETLK, F_OFD_SETLKW, or F_OFD_GETLK, and l_pid was not specified as zero.

       EMFILE cmd is F_DUPFD and the per-process limit on the number of open file descriptors has been reached.

       ENOLCK Too  many  segment  locks  open, lock table is full, or a remote locking protocol failed (e.g., locking over
              NFS).

       ENOTDIR
              F_NOTIFY was specified in cmd, but fd does not refer to a directory.

       EPERM  cmd is F_SETPIPE_SZ and the soft or hard user pipe limit has been reached; see pipe(7).

       EPERM  Attempted to clear the O_APPEND flag on a file that has the append-only attribute set.

       EPERM  cmd was F_ADD_SEALS, but fd was not open for writing or the  current  set  of  seals  on  the  file  already
              includes F_SEAL_SEAL.

CONFORMING TO
       SVr4, 4.3BSD, POSIX.1-2001.  Only the operations F_DUPFD, F_GETFD, F_SETFD, F_GETFL, F_SETFL, F_GETLK, F_SETLK, and
       F_SETLKW are specified in POSIX.1-2001.

       F_GETOWN and F_SETOWN are specified in POSIX.1-2001.  (To get their definitions, define either  _XOPEN_SOURCE  with
       the value 500 or greater, or _POSIX_C_SOURCE with the value 200809L or greater.)

       F_DUPFD_CLOEXEC  is  specified  in  POSIX.1-2008.   (To  get this definition, define _POSIX_C_SOURCE with the value
       200809L or greater, or _XOPEN_SOURCE with the value 700 or greater.)

       F_GETOWN_EX, F_SETOWN_EX, F_SETPIPE_SZ, F_GETPIPE_SZ, F_GETSIG, F_SETSIG, F_NOTIFY, F_GETLEASE, and F_SETLEASE  are
       Linux-specific.  (Define the _GNU_SOURCE macro to obtain these definitions.)

       F_OFD_SETLK, F_OFD_SETLKW, and F_OFD_GETLK are Linux-specific (and one must define _GNU_SOURCE to obtain their def‐
       initions), but work is being done to have them included in the next version of POSIX.1.

       F_ADD_SEALS and F_GET_SEALS are Linux-specific.

NOTES
       The errors returned by dup2(2) are different from those returned by F_DUPFD.

   File locking
       The original Linux fcntl() system call was not designed to handle large file  offsets  (in  the  flock  structure).
       Consequently, an fcntl64() system call was added in Linux 2.4.  The newer system call employs a different structure
       for file locking, flock64, and corresponding  commands,  F_GETLK64,  F_SETLK64,  and  F_SETLKW64.   However,  these
       details  can  be ignored by applications using glibc, whose fcntl() wrapper function transparently employs the more
       recent system call where it is available.

   Record locks
       Since kernel 2.0, there is no interaction between the types of lock placed by flock(2) and fcntl().

       Several systems have more fields in struct flock such as, for example, l_sysid.  Clearly, l_pid alone is not  going
       to be very useful if the process holding the lock may live on a different machine.

       The  original  Linux  fcntl()  system  call was not designed to handle large file offsets (in the flock structure).
       Consequently, an fcntl64() system call was added in Linux 2.4.  The newer system call employs a different structure
       for  file  locking,  flock64,  and  corresponding  commands,  F_GETLK64, F_SETLK64, and F_SETLKW64.  However, these
       details can be ignored by applications using glibc, whose fcntl() wrapper function transparently employs  the  more
       recent system call where it is available.

   Record locking and NFS
       Before  Linux  3.12, if an NFSv4 client loses contact with the server for a period of time (defined as more than 90
       seconds with no communication), it might lose and regain a lock without ever being aware of the fact.  (The  period
       of  time  after  which contact is assumed lost is known as the NFSv4 leasetime.  On a Linux NFS server, this can be
       determined by looking at /proc/fs/nfsd/nfsv4leasetime, which expresses the period in seconds.   The  default  value
       for  this file is 90.)  This scenario potentially risks data corruption, since another process might acquire a lock
       in the intervening period and perform file I/O.

       Since Linux 3.12, if an NFSv4 client loses contact with the server, any I/O to the file by a process which "thinks"
       it   holds   a   lock   will   fail  until  that  process  closes  and  reopens  the  file.   A  kernel  parameter,
       nfs.recover_lost_locks, can be set to 1 to obtain the pre-3.12 behavior, whereby the client will attempt to recover
       lost  locks  when contact is reestablished with the server.  Because of the attendant risk of data corruption, this
       parameter defaults to 0 (disabled).

BUGS
   F_SETFL
       It is not possible to use F_SETFL to change the state of the O_DSYNC and O_SYNC  flags.   Attempts  to  change  the
       state of these flags are silently ignored.

   F_GETOWN
       A  limitation  of the Linux system call conventions on some architectures (notably i386) means that if a (negative)
       process group ID to be returned by F_GETOWN falls in the range -1 to -4095, then the return value is wrongly inter‐
       preted  by  glibc  as  an error in the system call; that is, the return value of fcntl() will be -1, and errno will
       contain the (positive) process group ID.  The Linux-specific F_GETOWN_EX  operation  avoids  this  problem.   Since
       glibc version 2.11, glibc makes the kernel F_GETOWN problem invisible by implementing F_GETOWN using F_GETOWN_EX.

   F_SETOWN
       In  Linux  2.4  and  earlier, there is bug that can occur when an unprivileged process uses F_SETOWN to specify the
       owner of a socket file descriptor as a process (group) other than the caller.  In this case, fcntl() can return  -1
       with  errno set to EPERM, even when the owner process (group) is one that the caller has permission to send signals
       to.  Despite this error return, the file descriptor owner is set, and signals will be sent to the owner.

   Deadlock detection
       The deadlock-detection algorithm employed by the kernel when dealing with F_SETLKW requests can  yield  both  false
       negatives (failures to detect deadlocks, leaving a set of deadlocked processes blocked indefinitely) and false pos‐
       itives (EDEADLK errors when there is no deadlock).  For example, the kernel limits the lock depth of its dependency
       search to 10 steps, meaning that circular deadlock chains that exceed that size will not be detected.  In addition,
       the kernel may falsely indicate a deadlock when two or more processes created using the clone(2)  CLONE_FILES  flag
       place locks that appear (to the kernel) to conflict.

   Mandatory locking
       The  Linux implementation of mandatory locking is subject to race conditions which render it unreliable: a write(2)
       call that overlaps with a lock may modify data after the mandatory lock is acquired; a read(2) call  that  overlaps
       with  a  lock  may detect changes to data that were made only after a write lock was acquired.  Similar races exist
       between mandatory locks and mmap(2).  It is therefore inadvisable to rely on mandatory locking.

SEE ALSO
       dup2(2), flock(2), open(2), socket(2), lockf(3), capabilities(7), feature_test_macros(7), lslocks(8)

       locks.txt, mandatory-locking.txt, and dnotify.txt in the Linux kernel source  directory  Documentation/filesystems/
       (on older kernels, these files are directly under the Documentation/ directory, and mandatory-locking.txt is called
       mandatory.txt)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-02-02                                                FCNTL(2)
</pre>
<pre zoom>
<span xsmall>2 copy_file_range</span>
COPY_FILE_RANGE(2)                               Linux Programmer's Manual                              COPY_FILE_RANGE(2)

NAME
       copy_file_range - Copy a range of data from one file to another

SYNOPSIS
       #define _GNU_SOURCE
       #include <unistd.h>

       ssize_t copy_file_range(int fd_in, loff_t *off_in,
                               int fd_out, loff_t *off_out,
                               size_t len, unsigned int flags);

DESCRIPTION
       The  copy_file_range()  system  call performs an in-kernel copy between two file descriptors without the additional
       cost of transferring data from the kernel to user space and then back into the kernel.  It copies up to  len  bytes
       of data from file descriptor fd_in to file descriptor fd_out, overwriting any data that exists within the requested
       range of the target file.

       The following semantics apply for off_in, and similar statements apply to off_out:

       *  If off_in is NULL, then bytes are read from fd_in starting from the file offset, and the file offset is adjusted
          by the number of bytes copied.

       *  If  off_in  is  not NULL, then off_in must point to a buffer that specifies the starting offset where bytes from
          fd_in will be read.  The file offset of fd_in is not changed, but off_in is adjusted appropriately.

       The flags argument is provided to allow for future extensions and currently must be to 0.

RETURN VALUE
       Upon successful completion, copy_file_range() will return the number of bytes copied between files.  This could  be
       less than the length originally requested.

       On error, copy_file_range() returns -1 and errno is set to indicate the error.

ERRORS
       EBADF  One  or  more  file  descriptors  are not valid; or fd_in is not open for reading; or fd_out is not open for
              writing; or the O_APPEND flag is set for the open file description referred to by fd_out.

       EFBIG  An attempt was made to write a file that  exceeds  the  implementation-defined  maximum  file  size  or  the
              process's file size limit, or to write at a position past the maximum allowed offset.

       EINVAL Requested range extends beyond the end of the source file; or the flags argument is not 0.

       EIO    A low-level I/O error occurred while copying.

       EISDIR fd_in or fd_out refers to a directory.

       ENOMEM Out of memory.

       ENOSPC There is not enough space on the target filesystem to complete the copy.

       EXDEV  The files referred to by file_in and file_out are not on the same mounted filesystem.

VERSIONS
       The  copy_file_range() system call first appeared in Linux 4.5, but glibc 2.27 provides a user-space emulation when
       it is not available.

CONFORMING TO
       The copy_file_range() system call is a nonstandard Linux and GNU extension.

NOTES
       If file_in is a sparse file, then copy_file_range() may expand any holes existing in the  requested  range.   Users
       may  benefit from calling copy_file_range() in a loop, and using the lseek(2) SEEK_DATA and SEEK_HOLE operations to
       find the locations of data segments.

       copy_file_range() gives filesystems an opportunity to implement "copy acceleration" techniques, such as the use  of
       reflinks  (i.e.,  two or more inodes that share pointers to the same copy-on-write disk blocks) or server-side-copy
       (in the case of NFS).

EXAMPLE
       #define _GNU_SOURCE
       #include <fcntl.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/stat.h>
       #include <sys/syscall.h>
       #include <unistd.h>

       /* On versions of glibc before 2.27, we must invoke copy_file_range()
          using syscall(2) */

       static loff_t
       copy_file_range(int fd_in, loff_t *off_in, int fd_out,
                       loff_t *off_out, size_t len, unsigned int flags)
       {
           return syscall(__NR_copy_file_range, fd_in, off_in, fd_out,
                          off_out, len, flags);
       }

       int
       main(int argc, char **argv)
       {
           int fd_in, fd_out;
           struct stat stat;
           loff_t len, ret;

           if (argc != 3) {
               fprintf(stderr, "Usage: %s <source> <destination>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           fd_in = open(argv[1], O_RDONLY);
           if (fd_in == -1) {
               perror("open (argv[1])");
               exit(EXIT_FAILURE);
           }

           if (fstat(fd_in, &stat) == -1) {
               perror("fstat");
               exit(EXIT_FAILURE);
           }

           len = stat.st_size;

           fd_out = open(argv[2], O_CREAT | O_WRONLY | O_TRUNC, 0644);
           if (fd_out == -1) {
               perror("open (argv[2])");
               exit(EXIT_FAILURE);
           }

           do {
               ret = copy_file_range(fd_in, NULL, fd_out, NULL, len, 0);
               if (ret == -1) {
                   perror("copy_file_range");
                   exit(EXIT_FAILURE);
               }

               len -= ret;
           } while (len > 0);

           close(fd_in);
           close(fd_out);
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       lseek(2), sendfile(2), splice(2)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2018-02-02                                      COPY_FILE_RANGE(2)
</pre>
<pre zoom>
<span xsmall>2 listen</span>
LISTEN(2)                                        Linux Programmer's Manual                                       LISTEN(2)

NAME
       listen - listen for connections on a socket

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>

       int listen(int sockfd, int backlog);

DESCRIPTION
       listen()  marks  the  socket  referred  to by sockfd as a passive socket, that is, as a socket that will be used to
       accept incoming connection requests using accept(2).

       The sockfd argument is a file descriptor that refers to a socket of type SOCK_STREAM or SOCK_SEQPACKET.

       The backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.   If
       a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNRE‐
       FUSED or, if the underlying protocol supports retransmission, the request may be ignored so that a later  reattempt
       at connection succeeds.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EADDRINUSE
              Another socket is already listening on the same port.

       EADDRINUSE
              (Internet  domain sockets) The socket referred to by sockfd had not previously been bound to an address and,
              upon attempting to bind it to an ephemeral port, it was determined that all port numbers  in  the  ephemeral
              port range are currently in use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).

       EBADF  The argument sockfd is not a valid file descriptor.

       ENOTSOCK
              The file descriptor sockfd does not refer to a socket.

       EOPNOTSUPP
              The socket is not of a type that supports the listen() operation.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.4BSD (listen() first appeared in 4.2BSD).

NOTES
       To accept connections, the following steps are performed:

           1.  A socket is created with socket(2).

           2.  The socket is bound to a local address using bind(2), so that other sockets may be connect(2)ed to it.

           3.  A  willingness to accept incoming connections and a queue limit for incoming connections are specified with
               listen().

           4.  Connections are accepted with accept(2).

       POSIX.1 does not require the inclusion of <sys/types.h>, and this header file is not required on  Linux.   However,
       some  historical  (BSD)  implementations  required this header file, and portable applications are probably wise to
       include it.

       The behavior of the backlog argument on TCP sockets changed with Linux 2.2.  Now it specifies the queue length  for
       completely  established  sockets  waiting  to be accepted, instead of the number of incomplete connection requests.
       The maximum length of the queue for incomplete sockets can  be  set  using  /proc/sys/net/ipv4/tcp_max_syn_backlog.
       When  syncookies  are  enabled there is no logical maximum length and this setting is ignored.  See tcp(7) for more
       information.

       If the backlog argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently truncated to
       that  value;  the  default value in this file is 128.  In kernels before 2.4.25, this limit was a hard coded value,
       SOMAXCONN, with the value 128.

EXAMPLE
       See bind(2).

SEE ALSO
       accept(2), bind(2), connect(2), socket(2), socket(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                               LISTEN(2)
</pre>
<pre zoom>
<span xsmall>2 gettimeofday</span>
GETTIMEOFDAY(2)                                  Linux Programmer's Manual                                 GETTIMEOFDAY(2)

NAME
       gettimeofday, settimeofday - get / set time

SYNOPSIS
       #include <sys/time.h>

       int gettimeofday(struct timeval *tv, struct timezone *tz);

       int settimeofday(const struct timeval *tv, const struct timezone *tz);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       settimeofday():
           Since glibc 2.19:
               _DEFAULT_SOURCE
           Glibc 2.19 and earlier:
               _BSD_SOURCE

DESCRIPTION
       The functions gettimeofday() and settimeofday() can get and set the time as well as a timezone.  The tv argument is
       a struct timeval (as specified in <sys/time.h>):

           struct timeval {
               time_t      tv_sec;     /* seconds */
               suseconds_t tv_usec;    /* microseconds */
           };

       and gives the number of seconds and microseconds since the Epoch (see time(2)).  The tz argument is a struct  time‐
       zone:

           struct timezone {
               int tz_minuteswest;     /* minutes west of Greenwich */
               int tz_dsttime;         /* type of DST correction */
           };

       If  either  tv  or  tz is NULL, the corresponding structure is not set or returned.  (However, compilation warnings
       will result if tv is NULL.)

       The use of the timezone structure is obsolete; the tz argument should normally be specified as  NULL.   (See  NOTES
       below.)

       Under  Linux,  there  are some peculiar "warp clock" semantics associated with the settimeofday() system call if on
       the very first call (after booting) that has a non-NULL tz argument, the tv argument is NULL and the tz_minuteswest
       field is nonzero.  (The tz_dsttime field should be zero for this case.)  In such a case it is assumed that the CMOS
       clock is on local time, and that it has to be incremented by this amount to get UTC system time.  No doubt it is  a
       bad idea to use this feature.

RETURN VALUE
       gettimeofday()  and  settimeofday()  return  0 for success, or -1 for failure (in which case errno is set appropri‐
       ately).

ERRORS
       EFAULT One of tv or tz pointed outside the accessible address space.

       EINVAL Timezone (or something else) is invalid.

       EPERM  The calling process has insufficient privilege to call settimeofday(); under Linux the CAP_SYS_TIME capabil‐
              ity is required.

CONFORMING TO
       SVr4,  4.3BSD.  POSIX.1-2001 describes gettimeofday() but not settimeofday().  POSIX.1-2008 marks gettimeofday() as
       obsolete, recommending the use of clock_gettime(2) instead.

NOTES
       The time returned by gettimeofday() is affected by discontinuous jumps in the system  time  (e.g.,  if  the  system
       administrator  manually  changes  the  system  time).  If you need a monotonically increasing clock, see clock_get‐
       time(2).

       Macros for operating on timeval structures are described in timeradd(3).

       Traditionally, the fields of struct timeval were of type long.

   C library/kernel differences
       On some architectures, an implementation of gettimeofday() is provided in the vdso(7).

   The tz_dsttime field
       On a non-Linux kernel, with glibc, the tz_dsttime field of struct timezone will be set to a nonzero value  by  get‐
       timeofday()  if  the  current  timezone has ever had or will have a daylight saving rule applied.  In this sense it
       exactly mirrors the meaning of daylight(3) for the current zone.  On Linux, with glibc, the setting of the  tz_dst‐
       time  field  of  struct  timezone  has never been used by settimeofday() or gettimeofday().  Thus, the following is
       purely of historical interest.

       On old systems, the field tz_dsttime contains a symbolic constant (values are given below) that indicates in  which
       part  of the year Daylight Saving Time is in force.  (Note: this value is constant throughout the year: it does not
       indicate that DST is in force, it just selects an algorithm.)  The daylight saving time algorithms defined  are  as
       follows:

           DST_NONE     /* not on DST */
           DST_USA      /* USA style DST */
           DST_AUST     /* Australian style DST */
           DST_WET      /* Western European DST */
           DST_MET      /* Middle European DST */
           DST_EET      /* Eastern European DST */
           DST_CAN      /* Canada */
           DST_GB       /* Great Britain and Eire */
           DST_RUM      /* Romania */
           DST_TUR      /* Turkey */
           DST_AUSTALT  /* Australian style with shift in 1986 */

       Of course it turned out that the period in which Daylight Saving Time is in force cannot be given by a simple algo‐
       rithm, one per country; indeed, this period is determined by unpredictable political decisions.  So this method  of
       representing timezones has been abandoned.

SEE ALSO
       date(1),  adjtimex(2),  clock_gettime(2),  time(2),  ctime(3),  ftime(3),  timeradd(3),  capabilities(7),  time(7),
       vdso(7), hwclock(8)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                         GETTIMEOFDAY(2)
</pre>
<pre zoom>
<span xsmall>2 semtimedop</span>
SEMOP(2)                                         Linux Programmer's Manual                                        SEMOP(2)

NAME
       semop, semtimedop - System V semaphore operations

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/sem.h>

       int semop(int semid, struct sembuf *sops, size_t nsops);

       int semtimedop(int semid, struct sembuf *sops, size_t nsops,
                      const struct timespec *timeout);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       semtimedop(): _GNU_SOURCE

DESCRIPTION
       Each semaphore in a System V semaphore set has the following associated values:

           unsigned short  semval;   /* semaphore value */
           unsigned short  semzcnt;  /* # waiting for zero */
           unsigned short  semncnt;  /* # waiting for increase */
           pid_t           sempid;   /* PID of process that last

       semop()  performs  operations  on selected semaphores in the set indicated by semid.  Each of the nsops elements in
       the array pointed to by sops is a structure that specifies an operation to be performed on a single semaphore.  The
       elements of this structure are of type struct sembuf, containing the following members:

           unsigned short sem_num;  /* semaphore number */
           short          sem_op;   /* semaphore operation */
           short          sem_flg;  /* operation flags */

       Flags  recognized in sem_flg are IPC_NOWAIT and SEM_UNDO.  If an operation specifies SEM_UNDO, it will be automati‐
       cally undone when the process terminates.

       The set of operations contained in sops is performed in array order, and atomically, that is,  the  operations  are
       performed  either  as a complete unit, or not at all.  The behavior of the system call if not all operations can be
       performed immediately depends on the presence of the IPC_NOWAIT flag in the individual  sem_flg  fields,  as  noted
       below.

       Each  operation is performed on the sem_num-th semaphore of the semaphore set, where the first semaphore of the set
       is numbered 0.  There are three types of operation, distinguished by the value of sem_op.

       If sem_op is a positive integer, the operation adds this value to the semaphore value  (semval).   Furthermore,  if
       SEM_UNDO  is  specified  for  this  operation,  the system subtracts the value sem_op from the semaphore adjustment
       (semadj) value for this semaphore.  This operation can always proceed—it never forces a thread to wait.  The  call‐
       ing process must have alter permission on the semaphore set.

       If  sem_op  is  zero, the process must have read permission on the semaphore set.  This is a "wait-for-zero" opera‐
       tion: if semval is zero, the operation can immediately proceed.  Otherwise, if IPC_NOWAIT is specified in  sem_flg,
       semop()  fails with errno set to EAGAIN (and none of the operations in sops is performed).  Otherwise, semzcnt (the
       count of threads waiting until this semaphore's value becomes zero) is incremented by one  and  the  thread  sleeps
       until one of the following occurs:

       ·  semval becomes 0, at which time the value of semzcnt is decremented.

       ·  The semaphore set is removed: semop() fails, with errno set to EIDRM.

       ·  The  calling  thread  catches a signal: the value of semzcnt is decremented and semop() fails, with errno set to
          EINTR.

       If sem_op is less than zero, the process must have alter permission on the semaphore set.   If  semval  is  greater
       than  or equal to the absolute value of sem_op, the operation can proceed immediately: the absolute value of sem_op
       is subtracted from semval, and, if SEM_UNDO is specified for this operation, the system adds the absolute value  of
       sem_op  to  the semaphore adjustment (semadj) value for this semaphore.  If the absolute value of sem_op is greater
       than semval, and IPC_NOWAIT is specified in sem_flg, semop() fails, with errno set to EAGAIN (and none of the oper‐
       ations  in  sops  is  performed).  Otherwise, semncnt (the counter of threads waiting for this semaphore's value to
       increase) is incremented by one and the thread sleeps until one of the following occurs:

       ·  semval becomes greater than or equal to the absolute value of sem_op: the operation now proceeds,  as  described
          above.

       ·  The semaphore set is removed from the system: semop() fails, with errno set to EIDRM.

       ·  The  calling  thread  catches a signal: the value of semncnt is decremented and semop() fails, with errno set to
          EINTR.

       On successful completion, the sempid value for each semaphore specified in the array pointed to by sops is  set  to
       the caller's process ID.  In addition, the sem_otime is set to the current time.

   semtimedop()
       semtimedop()  behaves  identically  to semop() except that in those cases where the calling thread would sleep, the
       duration of that sleep is limited by the amount of elapsed time specified by the timespec structure  whose  address
       is  passed  in  the timeout argument.  (This sleep interval will be rounded up to the system clock granularity, and
       kernel scheduling delays mean that the interval may overrun by a small amount.)  If the specified  time  limit  has
       been  reached,  semtimedop()  fails with errno set to EAGAIN (and none of the operations in sops is performed).  If
       the timeout argument is NULL, then semtimedop() behaves exactly like semop().

       Note that if semtimedop() is interrupted by a signal, causing the call to fail with the error EINTR,  the  contents
       of timeout are left unchanged.

RETURN VALUE
       If successful, semop() and semtimedop() return 0; otherwise they return -1 with errno indicating the error.

ERRORS
       On failure, errno is set to one of the following:

       E2BIG  The argument nsops is greater than SEMOPM, the maximum number of operations allowed per system call.

       EACCES The  calling  process  does not have the permissions required to perform the specified semaphore operations,
              and does not have the CAP_IPC_OWNER capability in the user namespace that governs its IPC namespace.

       EAGAIN An operation could not proceed immediately and either IPC_NOWAIT was specified in sem_flg or the time  limit
              specified in timeout expired.

       EFAULT An address specified in either the sops or the timeout argument isn't accessible.

       EFBIG  For  some operation the value of sem_num is less than 0 or greater than or equal to the number of semaphores
              in the set.

       EIDRM  The semaphore set was removed.

       EINTR  While blocked in this system call, the thread caught a signal; see signal(7).

       EINVAL The semaphore set doesn't exist, or semid is less than zero, or nsops has a nonpositive value.

       ENOMEM The sem_flg of some operation specified SEM_UNDO and the system does not have enough memory to allocate  the
              undo structure.

       ERANGE For some operation sem_op+semval is greater than SEMVMX, the implementation dependent maximum value for sem‐
              val.

VERSIONS
       semtimedop() first appeared in Linux 2.5.52, and was subsequently backported into kernel 2.4.22.  Glibc support for
       semtimedop() first appeared in version 2.3.3.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

NOTES
       The  inclusion  of <sys/types.h> and <sys/ipc.h> isn't required on Linux or by any version of POSIX.  However, some
       old implementations required the inclusion of these header files, and the SVID  also  documented  their  inclusion.
       Applications intended to be portable to such old systems may need to include these header files.

       The  sem_undo  structures  of  a  process aren't inherited by the child produced by fork(2), but they are inherited
       across an execve(2) system call.

       semop() is never automatically restarted after being interrupted by a signal handler, regardless of the setting  of
       the SA_RESTART flag when establishing a signal handler.

       A semaphore adjustment (semadj) value is a per-process, per-semaphore integer that is the negated sum of all opera‐
       tions performed on a semaphore specifying the SEM_UNDO flag.  Each process has a list of  semadj  values—one  value
       for  each  semaphore on which it has operated using SEM_UNDO.  When a process terminates, each of its per-semaphore
       semadj values is added to the corresponding semaphore, thus undoing the effect of that process's operations on  the
       semaphore  (but  see  BUGS  below).  When a semaphore's value is directly set using the SETVAL or SETALL request to
       semctl(2), the corresponding semadj values in all processes are cleared.  The clone(2)  CLONE_SYSVSEM  flag  allows
       more than one process to share a semadj list; see clone(2) for details.

       The  semval,  sempid,  semzcnt,  and semnct values for a semaphore can all be retrieved using appropriate semctl(2)
       calls.

   Semaphore limits
       The following limits on semaphore set resources affect the semop() call:

       SEMOPM Maximum number of operations allowed for one semop() call.  Before Linux 3.19, the default  value  for  this
              limit  was  32.   Since Linux 3.19, the default value is 500.  On Linux, this limit can be read and modified
              via the third field of /proc/sys/kernel/sem.  Note: this limit should not be raised above 1000,  because  of
              the  risk  of  that semop() fails due to kernel memory fragmentation when allocating memory to copy the sops
              array.

       SEMVMX Maximum allowable value for semval: implementation dependent (32767).

       The implementation has no intrinsic limits for the adjust on exit maximum value (SEMAEM), the system  wide  maximum
       number of undo structures (SEMMNU) and the per-process maximum number of undo entries system parameters.

BUGS
       When  a  process terminates, its set of associated semadj structures is used to undo the effect of all of the sema‐
       phore operations it performed with the SEM_UNDO flag.  This raises a difficulty: if one (or more)  of  these  sema‐
       phore adjustments would result in an attempt to decrease a semaphore's value below zero, what should an implementa‐
       tion do?  One possible approach would be to block until all the semaphore adjustments could be performed.  This  is
       however undesirable since it could force process termination to block for arbitrarily long periods.  Another possi‐
       bility is that such semaphore adjustments could  be  ignored  altogether  (somewhat  analogously  to  failing  when
       IPC_NOWAIT  is specified for a semaphore operation).  Linux adopts a third approach: decreasing the semaphore value
       as far as possible (i.e., to zero) and allowing process termination to proceed immediately.

       In kernels 2.6.x, x <= 10, there is a bug that in some circumstances prevents a thread that is waiting for a  sema‐
       phore value to become zero from being woken up when the value does actually become zero.  This bug is fixed in ker‐
       nel 2.6.11.

EXAMPLE
       The following code segment uses semop() to atomically wait for the value of semaphore 0 to become  zero,  and  then
       increment the semaphore value by one.

           struct sembuf sops[2];
           int semid;

           /* Code to set semid omitted */

           sops[0].sem_num = 0;        /* Operate on semaphore 0 */
           sops[0].sem_op = 0;         /* Wait for value to equal 0 */
           sops[0].sem_flg = 0;

           sops[1].sem_num = 0;        /* Operate on semaphore 0 */
           sops[1].sem_op = 1;         /* Increment value by one */
           sops[1].sem_flg = 0;

           if (semop(semid, sops, 2) == -1) {
               perror("semop");
               exit(EXIT_FAILURE);
           }

SEE ALSO
       clone(2), semctl(2), semget(2), sigaction(2), capabilities(7), sem_overview(7), svipc(7), time(7)

COLOPHON
       This  page is part of release 4.16 of the Linux man-pages project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                SEMOP(2)
</pre>
<pre zoom>
<span xsmall>2 shmat</span>
SHMOP(2)                                         Linux Programmer's Manual                                        SHMOP(2)

NAME
       shmat, shmdt - System V shared memory operations

SYNOPSIS
       #include <sys/types.h>
       #include <sys/shm.h>

       void *shmat(int shmid, const void *shmaddr, int shmflg);

       int shmdt(const void *shmaddr);

DESCRIPTION
   shmat()
       shmat()  attaches  the  System V  shared  memory  segment  identified  by shmid to the address space of the calling
       process.  The attaching address is specified by shmaddr with one of the following criteria:

       *  If shmaddr is NULL, the system chooses a suitable (unused) page-aligned address to attach the segment.

       *  If shmaddr isn't NULL and SHM_RND is specified in shmflg, the attach occurs at  the  address  equal  to  shmaddr
          rounded down to the nearest multiple of SHMLBA.

       *  Otherwise, shmaddr must be a page-aligned address at which the attach occurs.

       In addition to SHM_RND, the following flags may be specified in the shmflg bit-mask argument:

       SHM_EXEC (Linux-specific; since Linux 2.6.9)
              Allow the contents of the segment to be executed.  The caller must have execute permission on the segment.

       SHM_RDONLY
              Attach  the  segment  for read-only access.  The process must have read permission for the segment.  If this
              flag is not specified, the segment is attached for read and write access, and the process must have read and
              write permission for the segment.  There is no notion of a write-only shared memory segment.

       SHM_REMAP (Linux-specific)
              This  flag specifies that the mapping of the segment should replace any existing mapping in the range start‐
              ing at shmaddr and continuing for the size of the segment.  (Normally, an EINVAL error  would  result  if  a
              mapping already exists in this address range.)  In this case, shmaddr must not be NULL.

       The  brk(2)  value of the calling process is not altered by the attach.  The segment will automatically be detached
       at process exit.  The same segment may be attached as a read and as a read-write one, and more than  once,  in  the
       process's address space.

       A  successful shmat() call updates the members of the shmid_ds structure (see shmctl(2)) associated with the shared
       memory segment as follows:

              shm_atime is set to the current time.

              shm_lpid is set to the process-ID of the calling process.

              shm_nattch is incremented by one.

   shmdt()
       shmdt() detaches the shared memory segment located at the address specified by shmaddr from the  address  space  of
       the  calling  process.   The  to-be-detached  segment  must  be  currently attached with shmaddr equal to the value
       returned by the attaching shmat() call.

       On a successful shmdt() call, the system updates the members of the shmid_ds structure associated with  the  shared
       memory segment as follows:

              shm_dtime is set to the current time.

              shm_lpid is set to the process-ID of the calling process.

              shm_nattch  is  decremented  by one.  If it becomes 0 and the segment is marked for deletion, the segment is
              deleted.

RETURN VALUE
       On success, shmat() returns the address of the attached shared memory segment; on error, (void *) -1  is  returned,
       and errno is set to indicate the cause of the error.

       On success, shmdt() returns 0; on error -1 is returned, and errno is set to indicate the cause of the error.

ERRORS
       When shmat() fails, errno is set to one of the following:

       EACCES The  calling process does not have the required permissions for the requested attach type, and does not have
              the CAP_IPC_OWNER capability in the user namespace that governs its IPC namespace.

       EIDRM  shmid points to a removed identifier.

       EINVAL Invalid shmid value, unaligned (i.e., not page-aligned and SHM_RND was not  specified)  or  invalid  shmaddr
              value, or can't attach segment at shmaddr, or SHM_REMAP was specified and shmaddr was NULL.

       ENOMEM Could not allocate memory for the descriptor or for the page tables.

       When shmdt() fails, errno is set as follows:

       EINVAL There is no shared memory segment attached at shmaddr; or, shmaddr is not aligned on a page boundary.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4.

       In SVID 3 (or perhaps earlier), the type of the shmaddr argument was changed from char * into const void *, and the
       returned type of shmat() from char * into void *.

NOTES
       After a fork(2), the child inherits the attached shared memory segments.

       After an execve(2), all attached shared memory segments are detached from the process.

       Upon _exit(2), all attached shared memory segments are detached from the process.

       Using shmat() with shmaddr equal to NULL is the preferred, portable way of attaching a shared memory  segment.   Be
       aware  that the shared memory segment attached in this way may be attached at different addresses in different pro‐
       cesses.  Therefore, any pointers maintained within the shared memory must be made relative (typically to the start‐
       ing address of the segment), rather than absolute.

       On  Linux,  it  is possible to attach a shared memory segment even if it is already marked to be deleted.  However,
       POSIX.1 does not specify this behavior and many other implementations do not support it.

       The following system parameter affects shmat():

       SHMLBA Segment low boundary address multiple.  When explicitly specifying an attach address in a call  to  shmat(),
              the  caller should ensure that the address is a multiple of this value.  This is necessary on some architec‐
              tures, in order either to ensure good CPU cache performance or to ensure that different attaches of the same
              segment  have  consistent  views  within the CPU cache.  SHMLBA is normally some multiple of the system page
              size.  (On many Linux architectures, SHMLBA is the same as the system page size.)

       The implementation places no intrinsic per-process limit on the number of shared memory segments (SHMSEG).

SEE ALSO
       brk(2), mmap(2), shmctl(2), shmget(2), capabilities(7), shm_overview(7), svipc(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                SHMOP(2)
</pre>
<pre zoom>
<span xsmall>2 lchown</span>
CHOWN(2)                                         Linux Programmer's Manual                                        CHOWN(2)

NAME
       chown, fchown, lchown, fchownat - change ownership of a file

SYNOPSIS
       #include <unistd.h>

       int chown(const char *pathname, uid_t owner, gid_t group);
       int fchown(int fd, uid_t owner, gid_t group);
       int lchown(const char *pathname, uid_t owner, gid_t group);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <unistd.h>

       int fchownat(int dirfd, const char *pathname,
                    uid_t owner, gid_t group, int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       fchown(), lchown():
           /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
               || _XOPEN_SOURCE >= 500
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE
       fchownat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  system  calls change the owner and group of a file.  The chown(), fchown(), and lchown() system calls differ
       only in how the file is specified:

       * chown() changes the ownership of the file specified by pathname, which is dereferenced if it is a symbolic link.

       * fchown() changes the ownership of the file referred to by the open file descriptor fd.

       * lchown() is like chown(), but does not dereference symbolic links.

       Only a privileged process (Linux: one with the CAP_CHOWN capability) may change the owner of a file.  The owner  of
       a file may change the group of the file to any group of which that owner is a member.  A privileged process (Linux:
       with CAP_CHOWN) may change the group arbitrarily.

       If the owner or group is specified as -1, then that ID is not changed.

       When the owner or group of an executable file is changed by an unprivileged user, the S_ISUID and S_ISGID mode bits
       are cleared.  POSIX does not specify whether this also should happen when root does the chown(); the Linux behavior
       depends on the kernel version, and since Linux 2.2.13, root is treated like other users.  In case of  a  non-group-
       executable  file  (i.e., one for which the S_IXGRP bit is not set) the S_ISGID bit indicates mandatory locking, and
       is not cleared by a chown().

       When the owner or group of an executable file is changed (by any user),  all  capability  sets  for  the  file  are
       cleared.

   fchownat()
       The fchownat() system call operates in exactly the same way as chown(), except for the differences described here.

       If  the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the
       file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done  by
       chown() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the cur‐
       rent working directory of the calling process (like chown()).

       If pathname is absolute, then dirfd is ignored.

       The flags argument is a bit mask created by ORing together 0 or more of the following values;

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred to by dirfd (which may have been obtained using
              the  open(2)  O_PATH  flag).   In  this case, dirfd can refer to any type of file, not just a directory.  If
              dirfd is AT_FDCWD, the call operates on the current working directory.  This flag is Linux-specific;  define
              _GNU_SOURCE to obtain its definition.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is  a symbolic link, do not dereference it: instead operate on the link itself, like lchown().
              (By default, fchownat() dereferences symbolic links, like chown().)

       See openat(2) for an explanation of the need for fchownat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       Depending on the filesystem, errors other than those listed below can be returned.

       The more general errors for chown() are listed below.

       EACCES Search permission is denied on a component of the path prefix.  (See also path_resolution(7).)

       EFAULT pathname points outside your accessible address space.

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ENAMETOOLONG
              pathname is too long.

       ENOENT The file does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of the path prefix is not a directory.

       EPERM  The calling process did not have the required permissions (see above) to change owner and/or group.

       EPERM  The file is marked immutable or append-only.  (See ioctl_iflags(2).)

       EROFS  The named file resides on a read-only filesystem.

       The general errors for fchown() are listed below:

       EBADF  fd is not a valid open file descriptor.

       EIO    A low-level I/O error occurred while modifying the inode.

       ENOENT See above.

       EPERM  See above.

       EROFS  See above.

       The same errors that occur for chown() can also occur for fchownat().  The following additional  errors  can  occur
       for fchownat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       fchownat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       chown(), fchown(), lchown(): 4.4BSD, SVr4, POSIX.1-2001, POSIX.1-2008.

       The 4.4BSD version can be used only by the superuser (that is, ordinary users cannot give away files).

       fchownat(): POSIX.1-2008.

NOTES
   Ownership of new files
       When  a  new  file  is created (by, for example, open(2) or mkdir(2)), its owner is made the same as the filesystem
       user ID of the creating process.  The group of the file depends on a  range  of  factors,  including  the  type  of
       filesystem,  the  options  used to mount the filesystem, and whether or not the set-group-ID mode bit is enabled on
       the parent directory.  If the filesystem supports the -o grpid (or, synonymously -o bsdgroups) and -o nogrpid  (or,
       synonymously -o sysvgroups) mount(8) options, then the rules are as follows:

       * If  the  filesystem is mounted with -o grpid, then the group of a new file is made the same as that of the parent
         directory.

       * If the filesystem is mounted with -o nogrpid and the set-group-ID bit is disabled on the parent  directory,  then
         the group of a new file is made the same as the process's filesystem GID.

       * If  the  filesystem  is mounted with -o nogrpid and the set-group-ID bit is enabled on the parent directory, then
         the group of a new file is made the same as that of the parent directory.

       As at Linux 4.12, the -o grpid and -o nogrpid mount options are supported by ext2, ext3, ext4, and  XFS.   Filesys‐
       tems that don't support these mount options follow the -o nogrpid rules.

   Glibc notes
       On  older  kernels where fchownat() is unavailable, the glibc wrapper function falls back to the use of chown() and
       lchown().  When pathname is a relative pathname, glibc  constructs  a  pathname  based  on  the  symbolic  link  in
       /proc/self/fd that corresponds to the dirfd argument.

   NFS
       The  chown()  semantics are deliberately violated on NFS filesystems which have UID mapping enabled.  Additionally,
       the semantics of all system calls which access the file contents are violated, because chown() may cause  immediate
       access  revocation on already open files.  Client side caching may lead to a delay between the time where ownership
       have been changed to allow access for a user and the time where the file can actually be accessed by  the  user  on
       other clients.

   Historical details
       The  original  Linux chown(), fchown(), and lchown() system calls supported only 16-bit user and group IDs.  Subse‐
       quently, Linux 2.4 added chown32(),  fchown32(),  and  lchown32(),  supporting  32-bit  IDs.   The  glibc  chown(),
       fchown(), and lchown() wrapper functions transparently deal with the variations across kernel versions.

       In  versions  of  Linux  prior  to 2.1.81 (and distinct from 2.1.46), chown() did not follow symbolic links.  Since
       Linux 2.1.81, chown() does follow symbolic links, and there is a new system call lchown() that does not follow sym‐
       bolic  links.   Since Linux 2.1.86, this new call (that has the same semantics as the old chown()) has got the same
       syscall number, and chown() got the newly introduced number.

EXAMPLE
       The following program changes the ownership of the file named in its second  command-line  argument  to  the  value
       specified  in its first command-line argument.  The new owner can be specified either as a numeric user ID, or as a
       username (which is converted to a user ID by using getpwnam(3) to perform a lookup in the system password file).

   Program source
       #include <pwd.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>

       int
       main(int argc, char *argv[])
       {
           uid_t uid;
           struct passwd *pwd;
           char *endptr;

           if (argc != 3 || argv[1][0] == '\0') {
               fprintf(stderr, "%s <owner> <file>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           uid = strtol(argv[1], &endptr, 10);  /* Allow a numeric string */

           if (*endptr != '\0') {         /* Was not pure numeric string */
               pwd = getpwnam(argv[1]);   /* Try getting UID for username */
               if (pwd == NULL) {
                   perror("getpwnam");
                   exit(EXIT_FAILURE);
               }

               uid = pwd->pw_uid;
           }

           if (chown(argv[2], uid, -1) == -1) {
               perror("chown");
               exit(EXIT_FAILURE);
           }

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       chgrp(1), chown(1), chmod(2), flock(2), path_resolution(7), symlink(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                                CHOWN(2)
</pre>
<pre zoom>
<span xsmall>2 setregid32</span>
SETREUID(2)                                      Linux Programmer's Manual                                     SETREUID(2)

NAME
       setreuid, setregid - set real and/or effective user or group ID

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int setreuid(uid_t ruid, uid_t euid);
       int setregid(gid_t rgid, gid_t egid);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       setreuid(), setregid():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.19: */ _DEFAULT_SOURCE
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       setreuid() sets real and effective user IDs of the calling process.

       Supplying a value of -1 for either the real or effective user ID forces the system to leave that ID unchanged.

       Unprivileged  processes may only set the effective user ID to the real user ID, the effective user ID, or the saved
       set-user-ID.

       Unprivileged users may only set the real user ID to the real user ID or the effective user ID.

       If the real user ID is set (i.e., ruid is not -1) or the effective user ID is set to a value not equal to the  pre‐
       vious real user ID, the saved set-user-ID will be set to the new effective user ID.

       Completely  analogously, setregid() sets real and effective group ID's of the calling process, and all of the above
       holds with "group" instead of "user".

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

       Note: there are cases where setreuid() can fail even when the caller is UID 0; it is a grave security error to omit
       checking for a failure return from setreuid().

ERRORS
       EAGAIN The call would change the caller's real UID (i.e., ruid does not match the caller's real UID), but there was
              a temporary failure allocating the necessary kernel data structures.

       EAGAIN ruid does not match the caller's real UID and this call would bring the number of processes belonging to the
              real user ID ruid over the caller's RLIMIT_NPROC resource limit.  Since Linux 3.1, this error case no longer
              occurs (but robust applications should check for this error); see the description of EAGAIN in execve(2).

       EINVAL One or more of the target user or group IDs is not valid in this user namespace.

       EPERM  The calling process is not privileged (on Linux, does not have the necessary capability in its  user  names‐
              pace: CAP_SETUID in the case of setreuid(), or CAP_SETGID in the case of setregid()) and a change other than
              (i) swapping the effective user (group) ID with the real user (group) ID, or (ii) setting one to  the  value
              of  the  other  or  (iii) setting the effective user (group) ID to the value of the saved set-user-ID (saved
              set-group-ID) was specified.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD (setreuid() and setregid() first appeared in 4.2BSD).

NOTES
       Setting the effective user (group) ID to the saved set-user-ID (saved set-group-ID) is possible since Linux  1.1.37
       (1.1.38).

       POSIX.1  does  not  specify all of the UID changes that Linux permits for an unprivileged process.  For setreuid(),
       the effective user ID can be made the same as the real user ID or the saved  set-user-ID,  and  it  is  unspecified
       whether  unprivileged  processes  may set the real user ID to the real user ID, the effective user ID, or the saved
       set-user-ID.  For setregid(), the real group ID can be changed to the value of  the  saved  set-group-ID,  and  the
       effective group ID can be changed to the value of the real group ID or the saved set-group-ID.  The precise details
       of what ID changes are permitted vary across implementations.

       POSIX.1 makes no specification about the effect of these calls on the saved set-user-ID and saved set-group-ID.

       The original Linux setreuid() and setregid() system calls supported only 16-bit user and group IDs.   Subsequently,
       Linux  2.4 added setreuid32() and setregid32(), supporting 32-bit IDs.  The glibc setreuid() and setregid() wrapper
       functions transparently deal with the variations across kernel versions.

   C library/kernel differences
       At the kernel level, user IDs and group IDs are a per-thread attribute.  However, POSIX requires that  all  threads
       in  a process share the same credentials.  The NPTL threading implementation handles the POSIX requirements by pro‐
       viding wrapper functions for the various system calls that change process UIDs and GIDs.  These  wrapper  functions
       (including  those  for  setreuid()  and  setregid()) employ a signal-based technique to ensure that when one thread
       changes credentials, all of the other threads in the process also  change  their  credentials.   For  details,  see
       nptl(7).

SEE ALSO
       getgid(2),  getuid(2), seteuid(2), setgid(2), setresuid(2), setuid(2), capabilities(7), credentials(7), user_names‐
       paces(7)

COLOPHON
       This page is part of release 4.16 of the Linux man-pages project.  A description of the project, information  about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                   2017-09-15                                             SETREUID(2)
</pre>
</body>

</html>
